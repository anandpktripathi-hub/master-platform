===== DIRECTORY TREE =====

FullName                                                                                                               
--------                                                                                                               
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas                                   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\reference-code-full-scan.txt                      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\.github                           
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\.vscode                           
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book                              
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas                              
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\.gitignore                        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\LICENSE.md                        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\README.md                         
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\.github\FUNDING.yml               
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\.vscode\extensions.json           
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\.vscode\settings.json             
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\1-begin                      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\1-end                        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin                     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end                       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional            
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-begin                      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-end                        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-begin                      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end                        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin                      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end                        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin                      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end                        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin                      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end                        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin                      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end                        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin                      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end                        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin                      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end                        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\.note                        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\package.json                 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\yarn.lock                    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\1-begin\.gitignore           
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\1-end\app                    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\1-end\.gitignore             
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\1-end\app\pages              
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\1-end\app\server             
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\1-end\app\.eslintignore      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\1-end\app\.eslintrc.js       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\1-end\app\.gitignore         
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\1-end\app\next-env.d.ts      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\1-end\app\next.config.js     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\1-end\app\package.json       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\1-end\app\README.md          
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\1-end\app\tsconfig.json      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\1-end\app\tsconfig.server....
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\1-end\app\yarn.lock          
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\1-end\app\pages\index.tsx    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\1-end\app\pages\_app.tsx     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\1-end\app\pages\_document.tsx
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\1-end\app\server\app.ts      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api                 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app                 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\lambda              
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\.gitignore          
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\server          
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\test            
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\.eslintignore   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\.eslintrc.js    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\.gitignore      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\nodemon.json    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\package.json    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\tsconfig.json   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\tsconfig.serv...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\yarn.lock       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\server\api      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\server\models   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\server\utils    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\server\aws-s3.ts
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\server\aws-se...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\server\google...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\server\mailch...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\server\passwo...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\server\passwo...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\server\server.ts
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\server\socket...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\server\stripe.ts
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\server\api\in...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\server\api\pu...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\server\api\te...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\server\api\te...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\server\models...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\server\models...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\server\models...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\server\models...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\server\models...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\server\models...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\server\utils\...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\server\utils\...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\test\server     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\test\server\u...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\test\server\u...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\test\server\u...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\components      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\lib             
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\pages           
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\public          
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\server          
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\.babelrc        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\.eslintignore   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\.eslintrc.js    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\.gitignore      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\next-env.d.ts   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\next.config.js  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\nodemon.json    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\package.json    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\README.md       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\tsconfig.json   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\tsconfig.serv...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\yarn.lock       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\components\co...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\components\di...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\components\la...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\components\posts
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\components\teams
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\components\co...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\components\co...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\components\co...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\components\co...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\components\co...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\components\co...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\components\di...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\components\di...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\components\di...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\components\di...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\components\di...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\components\la...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\components\po...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\components\po...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\components\po...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\components\po...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\components\te...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\lib\api         
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\lib\store       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\lib\confirm.ts  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\lib\isMobile.ts 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\lib\notify.ts   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\lib\resizeIma...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\lib\sharedSty...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\lib\theme.ts    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\lib\withAuth.tsx
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\lib\api\makeQ...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\lib\api\publi...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\lib\api\sendR...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\lib\api\team-...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\lib\api\team-...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\lib\store\dis...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\lib\store\ind...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\lib\store\inv...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\lib\store\pos...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\lib\store\tea...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\lib\store\use...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\pages\billing...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\pages\create-...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\pages\discuss...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\pages\invitat...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\pages\login.tsx 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\pages\team-se...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\pages\your-se...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\pages\_app.tsx  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\pages\_docume...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\public\pepe.jpg 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\server\server.ts
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\lambda\.eslintignore
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\lambda\.eslintrc.js 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\lambda\.gitignore   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\lambda\handler.ts   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\lambda\package.json 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\lambda\serverless...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\lambda\tsconfig.json
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\lambda\yarn.lock    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api                   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app                   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\lambda                
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\.gitignore            
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\.elasticbeanstalk 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\server            
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\static            
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\test              
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\.eslintignore     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\.eslintrc.js      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\.gitignore        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\nodemon.json      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\package.json      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\tsconfig.json     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\yarn.lock         
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\.elasticbeansta...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\server\api        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\server\models     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\server\utils      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\server\aws-s3.ts  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\server\aws-ses.ts 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\server\google-a...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\server\logger.ts  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\server\mailchim...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\server\password...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\server\password...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\server\server.ts  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\server\sockets.ts 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\server\stripe.ts  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\server\api\inde...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\server\api\publ...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\server\api\team...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\server\api\team...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\server\models\D...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\server\models\E...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\server\models\I...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\server\models\P...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\server\models\T...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\server\models\U...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\server\utils\sl...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\server\utils\su...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\static\robots.txt 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\test\server       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\test\server\utils 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\test\server\uti...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\test\server\uti...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\.elasticbeanstalk 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\components        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\lib               
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\pages             
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\public            
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\server            
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\.babelrc          
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\.eslintignore     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\.eslintrc.js      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\.gitignore        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\next-env.d.ts     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\next.config.js    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\nodemon.json      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\package.json      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\tsconfig.json     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\tsconfig.server...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\yarn.lock         
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\.elasticbeansta...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\components\common 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\components\disc...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\components\layout 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\components\posts  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\components\teams  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\components\comm...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\components\comm...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\components\comm...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\components\comm...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\components\comm...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\components\comm...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\components\disc...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\components\disc...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\components\disc...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\components\disc...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\components\disc...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\components\layo...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\components\post...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\components\post...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\components\post...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\components\post...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\components\team...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\lib\api           
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\lib\store         
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\lib\confirm.ts    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\lib\gtag.ts       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\lib\isMobile.ts   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\lib\notify.ts     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\lib\resizeImage.ts
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\lib\sharedStyle...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\lib\theme.ts      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\lib\withAuth.tsx  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\lib\api\makeQue...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\lib\api\public.ts 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\lib\api\sendReq...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\lib\api\team-le...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\lib\api\team-me...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\lib\store\discu...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\lib\store\index.ts
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\lib\store\invit...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\lib\store\post.ts 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\lib\store\team.ts 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\lib\store\user.ts 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\pages\billing.tsx 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\pages\create-te...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\pages\discussio...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\pages\discussio...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\pages\invitatio...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\pages\login-cac...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\pages\login.tsx   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\pages\team-sett...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\pages\your-sett...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\pages\_app.tsx    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\pages\_document...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\public\fonts      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\public\pepe.jpg   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\public\fonts\IB...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\public\fonts\Ro...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\public\fonts\cd...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\public\fonts\se...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\public\fonts\IB...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\public\fonts\IB...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\public\fonts\Ro...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\public\fonts\Ro...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\server\robots.txt 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\server\routesWi...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\server\server.ts  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\server\setupSit...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\lambda\.eslintignore  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\lambda\.eslintrc.js   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\lambda\.gitignore     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\lambda\handler.ts     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\lambda\package.json   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\lambda\serverless.yml 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\lambda\tsconfig.json  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\lambda\yarn.lock      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\lambda     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\.gitignore 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\.ela...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\server 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\static 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\test   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\.env...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\.esl...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\.esl...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\.git...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\node...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\pack...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\tsco...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\yarn...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\.ela...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\serv...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\serv...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\serv...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\serv...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\serv...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\serv...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\serv...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\serv...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\serv...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\serv...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\serv...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\serv...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\serv...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\serv...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\serv...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\serv...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\serv...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\serv...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\serv...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\serv...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\serv...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\serv...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\serv...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\serv...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\serv...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\stat...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\test...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\test...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\test...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\test...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\.ela...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\comp...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\lib    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\pages  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\public 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\server 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\.bab...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\.env...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\.esl...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\.esl...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\.git...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\next...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\next...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\node...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\pack...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\tsco...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\tsco...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\yarn...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\.ela...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\comp...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\comp...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\comp...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\comp...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\comp...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\comp...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\comp...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\comp...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\comp...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\comp...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\comp...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\comp...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\comp...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\comp...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\comp...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\comp...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\comp...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\comp...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\comp...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\comp...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\comp...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\comp...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\lib\api
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\lib\...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\lib\...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\lib\...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\lib\...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\lib\...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\lib\...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\lib\...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\lib\...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\lib\...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\lib\...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\lib\...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\lib\...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\lib\...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\lib\...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\lib\...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\lib\...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\lib\...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\lib\...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\lib\...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\lib\...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\page...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\page...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\page...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\page...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\page...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\page...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\page...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\page...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\page...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\page...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\publ...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\publ...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\publ...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\publ...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\publ...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\publ...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\publ...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\publ...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\publ...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\publ...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\serv...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\serv...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\serv...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\serv...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\lambda\....
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\lambda\....
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\lambda\....
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\lambda\h...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\lambda\p...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\lambda\s...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\lambda\s...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\lambda\t...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\lambda\y...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-begin\app                  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-begin\.gitignore           
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-begin\app\pages            
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-begin\app\server           
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-begin\app\.eslintignore    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-begin\app\.eslintrc.js     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-begin\app\.gitignore       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-begin\app\next-env.d.ts    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-begin\app\next.config.js   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-begin\app\package.json     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-begin\app\README.md        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-begin\app\tsconfig.json    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-begin\app\tsconfig.serve...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-begin\app\yarn.lock        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-begin\app\pages\index.tsx  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-begin\app\pages\_app.tsx   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-begin\app\pages\_documen...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-begin\app\server\app.ts    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-end\app                    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-end\.gitignore             
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-end\app\components         
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-end\app\lib                
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-end\app\pages              
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-end\app\server             
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-end\app\.eslintignore      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-end\app\.eslintrc.js       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-end\app\.gitignore         
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-end\app\next-env.d.ts      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-end\app\next.config.js     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-end\app\package.json       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-end\app\README.md          
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-end\app\tsconfig.json      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-end\app\tsconfig.server....
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-end\app\yarn.lock          
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-end\app\components\common  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-end\app\components\layout  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-end\app\components\commo...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-end\app\components\commo...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-end\app\components\commo...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-end\app\components\layou...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-end\app\lib\confirm.ts     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-end\app\lib\isMobile.ts    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-end\app\lib\notify.ts      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-end\app\lib\sharedStyles.ts
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-end\app\lib\theme.ts       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-end\app\pages\csr-page.tsx 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-end\app\pages\index.tsx    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-end\app\pages\_app.tsx     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-end\app\pages\_document.tsx
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-end\app\server\app.ts      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-begin\app                  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-begin\.gitignore           
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-begin\app\components       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-begin\app\lib              
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-begin\app\pages            
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-begin\app\server           
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-begin\app\.eslintignore    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-begin\app\.eslintrc.js     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-begin\app\.gitignore       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-begin\app\next-env.d.ts    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-begin\app\next.config.js   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-begin\app\package.json     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-begin\app\README.md        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-begin\app\tsconfig.json    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-begin\app\tsconfig.serve...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-begin\app\yarn.lock        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-begin\app\components\common
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-begin\app\components\layout
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-begin\app\components\com...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-begin\app\components\com...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-begin\app\components\com...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-begin\app\components\lay...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-begin\app\lib\confirm.ts   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-begin\app\lib\isMobile.ts  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-begin\app\lib\notify.ts    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-begin\app\lib\sharedStyl...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-begin\app\lib\theme.ts     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-begin\app\pages\csr-page...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-begin\app\pages\index.tsx  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-begin\app\pages\_app.tsx   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-begin\app\pages\_documen...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-begin\app\server\app.ts    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\api                    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app                    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\.gitignore             
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\api\server             
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\api\.eslintignore      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\api\.eslintrc.js       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\api\.gitignore         
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\api\nodemon.json       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\api\package.json       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\api\tsconfig.json      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\api\tsconfig.server....
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\api\yarn.lock          
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\api\server\server.ts   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app\components         
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app\lib                
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app\pages              
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app\public             
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app\server             
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app\.eslintignore      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app\.eslintrc.js       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app\.gitignore         
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app\next-env.d.ts      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app\next.config.js     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app\nodemon.json       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app\package.json       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app\README.md          
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app\tsconfig.json      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app\tsconfig.server....
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app\yarn.lock          
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app\components\common  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app\components\layout  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app\components\commo...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app\components\commo...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app\components\commo...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app\components\layou...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app\lib\api            
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app\lib\confirm.ts     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app\lib\isMobile.ts    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app\lib\notify.ts      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app\lib\sharedStyles.ts
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app\lib\theme.ts       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app\lib\api\public.ts  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app\lib\api\sendRequ...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app\pages\csr-page.tsx 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app\pages\index.tsx    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app\pages\_app.tsx     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app\pages\_document.tsx
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app\public\pepe.jpg    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app\server\server.ts   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\api                  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app                  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\.gitignore           
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\api\server           
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\api\.eslintignore    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\api\.eslintrc.js     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\api\.gitignore       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\api\nodemon.json     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\api\package.json     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\api\tsconfig.json    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\api\tsconfig.serve...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\api\yarn.lock        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\api\server\server.ts 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app\components       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app\lib              
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app\pages            
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app\public           
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app\server           
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app\.eslintignore    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app\.eslintrc.js     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app\.gitignore       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app\next-env.d.ts    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app\next.config.js   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app\nodemon.json     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app\package.json     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app\README.md        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app\tsconfig.json    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app\tsconfig.serve...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app\yarn.lock        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app\components\common
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app\components\layout
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app\components\com...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app\components\com...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app\components\com...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app\components\lay...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app\lib\api          
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app\lib\confirm.ts   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app\lib\isMobile.ts  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app\lib\notify.ts    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app\lib\sharedStyl...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app\lib\theme.ts     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app\lib\api\public.ts
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app\lib\api\sendRe...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app\pages\csr-page...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app\pages\index.tsx  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app\pages\_app.tsx   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app\pages\_documen...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app\public\pepe.jpg  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app\server\server.ts 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\api                    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app                    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\.gitignore             
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\api\server             
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\api\test               
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\api\.eslintignore      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\api\.eslintrc.js       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\api\.gitignore         
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\api\nodemon.json       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\api\package.json       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\api\tsconfig.json      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\api\tsconfig.server....
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\api\yarn.lock          
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\api\server\api         
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\api\server\models      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\api\server\utils       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\api\server\aws-s3.ts   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\api\server\server.ts   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\api\server\api\index.ts
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\api\server\api\publi...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\api\server\api\team-...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\api\server\models\Us...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\api\server\utils\slu...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\api\server\utils\sum.ts
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\api\test\server        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\api\test\server\utils  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\api\test\server\util...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\api\test\server\util...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\components         
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\lib                
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\pages              
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\public             
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\server             
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\.eslintignore      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\.eslintrc.js       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\.gitignore         
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\next-env.d.ts      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\next.config.js     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\nodemon.json       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\package.json       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\README.md          
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\tsconfig.json      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\tsconfig.server....
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\yarn.lock          
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\components\common  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\components\layout  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\components\commo...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\components\commo...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\components\commo...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\components\layou...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\lib\api            
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\lib\confirm.ts     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\lib\isMobile.ts    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\lib\notify.ts      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\lib\resizeImage.ts 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\lib\sharedStyles.ts
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\lib\theme.ts       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\lib\api\public.ts  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\lib\api\sendRequ...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\lib\api\team-mem...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\pages\csr-page.tsx 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\pages\index.tsx    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\pages\your-setti...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\pages\_app.tsx     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\pages\_document.tsx
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\public\pepe.jpg    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\server\server.ts   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\api                  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app                  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\.gitignore           
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\api\server           
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\api\test             
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\api\.eslintignore    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\api\.eslintrc.js     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\api\.gitignore       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\api\nodemon.json     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\api\package.json     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\api\tsconfig.json    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\api\tsconfig.serve...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\api\yarn.lock        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\api\server\api       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\api\server\models    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\api\server\utils     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\api\server\aws-s3.ts 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\api\server\server.ts 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\api\server\api\ind...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\api\server\api\pub...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\api\server\api\tea...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\api\server\models\...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\api\server\utils\s...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\api\server\utils\s...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\api\test\server      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\api\test\server\utils
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\api\test\server\ut...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\api\test\server\ut...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\components       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\lib              
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\pages            
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\public           
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\server           
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\.eslintignore    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\.eslintrc.js     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\.gitignore       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\next-env.d.ts    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\next.config.js   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\nodemon.json     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\package.json     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\README.md        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\tsconfig.json    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\tsconfig.serve...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\yarn.lock        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\components\common
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\components\layout
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\components\com...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\components\com...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\components\com...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\components\lay...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\lib\api          
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\lib\confirm.ts   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\lib\isMobile.ts  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\lib\notify.ts    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\lib\resizeImag...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\lib\sharedStyl...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\lib\theme.ts     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\lib\api\public.ts
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\lib\api\sendRe...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\lib\api\team-m...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\pages\csr-page...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\pages\index.tsx  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\pages\your-set...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\pages\_app.tsx   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\pages\_documen...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\public\pepe.jpg  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\server\server.ts 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\api                    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app                    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\.gitignore             
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\api\server             
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\api\test               
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\api\.eslintignore      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\api\.eslintrc.js       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\api\.gitignore         
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\api\nodemon.json       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\api\package.json       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\api\tsconfig.json      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\api\tsconfig.server....
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\api\yarn.lock          
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\api\server\api         
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\api\server\models      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\api\server\utils       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\api\server\aws-s3.ts   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\api\server\google-au...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\api\server\server.ts   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\api\server\api\index.ts
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\api\server\api\publi...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\api\server\api\team-...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\api\server\models\Us...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\api\server\utils\slu...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\api\server\utils\sum.ts
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\api\test\server        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\api\test\server\utils  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\api\test\server\util...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\api\test\server\util...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\components         
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\lib                
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\pages              
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\public             
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\server             
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\.eslintignore      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\.eslintrc.js       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\.gitignore         
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\next-env.d.ts      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\next.config.js     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\nodemon.json       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\package.json       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\README.md          
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\tsconfig.json      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\tsconfig.server....
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\yarn.lock          
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\components\common  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\components\layout  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\components\commo...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\components\commo...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\components\commo...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\components\commo...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\components\layou...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\lib\api            
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\lib\confirm.ts     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\lib\isMobile.ts    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\lib\notify.ts      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\lib\resizeImage.ts 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\lib\sharedStyles.ts
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\lib\theme.ts       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\lib\withAuth.tsx   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\lib\api\public.ts  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\lib\api\sendRequ...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\lib\api\team-mem...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\pages\csr-page.tsx 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\pages\index.tsx    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\pages\login.tsx    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\pages\your-setti...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\pages\_app.tsx     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\pages\_document.tsx
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\public\pepe.jpg    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\server\server.ts   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\api                  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app                  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\.gitignore           
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\api\server           
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\api\test             
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\api\.eslintignore    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\api\.eslintrc.js     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\api\.gitignore       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\api\nodemon.json     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\api\package.json     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\api\tsconfig.json    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\api\tsconfig.serve...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\api\yarn.lock        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\api\server\api       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\api\server\models    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\api\server\utils     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\api\server\aws-s3.ts 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\api\server\google-...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\api\server\server.ts 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\api\server\api\ind...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\api\server\api\pub...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\api\server\api\tea...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\api\server\models\...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\api\server\utils\s...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\api\server\utils\s...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\api\test\server      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\api\test\server\utils
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\api\test\server\ut...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\api\test\server\ut...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\components       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\lib              
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\pages            
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\public           
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\server           
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\.eslintignore    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\.eslintrc.js     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\.gitignore       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\next-env.d.ts    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\next.config.js   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\nodemon.json     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\package.json     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\README.md        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\tsconfig.json    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\tsconfig.serve...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\yarn.lock        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\components\common
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\components\layout
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\components\com...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\components\com...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\components\com...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\components\com...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\components\lay...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\lib\api          
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\lib\confirm.ts   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\lib\isMobile.ts  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\lib\notify.ts    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\lib\resizeImag...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\lib\sharedStyl...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\lib\theme.ts     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\lib\withAuth.tsx 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\lib\api\public.ts
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\lib\api\sendRe...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\lib\api\team-m...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\pages\csr-page...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\pages\index.tsx  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\pages\login.tsx  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\pages\your-set...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\pages\_app.tsx   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\pages\_documen...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\public\pepe.jpg  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\server\server.ts 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\api                    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app                    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\.gitignore             
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\api\server             
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\api\test               
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\api\.eslintignore      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\api\.eslintrc.js       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\api\.gitignore         
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\api\nodemon.json       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\api\package.json       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\api\tsconfig.json      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\api\tsconfig.server....
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\api\yarn.lock          
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\api\server\api         
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\api\server\models      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\api\server\utils       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\api\server\aws-s3.ts   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\api\server\aws-ses.ts  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\api\server\google-au...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\api\server\mailchimp.ts
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\api\server\passwordl...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\api\server\passwordl...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\api\server\server.ts   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\api\server\api\index.ts
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\api\server\api\publi...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\api\server\api\team-...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\api\server\models\Em...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\api\server\models\Us...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\api\server\utils\slu...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\api\server\utils\sum.ts
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\api\test\server        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\api\test\server\utils  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\api\test\server\util...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\api\test\server\util...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\components         
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\lib                
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\pages              
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\public             
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\server             
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\.eslintignore      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\.eslintrc.js       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\.gitignore         
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\next-env.d.ts      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\next.config.js     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\nodemon.json       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\package.json       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\README.md          
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\tsconfig.json      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\tsconfig.server....
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\yarn.lock          
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\components\common  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\components\layout  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\components\commo...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\components\commo...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\components\commo...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\components\commo...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\components\layou...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\lib\api            
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\lib\confirm.ts     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\lib\isMobile.ts    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\lib\notify.ts      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\lib\resizeImage.ts 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\lib\sharedStyles.ts
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\lib\theme.ts       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\lib\withAuth.tsx   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\lib\api\public.ts  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\lib\api\sendRequ...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\lib\api\team-mem...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\pages\csr-page.tsx 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\pages\index.tsx    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\pages\login.tsx    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\pages\your-setti...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\pages\_app.tsx     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\pages\_document.tsx
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\public\pepe.jpg    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\server\server.ts   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\api                  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app                  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\.gitignore           
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\api\server           
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\api\test             
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\api\.eslintignore    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\api\.eslintrc.js     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\api\.gitignore       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\api\nodemon.json     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\api\package.json     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\api\tsconfig.json    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\api\tsconfig.serve...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\api\yarn.lock        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\api\server\api       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\api\server\models    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\api\server\utils     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\api\server\aws-s3.ts 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\api\server\aws-ses.ts
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\api\server\google-...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\api\server\mailchi...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\api\server\passwor...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\api\server\passwor...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\api\server\server.ts 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\api\server\api\ind...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\api\server\api\pub...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\api\server\api\tea...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\api\server\models\...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\api\server\models\...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\api\server\utils\s...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\api\server\utils\s...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\api\test\server      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\api\test\server\utils
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\api\test\server\ut...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\api\test\server\ut...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\components       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\lib              
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\pages            
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\public           
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\server           
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\.eslintignore    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\.eslintrc.js     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\.gitignore       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\next-env.d.ts    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\next.config.js   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\nodemon.json     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\package.json     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\README.md        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\tsconfig.json    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\tsconfig.serve...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\yarn.lock        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\components\common
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\components\layout
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\components\com...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\components\com...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\components\com...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\components\com...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\components\lay...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\lib\api          
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\lib\confirm.ts   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\lib\isMobile.ts  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\lib\notify.ts    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\lib\resizeImag...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\lib\sharedStyl...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\lib\theme.ts     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\lib\withAuth.tsx 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\lib\api\public.ts
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\lib\api\sendRe...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\lib\api\team-m...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\pages\csr-page...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\pages\index.tsx  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\pages\login.tsx  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\pages\your-set...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\pages\_app.tsx   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\pages\_documen...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\public\pepe.jpg  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\server\server.ts 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\api                    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app                    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\.gitignore             
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\api\server             
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\api\test               
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\api\.eslintignore      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\api\.eslintrc.js       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\api\.gitignore         
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\api\nodemon.json       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\api\package.json       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\api\tsconfig.json      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\api\tsconfig.server....
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\api\yarn.lock          
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\api\server\api         
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\api\server\models      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\api\server\utils       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\api\server\aws-s3.ts   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\api\server\aws-ses.ts  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\api\server\google-au...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\api\server\mailchimp.ts
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\api\server\passwordl...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\api\server\passwordl...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\api\server\server.ts   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\api\server\api\index.ts
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\api\server\api\publi...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\api\server\api\team-...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\api\server\api\team-...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\api\server\models\Em...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\api\server\models\In...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\api\server\models\Te...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\api\server\models\Us...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\api\server\utils\slu...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\api\server\utils\sum.ts
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\api\test\server        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\api\test\server\utils  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\api\test\server\util...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\api\test\server\util...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\components         
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\lib                
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\pages              
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\public             
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\server             
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\.eslintignore      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\.eslintrc.js       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\.gitignore         
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\next-env.d.ts      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\next.config.js     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\nodemon.json       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\package.json       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\README.md          
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\tsconfig.json      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\tsconfig.server....
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\yarn.lock          
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\components\common  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\components\layout  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\components\teams   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\components\commo...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\components\commo...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\components\commo...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\components\commo...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\components\commo...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\components\layou...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\components\teams...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\lib\api            
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\lib\store          
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\lib\confirm.ts     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\lib\isMobile.ts    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\lib\notify.ts      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\lib\resizeImage.ts 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\lib\sharedStyles.ts
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\lib\theme.ts       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\lib\withAuth.tsx   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\lib\api\makeQuer...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\lib\api\public.ts  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\lib\api\sendRequ...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\lib\api\team-lea...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\lib\api\team-mem...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\lib\store\index.ts 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\lib\store\invita...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\lib\store\team.ts  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\lib\store\user.ts  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\pages\create-tea...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\pages\invitation...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\pages\login.tsx    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\pages\team-setti...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\pages\your-setti...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\pages\_app.tsx     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\pages\_document.tsx
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\public\pepe.jpg    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\server\server.ts   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\api                  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app                  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\.gitignore           
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\api\server           
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\api\test             
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\api\.eslintignore    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\api\.eslintrc.js     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\api\.gitignore       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\api\nodemon.json     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\api\package.json     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\api\tsconfig.json    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\api\tsconfig.serve...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\api\yarn.lock        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\api\server\api       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\api\server\models    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\api\server\utils     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\api\server\aws-s3.ts 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\api\server\aws-ses.ts
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\api\server\google-...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\api\server\mailchi...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\api\server\passwor...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\api\server\passwor...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\api\server\server.ts 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\api\server\api\ind...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\api\server\api\pub...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\api\server\api\tea...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\api\server\api\tea...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\api\server\models\...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\api\server\models\...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\api\server\models\...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\api\server\models\...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\api\server\utils\s...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\api\server\utils\s...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\api\test\server      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\api\test\server\utils
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\api\test\server\ut...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\api\test\server\ut...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\components       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\lib              
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\pages            
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\public           
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\server           
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\.eslintignore    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\.eslintrc.js     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\.gitignore       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\next-env.d.ts    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\next.config.js   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\nodemon.json     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\package.json     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\README.md        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\tsconfig.json    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\tsconfig.serve...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\yarn.lock        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\components\common
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\components\layout
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\components\teams 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\components\com...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\components\com...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\components\com...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\components\com...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\components\com...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\components\lay...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\components\tea...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\lib\api          
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\lib\store        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\lib\confirm.ts   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\lib\isMobile.ts  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\lib\notify.ts    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\lib\resizeImag...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\lib\sharedStyl...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\lib\theme.ts     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\lib\withAuth.tsx 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\lib\api\makeQu...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\lib\api\public.ts
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\lib\api\sendRe...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\lib\api\team-l...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\lib\api\team-m...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\lib\store\inde...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\lib\store\invi...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\lib\store\team.ts
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\lib\store\user.ts
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\pages\create-t...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\pages\invitati...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\pages\login.tsx  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\pages\team-set...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\pages\your-set...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\pages\_app.tsx   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\pages\_documen...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\public\pepe.jpg  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\server\server.ts 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api                    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app                    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\.gitignore             
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\server             
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\test               
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\.eslintignore      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\.eslintrc.js       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\.gitignore         
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\nodemon.json       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\package.json       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\tsconfig.json      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\tsconfig.server....
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\yarn.lock          
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\server\api         
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\server\models      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\server\utils       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\server\aws-s3.ts   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\server\aws-ses.ts  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\server\google-au...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\server\mailchimp.ts
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\server\passwordl...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\server\passwordl...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\server\server.ts   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\server\sockets.ts  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\server\api\index.ts
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\server\api\publi...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\server\api\team-...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\server\api\team-...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\server\models\Di...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\server\models\Em...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\server\models\In...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\server\models\Po...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\server\models\Te...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\server\models\Us...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\server\utils\slu...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\server\utils\sum.ts
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\test\server        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\test\server\utils  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\test\server\util...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\test\server\util...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\components         
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\lib                
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\pages              
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\public             
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\server             
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\.babelrc           
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\.eslintignore      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\.eslintrc.js       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\.gitignore         
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\next-env.d.ts      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\next.config.js     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\nodemon.json       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\package.json       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\README.md          
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\tsconfig.json      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\tsconfig.server....
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\yarn.lock          
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\components\common  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\components\discu...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\components\layout  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\components\posts   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\components\teams   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\components\commo...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\components\commo...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\components\commo...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\components\commo...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\components\commo...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\components\commo...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\components\discu...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\components\discu...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\components\discu...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\components\discu...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\components\discu...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\components\layou...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\components\posts...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\components\posts...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\components\posts...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\components\posts...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\components\teams...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\lib\api            
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\lib\store          
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\lib\confirm.ts     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\lib\isMobile.ts    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\lib\notify.ts      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\lib\resizeImage.ts 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\lib\sharedStyles.ts
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\lib\theme.ts       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\lib\withAuth.tsx   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\lib\api\makeQuer...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\lib\api\public.ts  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\lib\api\sendRequ...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\lib\api\team-lea...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\lib\api\team-mem...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\lib\store\discus...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\lib\store\index.ts 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\lib\store\invita...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\lib\store\post.ts  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\lib\store\team.ts  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\lib\store\user.ts  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\pages\create-tea...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\pages\discussion...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\pages\invitation...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\pages\login.tsx    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\pages\team-setti...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\pages\your-setti...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\pages\_app.tsx     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\pages\_document.tsx
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\public\pepe.jpg    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\server\server.ts   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api                  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app                  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\.gitignore           
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\server           
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\test             
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\.eslintignore    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\.eslintrc.js     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\.gitignore       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\nodemon.json     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\package.json     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\tsconfig.json    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\tsconfig.serve...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\yarn.lock        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\server\api       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\server\models    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\server\utils     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\server\aws-s3.ts 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\server\aws-ses.ts
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\server\google-...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\server\mailchi...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\server\passwor...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\server\passwor...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\server\server.ts 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\server\sockets.ts
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\server\api\ind...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\server\api\pub...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\server\api\tea...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\server\api\tea...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\server\models\...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\server\models\...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\server\models\...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\server\models\...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\server\models\...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\server\models\...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\server\utils\s...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\server\utils\s...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\test\server      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\test\server\utils
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\test\server\ut...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\test\server\ut...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\components       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\lib              
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\pages            
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\public           
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\server           
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\.babelrc         
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\.eslintignore    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\.eslintrc.js     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\.gitignore       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\next-env.d.ts    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\next.config.js   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\nodemon.json     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\package.json     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\README.md        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\tsconfig.json    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\tsconfig.serve...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\yarn.lock        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\components\common
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\components\dis...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\components\layout
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\components\posts 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\components\teams 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\components\com...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\components\com...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\components\com...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\components\com...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\components\com...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\components\com...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\components\dis...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\components\dis...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\components\dis...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\components\dis...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\components\dis...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\components\lay...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\components\pos...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\components\pos...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\components\pos...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\components\pos...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\components\tea...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\lib\api          
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\lib\store        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\lib\confirm.ts   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\lib\isMobile.ts  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\lib\notify.ts    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\lib\resizeImag...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\lib\sharedStyl...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\lib\theme.ts     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\lib\withAuth.tsx 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\lib\api\makeQu...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\lib\api\public.ts
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\lib\api\sendRe...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\lib\api\team-l...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\lib\api\team-m...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\lib\store\disc...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\lib\store\inde...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\lib\store\invi...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\lib\store\post.ts
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\lib\store\team.ts
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\lib\store\user.ts
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\pages\create-t...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\pages\discussi...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\pages\invitati...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\pages\login.tsx  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\pages\team-set...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\pages\your-set...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\pages\_app.tsx   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\pages\_documen...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\public\pepe.jpg  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\server\server.ts 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api                    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app                    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\lambda                 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\.gitignore             
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\server             
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\test               
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\.eslintignore      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\.eslintrc.js       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\.gitignore         
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\nodemon.json       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\package.json       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\tsconfig.json      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\tsconfig.server....
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\yarn.lock          
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\server\api         
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\server\models      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\server\utils       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\server\aws-s3.ts   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\server\aws-ses.ts  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\server\google-au...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\server\mailchimp.ts
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\server\passwordl...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\server\passwordl...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\server\server.ts   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\server\sockets.ts  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\server\stripe.ts   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\server\api\index.ts
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\server\api\publi...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\server\api\team-...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\server\api\team-...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\server\models\Di...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\server\models\Em...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\server\models\In...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\server\models\Po...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\server\models\Te...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\server\models\Us...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\server\utils\slu...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\server\utils\sum.ts
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\test\server        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\test\server\utils  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\test\server\util...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\test\server\util...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\components         
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\lib                
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\pages              
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\public             
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\server             
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\.babelrc           
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\.eslintignore      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\.eslintrc.js       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\.gitignore         
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\next-env.d.ts      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\next.config.js     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\nodemon.json       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\package.json       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\README.md          
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\tsconfig.json      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\tsconfig.server....
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\yarn.lock          
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\components\common  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\components\discu...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\components\layout  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\components\posts   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\components\teams   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\components\commo...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\components\commo...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\components\commo...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\components\commo...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\components\commo...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\components\commo...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\components\discu...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\components\discu...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\components\discu...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\components\discu...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\components\discu...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\components\layou...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\components\posts...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\components\posts...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\components\posts...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\components\posts...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\components\teams...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\lib\api            
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\lib\store          
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\lib\confirm.ts     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\lib\isMobile.ts    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\lib\notify.ts      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\lib\resizeImage.ts 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\lib\sharedStyles.ts
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\lib\theme.ts       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\lib\withAuth.tsx   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\lib\api\makeQuer...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\lib\api\public.ts  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\lib\api\sendRequ...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\lib\api\team-lea...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\lib\api\team-mem...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\lib\store\discus...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\lib\store\index.ts 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\lib\store\invita...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\lib\store\post.ts  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\lib\store\team.ts  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\lib\store\user.ts  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\pages\billing.tsx  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\pages\create-tea...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\pages\discussion...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\pages\invitation...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\pages\login.tsx    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\pages\team-setti...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\pages\your-setti...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\pages\_app.tsx     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\pages\_document.tsx
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\public\pepe.jpg    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\server\server.ts   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\lambda\.eslintignore   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\lambda\.eslintrc.js    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\lambda\.gitignore      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\lambda\handler.ts      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\lambda\package.json    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\lambda\serverless.yml  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\lambda\tsconfig.json   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\lambda\yarn.lock       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api                          
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app                          
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\lambda                       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\.gitignore                   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\.elasticbeanstalk        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\server                   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\static                   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\test                     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\.env.example             
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\.eslintignore            
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\.eslintrc.js             
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\.gitignore               
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\nodemon.json             
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\package.json             
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\tsconfig.json            
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\yarn.lock                
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\.elasticbeanstalk\conf...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\server\api               
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\server\models            
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\server\utils             
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\server\aws-s3.ts         
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\server\aws-ses.ts        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\server\google-auth.ts    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\server\logger.ts         
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\server\mailchimp.ts      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\server\passwordless-au...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\server\passwordless-to...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\server\server.ts         
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\server\sockets.ts        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\server\stripe.ts         
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\server\api\index.ts      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\server\api\public.ts     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\server\api\team-leader.ts
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\server\api\team-member.ts
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\server\models\Discussi...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\server\models\EmailTem...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\server\models\Invitati...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\server\models\Post.ts    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\server\models\Team.ts    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\server\models\User.ts    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\server\utils\slugify.ts  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\server\utils\sum.ts      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\static\robots.txt        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\test\server              
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\test\server\utils        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\test\server\utils\slug...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\test\server\utils\sum....
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\.elasticbeanstalk        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\components               
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\lib                      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\pages                    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\public                   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\server                   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\.babelrc                 
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\.env.example             
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\.eslintignore            
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\.eslintrc.js             
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\.gitignore               
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\next-env.d.ts            
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\next.config.js           
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\nodemon.json             
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\package.json             
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\tsconfig.json            
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\tsconfig.server.json     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\yarn.lock                
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\.elasticbeanstalk\conf...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\components\common        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\components\discussions   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\components\layout        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\components\posts         
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\components\teams         
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\components\common\Conf...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\components\common\Logi...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\components\common\Memb...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\components\common\Menu...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\components\common\Menu...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\components\common\Noti...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\components\discussions...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\components\discussions...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\components\discussions...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\components\discussions...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\components\discussions...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\components\layout\inde...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\components\posts\PostC...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\components\posts\PostD...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\components\posts\PostE...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\components\posts\PostF...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\components\teams\Invit...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\lib\api                  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\lib\store                
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\lib\confirm.ts           
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\lib\gtag.ts              
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\lib\isMobile.ts          
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\lib\notify.ts            
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\lib\resizeImage.ts       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\lib\sharedStyles.ts      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\lib\theme.ts             
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\lib\withAuth.tsx         
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\lib\api\makeQueryStrin...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\lib\api\public.ts        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\lib\api\sendRequestAnd...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\lib\api\team-leader.ts   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\lib\api\team-member.ts   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\lib\store\discussion.ts  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\lib\store\index.ts       
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\lib\store\invitation.ts  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\lib\store\post.ts        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\lib\store\team.ts        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\lib\store\user.ts        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\pages\billing.tsx        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\pages\create-team.tsx    
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\pages\discussion.tsx     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\pages\invitation.tsx     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\pages\login-cached.tsx   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\pages\login.tsx          
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\pages\team-settings.tsx  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\pages\your-settings.tsx  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\pages\_app.tsx           
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\pages\_document.tsx      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\public\fonts             
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\public\pepe.jpg          
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\public\fonts\IBM-Plex-...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\public\fonts\Roboto      
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\public\fonts\cdn.css     
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\public\fonts\server.css  
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\public\fonts\IBM-Plex-...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\public\fonts\IBM-Plex-...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\public\fonts\Roboto\Ro...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\public\fonts\Roboto\Ro...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\server\robots.txt        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\server\routesWithCache.ts
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\server\server.ts         
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\server\setupSitemapAnd...
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\lambda\.eslintignore         
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\lambda\.eslintrc.js          
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\lambda\.gitignore            
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\lambda\api                   
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\lambda\handler.ts            
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\lambda\package.json          
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\lambda\serverless.yml        
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\lambda\symlink               
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\lambda\tsconfig.json         
C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\lambda\yarn.lock             




===== FILE CONTENTS (.ts, .tsx, .js, .jsx, .json) =====


----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\.vscode\extensions.json -----

{
  "recommendations": ["dbaeumer.vscode-eslint"]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\.vscode\settings.json -----

{
  "window.zoomLevel": 0,
  "files.autoSave": "afterDelay",
  "git.enableSmartCommit": true,
  "git.autofetch": true,
  "editor.detectIndentation": false,
  "editor.tabSize": 2,
  "editor.insertSpaces": true,
  "typescript.updateImportsOnFileMove.enabled": "never",
  "search.exclude": {
    "**/node_modules": true,
    "**/production-server": true,
    "**/lambda/src/api": true,
    "**/.next": true,
    "**/.coverage": true
  },
  "editor.defaultFormatter": "dbaeumer.vscode-eslint",
  "editor.formatOnSave": true,
  "editor.codeActionsOnSave": {
    "source.fixAll.eslint": true
  },
  "eslint.alwaysShowStatus": true,
  "eslint.workingDirectories": [
    { "directory": "./saas/app", "changeProcessCWD": true },
    { "directory": "./saas/api", "changeProcessCWD": true },
    { "directory": "./saas/lambda", "changeProcessCWD": true },
    { "directory": "./book/1-end/app", "changeProcessCWD": true },
    { "directory": "./book/2-begin/app", "changeProcessCWD": true },
    { "directory": "./book/2-end/app", "changeProcessCWD": true },
    { "directory": "./book/3-begin/app", "changeProcessCWD": true },
    { "directory": "./book/3-end/app", "changeProcessCWD": true },
    { "directory": "./book/3-end/api", "changeProcessCWD": true },
    { "directory": "./book/4-begin/app", "changeProcessCWD": true },
    { "directory": "./book/4-begin/api", "changeProcessCWD": true },
    { "directory": "./book/4-end/app", "changeProcessCWD": true },
    { "directory": "./book/4-end/api", "changeProcessCWD": true },
    { "directory": "./book/5-begin/app", "changeProcessCWD": true },
    { "directory": "./book/5-begin/api", "changeProcessCWD": true },
    { "directory": "./book/5-end/app", "changeProcessCWD": true },
    { "directory": "./book/5-end/api", "changeProcessCWD": true },
    { "directory": "./book/6-begin/app", "changeProcessCWD": true },
    { "directory": "./book/6-begin/api", "changeProcessCWD": true },
    { "directory": "./book/6-end/app", "changeProcessCWD": true },
    { "directory": "./book/6-end/api", "changeProcessCWD": true },
    { "directory": "./book/7-begin/app", "changeProcessCWD": true },
    { "directory": "./book/7-begin/api", "changeProcessCWD": true },
    { "directory": "./book/7-end/app", "changeProcessCWD": true },
    { "directory": "./book/7-end/api", "changeProcessCWD": true },
    { "directory": "./book/8-begin/app", "changeProcessCWD": true },
    { "directory": "./book/8-begin/api", "changeProcessCWD": true },
    { "directory": "./book/8-end/app", "changeProcessCWD": true },
    { "directory": "./book/8-end/api", "changeProcessCWD": true },
    { "directory": "./book/9-begin/app", "changeProcessCWD": true },
    { "directory": "./book/9-begin/api", "changeProcessCWD": true },
    { "directory": "./book/9-begin/lambda", "changeProcessCWD": true },
    { "directory": "./book/9-end/app", "changeProcessCWD": true },
    { "directory": "./book/9-end/api", "changeProcessCWD": true },
    { "directory": "./book/9-end/lambda", "changeProcessCWD": true },
    { "directory": "./book/10-begin/app", "changeProcessCWD": true },
    { "directory": "./book/10-begin/api", "changeProcessCWD": true },
    { "directory": "./book/10-begin/lambda", "changeProcessCWD": true },
    { "directory": "./book/10-end/app", "changeProcessCWD": true },
    { "directory": "./book/10-end/api", "changeProcessCWD": true },
    { "directory": "./book/10-end/lambda", "changeProcessCWD": true },
	]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\1-end\app\pages\index.tsx -----

import React from 'react';
import Head from 'next/head';

const Index = () => (
  <div>
    <Head>
      <title>Index page</title>
      <meta name="description" content="This is a description of the Index page" />
    </Head>
    <div style={{ padding: '0px 30px', fontSize: '15px', height: '100%', color: '#222' }}>
      <p>Content on Index page</p>
    </div>
  </div>
);

export default Index;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\1-end\app\pages\_app.tsx -----

import App from 'next/app';
import React from 'react';

class MyApp extends App {
  public render() {
    const { Component, pageProps } = this.props;

    return <Component {...pageProps} />;
  }
}

export default MyApp;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\1-end\app\pages\_document.tsx -----

import Document, { Head, Html, Main, NextScript } from 'next/document';
import React from 'react';

class MyDocument extends Document {
  public render() {
    console.log(process.env.NEXT_PUBLIC_URL_APP);
    return (
      <Html lang="en">
        <Head>
          <meta charSet="utf-8" />
          <meta name="google" content="notranslate" />
          <meta name="theme-color" content="#303030" />
        </Head>
        <body>
          <Main />
          <NextScript />
        </body>
      </Html>
    );
  }
}

export default MyDocument;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\1-end\app\server\app.ts -----

const a = 'someString';

// some comment

export default a;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\1-end\app\.eslintrc.js -----

module.exports = {
  settings: {
    react: { version: 'detect' },
  },
  parser: '@typescript-eslint/parser',
  extends: ['plugin:react/recommended', 'plugin:@typescript-eslint/recommended', 'prettier'],
  env: {
    es6: true,
    node: true,
  },
  plugins: ['prettier', 'react'],
  rules: {
    'prettier/prettier': [
      'error',
      {
        singleQuote: true,
        trailingComma: 'all',
        arrowParens: 'always',
        printWidth: 100,
        semi: true,
      },
    ],
    '@typescript-eslint/camelcase': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    'react/no-unescaped-entities': 'off',
    'react/jsx-filename-extension': ['error', { extensions: ['.tsx'] }],
    'prefer-arrow-callback': 'error',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
  },
};

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\1-end\app\next-env.d.ts -----

/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/basic-features/typescript for more information.

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\1-end\app\next.config.js -----

module.exports = {
  poweredByHeader: false,
  webpack5: true,
  typescript: {
    ignoreBuildErrors: true,
  },
};

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\1-end\app\package.json -----

{
  "name": "1-end-app",
  "version": "1",
  "license": "MIT",
  "scripts": {
    "dev": "next",
    "build": "next build && tsc --project tsconfig.server.json",
    "lint": "eslint . --ext .ts,.tsx"
  },
  "dependencies": {
    "dotenv": "^16.4.7",
    "next": "^15.2.3",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "typescript": "^5.8.2"
  },
  "devDependencies": {
    "@types/node": "^22.13.10",
    "@types/react": "^19.0.12",
    "@types/react-dom": "^19.0.4",
    "@typescript-eslint/eslint-plugin": "^8.27.0",
    "@typescript-eslint/parser": "^8.27.0",
    "eslint": "^9.22.0",
    "eslint-config-prettier": "^10.1.1",
    "eslint-plugin-prettier": "^5.2.3",
    "eslint-plugin-react": "^7.37.4",
    "prettier": "^3.5.3"
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\1-end\app\tsconfig.json -----

{
  "compileOnSave": false,
  "compilerOptions": {
    "target": "esnext",
    "module": "esnext",
    "jsx": "preserve",
    "allowJs": true,
    "alwaysStrict": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "removeComments": true,
    "preserveConstEnums": true,
    "sourceMap": false,
    "skipLibCheck": true,
    "baseUrl": ".",
    "typeRoots": [
      "./node_modules/@types"
    ],
    "lib": [
      "dom",
      "es2017"
    ],
    "strict": false,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "incremental": true
  },
  "include": [
    "next-env.d.ts",
    "./**/*.tsx",
    "./**/*.ts"
  ],
  "exclude": [
    "dist",
    "production-server",
    ".next",
    "out",
    "next.config.js",
    "node_modules"
  ]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\1-end\app\tsconfig.server.json -----

{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "module": "commonjs",
    "outDir": "production-server/",
    "target": "es2017",
    "isolatedModules": false,
    "noEmit": false
  },
  "exclude": ["./server/types.d.ts"],
  "include": ["./server/**/*.ts"],
  "typeRoots": ["./node_modules/@types", "./server/types.d.ts"]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\server\api\index.ts -----

import * as express from 'express';

import publicExpressRoutes from './public';
import teamMemberExpressRoutes from './team-member';
import teamLeaderApi from './team-leader';

function handleError(err, _, res, __) {
  console.error(err.stack);

  res.json({ error: err.message || err.toString() });
}

export default function api(server: express.Express) {
  server.use('/api/v1/public', publicExpressRoutes, handleError);
  server.use('/api/v1/team-member', teamMemberExpressRoutes, handleError);
  server.use('/api/v1/team-leader', teamLeaderApi, handleError);
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\server\api\public.ts -----

import * as express from 'express';

import User from '../models/User';
import Invitation from '../models/Invitation';

const router = express.Router();

router.get('/get-user', (req, res) => {
  console.log(req.user);
  res.json({ user: req.user || null });
});

router.post('/get-user-by-slug', async (req, res, next) => {
  console.log('Express route: /get-user-by-slug');

  // req.session.foo = 'bar';

  try {
    const { slug } = req.body;

    const user = await User.getUserBySlug({ slug });

    res.json({ user });
  } catch (err) {
    next(err);
  }
});

router.get('/invitations/get-team-by-token', async (req, res, next) => {
  const token = req.query.token as string;

  try {
    const team = await Invitation.getTeamByToken({ token });

    res.json({ team });
  } catch (err) {
    next(err);
  }
});

export default router;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\server\api\team-leader.ts -----

import * as express from 'express';

import Invitation from '../models/Invitation';
import Team from '../models/Team';
import User from '../models/User';
import { createSession } from '../stripe';

const router = express.Router();

router.use((req, res, next) => {
  console.log('team leader API', req.path);

  if (!req.user) {
    res.status(401).json({ error: 'Unauthorized' });
    return;
  }

  next();
});

router.post('/teams/add', async (req: any, res, next) => {
  try {
    const { name, avatarUrl } = req.body;

    console.log(`Express route: ${name}, ${avatarUrl}`);

    const team = await Team.addTeam({ userId: req.user.id, name, avatarUrl });

    res.json(team);
  } catch (err) {
    next(err);
  }
});

router.post('/teams/update', async (req: any, res, next) => {
  try {
    const { teamId, name, avatarUrl } = req.body;

    // console.log(req.user.id, typeof req.user.id);
    // console.log(req.user._id, typeof req.user._id);

    const team = await Team.updateTeam({
      userId: req.user.id,
      teamId,
      name,
      avatarUrl,
    });

    res.json(team);
  } catch (err) {
    next(err);
  }
});

router.get('/teams/get-invitations-for-team', async (req: any, res, next) => {
  try {
    const invitations = await Invitation.getTeamInvitations({
      userId: req.user.id,
      teamId: req.query.teamId as string,
    });

    res.json({ invitations });
  } catch (err) {
    next(err);
  }
});

router.post('/teams/invite-member', async (req: any, res, next) => {
  try {
    const { teamId, email } = req.body;

    const newInvitation = await Invitation.add({ userId: req.user.id, teamId, email });

    res.json({ newInvitation });
  } catch (err) {
    next(err);
  }
});

router.post('/teams/remove-member', async (req: any, res, next) => {
  try {
    const { teamId, userId } = req.body;

    await Team.removeMember({ teamLeaderId: req.user.id, teamId, userId });

    res.json({ done: 1 });
  } catch (err) {
    next(err);
  }
});

router.post('/stripe/fetch-checkout-session', async (req: any, res, next) => {
  try {
    const { mode, teamId } = req.body;

    const user = await User.findById(req.user.id)
      .select(['stripeCustomer', 'email'])
      .setOptions({ lean: true });

    const team = await Team.findById(teamId)
      .select(['stripeSubscription', 'slug', 'teamLeaderId'])
      .setOptions({ lean: true });

    if (!user || !team || team.teamLeaderId !== req.user.id) {
      throw new Error('Permission denied');
    }

    const session = await createSession({
      mode,
      userId: user._id.toString(),
      userEmail: user.email,
      teamId,
      teamSlug: team.slug,
      customerId: (user.stripeCustomer && user.stripeCustomer.id) || undefined,
      subscriptionId: (team.stripeSubscription && team.stripeSubscription.id) || undefined,
    });

    res.json({ sessionId: session.id });
  } catch (err) {
    next(err);
  }
});

router.post('/cancel-subscription', async (req: any, res, next) => {
  const { teamId } = req.body;

  try {
    const { isSubscriptionActive } = await Team.cancelSubscription({
      teamLeaderId: req.user.id,
      teamId,
    });

    res.json({ isSubscriptionActive });
  } catch (err) {
    next(err);
  }
});

router.get('/get-list-of-invoices-for-customer', async (req: any, res, next) => {
  try {
    const { stripeListOfInvoices } = await User.getListOfInvoicesForCustomer({
      userId: req.user.id,
    });
    res.json({ stripeListOfInvoices });
  } catch (err) {
    next(err);
  }
});

export default router;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\server\api\team-member.ts -----

import * as express from "express";

import { signRequestForUpload } from "../aws-s3";

import User from "../models/User";
import Team from "../models/Team";
import Invitation from "../models/Invitation";
import Discussion from "../models/Discussion";
import Post from "../models/Post";

import { discussionAdded, discussionDeleted, discussionEdited, postAdded, postDeleted, postEdited } from "../sockets";

const router = express.Router();

router.use((req, res, next) => {
  console.log("team member API", req.path);
  if (!req.user) {
    res.status(401).json({ error: "Unauthorized" });
    return;
  }

  next();
});

// Get signed request from AWS S3 server
router.post("/aws/get-signed-request-for-upload-to-s3", async (req, res, next) => {
  try {
    const { fileName, fileType, prefix, bucket } = req.body;

    const returnData = await signRequestForUpload({
      fileName,
      fileType,
      prefix,
      bucket,
    });

    console.log(bucket);

    res.json(returnData);
  } catch (err) {
    next(err);
  }
});

router.post("/user/update-profile", async (req: any, res, next) => {
  try {
    const { name, avatarUrl } = req.body;

    const updatedUser = await User.updateProfile({
      userId: req.user.id,
      name,
      avatarUrl,
    });

    res.json({ updatedUser });
  } catch (err) {
    next(err);
  }
});

router.post("/user/toggle-theme", async (req: any, res, next) => {
  try {
    const { darkTheme } = req.body;

    await User.toggleTheme({ userId: req.user.id, darkTheme });

    res.json({ done: 1 });
  } catch (err) {
    next(err);
  }
});

async function loadDiscussionsData(team, userId, body) {
  const { discussionSlug } = body;

  if (!discussionSlug) {
    return [];
  }

  const { discussions } = await Discussion.getList({
    userId,
    teamId: team._id,
  });

  for (const discussion of discussions) {
    if (discussion.slug === discussionSlug) {
      Object.assign(discussion, {
        initialPosts: await Post.getList({
          userId,
          discussionId: discussion._id.toString(),
        }),
      });

      break;
    }
  }

  return discussions;
}

async function loadTeamData(team, userId, body) {
  const initialMembers = await User.getMembersForTeam({
    userId,
    teamId: team._id,
  });

  let initialInvitations = [];
  if (userId === team.teamLeaderId) {
    initialInvitations = await Invitation.getTeamInvitations({
      userId,
      teamId: team._id,
    });
  }

  console.log(`initialMembers:${initialMembers}`);

  const initialDiscussions = await loadDiscussionsData(team, userId, body);

  const data: any = { initialMembers, initialInvitations, initialDiscussions };

  // console.log(`Express route:${data.initialPosts}`);

  return data;
}

router.post("/get-initial-data", async (req: any, res, next) => {
  try {
    const teams = await Team.getAllTeamsForUser(req.user.id);

    let selectedTeamSlug = req.body.teamSlug;
    if (!selectedTeamSlug && teams && teams.length > 0) {
      selectedTeamSlug = teams[0].slug;
    }

    for (const team of teams) {
      if (team.slug === selectedTeamSlug) {
        Object.assign(team, await loadTeamData(team, req.user.id, req.body));
        break;
      }
    }

    res.json({ teams });
  } catch (err) {
    next(err);
  }
});

router.get("/teams", async (req: any, res, next) => {
  try {
    const teams = await Team.getAllTeamsForUser(req.user.id);

    console.log(teams);

    res.json({ teams });
  } catch (err) {
    next(err);
  }
});

router.get("/teams/get-members", async (req: any, res, next) => {
  try {
    const users = await User.getMembersForTeam({
      userId: req.user.id,
      teamId: req.query.teamId as string,
    });

    res.json({ users });
  } catch (err) {
    next(err);
  }
});

router.post("/discussions/add", async (req: any, res, next) => {
  try {
    const { name, teamId, memberIds = [], socketId, notificationType } = req.body;

    const discussion = await Discussion.add({
      userId: req.user.id,
      name,
      teamId,
      memberIds,
      notificationType,
    });

    discussionAdded({ socketId, discussion });

    res.json({ discussion });
  } catch (err) {
    next(err);
  }
});

router.post("/discussions/edit", async (req: any, res, next) => {
  try {
    const { name, id, memberIds = [], socketId, notificationType } = req.body;

    const updatedDiscussion = await Discussion.edit({
      userId: req.user.id,
      name,
      id,
      memberIds,
      notificationType,
    });

    discussionEdited({ socketId, discussion: updatedDiscussion });

    res.json({ done: 1 });
  } catch (err) {
    next(err);
  }
});

router.post("/discussions/delete", async (req: any, res, next) => {
  try {
    const { id, socketId } = req.body;

    const { teamId } = await Discussion.delete({ userId: req.user.id, id });

    discussionDeleted({ socketId, teamId, id });

    res.json({ done: 1 });
  } catch (err) {
    next(err);
  }
});

router.get("/discussions/list", async (req: any, res, next) => {
  try {
    const { discussions } = await Discussion.getList({
      userId: req.user.id,
      teamId: req.query.teamId as string,
    });

    res.json({ discussions });
  } catch (err) {
    next(err);
  }
});

router.get("/posts/list", async (req: any, res, next) => {
  try {
    const posts = await Post.getList({
      userId: req.user.id,
      discussionId: req.query.discussionId as string,
    });

    res.json({ posts });
  } catch (err) {
    next(err);
  }
});

router.post("/posts/add", async (req: any, res, next) => {
  try {
    const { content, discussionId, socketId } = req.body;

    const post = await Post.add({ userId: req.user.id, content, discussionId });

    postAdded({ socketId, post });

    res.json({ post });
  } catch (err) {
    next(err);
  }
});

router.post("/posts/edit", async (req: any, res, next) => {
  try {
    const { content, id, socketId } = req.body;

    const updatedPost = await Post.edit({ userId: req.user.id, content, id });

    postEdited({ socketId, post: updatedPost });

    res.json({ done: 1 });
  } catch (err) {
    next(err);
  }
});

router.post("/posts/delete", async (req: any, res, next) => {
  try {
    const { id, discussionId, socketId } = req.body;

    await Post.delete({ userId: req.user.id, id });

    postDeleted({ socketId, id, discussionId });

    res.json({ done: 1 });
  } catch (err) {
    next(err);
  }
});

export default router;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\server\models\Discussion.ts -----

import { uniq } from 'lodash';
import * as mongoose from 'mongoose';

import { generateNumberSlug } from '../utils/slugify';
import Team, { TeamDocument } from './Team';
import Post from './Post';

const mongoSchema = new mongoose.Schema({
  createdUserId: {
    type: String,
    required: true,
  },
  teamId: {
    type: String,
    required: true,
  },
  name: {
    type: String,
    required: true,
  },
  slug: {
    type: String,
    required: true,
  },
  memberIds: [
    {
      type: String,
    },
  ],
  createdAt: {
    type: Date,
    required: true,
    default: Date.now,
  },
  notificationType: {
    type: String,
    enum: ['default', 'email'],
    required: true,
    default: 'default',
  },
});

export interface DiscussionDocument extends mongoose.Document {
  createdUserId: string;
  teamId: string;
  name: string;
  slug: string;
  memberIds: string[];
  createdAt: Date;
  notificationType: string;
}

interface DiscussionModel extends mongoose.Model<DiscussionDocument> {
  getList({
    userId,
    teamId,
  }: {
    userId: string;
    teamId: string;
  }): Promise<{ discussions: DiscussionDocument[] }>;

  add({
    name,
    userId,
    teamId,
    memberIds,
    notificationType,
  }: {
    name: string;
    userId: string;
    teamId: string;
    memberIds: string[];
    notificationType: string;
  }): Promise<DiscussionDocument>;

  edit({
    userId,
    id,
    name,
    memberIds,
    notificationType,
  }: {
    userId: string;
    id: string;
    name: string;
    memberIds: string[];
    notificationType: string;
  }): Promise<DiscussionDocument>;

  delete({ userId, id }: { userId: string; id: string }): Promise<{ teamId: string }>;

  checkPermissionAndGetTeam({
    userId,
    teamId,
    memberIds,
  }: {
    userId: string;
    teamId: string;
    memberIds: string[];
  }): Promise<TeamDocument>;
}

class DiscussionClass extends mongoose.Model {
  public static async getList({ userId, teamId }) {
    await this.checkPermissionAndGetTeam({ userId, teamId });

    const filter: any = { teamId, memberIds: userId };

    const discussions: any[] = await this.find(filter).setOptions({ lean: true });

    return { discussions };
  }

  public static async add({ name, userId, teamId, memberIds = [], notificationType }) {
    if (!name) {
      throw new Error('Bad data');
    }

    await this.checkPermissionAndGetTeam({ userId, teamId, memberIds });

    const slug = await generateNumberSlug(this, { teamId });

    return this.create({
      createdUserId: userId,
      teamId,
      name,
      slug,
      memberIds: uniq([userId, ...memberIds]),
      createdAt: new Date(),
      notificationType,
    });
  }

  public static async edit({ userId, id, name, memberIds = [], notificationType }) {
    if (!id) {
      throw new Error('Bad data');
    }

    const discussion = await this.findById(id)
      .select('teamId createdUserId')
      .setOptions({ lean: true });

    const team = await this.checkPermissionAndGetTeam({
      userId,
      teamId: discussion.teamId,
      memberIds,
    });

    if (discussion.createdUserId !== userId && team.teamLeaderId !== userId) {
      throw new Error('Permission denied. Only author or team leader can edit Discussion.');
    }

    const updatedObj = await this.findOneAndUpdate(
      { _id: id },
      {
        name,
        memberIds: uniq([userId, ...memberIds]),
        notificationType,
      },
      { runValidators: true, new: true },
    );

    return updatedObj;
  }

  public static async delete({ userId, id }) {
    if (!id) {
      throw new Error('Bad data');
    }

    const discussion = await this.findById(id).select('teamId').setOptions({ lean: true });

    await this.checkPermissionAndGetTeam({ userId, teamId: discussion.teamId });

    await Post.deleteMany({ discussionId: id });

    await this.deleteOne({ _id: id });

    return { teamId: discussion.teamId };
  }

  private static async checkPermissionAndGetTeam({ userId, teamId, memberIds = [] }) {
    if (!userId || !teamId) {
      throw new Error('Bad data');
    }

    const team = await Team.findById(teamId)
      .select('memberIds teamLeaderId')
      .setOptions({ lean: true });

    if (!team || team.memberIds.indexOf(userId) === -1) {
      throw new Error('Team not found');
    }

    for (const id of memberIds) {
      if (team.memberIds.indexOf(id) === -1) {
        throw new Error('Permission denied');
      }
    }

    return team;
  }
}

mongoSchema.loadClass(DiscussionClass);

const Discussion = mongoose.model<DiscussionDocument, DiscussionModel>('Discussion', mongoSchema);

export default Discussion;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\server\models\EmailTemplate.ts -----

import * as _ from 'lodash';
import * as mongoose from 'mongoose';

interface EmailTemplateDocument extends mongoose.Document {
  name: string;
  subject: string;
  message: string;
}

const EmailTemplate = mongoose.model<EmailTemplateDocument>(
  'EmailTemplate',
  new mongoose.Schema({
    name: {
      type: String,
      required: true,
      unique: true,
    },
    subject: {
      type: String,
      required: true,
    },
    message: {
      type: String,
      required: true,
    },
  }),
);

export async function insertTemplates() {
  const templates = [
    {
      name: 'welcome',
      subject: 'Welcome to SaaS boilerplate by Async',
      message: `Welcome <%= userName %>,
        <p>
          Thanks for signing up on our <a href="https://github.com/async-labs/saas" target="blank">SaaS boilerplate</a>!
        </p>
        <p>
          If you are learning how to build a SaaS web app, check out our 2 books:
           <a href="https://builderbook.org" target="blank">Builder Book</a>
           and
           <a href="https://builderbook.org/book" target="blank">SaaS Boilerplate</a>.
        </p>
        <p>
          Also check out
          <a href="https://async-await.com" target="blank"> Async</a>
          , our communication tool for small teams of software developers.
        </p>
        Kelly & Timur, Team Async
      `,
    },
    {
      name: 'login',
      subject: 'Login link for saas-app.async-await.com',
      message: `
        <p>Log into your account by clicking on this link: <a href="<%= loginURL %>"><%= loginURL %></a>.</p>`,
    },
    {
      name: 'invitation',
      subject: 'You are invited to join a team at saas-app.async-await.com',
      message: `You've been invited to join <b><%= teamName%></b>.
        <br/>Click here to accept the invitation: <%= invitationURL%>
      `,
    },
    {
      name: 'newPost',
      subject: 'New Post was created in Discussion: <%= discussionName %>',
      message: `<p>New Post in Discussion: "<%= discussionName%>" by <%= authorName%></p>
        New Post: "<%= postContent %>"
        <p>---</p>
        <p>View it at <a href="<%= discussionLink %>"><%= discussionLink %></a>.</p>
      `,
    },
  ];

  for (const t of templates) {
    const et = await EmailTemplate.findOne({ name: t.name }).setOptions({ lean: true });
    const message = t.message.replace(/\n/g, '').replace(/[ ]+/g, ' ').trim();

    if (!et) {
      EmailTemplate.create(Object.assign({}, t, { message }));
    } else if (et.subject !== t.subject || et.message !== message) {
      EmailTemplate.updateOne({ _id: et._id }, { $set: { message, subject: t.subject } }).exec();
    }
  }
}

export default async function getEmailTemplate(name: string, params: any) {
  await insertTemplates();

  const et = await EmailTemplate.findOne({ name }).setOptions({ lean: true });

  if (!et) {
    throw new Error('Email Template is not found in database.');
  }

  return {
    message: _.template(et.message)(params),
    subject: _.template(et.subject)(params),
  };
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\server\models\Invitation.ts -----

import * as mongoose from 'mongoose';

import sendEmail from '../aws-ses';
import getEmailTemplate from './EmailTemplate';
import Team from './Team';
import User, { UserDocument } from './User';

const mongoSchema = new mongoose.Schema({
  teamId: {
    type: String,
    required: true,
  },
  email: {
    type: String,
    required: true,
  },
  createdAt: {
    type: Date,
    required: true,
    default: Date.now,
    expires: 60 * 60 * 24, // delete doc after 24 hours
  },
  token: {
    type: String,
    required: true,
    unique: true,
  },
});

mongoSchema.index({ teamId: 1, email: 1 }, { unique: true });

interface InvitationDocument extends mongoose.Document {
  teamId: string;
  email: string;
  createdAt: Date;
  token: string;
}

interface InvitationModel extends mongoose.Model<InvitationDocument> {
  add({
    userId,
    teamId,
    email,
  }: {
    userId: string;
    teamId: string;
    email: string;
  }): InvitationDocument;

  getTeamInvitations({ userId, teamId }: { userId: string; teamId: string });
  getTeamByToken({ token }: { token: string });
  addUserToTeam({ token, user }: { token: string; user: UserDocument });
}

function generateToken() {
  const gen = () =>
    Math.random().toString(36).substring(2, 12) + Math.random().toString(36).substring(2, 12);

  return `${gen()}`;
}

class InvitationClass extends mongoose.Model {
  public static async add({ userId, teamId, email }) {
    if (!teamId || !email) {
      throw new Error('Bad data');
    }

    const team = await Team.findById(teamId).setOptions({ lean: true });
    if (!team || team.teamLeaderId !== userId) {
      throw new Error('Team does not exist or you have no permission');
    }

    const registeredUser = await User.findOne({ email }).setOptions({ lean: true });

    if (registeredUser && team.memberIds.includes(registeredUser._id.toString())) {
      throw new Error('This user is already Team Member.');
    }

    let token;
    const invitation = await this.findOne({ teamId, email })
      .select('token')
      .setOptions({ lean: true });

    if (invitation) {
      token = invitation.token;
    } else {
      token = generateToken();
      while ((await this.countDocuments({ token })) > 0) {
        token = generateToken();
      }

      await this.create({
        teamId,
        email,
        token,
      });
    }

    const emailTemplate = await getEmailTemplate('invitation', {
      teamName: team.name,
      invitationURL: `${process.env.URL_APP}/invitation?token=${token}`,
    });

    if (!emailTemplate) {
      throw new Error('Invitation email template not found');
    }

    try {
      await sendEmail({
        from: `Kelly from saas-app.async-await.com <${process.env.EMAIL_SUPPORT_FROM_ADDRESS}>`,
        to: [email],
        subject: emailTemplate.subject,
        body: emailTemplate.message,
      });
    } catch (err) {
      console.log('Email sending error:', err);
    }

    return await this.findOne({ teamId, email }).setOptions({ lean: true });
  }

  public static async getTeamInvitations({ userId, teamId }) {
    const team = await Team.findOne({ _id: teamId })
      .select('teamLeaderId')
      .setOptions({ lean: true });

    if (userId !== team.teamLeaderId) {
      throw new Error('You have no permission.');
    }

    return this.find({ teamId }).select('email').setOptions({ lean: true });
  }

  public static async getTeamByToken({ token }) {
    if (!token) {
      throw new Error('Bad data');
    }

    const invitation = await this.findOne({ token }).setOptions({ lean: true });

    if (!invitation) {
      throw new Error('Invitation not found');
    }

    const team = await Team.findById(invitation.teamId)
      .select('name slug avatarUrl memberIds')
      .setOptions({ lean: true });

    if (!team) {
      throw new Error('Team does not exist');
    }

    return team;
  }

  public static async addUserToTeam({ token, user }) {
    if (!token || !user) {
      throw new Error('Bad data');
    }

    const invitation = await this.findOne({ token }).setOptions({ lean: true });

    if (!invitation || invitation.email !== user.email) {
      throw new Error('Invitation not found');
    }

    await this.deleteOne({ token });

    const team = await Team.findById(invitation.teamId)
      .select('memberIds slug teamLeaderId')
      .setOptions({ lean: true });

    if (!team) {
      throw new Error('Team does not exist');
    }

    if (team && !team.memberIds.includes(user._id)) {
      await Team.updateOne({ _id: team._id }, { $addToSet: { memberIds: user._id } });

      if (user._id !== team.teamLeaderId) {
        await User.findByIdAndUpdate(user._id, { $set: { defaultTeamSlug: team.slug } });
      }
    }

    return team.slug;
  }
}

mongoSchema.loadClass(InvitationClass);

const Invitation = mongoose.model<InvitationDocument, InvitationModel>('Invitation', mongoSchema);

export default Invitation;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\server\models\Post.ts -----

import * as mongoose from "mongoose";

import * as he from "he";
import hljs from "highlight.js";
import { marked } from "marked";

import Discussion from "./Discussion";
import Team from "./Team";

const mongoSchema = new mongoose.Schema({
  createdUserId: {
    type: String,
    required: true,
  },
  discussionId: {
    type: String,
    required: true,
  },
  content: {
    type: String,
    required: true,
  },
  htmlContent: {
    type: String,
    required: true,
  },
  isEdited: {
    type: Boolean,
    default: false,
  },
  lastUpdatedAt: Date,
  createdAt: {
    type: Date,
    required: true,
  },
});

function markdownToHtml(content) {
  const renderer = new marked.Renderer();

  renderer.link = ({ href, title, text }) => {
    const t = title ? ` title="${title}"` : "";

    if (text.startsWith("<code>@#")) {
      return `${text.replace("<code>@#", "<code>@")} `;
    }

    return `
      <a target="_blank" href="${href}" rel="noopener noreferrer"${t}>
        ${text}
      </a>
    `;
  };

  renderer.code = ({ text, lang }) => {
    const language = hljs.getLanguage(lang) ? lang : "plaintext";

    return `<pre><code class="hljs language-${lang}">${hljs.highlight(text, { language }).value}</code></pre>`;
  };

  marked.setOptions({
    renderer,
    breaks: true,
  });

  return marked(he.decode(content));
}

export interface PostDocument extends mongoose.Document {
  createdUserId: string;
  discussionId: string;
  content: string;
  isEdited: boolean;
  lastUpdatedAt: Date;
  createdAt: Date;
}

interface PostModel extends mongoose.Model<PostDocument> {
  getList({ userId, discussionId }: { userId: string; discussionId: string }): Promise<PostDocument[]>;

  add({
    content,
    userId,
    discussionId,
  }: {
    content: string;
    userId: string;
    discussionId: string;
  }): Promise<PostDocument>;

  edit({ content, userId, id }: { content: string; userId: string; id: string }): Promise<PostDocument>;

  delete({ userId, id }: { userId: string; id: string }): Promise<void>;

  checkPermissionAndGetTeamAndDiscussion({
    userId,
    discussionId,
    post,
  }: {
    userId: string;
    discussionId: string;
    post: PostDocument;
  }): Promise<{ TeamDocument; DiscussionDocument }>;
}

class PostClass extends mongoose.Model {
  public static async getList({ userId, discussionId }) {
    await this.checkPermissionAndGetTeamAndDiscussion({ userId, discussionId });

    const filter: any = { discussionId };

    const posts: any[] = await this.find(filter).sort({ createdAt: 1 }).setOptions({ lean: true });

    return posts;
  }

  public static async add({ content, userId, discussionId }) {
    if (!content) {
      throw new Error("Bad data");
    }

    await this.checkPermissionAndGetTeamAndDiscussion({ userId, discussionId });

    const htmlContent = markdownToHtml(content);

    const post = await this.create({
      createdUserId: userId,
      discussionId,
      content,
      htmlContent,
      createdAt: new Date(),
    });

    return post;
  }

  public static async edit({ content, userId, id }) {
    if (!content || !id) {
      throw new Error("Bad data");
    }

    const post = await this.findById(id).select("createdUserId discussionId").setOptions({ lean: true });

    await this.checkPermissionAndGetTeamAndDiscussion({
      userId,
      discussionId: post.discussionId,
      post,
    });

    const htmlContent = markdownToHtml(content);

    const updatedObj = await this.findOneAndUpdate(
      { _id: id },
      { content, htmlContent, isEdited: true, lastUpdatedAt: new Date() },
      { runValidators: true, new: true }
    );

    return updatedObj;
  }

  public static async delete({ userId, id }) {
    if (!id) {
      throw new Error("Bad data");
    }

    const post = await this.findById(id).select("createdUserId discussionId content").setOptions({ lean: true });

    await this.checkPermissionAndGetTeamAndDiscussion({
      userId,
      discussionId: post.discussionId,
      post,
    });

    await this.deleteOne({ _id: id });
  }

  private static async checkPermissionAndGetTeamAndDiscussion({ userId, discussionId, post = null }) {
    if (!userId || !discussionId) {
      throw new Error("Bad data");
    }

    if (post && post.createdUserId !== userId) {
      throw new Error("Permission denied");
    }

    const discussion = await Discussion.findById(discussionId)
      .select("teamId memberIds slug")
      .setOptions({ lean: true });

    if (!discussion) {
      throw new Error("Discussion not found");
    }

    if (discussion.memberIds.indexOf(userId) === -1) {
      throw new Error("Permission denied");
    }

    const team = await Team.findById(discussion.teamId).select("memberIds slug").setOptions({ lean: true });

    if (!team || team.memberIds.indexOf(userId) === -1) {
      throw new Error("Team not found");
    }

    return { team, discussion };
  }
}

mongoSchema.loadClass(PostClass);

const Post = mongoose.model<PostDocument, PostModel>("Post", mongoSchema);

export default Post;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\server\models\Team.ts -----

import * as mongoose from 'mongoose';
import Stripe from 'stripe';

import { cancelSubscription } from '../stripe';
import { generateNumberSlug } from '../utils/slugify';
import User from './User';

const mongoSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
  },
  slug: {
    type: String,
    required: true,
    unique: true,
  },
  avatarUrl: String,
  createdAt: {
    type: Date,
    required: true,
  },
  teamLeaderId: {
    type: String,
    required: true,
  },
  memberIds: [
    {
      type: String,
      required: true,
    },
  ],
  defaultTeam: {
    type: Boolean,
    default: false,
  },
  stripeSubscription: {
    id: String,
    object: String,
    application_fee_percent: Number,
    billing: String,
    cancel_at_period_end: Boolean,
    billing_cycle_anchor: Number,
    canceled_at: Number,
    created: Number,
  },
  isSubscriptionActive: {
    type: Boolean,
    default: false,
  },
  isPaymentFailed: {
    type: Boolean,
    default: false,
  },
});

export interface TeamDocument extends mongoose.Document {
  name: string;
  slug: string;
  avatarUrl: string;
  createdAt: Date;

  teamLeaderId: string;
  memberIds: string[];
  defaultTeam: boolean;

  stripeSubscription: {
    id: string;
    object: string;
    application_fee_percent: number;
    billing: string;
    cancel_at_period_end: boolean;
    billing_cycle_anchor: number;
    canceled_at: number;
    created: number;
  };
  isSubscriptionActive: boolean;
  isPaymentFailed: boolean;
}

interface TeamModel extends mongoose.Model<TeamDocument> {
  addTeam({
    name,
    userId,
  }: {
    userId: string;
    name: string;
    avatarUrl: string;
  }): Promise<TeamDocument>;

  updateTeam({
    userId,
    teamId,
    name,
    avatarUrl,
  }: {
    userId: string;
    teamId: string;
    name: string;
    avatarUrl: string;
  }): Promise<TeamDocument>;

  getAllTeamsForUser(userId: string): Promise<TeamDocument[]>;

  removeMember({
    teamId,
    teamLeaderId,
    userId,
  }: {
    teamId: string;
    teamLeaderId: string;
    userId: string;
  }): Promise<void>;

  subscribeTeam({
    session,
    team,
  }: {
    session: Stripe.Checkout.Session;
    team: TeamDocument;
  }): Promise<void>;

  cancelSubscription({
    teamLeaderId,
    teamId,
  }: {
    teamLeaderId: string;
    teamId: string;
  }): Promise<TeamDocument>;

  cancelSubscriptionAfterFailedPayment({
    subscriptionId,
  }: {
    subscriptionId: string;
  }): Promise<TeamDocument>;
}

class TeamClass extends mongoose.Model {
  public static async addTeam({ userId, name, avatarUrl }) {
    console.log(`Static method: ${name}, ${avatarUrl}`);

    if (!userId || !name || !avatarUrl) {
      throw new Error('Bad data');
    }

    const slug = await generateNumberSlug(this);

    let defaultTeam = false;
    if ((await this.countDocuments({ teamLeaderId: userId })) === 0) {
      await User.findByIdAndUpdate(userId, { $set: { defaultTeamSlug: slug } });
      defaultTeam = true;
    }

    const team = await this.create({
      teamLeaderId: userId,
      name,
      slug,
      avatarUrl,
      memberIds: [userId],
      createdAt: new Date(),
      defaultTeam,
    });

    return team;
  }

  public static async updateTeam({ userId, teamId, name, avatarUrl }) {
    const team = await this.findById(teamId, 'name teamLeaderId');

    if (!team) {
      throw new Error('Team not found');
    }

    if (team.teamLeaderId !== userId) {
      throw new Error('Permission denied');
    }

    const modifier = { name: team.name, avatarUrl };

    if (name !== team.name) {
      modifier.name = name;
    }

    await this.updateOne({ _id: teamId }, { $set: modifier }, { runValidators: true });

    return this.findById(teamId, 'name avatarUrl slug defaultTeam').setOptions({ lean: true });
  }

  public static getAllTeamsForUser(userId: string) {
    console.log(`userId:${userId}`);
    return this.find({ memberIds: userId }).setOptions({ lean: true });
  }

  public static async removeMember({ teamId, teamLeaderId, userId }) {
    const team = await this.findById(teamId).select('memberIds teamLeaderId');

    if (!team) {
      throw new Error('Team does not exist');
    }

    if (team.teamLeaderId !== teamLeaderId || teamLeaderId === userId) {
      throw new Error('Permission denied');
    }

    await this.findByIdAndUpdate(teamId, { $pull: { memberIds: userId } });
  }

  public static async subscribeTeam({
    session,
    team,
  }: {
    session: Stripe.Checkout.Session;
    team: TeamDocument;
  }) {
    if (!session.subscription) {
      throw new Error('Not subscribed');
    }

    if (!team) {
      throw new Error('User not found.');
    }

    if (team.isSubscriptionActive) {
      throw new Error('Team is already subscribed.');
    }

    const stripeSubscription = session.subscription as Stripe.Subscription;
    if (stripeSubscription.canceled_at) {
      throw new Error('Unsubscribed');
    }

    await this.updateOne({ _id: team._id }, { stripeSubscription, isSubscriptionActive: true });
  }

  public static async cancelSubscription({ teamLeaderId, teamId }) {
    const team = await this.findById(teamId).select(
      'teamLeaderId isSubscriptionActive stripeSubscription',
    );

    if (team.teamLeaderId !== teamLeaderId) {
      throw new Error('You do not have permission to subscribe Team.');
    }

    if (!team.isSubscriptionActive) {
      throw new Error('Team is already unsubscribed.');
    }

    const cancelledSubscriptionObj = await cancelSubscription({
      subscriptionId: team.stripeSubscription.id,
    });

    return this.findByIdAndUpdate(
      teamId,
      {
        stripeSubscription: cancelledSubscriptionObj,
        isSubscriptionActive: false,
      },
      { new: true, runValidators: true },
    )
      .select('isSubscriptionActive stripeSubscription')
      .setOptions({ lean: true });
  }

  public static async cancelSubscriptionAfterFailedPayment({ subscriptionId }) {
    const team: any = await this.find({ 'stripeSubscription.id': subscriptionId })
      .select('teamLeaderId isSubscriptionActive stripeSubscription isPaymentFailed')
      .setOptions({ lean: true });
    if (!team.isSubscriptionActive) {
      throw new Error('Team is already unsubscribed.');
    }
    if (team.isPaymentFailed) {
      throw new Error('Team is already unsubscribed after failed payment.');
    }
    const cancelledSubscriptionObj = await cancelSubscription({
      subscriptionId,
    });
    return this.findByIdAndUpdate(
      team._id,
      {
        stripeSubscription: cancelledSubscriptionObj,
        isSubscriptionActive: false,
        isPaymentFailed: true,
      },
      { new: true, runValidators: true },
    )
      .select('isSubscriptionActive stripeSubscription isPaymentFailed')
      .setOptions({ lean: true });
  }
}

mongoSchema.loadClass(TeamClass);

const Team = mongoose.model<TeamDocument, TeamModel>('Team', mongoSchema);

export default Team;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\server\models\User.ts -----

import * as _ from 'lodash';
import * as mongoose from 'mongoose';
import Stripe from 'stripe';

import sendEmail from '../aws-ses';
import { addToMailchimp } from '../mailchimp';
import { generateSlug } from '../utils/slugify';
import getEmailTemplate from './EmailTemplate';
import Team, { TeamDocument } from './Team';

import { getListOfInvoices } from '../stripe';

const mongoSchema = new mongoose.Schema({
  slug: {
    type: String,
    required: true,
    unique: true,
  },
  createdAt: {
    type: Date,
    required: true,
  },
  email: {
    type: String,
    required: true,
    unique: true,
  },
  displayName: String,
  avatarUrl: String,
  googleId: {
    type: String,
    unique: true,
    sparse: true,
  },
  googleToken: {
    accessToken: String,
    refreshToken: String,
  },
  isSignedupViaGoogle: {
    type: Boolean,
    required: true,
    default: false,
  },
  darkTheme: Boolean,
  defaultTeamSlug: {
    type: String,
    default: '',
  },
  stripeCustomer: {
    id: String,
    object: String,
    created: Number,
    currency: String,
    default_source: String,
    description: String,
  },
  stripeCard: {
    id: String,
    object: String,
    brand: String,
    funding: String,
    country: String,
    last4: String,
    exp_month: Number,
    exp_year: Number,
  },
  hasCardInformation: {
    type: Boolean,
    default: false,
  },
  stripeListOfInvoices: {
    object: String,
    has_more: Boolean,
    data: [
      {
        id: String,
        object: String,
        amount_paid: Number,
        created: Number,
        customer: String,
        subscription: String,
        hosted_invoice_url: String,
        billing: String,
        paid: Boolean,
        number: String,
        teamId: String,
        teamName: String,
      },
    ],
  },
});

export interface UserDocument extends mongoose.Document {
  slug: string;
  createdAt: Date;
  email: string;
  displayName: string;
  avatarUrl: string;
  googleId: string;
  googleToken: { accessToken: string; refreshToken: string };
  isSignedupViaGoogle: boolean;
  darkTheme: boolean;
  defaultTeamSlug: string;
  stripeCustomer: {
    id: string;
    default_source: string;
    created: number;
    object: string;
    description: string;
  };
  stripeCard: {
    id: string;
    object: string;
    brand: string;
    country: string;
    last4: string;
    exp_month: number;
    exp_year: number;
    funding: string;
  };
  hasCardInformation: boolean;
  stripeListOfInvoices: {
    object: string;
    has_more: boolean;
    data: [
      {
        id: string;
        object: string;
        amount_paid: number;
        date: number;
        customer: string;
        subscription: string;
        hosted_invoice_url: string;
        billing: string;
        paid: boolean;
        number: string;
        teamId: string;
        teamName: string;
      },
    ];
  };
}

interface UserModel extends mongoose.Model<UserDocument> {
  getUserBySlug({ slug }: { slug: string }): Promise<UserDocument>;

  updateProfile({
    userId,
    name,
    avatarUrl,
  }: {
    userId: string;
    name: string;
    avatarUrl: string;
  }): Promise<UserDocument[]>;

  publicFields(): string[];

  signInOrSignUpViaGoogle({
    googleId,
    email,
    displayName,
    avatarUrl,
    googleToken,
  }: {
    googleId: string;
    email: string;
    displayName: string;
    avatarUrl: string;
    googleToken: { accessToken?: string; refreshToken?: string };
  }): Promise<UserDocument>;

  signInOrSignUpByPasswordless({
    uid,
    email,
  }: {
    uid: string;
    email: string;
  }): Promise<UserDocument>;

  toggleTheme({ userId, darkTheme }: { userId: string; darkTheme: boolean }): Promise<void>;

  getMembersForTeam({
    userId,
    teamId,
  }: {
    userId: string;
    teamId: string;
  }): Promise<UserDocument[]>;

  checkPermissionAndGetTeam({
    userId,
    teamId,
  }: {
    userId: string;
    teamId: string;
  }): Promise<TeamDocument>;

  saveStripeCustomerAndCard({
    user,
    session,
  }: {
    session: Stripe.Checkout.Session;
    user: UserDocument;
  }): Promise<void>;

  changeStripeCard({
    session,
    user,
  }: {
    session: Stripe.Checkout.Session;
    user: UserDocument;
  }): Promise<void>;

  getListOfInvoicesForCustomer({ userId }: { userId: string }): Promise<UserDocument>;
}

class UserClass extends mongoose.Model {
  public static async getUserBySlug({ slug }) {
    console.log('Static method: getUserBySlug');

    return this.findOne({ slug }, 'email displayName avatarUrl').setOptions({ lean: true });
  }

  public static async updateProfile({ userId, name, avatarUrl }) {
    console.log('Static method: updateProfile');

    const user = await this.findById(userId, 'slug displayName');

    const modifier = { displayName: user.displayName, avatarUrl, slug: user.slug };

    console.log(user.slug);

    if (name !== user.displayName) {
      modifier.displayName = name;
      modifier.slug = await generateSlug(this, name);
    }

    return this.findByIdAndUpdate(userId, { $set: modifier }, { new: true, runValidators: true })
      .select('displayName avatarUrl slug')
      .setOptions({ lean: true });
  }

  public static publicFields(): string[] {
    return [
      '_id',
      'id',
      'displayName',
      'email',
      'avatarUrl',
      'slug',
      'isSignedupViaGoogle',
      'darkTheme',
      'defaultTeamSlug',
      'stripeCard',
      'hasCardInformation',
      'stripeListOfInvoices',
    ];
  }

  public static async signInOrSignUpViaGoogle({
    googleId,
    email,
    displayName,
    avatarUrl,
    googleToken,
  }) {
    const user = await this.findOne({ email })
      .select([...this.publicFields(), 'googleId'].join(' '))
      .setOptions({ lean: true });

    if (user) {
      if (_.isEmpty(googleToken) && user.googleId) {
        return user;
      }

      const modifier = { googleId };
      if (googleToken.accessToken) {
        modifier['googleToken.accessToken'] = googleToken.accessToken;
      }

      if (googleToken.refreshToken) {
        modifier['googleToken.refreshToken'] = googleToken.refreshToken;
      }

      await this.updateOne({ email }, { $set: modifier });

      return user;
    }

    const slug = await generateSlug(this, displayName);

    const newUser = await this.create({
      createdAt: new Date(),
      googleId,
      email,
      googleToken,
      displayName,
      avatarUrl,
      slug,
      isSignedupViaGoogle: true,
      defaultTeamSlug: '',
      darkTheme: false,
    });

    const emailTemplate = await getEmailTemplate('welcome', { userName: displayName });

    if (!emailTemplate) {
      throw new Error('Welcome email template not found');
    }

    try {
      await sendEmail({
        from: `Kelly from saas-app.async-await.com <${process.env.EMAIL_SUPPORT_FROM_ADDRESS}>`,
        to: [email],
        subject: emailTemplate.subject,
        body: emailTemplate.message,
      });
    } catch (err) {
      console.error('Email sending error:', err);
    }

    try {
      await addToMailchimp({ email, listName: 'signups' });
    } catch (error) {
      console.error('Mailchimp error:', error);
    }

    return _.pick(newUser, this.publicFields());
  }

  public static async signInOrSignUpByPasswordless({ uid, email }) {
    const user = await this.findOne({ email })
      .select(this.publicFields().join(' '))
      .setOptions({ lean: true });

    if (user) {
      throw Error('User already exists');
    }

    const slug = await generateSlug(this, email);

    const newUser = await this.create({
      _id: uid,
      createdAt: new Date(),
      email,
      slug,
      defaultTeamSlug: '',
    });

    const emailTemplate = await getEmailTemplate('welcome', { userName: email });

    if (!emailTemplate) {
      throw new Error('Email template "welcome" not found in database.');
    }

    try {
      await sendEmail({
        from: `Kelly from saas-app.async-await.com <${process.env.EMAIL_SUPPORT_FROM_ADDRESS}>`,
        to: [email],
        subject: emailTemplate.subject,
        body: emailTemplate.message,
      });
    } catch (err) {
      console.error('Email sending error:', err);
    }

    try {
      await addToMailchimp({ email, listName: 'signups' });
    } catch (error) {
      console.error('Mailchimp error:', error);
    }

    return _.pick(newUser, this.publicFields());
  }

  public static toggleTheme({ userId, darkTheme }) {
    return this.updateOne({ _id: userId }, { darkTheme: !!darkTheme });
  }

  public static async getMembersForTeam({ userId, teamId }) {
    const team = await this.checkPermissionAndGetTeam({ userId, teamId });

    return this.find({ _id: { $in: team.memberIds } })
      .select(this.publicFields().join(' '))
      .setOptions({ lean: true });
  }

  public static async saveStripeCustomerAndCard({
    user,
    session,
  }: {
    session: Stripe.Checkout.Session;
    user: UserDocument;
  }) {
    if (!user) {
      throw new Error('User not found.');
    }

    const stripeSubscription = session.subscription as Stripe.Subscription;

    const stripeCard =
      (stripeSubscription.default_payment_method &&
        (stripeSubscription.default_payment_method as Stripe.PaymentMethod).card) ||
      undefined;

    const hasCardInformation = !!stripeCard;

    await this.updateOne(
      { _id: user._id },
      {
        stripeCustomer: session.customer,
        stripeCard,
        hasCardInformation,
      },
    );
  }

  public static async changeStripeCard({
    session,
    user,
  }: {
    session: Stripe.Checkout.Session;
    user: UserDocument;
  }): Promise<void> {
    if (!user) {
      throw new Error('User not found.');
    }

    const si: Stripe.SetupIntent = session.setup_intent as Stripe.SetupIntent;
    const pm: Stripe.PaymentMethod = si.payment_method as Stripe.PaymentMethod;

    if (!pm.card) {
      throw new Error('No card found.');
    }
    await this.updateOne({ _id: user._id }, { stripeCard: pm.card, hasCardInformation: true });
  }

  public static async getListOfInvoicesForCustomer({ userId }) {
    const user = await this.findById(userId, 'stripeCustomer');

    if (!user.stripeCustomer.id) {
      throw new Error('You are not a customer and you have no payment history.');
    }

    const newListOfInvoices = await getListOfInvoices({
      customerId: user.stripeCustomer.id,
    });

    if (newListOfInvoices.data === undefined || newListOfInvoices.data.length === 0) {
      throw new Error('You are a customer. But there is no payment history.');
    }

    const modifier = {
      stripeListOfInvoices: newListOfInvoices,
    };

    return this.findByIdAndUpdate(userId, { $set: modifier }, { new: true, runValidators: true })
      .select('stripeListOfInvoices')
      .setOptions({ lean: true });
  }

  private static async checkPermissionAndGetTeam({ userId, teamId }) {
    console.log(userId, teamId);

    if (!userId || !teamId) {
      throw new Error('Bad data');
    }

    const team = await Team.findById(teamId).select('memberIds').setOptions({ lean: true });

    if (!team || team.memberIds.indexOf(userId) === -1) {
      throw new Error('Team not found');
    }

    return team;
  }
}

mongoSchema.loadClass(UserClass);

const User = mongoose.model<UserDocument, UserModel>('User', mongoSchema);

export default User;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\server\utils\slugify.ts -----

import * as _ from 'lodash';

const slugify = (text) => _.kebabCase(text);

async function createUniqueSlug(Model, slug, count, filter) {
  const obj = await Model.findOne({ slug: `${slug}-${count}`, ...filter })
    .select('_id')
    .setOptions({ lean: true });

  if (!obj) {
    return `${slug}-${count}`;
  }

  return createUniqueSlug(Model, slug, count + 1, filter);
}

async function generateSlug(Model, name, filter = {}) {
  const origSlug = slugify(name);

  const obj = await Model.findOne({ slug: origSlug, ...filter })
    .select('_id')
    .setOptions({ lean: true });

  if (!obj) {
    return origSlug;
  }

  return createUniqueSlug(Model, origSlug, 1, filter);
}

async function generateNumberSlug(Model, filter = {}, n = 1) {
  const obj = await Model.findOne({ slug: n, ...filter })
    .select('_id')
    .setOptions({ lean: true });

  if (!obj) {
    return `${n}`;
  }

  return generateNumberSlug(Model, filter, ++n);
}

export { generateSlug, generateNumberSlug };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\server\utils\sum.ts -----

function sum(a, b) {
  return a + b;
}

export { sum };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\server\aws-s3.ts -----

import * as url from 'url';
import * as aws from 'aws-sdk';

async function signRequestForUpload({ fileName, fileType, prefix, bucket }) {
  const randomStringForPrefix =
    Math.random().toString(36).substring(2, 12) + Math.random().toString(36).substring(2, 12);

  const key = `${prefix}/${randomStringForPrefix}/${fileName}`;

  const acl = 'public-read';

  const params = {
    Bucket: bucket,
    Key: key,
    Expires: 60,
    ContentType: fileType,
    ACL: acl,
  };

  console.log(key, bucket);

  const s3 = new aws.S3({
    apiVersion: 'latest',
    region: process.env.AWS_REGION,
    accessKeyId: process.env.AWS_ACCESSKEYID,
    secretAccessKey: process.env.AWS_SECRETACCESSKEY,
  });

  return new Promise((resolve, reject) => {
    s3.getSignedUrl('putObject', params, (err, data) => {
      const parsedUrl = url.parse(data);

      const returnData = {
        signedRequest: data,
        url: `${parsedUrl.protocol}//${parsedUrl.hostname}${parsedUrl.pathname}`,
      };

      console.log(returnData);

      if (err) {
        console.error(err);
        reject(err);
      } else {
        resolve(returnData);
      }
    });
  });
}

export { signRequestForUpload };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\server\aws-ses.ts -----

import * as aws from 'aws-sdk';

export default function sendEmail(options) {
  const ses = new aws.SES({
    apiVersion: 'latest',
    region: process.env.AWS_REGION,
    accessKeyId: process.env.AWS_ACCESSKEYID,
    secretAccessKey: process.env.AWS_SECRETACCESSKEY,
  });

  return new Promise((resolve, reject) => {
    ses.sendEmail(
      {
        Source: options.from,
        Destination: {
          CcAddresses: options.cc,
          ToAddresses: options.to,
        },
        Message: {
          Subject: {
            Data: options.subject,
          },
          Body: {
            Html: {
              Data: options.body,
            },
          },
        },
        ReplyToAddresses: options.replyTo,
      },
      (err, info) => {
        if (err) {
          reject(err);
        } else {
          resolve(info);
        }
      },
    );
  });
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\server\google-auth.ts -----

import * as passport from 'passport';
import { OAuth2Strategy as Strategy } from 'passport-google-oauth';

import User, { UserDocument } from './models/User';
import Invitation from './models/Invitation';

function setupGoogle({ server }) {
  if (!process.env.GOOGLE_CLIENTID) {
    return;
  }

  const verify = async (req, accessToken, refreshToken, profile, done) => {
    let email;
    let avatarUrl;

    if (profile.emails) {
      email = profile.emails[0].value;
    }

    if (profile.photos && profile.photos.length > 0) {
      avatarUrl = profile.photos[0].value.replace('sz=50', 'sz=128');
    }

    try {
      const user = await User.signInOrSignUpViaGoogle({
        googleId: profile.id,
        email,
        googleToken: { accessToken, refreshToken },
        displayName: profile.displayName,
        avatarUrl,
      });

      let teamSlugOfInvitedTeam;
      if (user && req.session.invitationToken) {
        teamSlugOfInvitedTeam = await Invitation.addUserToTeam({
          token: req.session.invitationToken,
          user,
        }).catch((err) => console.error(err));
      }

      user.defaultTeamSlug = teamSlugOfInvitedTeam ? teamSlugOfInvitedTeam : user.defaultTeamSlug;

      done(null, user);
    } catch (err) {
      done(err);
      console.error(err);
    }
  };

  passport.use(
    new Strategy(
      {
        clientID: process.env.GOOGLE_CLIENTID,
        clientSecret: process.env.GOOGLE_CLIENTSECRET,
        callbackURL: `${process.env.URL_API}/oauth2callback`,
        passReqToCallback: true,
      },
      verify,
    ),
  );

  passport.serializeUser((user: UserDocument, done) => {
    done(null, user._id);
  });

  passport.deserializeUser((id, done) => {
    User.findById(id, User.publicFields())
      .then((user) => {
        done(null, user);
      })
      .catch((error) => {
        done(error, null);
      });
  });

  server.use(passport.initialize());
  server.use(passport.session());

  server.get('/auth/google', (req, res, next) => {
    const options = {
      scope: ['profile', 'email'],
      prompt: 'select_account',
    };

    if (req.query && req.query.invitationToken) {
      req.session.invitationToken = req.query.invitationToken;
    } else {
      req.session.invitationToken = null;
    }

    passport.authenticate('google', options)(req, res, next);
  });

  server.get(
    '/oauth2callback',
    passport.authenticate('google', {
      failureRedirect: '/login',
    }),
    async (req, res) => {
      let teamSlugOfInvitedTeam;

      if (req.user && req.session.invitationToken) {
        teamSlugOfInvitedTeam = await Invitation.addUserToTeam({
          token: req.session.invitationToken,
          user: req.user,
        }).catch((err) => console.error(err));

        req.session.invitationToken = null;
      }

      let redirectUrlAfterLogin;
      const defaultTeamSlug = req.user && req.user.defaultTeamSlug;

      if (teamSlugOfInvitedTeam || defaultTeamSlug) {
        redirectUrlAfterLogin = `/your-settings`;
      } else {
        redirectUrlAfterLogin = `/create-team`;
      }

      res.redirect(`${process.env.URL_APP}${redirectUrlAfterLogin}`);
    },
  );
}

export { setupGoogle };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\server\mailchimp.ts -----

import fetch, { Response } from 'node-fetch';

// eslint-disable-next-line
require('dotenv').config();

const LIST_IDS = {
  signups: process.env.MAILCHIMP_SAAS_ALL_LIST_ID,
};

function callAPI({ path, method, data }): Promise<Response> {
  const ROOT_URI = `https://${process.env.MAILCHIMP_REGION}.api.mailchimp.com/3.0`;

  return fetch(`${ROOT_URI}${path}`, {
    method,
    headers: {
      Accept: 'application/json',
      Authorization: `Basic ${Buffer.from(`apikey:${process.env.MAILCHIMP_API_KEY}`).toString(
        'base64',
      )}`,
    },
    body: JSON.stringify(data),
  });
}

async function addToMailchimp({ email, listName }) {
  const data = {
    // eslint-disable-next-line
    email_address: email,
    status: 'subscribed',
  };

  const path = `/lists/${LIST_IDS[listName]}/members/`;

  await callAPI({ path, method: 'POST', data });
}

export { addToMailchimp };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\server\passwordless-auth.ts -----

import * as passwordless from 'passwordless';

import sendEmail from './aws-ses';
import getEmailTemplate from './models/EmailTemplate';
import User from './models/User';
import PasswordlessMongoStore from './passwordless-token-mongostore';
import Invitation from './models/Invitation';

function setupPasswordless({ server }) {
  const mongoStore = new PasswordlessMongoStore();

  passwordless.addDelivery(async (tokenToSend, uidToSend, recipient, callback) => {
    try {
      const template = await getEmailTemplate('login', {
        loginURL: `${
          process.env.URL_API
        }/auth/logged_in?token=${tokenToSend}&uid=${encodeURIComponent(uidToSend)}`,
      });

      await sendEmail({
        from: `Kelly from saas-app.async-await.com <${process.env.EMAIL_SUPPORT_FROM_ADDRESS}>`,
        to: [recipient],
        subject: template.subject,
        body: template.message,
      });

      callback();
    } catch (err) {
      console.error('Email sending error:', err);
      callback(err);
    }
  });

  passwordless.init(mongoStore);
  server.use(passwordless.sessionSupport());

  server.use((req, __, next) => {
    if (req.user && typeof req.user === 'string') {
      User.findById(req.user, User.publicFields())
        .then((user) => {
          req.user = user;
          console.log('passwordless middleware');
          next();
        })
        .catch((err) => {
          next(err);
        });
    } else {
      next();
    }
  });

  server.post(
    '/auth/email-login-link',
    passwordless.requestToken(async (email, __, callback) => {
      try {
        const user = await User.findOne({ email }).select('_id').setOptions({ lean: true });

        if (user) {
          callback(null, user._id);
        } else {
          const id = await mongoStore.storeOrUpdateByEmail(email);
          callback(null, id);
        }
      } catch (error) {
        callback(error, null);
      }
    }),
    (req, res) => {
      if (req.query && req.query.invitationToken) {
        req.session.invitationToken = req.query.invitationToken;
      } else {
        req.session.invitationToken = null;
      }

      res.json({ done: 1 });
    },
  );

  server.get(
    '/auth/logged_in',
    passwordless.acceptToken(),
    (req, __, next) => {
      User.findById(req.user, User.publicFields())
        .then((user) => {
          req.user = user;
          next();
        })
        .catch((err) => {
          next(err);
        });
    },
    async (req, res) => {
      let teamSlugOfInvitedTeam;

      if (req.user && req.session.invitationToken) {
        teamSlugOfInvitedTeam = await Invitation.addUserToTeam({
          token: req.session.invitationToken,
          user: req.user,
        }).catch((err) => console.error(err));

        req.session.invitationToken = null;
      }

      let redirectUrlAfterLogin;
      const defaultTeamSlug = req.user && req.user.defaultTeamSlug;

      if (teamSlugOfInvitedTeam || defaultTeamSlug) {
        redirectUrlAfterLogin = `/your-settings`;
      } else {
        redirectUrlAfterLogin = `/create-team`;
      }

      res.redirect(`${process.env.URL_APP}${redirectUrlAfterLogin}`);
    },
  );

  server.get('/logout', (req, res, next) => {
    req.logout((err) => {
      if (err) {
        next(err);
      }

      if (req.query && req.query.invitationToken) {
        res.redirect(`${process.env.URL_APP}/invitation?token=${req.query.invitationToken}`);
      } else {
        res.redirect(`${process.env.URL_APP}/login`);
      }
    });
  });
}

export { setupPasswordless };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\server\passwordless-token-mongostore.ts -----

import * as bcrypt from 'bcrypt';
import * as mongoose from 'mongoose';
import * as TokenStore from 'passwordless-tokenstore';
import * as util from 'util';

import User from './models/User';

interface TokenDocument extends mongoose.Document {
  hashedToken: string;
  uid: string;
  ttl: Date;
  originUrl: string;
  email: string;
}

const mongoSchema = new mongoose.Schema({
  hashedToken: {
    type: String,
    required: true,
  },
  uid: {
    type: String,
    required: true,
    unique: true,
  },
  ttl: {
    type: Date,
    required: true,
    expires: 0,
  },
  originUrl: String,
  email: String,
});

const PasswordlessToken = mongoose.model<TokenDocument>(
  'PasswordlessToken',
  mongoSchema,
  'passwordless-token',
);

function MongoStore(options = {}) {
  TokenStore.call(this);

  this._options = options || {};
}

util.inherits(MongoStore, TokenStore);

MongoStore.prototype.authenticate = async function (token, uid, callback) {
  if (!token || !uid || !callback) {
    throw new Error('TokenStore:authenticate called with invalid parameters');
  }

  try {
    const tokenDoc = await PasswordlessToken.findOne({ uid, ttl: { $gt: new Date() } }).setOptions({
      lean: true,
    });

    if (tokenDoc) {
      const isMatch = await bcrypt.compare(token, tokenDoc.hashedToken);
      if (isMatch) {
        if (tokenDoc.email) {
          await User.signInOrSignUpByPasswordless({ uid, email: tokenDoc.email });
        }

        callback(null, true, tokenDoc.originUrl);
      } else {
        callback(null, false, null);
      }
    } else {
      callback(null, false, null);
    }
  } catch (error) {
    callback(error, false, null);
  }
};

MongoStore.prototype.storeOrUpdate = async function (token, uid, msToLive, originUrl, callback) {
  if (!token || !uid || !msToLive || !callback) {
    throw new Error('TokenStore:storeOrUpdate called with invalid parameters');
  }

  const saltRounds = 10;

  try {
    const hashedToken = await bcrypt.hash(token, saltRounds);
    const newRecord = { hashedToken, uid, ttl: new Date(Date.now() + msToLive), originUrl };

    await PasswordlessToken.updateOne(
      { uid },
      { $set: newRecord },
      { upsert: true, runValidators: true },
    );
    callback();
  } catch (error) {
    callback(error);
  }
};

MongoStore.prototype.invalidateUser = async function (uid, callback) {
  if (!uid || !callback) {
    throw new Error('TokenStore:invalidateUser called with invalid parameters');
  }

  try {
    await PasswordlessToken.deleteOne({ uid });
    callback();
  } catch (error) {
    callback(error);
  }
};

MongoStore.prototype.clear = async function (callback) {
  if (!callback) {
    throw new Error('TokenStore:clear called with invalid parameters');
  }

  try {
    await PasswordlessToken.deleteMany({});
    callback();
  } catch (error) {
    callback(error);
  }
};

MongoStore.prototype.length = function (callback) {
  PasswordlessToken.countDocuments(callback);
};

MongoStore.prototype.storeOrUpdateByEmail = async function addEmail(email: string) {
  if (!email) {
    throw new Error('TokenStore:addEmail called with invalid parameters');
  }

  const obj = await PasswordlessToken.findOne({ email }).select('uid').setOptions({ lean: true });

  if (obj) {
    return obj.uid;
  }

  const uid = new mongoose.Types.ObjectId().toHexString();
  await PasswordlessToken.updateOne({ uid }, { email }, { upsert: true });

  return uid;
};

export default MongoStore;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\server\server.ts -----

// eslint-disable-next-line @typescript-eslint/no-var-requires
const MongoStore = require('connect-mongo');

import * as cors from 'cors';
import * as express from 'express';
import * as session from 'express-session';
import * as httpModule from 'http';
import * as mongoose from 'mongoose';

import api from './api';
import { setupGoogle } from './google-auth';
import { setupPasswordless } from './passwordless-auth';
import { setupSockets } from './sockets';
import { stripeWebhookAndCheckoutCallback } from './stripe';

// eslint-disable-next-line
require('dotenv').config();

mongoose.connect(process.env.MONGO_URL_TEST);

const server = express();

server.use(
  cors({
    origin: process.env.URL_APP,
    methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',
    credentials: true,
  }),
);

stripeWebhookAndCheckoutCallback({ server });

server.use(express.json());

const sessionOptions = {
  name: process.env.SESSION_NAME,
  secret: process.env.SESSION_SECRET,
  resave: false,
  saveUninitialized: false,
  store: MongoStore.create({
    mongoUrl: process.env.MONGO_URL_TEST,
    ttl: 14 * 24 * 60 * 60, // save session 14 days
    autoRemove: 'interval',
    autoRemoveInterval: 1440, // clears every day
  }),
  cookie: {
    httpOnly: true,
    maxAge: 14 * 24 * 60 * 60 * 1000, // expires in 14 days
    secure: false,
  },
};

const sessionMiddleware = session(sessionOptions);
server.use(sessionMiddleware);

setupGoogle({ server });
setupPasswordless({ server });

api(server);

const httpServer = httpModule.createServer(server);
setupSockets({ httpServer, origin: process.env.URL_APP, sessionMiddleware });

server.get('*', (_, res) => {
  res.sendStatus(403);
});

httpServer.listen(process.env.PORT_API, () => {
  console.log(`> Ready on ${process.env.URL_API}`);
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\server\sockets.ts -----

import { Response } from 'express';
import { Server } from 'socket.io';

import { DiscussionDocument } from './models/Discussion';
import { PostDocument } from './models/Post';

let io: Server = null;
// const dev = process.env.NODE_ENV !== 'production';

function setupSockets({ httpServer, origin, sessionMiddleware }) {
  if (io === null) {
    io = new Server(httpServer, {
      cors: {
        origin,
        methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',
        credentials: true,
      },
      cookie: {
        name: 'io',
        httpOnly: true,
        maxAge: 14 * 24 * 60 * 60 * 1000, // expires in 14 days
        domain: 'localhost',
        secure: false,
      },
      serveClient: false,
      transports: ['polling', 'websocket'],
    });

    const wrap = (middleware) => (socket, next) => middleware(socket.request, {} as Response, next);

    io.use(wrap(sessionMiddleware));

    io.on('connection', (socket: any) => {
      if (
        !socket.request.session ||
        ((!socket.request.session.passport || !socket.request.session.passport.user) &&
          !socket.request.session.passwordless)
      ) {
        socket.disconnect(true);
        return;
      }

      socket.on('joinTeamRoom', (teamId) => {
        console.log(`    joinTeamRoom ${teamId}`);
        socket.join(`teamRoom-${teamId}`);
      });

      socket.on('leaveTeamRoom', (teamId) => {
        console.log(`** leaveTeamRoom ${teamId}`);
        socket.leave(`teamRoom-${teamId}`);
      });

      socket.on('joinDiscussionRoom', (discussionId) => {
        console.log(`    joinDiscussionRoom ${discussionId}`);
        socket.join(`discussionRoom-${discussionId}`);
      });

      socket.on('leaveDiscussionRoom', (discussionId) => {
        console.log(`** leaveDiscussionRoom ${discussionId}`);
        socket.leave(`discussionRoom-${discussionId}`);
      });

      socket.on('disconnect', (reason) => {
        console.log(`disconnected`, `reason: ` + reason);
      });
    });
  }
}

function getSocket(socketId?: string) {
  if (!io) {
    return null;
  }

  if (socketId && io.sockets.sockets.get(socketId)) {
    return io.sockets.sockets.get(socketId).broadcast;
  } else {
    return io;
  }
}

function discussionAdded({
  socketId,
  discussion,
}: {
  socketId?: string;
  discussion: DiscussionDocument;
}) {
  const roomName = `teamRoom-${discussion.teamId}`;

  const socket = getSocket(socketId);
  if (socket) {
    socket.to(roomName).emit('discussionEvent', { actionType: 'added', discussion });
  }
}

function discussionEdited({
  socketId,
  discussion,
}: {
  socketId?: string;
  discussion: DiscussionDocument;
}) {
  const roomName = `teamRoom-${discussion.teamId}`;
  const socket = getSocket(socketId);

  if (socket) {
    socket.to(roomName).emit('discussionEvent', {
      actionType: 'edited',
      discussion,
    });
  }
}

function discussionDeleted({
  socketId,
  teamId,
  id,
}: {
  socketId?: string;
  teamId: string;
  id: string;
}) {
  const roomName = `teamRoom-${teamId}`;
  const socket = getSocket(socketId);

  if (socket) {
    socket.to(roomName).emit('discussionEvent', { actionType: 'deleted', id });
  }
}

function postAdded({ socketId, post }: { socketId?: string; post: PostDocument }) {
  const roomName = `discussionRoom-${post.discussionId}`;

  const socket = getSocket(socketId);
  if (socket) {
    socket.to(roomName).emit('postEvent', { actionType: 'added', post });
  }
}

function postEdited({ socketId, post }: { socketId?: string; post: PostDocument }) {
  const roomName = `discussionRoom-${post.discussionId}`;

  const socket = getSocket(socketId);
  if (socket) {
    socket.to(roomName).emit('postEvent', { actionType: 'edited', post });
  }
}

function postDeleted({
  socketId,
  id,
  discussionId,
}: {
  socketId?: string;
  id: string;
  discussionId: string;
}) {
  const roomName = `discussionRoom-${discussionId}`;

  const socket = getSocket(socketId);
  if (socket) {
    socket.to(roomName).emit('postEvent', { actionType: 'deleted', id });
  }
}

export {
  setupSockets,
  postAdded,
  postEdited,
  postDeleted,
  discussionAdded,
  discussionEdited,
  discussionDeleted,
};

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\server\stripe.ts -----

import * as bodyParser from "body-parser";
import Stripe from "stripe";

import Team from "./models/Team";
import User from "./models/User";

const dev = process.env.NODE_ENV !== "production";

const stripeInstance = new Stripe(dev ? process.env.STRIPE_TEST_SECRETKEY : process.env.STRIPE_LIVE_SECRETKEY, {
  apiVersion: "2025-02-24.acacia",
});

function createSession({ userId, teamId, teamSlug, customerId, subscriptionId, userEmail, mode }) {
  const params: Stripe.Checkout.SessionCreateParams = {
    customer_email: customerId ? undefined : userEmail,
    customer: customerId,
    payment_method_types: ["card"],
    mode,
    success_url: `${process.env.URL_API}/stripe/checkout-completed/{CHECKOUT_SESSION_ID}`,
    cancel_url: `${process.env.URL_APP}/team/${teamSlug}/billing?redirectMessage=Checkout%20canceled`,
    metadata: { userId, teamId },
  };

  if (mode === "subscription") {
    params.line_items = [
      {
        price: dev ? process.env.STRIPE_TEST_PRICEID : process.env.STRIPE_LIVE_PRICEID,
        quantity: 1,
      },
    ];
  } else if (mode === "setup") {
    if (!customerId || !subscriptionId) {
      throw new Error("customerId and subscriptionId required");
    }

    params.setup_intent_data = {
      metadata: { customer_id: customerId, subscription_id: subscriptionId },
    };
  }

  return stripeInstance.checkout.sessions.create(params);
}

function retrieveSession({ sessionId }: { sessionId: string }) {
  return stripeInstance.checkout.sessions.retrieve(sessionId, {
    expand: [
      "setup_intent",
      "setup_intent.payment_method",
      "customer",
      "subscription",
      "subscription.default_payment_method",
    ],
  });
}

function updateCustomer(customerId, params: Stripe.CustomerUpdateParams) {
  console.log("updating customer", customerId);
  return stripeInstance.customers.update(customerId, params);
}

function updateSubscription(subscriptionId: string, params: Stripe.SubscriptionUpdateParams) {
  console.log("updating subscription", subscriptionId);
  return stripeInstance.subscriptions.update(subscriptionId, params);
}

function cancelSubscription({ subscriptionId }) {
  console.log("cancel subscription", subscriptionId);
  return stripeInstance.subscriptions.cancel(subscriptionId);
}

function getListOfInvoices({ customerId }) {
  console.log("getting list of invoices for customer", customerId);
  return stripeInstance.invoices.list({ customer: customerId, limit: 100 });
}

function stripeWebhookAndCheckoutCallback({ server }) {
  server.post(
    "/api/v1/public/stripe-invoice-payment-failed",
    bodyParser.raw({ type: "application/json" }),
    async (req, res, next) => {
      try {
        const event = stripeInstance.webhooks.constructEvent(
          req.body,
          req.headers["stripe-signature"],
          dev ? process.env.STRIPE_TEST_ENDPOINTSECRET : process.env.STRIPE_LIVE_ENDPOINTSECRET
        );

        console.log(`${event.id}, ${event.type}`);

        // invoice.payment_failed
        // data.object is an invoice
        // Occurs whenever an invoice payment attempt fails, due either to a declined payment or to the lack of a stored payment method.

        if (event.type === "invoice.payment_failed") {
          const { subscription } = event.data.object;
          console.log(JSON.stringify(subscription));

          await Team.cancelSubscriptionAfterFailedPayment({
            subscriptionId: JSON.stringify(subscription),
          });
        }

        res.sendStatus(200);
      } catch (err) {
        console.log(`Webhook error: ${err.message}`);
        next(err);
      }
    }
  );

  server.get("/stripe/checkout-completed/:sessionId", async (req, res) => {
    const { sessionId } = req.params;

    const session = await retrieveSession({ sessionId });
    if (!session || !session.metadata || !session.metadata.userId || !session.metadata.teamId) {
      throw new Error("Wrong session.");
    }

    const user = await User.findById(
      session.metadata.userId,
      "_id stripeCustomer email displayName isSubscriptionActive stripeSubscription"
    ).setOptions({ lean: true });

    const team = await Team.findById(
      session.metadata.teamId,
      "isSubscriptionActive stripeSubscription teamLeaderId slug"
    ).setOptions({ lean: true });

    if (!user) {
      throw new Error("User not found.");
    }

    if (!team) {
      throw new Error("Team not found.");
    }

    if (team.teamLeaderId !== user._id.toString()) {
      throw new Error("Permission denied");
    }

    try {
      if (session.mode === "setup" && session.setup_intent) {
        const si: Stripe.SetupIntent = session.setup_intent as Stripe.SetupIntent;
        const pm: Stripe.PaymentMethod = si.payment_method as Stripe.PaymentMethod;

        if (user.stripeCustomer) {
          await updateCustomer(user.stripeCustomer.id, {
            invoice_settings: { default_payment_method: pm.id },
          });
        }

        if (team.stripeSubscription) {
          await updateSubscription(team.stripeSubscription.id, { default_payment_method: pm.id });
        }

        await User.changeStripeCard({ session, user });
      } else if (session.mode === "subscription") {
        await User.saveStripeCustomerAndCard({ session, user });
        await Team.subscribeTeam({ session, team });
        await User.getListOfInvoicesForCustomer({ userId: user._id.toString() });
      } else {
        throw new Error("Wrong session.");
      }

      res.redirect(`${process.env.URL_APP}/team/${team.slug}/billing`);
    } catch (err) {
      console.error(err);

      res.redirect(`${process.env.URL_APP}/team/${team.slug}/billing?redirectMessage=${err.message || err.toString()}`);
    }
  });
}

export { createSession, cancelSubscription, getListOfInvoices, stripeWebhookAndCheckoutCallback };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\test\server\utils\slugify.test.ts -----

import * as mongoose from 'mongoose';
import User from '../../../server/models/User';
import { generateSlug } from '../../../server/utils/slugify';

// eslint-disable-next-line
require('dotenv').config();

describe('slugify', () => {
  beforeAll(async () => {
    await mongoose.connect(process.env.MONGO_URL_TEST);

    const mockUsers = [
      {
        slug: 'john',
        email: 'john@example.com',
        createdAt: new Date(),
        displayName: 'abc',
        avatarUrl: 'def',
      },
      {
        slug: 'john-johnson',
        email: 'john-johnson@example.com',
        createdAt: new Date(),
        displayName: 'abc',
        avatarUrl: 'def',
      },
      {
        slug: 'john-johnson-1',
        email: 'john-johnson-1@example.com',
        createdAt: new Date(),
        displayName: 'abc',
        avatarUrl: 'def',
      },
    ];

    await User.insertMany(mockUsers);
  });

  test('not duplicated', async () => {
    expect.assertions(1);

    await expect(generateSlug(User, 'John J Johnson@#$')).resolves.toEqual('john-j-johnson');
  });

  test('one time duplicated', async () => {
    expect.assertions(1);

    await expect(generateSlug(User, ' John@#$')).resolves.toEqual('john-1');
  });

  test('multiple duplicated', async () => {
    expect.assertions(1);

    await expect(generateSlug(User, 'John & Johnson@#$')).resolves.toEqual('john-johnson-2');
  });

  afterAll(async () => {
    await User.deleteMany({ slug: { $in: ['john', 'john-johnson', 'john-johnson-1'] } });
    await mongoose.disconnect();
  });
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\test\server\utils\sum.test.ts -----

import { sum } from '../../../server/utils/sum';

console.log(sum(1, 2));

describe.skip('testing sum function', () => {
  test('adds 1 + 2 to equal 3', () => {
    expect(sum(1, 2)).toBe(3);
  });
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\.eslintrc.js -----

module.exports = {
  parser: "@typescript-eslint/parser",
  extends: ["plugin:@typescript-eslint/recommended", "prettier"],
  env: {
    "es6": true,
    "node": true,
  },
  plugins: ["prettier"],
  rules: {
    'prettier/prettier': [
      'error',
      {
        singleQuote: true,
        trailingComma: 'all',
        arrowParens: 'always',
        printWidth: 100,
        semi: true,
      },
    ],
    '@typescript-eslint/no-unused-vars': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/no-explicit-any': 'off',
    'prefer-arrow-callback': 'error',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
 },
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\nodemon.json -----

{
  "watch": ["server"],
  "exec": "ts-node --project tsconfig.server.json",
  "ext": "ts"
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\package.json -----

{
  "name": "10-begin-api",
  "version": "1",
  "license": "MIT",
  "scripts": {
    "dev": "nodemon server/server.ts",
    "lint": "eslint . --ext .ts,.tsx",
    "test": "jest"
  },
  "jest": {
    "preset": "ts-jest",
    "testPathIgnorePatterns": [
      "production-server"
    ],
    "testEnvironment": "node"
  },
  "dependencies": {
    "aws-sdk": "^2.1692.0",
    "bcrypt": "^5.1.1",
    "connect-mongo": "^5.1.0",
    "cors": "^2.8.5",
    "dotenv": "^16.4.7",
    "express": "^4.21.2",
    "express-session": "^1.18.1",
    "he": "^1.2.0",
    "highlight.js": "^11.11.1",
    "lodash": "^4.17.20",
    "marked": "^15.0.7",
    "mongoose": "^8.12.1",
    "node-fetch": "2",
    "passport": "^0.7.0",
    "passport-google-oauth": "^2.0.0",
    "passwordless": "^1.1.3",
    "passwordless-tokenstore": "^0.0.10",
    "socket.io": "^4.8.1",
    "stripe": "^17.7.0",
    "typescript": "^5.8.2"
  },
  "devDependencies": {
    "@types/connect-mongo": "^3.1.6",
    "@types/dotenv": "^8.2.3",
    "@types/express": "^5.0.1",
    "@types/express-session": "^1.18.1",
    "@types/jest": "^29.5.14",
    "@types/lodash": "^4.17.16",
    "@types/mongoose": "^5.5.43",
    "@types/node": "^22.13.11",
    "@types/node-fetch": "^2.6.12",
    "@types/passport": "^1.0.17",
    "@types/socket.io": "^3.0.2",
    "@typescript-eslint/eslint-plugin": "^8.27.0",
    "@typescript-eslint/parser": "^8.27.0",
    "eslint": "^9.22.0",
    "eslint-config-prettier": "^10.1.1",
    "eslint-plugin-prettier": "^5.2.3",
    "jest": "^29.7.0",
    "nodemon": "^3.1.9",
    "prettier": "^3.5.3",
    "ts-jest": "^29.2.6",
    "ts-node": "^10.9.2"
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\tsconfig.json -----

{
  "compileOnSave": false,
  "compilerOptions": {
    "jsx": "preserve",
    "allowJs": true,
    "alwaysStrict": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "removeComments": false,
    "preserveConstEnums": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "sourceMap": true,
    "skipLibCheck": true,
    "baseUrl": ".",
    "experimentalDecorators": true,
    "typeRoots": ["./node_modules/@types"],
    "lib": ["es2015", "es2016"]
  },
  "exclude": ["production-server", "node_modules"]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\api\tsconfig.server.json -----

{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "module": "commonjs",
    "outDir": "production-server/"
  },
  "include": ["./server/**/*.ts"],
  "exclude": ["./server/**/*.test.ts"]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\components\common\Confirmer.tsx -----

import Button from "@mui/material/Button";
import Dialog from "@mui/material/Dialog";
import DialogActions from "@mui/material/DialogActions";
import DialogContent from "@mui/material/DialogContent";
import DialogContentText from "@mui/material/DialogContentText";
import DialogTitle from "@mui/material/DialogTitle";
import React from "react";

export let openConfirmDialogExternal;

type State = {
  open: boolean;
  title: string;
  message: string;
  onAnswer: (answer) => void;
};

class Confirmer extends React.Component<any, State> {
  constructor(props) {
    super(props);

    this.state = {
      open: false,
      title: "Are you sure?",
      message: "",
      onAnswer: null,
    };

    openConfirmDialogExternal = this.openConfirmDialog;
  }

  public render() {
    return (
      <Dialog
        open={this.state.open}
        onClose={this.handleClose}
        aria-labelledby="alert-dialog-title"
        aria-describedby="alert-dialog-description"
      >
        <DialogTitle id="alert-dialog-title">{this.state.title}</DialogTitle>
        <DialogContent>
          <DialogContentText id="alert-dialog-description">{this.state.message}</DialogContentText>
        </DialogContent>
        <DialogActions style={{ padding: "10px" }}>
          <Button onClick={this.handleClose} variant="contained" color="primary" autoFocus>
            Cancel
          </Button>
          <Button onClick={this.handleYes} variant="contained" color="secondary">
            OK
          </Button>
        </DialogActions>
      </Dialog>
    );
  }

  public handleClose = () => {
    this.setState({ open: false });
    this.state.onAnswer(false);
  };

  public handleYes = () => {
    this.setState({ open: false });
    this.state.onAnswer(true);
  };

  public openConfirmDialog = ({ title, message, onAnswer }) => {
    this.setState({ open: true, title, message, onAnswer });
  };
}

export default Confirmer;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\components\common\LoginButton.tsx -----

import Button from "@mui/material/Button";
import TextField from "@mui/material/TextField";
import React from "react";

import { emailLoginLinkApiMethod } from "../../lib/api/public";
import notify from "../../lib/notify";
import { makeQueryString } from "../../lib/api/makeQueryString";

type Props = { invitationToken?: string };
type State = { email: string };

class LoginButton extends React.PureComponent<Props, State> {
  constructor(props) {
    super(props);

    this.state = { email: "" };
  }

  public render() {
    const { invitationToken } = this.props;

    let url = `${process.env.NEXT_PUBLIC_URL_API}/auth/google`;
    const qs = makeQueryString({ invitationToken });

    if (qs) {
      url += `?${qs}`;
    }

    // console.log(url);

    return (
      <React.Fragment>
        <Button variant="contained" color="secondary" href={url}>
          <img src="https://storage.googleapis.com/async-await-all/G.svg" alt="Log in with Google" />
          &nbsp;&nbsp;&nbsp; Log in with Google
        </Button>
        <p />
        <br />
        <hr style={{ width: "60px" }} /> <h4>OR</h4> <hr style={{ width: "60px" }} />
        <p />
        <br />
        <div>
          <form autoComplete="off" onSubmit={this.onSubmit}>
            <TextField
              required
              type="email"
              label="Email address"
              value={this.state.email}
              onChange={(event) => {
                this.setState({ email: event.target.value });
              }}
              style={{ width: "300px" }}
            />
            <p />
            <Button variant="contained" color="primary" type="submit">
              Log in with email
            </Button>
          </form>
          <p />
          <br />
        </div>
      </React.Fragment>
    );
  }

  private onSubmit = async (event) => {
    event.preventDefault();
    const { email } = this.state;
    const { invitationToken } = this.props;

    if (!email) {
      notify("Email is required");
    }

    try {
      await emailLoginLinkApiMethod({ email, invitationToken });
      this.setState({ email: "" });
      notify("SaaS boilerplate emailed you a login link.");
    } catch (error) {
      notify(error);
    }
  };
}

export default LoginButton;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\components\common\MemberChooser.tsx -----

import React from "react";

import Autocomplete from "@mui/material/Autocomplete";
import TextField from "@mui/material/TextField";

import { User } from "../../lib/store/user";

type Props = {
  onChange: (item) => void;
  selectedMemberIds?: string[];
  members: User[];
  label?: string;
  helperText?: string;
};

type State = {
  selectedItems: { label: string; id: string }[];
};

class MemberChooser extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    const suggestions = this.props.members.map((user) => ({
      label: user.displayName || user.email,
      id: user._id,
    }));

    const selectedItems = suggestions.filter((s) => this.props.selectedMemberIds.indexOf(s.id) !== -1);

    this.state = {
      selectedItems: selectedItems || [],
    };
  }

  public render() {
    const suggestions = this.props.members.map((user) => ({
      label: user.displayName || user.email,
      id: user._id,
    }));

    return (
      <Autocomplete
        multiple
        id="tags-standard"
        options={suggestions}
        getOptionLabel={(option) => option.label}
        getOptionSelected={(option, value) => option.id === value.id}
        value={this.state.selectedItems}
        renderInput={(params) => (
          <TextField
            {...params}
            variant="standard"
            label="Find team member by name"
            placeholder="Select participants"
          />
        )}
        onChange={this.handleChange}
        filterSelectedOptions={true}
        noOptionsText="No team members to select from"
      />
    );
  }

  public handleChange = (event, value) => {
    event.preventDefault();

    const selectedItems = value;

    this.setState({ selectedItems });

    this.props.onChange(selectedItems.map((i) => i.id));
  };
}

export default MemberChooser;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\components\common\MenuWithLinks.tsx -----

import Menu from "@mui/material/Menu";
import MenuItem from "@mui/material/MenuItem";
import Link from "next/link";
import { NextRouter, withRouter } from "next/router";
import React from "react";

type Props = {
  options: {
    href: string;
    as: string;
    highlighterSlug: string;
    text: string;
    externalServer: boolean;
    separator: boolean;
  }[];
  router: NextRouter;
  children: any;
};

type State = {
  anchorEl: Element | ((element: Element) => Element);
};

class MenuWithLinks extends React.PureComponent<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      anchorEl: null,
    };
  }

  public render() {
    const { options, children, router } = this.props;
    const { anchorEl } = this.state;

    return (
      <div style={{ textAlign: "center" }}>
        <div
          aria-controls={anchorEl ? "simple-menu" : null}
          aria-haspopup="true"
          onClick={this.handleClick}
          onKeyPress={this.handleClick}
        >
          {children}
        </div>
        <Menu id="simple-menu" anchorEl={anchorEl} open={Boolean(anchorEl)} onClose={this.handleClose} keepMounted>
          {options.map((option, i) =>
            option.separator ? (
              <hr style={{ width: "95%", margin: "10px auto" }} key={`separated-${i}`} />
            ) : option.externalServer ? (
              <MenuItem
                onClick={(event) => {
                  event.preventDefault();
                  window.location.href = option.href;
                  this.handleClose();
                }}
                key={option.href || option.text}
              >
                {option.text}
              </MenuItem>
            ) : (
              <Link key={option.href} href={option.href} as={option.as} passHref>
                <MenuItem
                  key={option.href}
                  style={{
                    fontWeight: router.asPath.includes(option.highlighterSlug) ? 600 : 300,
                    fontSize: "14px",
                  }}
                >
                  {option.text}
                </MenuItem>
              </Link>
            )
          )}
        </Menu>
      </div>
    );
  }

  public handleClick = (event) => {
    this.setState({ anchorEl: event.currentTarget });
  };

  public handleClose = () => {
    this.setState({ anchorEl: null });
  };
}

export default withRouter(MenuWithLinks);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\components\common\MenuWithMenuItems.tsx -----

import Menu from "@mui/material/Menu";
import MenuItem from "@mui/material/MenuItem";
import React from "react";

type Props = {
  menuOptions: any;
  itemOptions: any[];
};

type State = {
  menuElem: Element | ((element: Element) => Element);
};

class MenuWithMenuItems extends React.PureComponent<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      menuElem: null,
    };
  }

  public render() {
    const { menuOptions, itemOptions } = this.props;
    const { menuElem } = this.state;

    return (
      <div style={{ verticalAlign: "middle" }}>
        <i
          aria-controls={menuElem ? menuOptions.id : null}
          data-id={menuOptions.dataId}
          aria-haspopup="true"
          style={{ fontSize: "14px", opacity: 0.7, cursor: "pointer" }}
          className="material-icons"
          onClick={(e) => this.handleClick(e)}
        >
          more_vert
        </i>

        <Menu id={menuOptions.id} anchorEl={menuElem} open={Boolean(menuElem)} onClose={this.handleClose}>
          {itemOptions.map((option, i) => (
            <MenuItem
              key={option.dataId + i}
              data-id={option.dataId}
              data-more-id={option.dataMoreId}
              onClick={(e) => {
                this.setState({ menuElem: null });
                option.onClick(e);
              }}
            >
              {option.text}
            </MenuItem>
          ))}
        </Menu>
      </div>
    );
  }

  public handleClick = (event) => {
    event.preventDefault();
    this.setState({ menuElem: event.currentTarget });
  };

  public handleClose = () => {
    this.setState({ menuElem: null });
  };
}

export default MenuWithMenuItems;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\components\common\Notifier.tsx -----

import Snackbar from "@mui/material/Snackbar";
import React from "react";

export let openSnackbarExternal;

type State = {
  open: boolean;
  message: string;
};

class Notifier extends React.PureComponent<any, State> {
  constructor(props) {
    super(props);
    openSnackbarExternal = this.openSnackbar;

    this.state = {
      open: false,
      message: "",
    };
  }

  public render() {
    const message = <span id="snackbar-message-id" dangerouslySetInnerHTML={{ __html: this.state.message }} />;

    return (
      <Snackbar
        anchorOrigin={{ vertical: "top", horizontal: "right" }}
        message={message}
        autoHideDuration={5000}
        onClose={this.handleSnackbarClose}
        open={this.state.open}
        ContentProps={{
          "aria-describedby": "snackbar-message-id",
        }}
      />
    );
  }

  public handleSnackbarClose = () => {
    this.setState({
      open: false,
      message: "",
    });
  };

  public openSnackbar = ({ message }) => {
    this.setState({ open: true, message });
  };
}

export default Notifier;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\components\discussions\CreateDiscussionForm.tsx -----

import Button from "@mui/material/Button";
import Dialog from "@mui/material/Dialog";
import DialogContent from "@mui/material/DialogContent";
import DialogTitle from "@mui/material/DialogTitle";
import FormControl from "@mui/material/FormControl";
import FormHelperText from "@mui/material/FormHelperText";
import InputLabel from "@mui/material/InputLabel";
import Select from "@mui/material/Select";
import MenuItem from "@mui/material/MenuItem";
import TextField from "@mui/material/TextField";
import { observer } from "mobx-react";
import Head from "next/head";
import Router from "next/router";
import NProgress from "nprogress";
import React from "react";

import notify from "../../lib/notify";
import { Store } from "../../lib/store";
import MemberChooser from "../common/MemberChooser";
import PostEditor from "../posts/PostEditor";

type Props = {
  isMobile: boolean;
  store: Store;
  open: boolean;
  onClose: () => void;
};

type State = {
  name: string;
  memberIds: string[];
  disabled: boolean;
  content: string;
  notificationType: string;
};

class CreateDiscussionForm extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      name: "",
      memberIds: [],
      disabled: false,
      content: "",
      notificationType: "default",
    };
  }

  public render() {
    const { open, isMobile, store } = this.props;
    const { currentTeam, currentUser } = store;

    const membersMinusCreator = Array.from(currentTeam.members.values()).filter((user) => user._id !== currentUser._id);

    return (
      <React.Fragment>
        {open ? (
          <Head>
            <title>New Discussion</title>
            <meta name="description" content="Create new discussion" />
          </Head>
        ) : null}
        <Dialog onClose={this.handleClose} aria-labelledby="simple-dialog-title" open={open} fullScreen={true}>
          <DialogTitle id="simple-dialog-title">Create new Discussion</DialogTitle>
          <DialogContent>
            <br />
            <form style={{ width: "100%", height: "60%" }} onSubmit={this.onSubmit}>
              <p />
              <br />
              <TextField
                autoFocus
                label="Type name of Discussion"
                helperText="Give a short and informative name to new Discussion"
                value={this.state.name}
                onChange={(event) => {
                  this.setState({ name: event.target.value });
                }}
              />
              <br />
              <p />
              <MemberChooser
                helperText="These members will see all posts and be notified about unread posts in this discussion."
                onChange={this.handleMembersChange}
                members={membersMinusCreator}
                selectedMemberIds={this.state.memberIds}
              />
              <p />
              <br />
              <FormControl>
                <InputLabel>Notification type</InputLabel>
                <Select
                  value={this.state.notificationType}
                  onChange={(event: React.ChangeEvent<HTMLSelectElement>) => {
                    this.setState({ notificationType: event.target.value });
                  }}
                  required
                >
                  <MenuItem value="default">Default: without email notification.</MenuItem>
                  <MenuItem value="email">Email: with email notification.</MenuItem>
                </Select>
                <FormHelperText>Choose how to notify members about new Posts inside Discussion.</FormHelperText>
              </FormControl>
              <p />
              <br />
              <div>
                <Button type="submit" variant="contained" color="primary" disabled={this.state.disabled}>
                  Create Discussion
                </Button>
                {isMobile ? <p /> : null}
                <Button
                  variant="outlined"
                  onClick={this.handleClose}
                  disabled={this.state.disabled}
                  style={{ marginLeft: isMobile ? "0px" : "20px" }}
                >
                  Cancel
                </Button>{" "}
              </div>
              <p />
              <PostEditor
                content={this.state.content}
                onChanged={this.onContentChanged}
                members={Array.from(store.currentTeam.members.values())}
                store={store}
                parentComponent="CDF"
              />
              <p />
              <div>
                <Button type="submit" variant="contained" color="primary" disabled={this.state.disabled}>
                  Create Discussion
                </Button>
                {isMobile ? <p /> : null}
                <Button
                  variant="outlined"
                  onClick={this.handleClose}
                  disabled={this.state.disabled}
                  style={{ marginLeft: isMobile ? "0px" : "20px" }}
                >
                  Cancel
                </Button>{" "}
                <p />
                <br />
                <br />
              </div>
            </form>
          </DialogContent>
        </Dialog>
      </React.Fragment>
    );
  }

  public handleMembersChange = (memberIds) => {
    this.setState({ memberIds });
  };

  public handleClose = () => {
    this.setState({
      name: "",
      memberIds: [],
      disabled: false,
      content: "",
      notificationType: "default",
    });
    this.props.onClose();
  };

  private onContentChanged = (content: string) => {
    console.log("onContentChanged", content);
    this.setState({ content });
  };

  private onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();

    const { store } = this.props;
    const { currentTeam } = store;

    if (!currentTeam) {
      notify("Team have not selected");
      return;
    }

    const { name, memberIds, content, notificationType } = this.state;

    if (!name) {
      notify("Name is required");
      return;
    }

    if (!content) {
      notify("Content is required");
      return;
    }

    if (!memberIds || memberIds.length < 1) {
      notify("Please assign at least one person to this Discussion.");
      return;
    }

    if (!notificationType) {
      notify("Please select notification type.");
      return;
    }

    this.setState({ disabled: true });
    NProgress.start();

    try {
      const discussion = await currentTeam.addDiscussion({
        name,
        memberIds,
        notificationType,
      });

      const post = await discussion.addPost(content);

      if (discussion.notificationType === "email") {
        const userIdsForLambda = discussion.memberIds.filter((m) => m !== discussion.createdUserId);

        await discussion.sendDataToLambda({
          discussionName: discussion.name,
          discussionLink: `${process.env.NEXT_PUBLIC_URL_APP}/team/${discussion.team.slug}/discussions/${discussion.slug}`,
          postContent: post.content,
          authorName: post.user.displayName,
          userIds: userIdsForLambda,
        });
      }

      this.setState({ name: "", memberIds: [], content: "", notificationType: "default" });

      notify("You successfully added new Discussion.");

      Router.push(
        `/discussion?teamSlug=${currentTeam.slug}&discussionSlug=${discussion.slug}`,
        `/team/${currentTeam.slug}/discussions/${discussion.slug}`
      );
    } catch (error) {
      console.log(error);
      notify(error);
    } finally {
      this.setState({ disabled: false });
      NProgress.done();
      this.props.onClose();
    }
  };
}

export default observer(CreateDiscussionForm);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\components\discussions\DiscussionActionMenu.tsx -----

import { observer } from 'mobx-react';
import NProgress from 'nprogress';
import React from 'react';

import confirm from '../../lib/confirm';
import notify from '../../lib/notify';
import { Store } from '../../lib/store';
import { Discussion } from '../../lib/store/discussion';

import MenuWithMenuItems from '../common/MenuWithMenuItems';
import EditDiscussionForm from './EditDiscussionForm';

const getMenuOptions = (discussion) => ({
  dataId: discussion._id,
  id: `discussion-menu-${discussion._id}`,
});

const getMenuItemOptionsForCreator = (discussion, component) => [
  {
    text: 'Copy URL',
    dataId: discussion._id,
    onClick: component.handleCopyUrl,
  },
  {
    text: 'Edit',
    dataId: discussion._id,
    onClick: component.editDiscussion,
  },
  {
    text: 'Delete',
    dataId: discussion._id,
    onClick: component.deleteDiscussion,
  },
];

const getMenuItemOptions = (discussion, component) => [
  {
    text: 'Copy URL',
    dataId: discussion._id,
    onClick: component.handleCopyUrl,
  },
];

type Props = {
  discussion: Discussion;
  store: Store;
  isMobile: boolean;
};

type State = {
  discussionFormOpen: boolean;
  selectedDiscussion: Discussion;
};

class DiscussionActionMenu extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      discussionFormOpen: false,
      selectedDiscussion: null,
    };
  }

  public render() {
    const { discussion, store } = this.props;
    const { currentUser } = store;

    const isCreator = currentUser._id === discussion.createdUserId ? true : false;

    return (
      <React.Fragment>
        <MenuWithMenuItems
          menuOptions={getMenuOptions(discussion)}
          itemOptions={
            isCreator
              ? getMenuItemOptionsForCreator(discussion, this)
              : getMenuItemOptions(discussion, this)
          }
        />

        {this.state.discussionFormOpen ? (
          <EditDiscussionForm
            open={true}
            onClose={this.handleDiscussionFormClose}
            discussion={discussion}
            isMobile={this.props.isMobile}
            store={store}
          />
        ) : null}
      </React.Fragment>
    );
  }

  public handleCopyUrl = async (event) => {
    const { store } = this.props;
    const { currentTeam } = store;

    const id = event.currentTarget.dataset.id;
    if (!id) {
      return;
    }

    const selectedDiscussion = currentTeam.discussions.find((d) => d._id === id);
    const discussionUrl = `${process.env.NEXT_PUBLIC_URL_APP}/team/${currentTeam.slug}/discussions/${selectedDiscussion.slug}`;

    try {
      if (window.navigator) {
        await window.navigator.clipboard.writeText(discussionUrl);
        notify('You successfully copied URL.');
      }
    } catch (err) {
      notify(err);
    } finally {
      this.setState({ discussionFormOpen: false, selectedDiscussion: null });
    }
  };

  public editDiscussion = (event) => {
    const { currentTeam } = this.props.store;
    if (!currentTeam) {
      notify('You have not selected Team.');
      return;
    }

    const id = event.currentTarget.dataset.id;
    if (!id) {
      return;
    }

    const selectedDiscussion = currentTeam.discussions.find((d) => d._id === id);

    this.setState({ discussionFormOpen: true, selectedDiscussion });
  };

  public deleteDiscussion = async (event) => {
    const { currentTeam } = this.props.store;
    if (!currentTeam) {
      notify('You have not selected Team.');
      return;
    }

    const id = event.currentTarget.dataset.id;

    confirm({
      title: 'Are you sure?',
      message: '',
      onAnswer: async (answer) => {
        if (!answer) {
          return;
        }

        NProgress.start();

        try {
          await currentTeam.deleteDiscussion(id);

          notify('You successfully deleted Discussion.');
        } catch (error) {
          console.error(error);
          notify(error);
        } finally {
          NProgress.done();
        }
      },
    });
  };

  public handleDiscussionFormClose = () => {
    this.setState({ discussionFormOpen: false, selectedDiscussion: null });
  };
}

export default observer(DiscussionActionMenu);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\components\discussions\DiscussionList.tsx -----

import Tooltip from "@mui/material/Tooltip";
import { observer } from "mobx-react";
import React from "react";

import { Store } from "../../lib/store";
import { Team } from "../../lib/store/team";

import CreateDiscussionForm from "./CreateDiscussionForm";
import DiscussionListItem from "./DiscussionListItem";

import notify from "../../lib/notify";

type Props = { store: Store; team: Team; isMobile: boolean };

type State = { discussionFormOpen: boolean };

class DiscussionList extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      discussionFormOpen: false,
    };
  }

  public componentDidMount() {
    this.props.team.loadDiscussions().catch((err) => notify(err));
  }

  public componentDidUpdate(prevProps: Props) {
    if (this.props.team._id !== prevProps.team._id) {
      this.props.team.loadDiscussions().catch((err) => notify(err));
    }
  }

  public render() {
    const { store, team } = this.props;

    const isThemeDark = store && store.currentUser && store.currentUser.darkTheme === true;

    return (
      <div>
        Discussions
        <Tooltip title="Add Discussion" placement="right" disableFocusListener disableTouchListener>
          <a onClick={this.addDiscussion} style={{ float: "right", padding: "0px 10px" }}>
            <i
              className="material-icons"
              color="action"
              style={{ fontSize: 14, opacity: 0.7, color: isThemeDark ? "#fff" : "#000" }}
            >
              add_circle_outline
            </i>{" "}
          </a>
        </Tooltip>
        <p />
        <ul style={{ listStyle: "none", padding: "0px" }}>
          {team &&
            team.orderedDiscussions.map((d) => {
              return (
                <DiscussionListItem
                  key={d._id}
                  discussion={d}
                  team={team}
                  isMobile={this.props.isMobile}
                  store={this.props.store}
                />
              );
            })}
        </ul>
        <CreateDiscussionForm
          isMobile={this.props.isMobile}
          store={this.props.store}
          open={this.state.discussionFormOpen}
          onClose={this.handleDiscussionFormClose}
        />
      </div>
    );
  }

  public addDiscussion = (event) => {
    event.preventDefault();
    this.setState({ discussionFormOpen: true });
  };

  public handleDiscussionFormClose = () => {
    this.setState({ discussionFormOpen: false });
  };
}

export default observer(DiscussionList);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\components\discussions\DiscussionListItem.tsx -----

import Paper from "@mui/material/Paper";
import { observer } from "mobx-react";
import Link from "next/link";
import React from "react";

import { Store } from "../../lib/store";
import { Discussion } from "../../lib/store/discussion";
import { Team } from "../../lib/store/team";

import DiscussionActionMenu from "./DiscussionActionMenu";

type Props = {
  store: Store;
  discussion: Discussion;
  team: Team;
  isMobile: boolean;
};

class DiscussionListItem extends React.Component<Props> {
  public render() {
    const { store, discussion, team, isMobile } = this.props;
    const trimmingLength = 16;

    const selectedDiscussion = store.currentUrl === `/team/${team.slug}/discussions/${discussion.slug}`;

    console.log(store.currentUrl);

    const isThemeDark = store && store.currentUser && store.currentUser.darkTheme === true;

    const selectedItemBorder = isThemeDark ? "1px rgba(255, 255, 255, 0.75) solid" : "1px rgba(0, 0, 0, 0.75) solid";

    return (
      <Paper
        key={discussion._id}
        style={{
          margin: "10px 10px 5px 0px",
          padding: "8px",
          border: selectedDiscussion ? selectedItemBorder : "none",
        }}
        elevation={selectedDiscussion ? 24 : 1}
      >
        <li key={discussion._id} style={{ whiteSpace: "nowrap", paddingRight: "10px" }}>
          <Link
            scroll={false}
            href={`/discussion?teamSlug=${team.slug}&discussionSlug=${discussion.slug}`}
            as={`/team/${team.slug}/discussions/${discussion.slug}`}
            style={{ fontWeight: 300, color: isThemeDark ? "#fff" : "#000" }}
            key={discussion._id}
          >
            {discussion.name.length > trimmingLength
              ? `${discussion.name.substring(0, trimmingLength)}...`
              : discussion.name}
          </Link>
          <div
            style={{
              float: "right",
              marginRight: "-12px",
            }}
          >
            <DiscussionActionMenu discussion={discussion} isMobile={isMobile} store={store} />
          </div>
        </li>
      </Paper>
    );
  }
}

export default observer(DiscussionListItem);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\components\discussions\EditDiscussionForm.tsx -----

import Button from "@mui/material/Button";
import Dialog from "@mui/material/Dialog";
import DialogActions from "@mui/material/DialogActions";
import DialogContent from "@mui/material/DialogContent";
import DialogContentText from "@mui/material/DialogContentText";
import DialogTitle from "@mui/material/DialogTitle";
import FormControl from "@mui/material/FormControl";
import FormHelperText from "@mui/material/FormHelperText";
import InputLabel from "@mui/material/InputLabel";
import Select from "@mui/material/Select";
import MenuItem from "@mui/material/MenuItem";
import TextField from "@mui/material/TextField";
import { observer } from "mobx-react";
import NProgress from "nprogress";
import React from "react";

import notify from "../../lib/notify";
import { Store } from "../../lib/store";
import { Discussion } from "../../lib/store/discussion";
import MemberChooser from "../common/MemberChooser";

type Props = {
  store: Store;
  onClose: () => void;
  open: boolean;
  discussion: Discussion;
  isMobile: boolean;
};

type State = {
  name: string;
  memberIds: string[];
  disabled: boolean;
  discussionId: string;
  notificationType: string;
};

class EditDiscussionForm extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      name: "",
      memberIds: [],
      disabled: false,
      discussionId: "",
      notificationType: "default",
    };
  }

  public static getDerivedStateFromProps(props: Props, state: State) {
    const { discussion } = props;

    if (state.discussionId === discussion._id) {
      return null;
    }

    return {
      name: (discussion && discussion.name) || "",
      memberIds: (discussion && discussion.memberIds) || [],
      discussionId: discussion._id,
      notificationType: discussion.notificationType || "default",
    };
  }

  public render() {
    const { open, store } = this.props;
    const { currentTeam, currentUser } = store;

    const membersMinusCreator = Array.from(currentTeam.members.values()).filter((user) => user._id !== currentUser._id);

    // console.log(currentTeam.members);

    return (
      <Dialog onClose={this.handleClose} aria-labelledby="simple-dialog-title" open={open}>
        <DialogTitle id="simple-dialog-title">Edit Discussion</DialogTitle>
        <DialogContent>
          <DialogContentText>Edit discussion</DialogContentText>
          <br />
          <form onSubmit={this.onSubmit}>
            <TextField
              label="Type name of Discussion"
              helperText="Give a short and informative name to Discussion"
              value={this.state.name}
              onChange={(event) => {
                this.setState({ name: event.target.value });
              }}
            />
            <br />
            <p />
            <MemberChooser
              helperText="These members will see all posts and be notified about unread posts in this discussion."
              onChange={this.handleMembersChange}
              members={membersMinusCreator}
              selectedMemberIds={this.state.memberIds}
            />
            <p />
            <br />
            <FormControl>
              <InputLabel>Notification type</InputLabel>
              <Select
                value={this.state.notificationType}
                onChange={(event: React.ChangeEvent<HTMLSelectElement>) => {
                  this.setState({ notificationType: event.target.value });
                }}
                required
              >
                <MenuItem value="default">Default: without email notification.</MenuItem>
                <MenuItem value="email">Email: with email notification.</MenuItem>
              </Select>
              <FormHelperText>Choose how to notify members about new Posts inside Discussion.</FormHelperText>
            </FormControl>
            <p />
            <br />
            <DialogActions>
              <Button color="primary" variant="outlined" onClick={this.handleClose} disabled={this.state.disabled}>
                Cancel
              </Button>
              <Button type="submit" variant="contained" color="primary" disabled={this.state.disabled}>
                Update Discussion
              </Button>
            </DialogActions>
          </form>
        </DialogContent>
      </Dialog>
    );
  }

  public handleMembersChange = (memberIds) => {
    this.setState({ memberIds });
  };

  public handleClose = () => {
    this.setState({ name: "", memberIds: [], disabled: false, notificationType: "default" });
    this.props.onClose();
  };

  private onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();

    const { discussion, store } = this.props;
    const { currentTeam } = store;
    const { notificationType } = this.state;

    if (!currentTeam) {
      notify("Team have not selected");
      return;
    }

    const { name, memberIds } = this.state;

    if (!name) {
      notify("Please name this Discussion.");
      return;
    }

    if (memberIds && !memberIds.includes(discussion.store.currentUser._id)) {
      memberIds.push(discussion.store.currentUser._id);
    }

    if (!memberIds || memberIds.length < 1) {
      notify("Please assign at least one person to this Discussion.");
      return;
    }

    if (!notificationType) {
      notify("Please select notification type.");
      return;
    }

    NProgress.start();
    try {
      await discussion.editDiscussion({ name, memberIds, notificationType });

      this.setState({ name: "", memberIds: [], disabled: false, notificationType: "default" });
      notify("You successfully edited Discussion.");
    } catch (error) {
      console.log(error);
      notify(error);
    } finally {
      this.setState({ disabled: false });
      NProgress.done();

      this.props.onClose();
    }
  };
}

export default observer(EditDiscussionForm);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\components\layout\index.tsx -----

import Avatar from "@mui/material/Avatar";
import Button from "@mui/material/Button";
import Grid from "@mui/material/Grid";

import Link from "next/link";
import React from "react";

import MenuWithLinks from "../common/MenuWithLinks";
import Confirmer from "../common/Confirmer";
import Notifier from "../common/Notifier";

import { Store } from "../../lib/store";
import DiscussionList from "../discussions/DiscussionList";

const styleGrid = {
  width: "100%",
  height: "100vh",
  maxWidth: "100%",
  padding: "0px 10px",
  display: "flex",
  overflow: "hidden",
};

const styleGridIsMobile = {
  width: "100%",
  height: "100vh",
  maxWidth: "100%",
  padding: "0px 0px 0px 10px",
  display: "flex",
  overflow: "hidden",
};

function LayoutWrapper({
  children,
  isMobile,
  firstGridItem,
  store,
}: {
  children: React.ReactNode;
  isMobile: boolean;
  firstGridItem: boolean;
  store: Store;
}) {
  const isThemeDark = store.currentUser ? store.currentUser.darkTheme : true;

  return (
    <React.Fragment>
      <Grid
        container
        direction="row"
        justify="flex-start"
        alignItems="stretch"
        style={isMobile ? styleGridIsMobile : styleGrid}
      >
        {firstGridItem ? (
          <Grid
            item
            sm={2}
            xs={12}
            style={{
              borderRight: "1px #707070 solid",
              justifyContent: "center",
              overflow: "hidden",
            }}
          >
            <div style={{ display: "flex", justifyContent: "space-between" }}>
              <svg
                xmlns="http://www.w3.org/2000/svg"
                width="124"
                height="40"
                viewBox="0 0 124 40"
                style={{
                  marginTop: "20px",
                  display: "inline-flex",
                  height: "40px",
                }}
              >
                <g id="async-logo">
                  <g id="async-logo-40">
                    <circle id="Ellipse 2" cx="20" cy="20" r="20" fill="black" />
                    <path
                      id="path-async-logo"
                      d="M7.07825 -0.0960007V16H4.51825V13.088C4.04892 14.0907 3.33425 14.8693 2.37425 15.424C1.43558 15.9573 0.336917 16.224 -0.92175 16.224C-2.35108 16.224 -3.60975 15.8827 -4.69775 15.2C-5.76442 14.5173 -6.59642 13.5573 -7.19375 12.32C-7.76975 11.0613 -8.05775 9.6 -8.05775 7.936C-8.05775 6.272 -7.75908 4.81067 -7.16175 3.552C-6.56442 2.272 -5.73242 1.28 -4.66575 0.576C-3.57775 -0.128 -2.32975 -0.48 -0.92175 -0.48C0.336917 -0.48 1.43558 -0.202666 2.37425 0.352C3.31292 0.906667 4.02758 1.68533 4.51825 2.688V-0.0960007H7.07825ZM-0.40975 14.08C1.16892 14.08 2.38492 13.5467 3.23825 12.48C4.09158 11.392 4.51825 9.856 4.51825 7.872C4.51825 5.888 4.09158 4.36267 3.23825 3.296C2.38492 2.22933 1.16892 1.696 -0.40975 1.696C-1.98842 1.696 -3.22575 2.25067 -4.12175 3.36C-4.99642 4.448 -5.43375 5.97333 -5.43375 7.936C-5.43375 9.89867 -4.99642 11.4133 -4.12175 12.48C-3.24708 13.5467 -2.00975 14.08 -0.40975 14.08Z"
                      transform="translate(19.5938 12)"
                      fill="white"
                    />
                  </g>
                  <path
                    id="path-async-text"
                    d="M22.6251 11.928V24H20.7051V21.816C20.3531 22.568 19.8171 23.152 19.0971 23.568C18.3931 23.968 17.5691 24.168 16.6251 24.168C15.5531 24.168 14.6091 23.912 13.7931 23.4C12.9931 22.888 12.3691 22.168 11.9211 21.24C11.4891 20.296 11.2731 19.2 11.2731 17.952C11.2731 16.704 11.4971 15.608 11.9451 14.664C12.3931 13.704 13.0171 12.96 13.8171 12.432C14.6331 11.904 15.5691 11.64 16.6251 11.64C17.5691 11.64 18.3931 11.848 19.0971 12.264C19.8011 12.68 20.3371 13.264 20.7051 14.016V11.928H22.6251ZM17.0091 22.56C18.1931 22.56 19.1051 22.16 19.7451 21.36C20.3851 20.544 20.7051 19.392 20.7051 17.904C20.7051 16.416 20.3851 15.272 19.7451 14.472C19.1051 13.672 18.1931 13.272 17.0091 13.272C15.8251 13.272 14.8971 13.688 14.2251 14.52C13.5691 15.336 13.2411 16.48 13.2411 17.952C13.2411 19.424 13.5691 20.56 14.2251 21.36C14.8811 22.16 15.8091 22.56 17.0091 22.56ZM30.4637 24.168C28.4317 24.168 26.8237 23.648 25.6397 22.608L26.2877 21.168C26.9437 21.68 27.6077 22.048 28.2797 22.272C28.9517 22.496 29.7037 22.608 30.5357 22.608C31.4477 22.608 32.1357 22.456 32.5997 22.152C33.0797 21.832 33.3197 21.376 33.3197 20.784C33.3197 20.304 33.1597 19.92 32.8397 19.632C32.5197 19.344 31.9917 19.12 31.2557 18.96L29.2157 18.48C28.2077 18.256 27.4237 17.856 26.8637 17.28C26.3197 16.704 26.0477 16.016 26.0477 15.216C26.0477 14.16 26.4717 13.304 27.3197 12.648C28.1677 11.976 29.2877 11.64 30.6797 11.64C31.5277 11.64 32.3277 11.776 33.0797 12.048C33.8317 12.32 34.4637 12.712 34.9757 13.224L34.3277 14.64C33.1917 13.696 31.9757 13.224 30.6797 13.224C29.8157 13.224 29.1437 13.392 28.6637 13.728C28.1997 14.048 27.9677 14.504 27.9677 15.096C27.9677 15.592 28.1117 15.984 28.3997 16.272C28.7037 16.56 29.1837 16.784 29.8397 16.944L31.8797 17.448C32.9997 17.704 33.8317 18.104 34.3757 18.648C34.9197 19.176 35.1917 19.872 35.1917 20.736C35.1917 21.776 34.7677 22.608 33.9197 23.232C33.0717 23.856 31.9197 24.168 30.4637 24.168ZM48.687 11.928L43.047 25.104C42.455 26.48 41.711 27.488 40.815 28.128C39.919 28.768 38.815 29.208 37.503 29.448L37.095 27.936C38.231 27.68 39.087 27.336 39.663 26.904C40.255 26.488 40.743 25.84 41.127 24.96L41.607 23.88L36.495 11.928H38.535L42.615 21.888L46.743 11.928H48.687ZM56.853 11.64C59.749 11.64 61.197 13.232 61.197 16.416V24H59.253V16.512C59.253 15.392 59.029 14.576 58.581 14.064C58.133 13.536 57.429 13.272 56.469 13.272C55.349 13.272 54.453 13.616 53.781 14.304C53.109 14.992 52.773 15.92 52.773 17.088V24H50.829V15.312C50.829 14.064 50.765 12.936 50.637 11.928H52.485L52.677 14.088C53.045 13.304 53.597 12.704 54.333 12.288C55.069 11.856 55.909 11.64 56.853 11.64ZM69.9321 24.168C68.7641 24.168 67.7401 23.912 66.8601 23.4C65.9961 22.888 65.3241 22.168 64.8441 21.24C64.3801 20.296 64.1481 19.2 64.1481 17.952C64.1481 16.704 64.3881 15.608 64.8681 14.664C65.3481 13.704 66.0281 12.96 66.9081 12.432C67.8041 11.904 68.8441 11.64 70.0281 11.64C70.8441 11.64 71.6281 11.784 72.3801 12.072C73.1481 12.344 73.7801 12.728 74.2761 13.224L73.6281 14.664C73.0201 14.184 72.4281 13.832 71.8521 13.608C71.2921 13.384 70.7161 13.272 70.1241 13.272C68.8921 13.272 67.9241 13.688 67.2201 14.52C66.5161 15.336 66.1641 16.48 66.1641 17.952C66.1641 19.408 66.5081 20.544 67.1961 21.36C67.9001 22.16 68.8761 22.56 70.1241 22.56C70.7161 22.56 71.2921 22.448 71.8521 22.224C72.4281 22 73.0201 21.648 73.6281 21.168L74.2761 22.608C73.7641 23.088 73.1161 23.472 72.3321 23.76C71.5641 24.032 70.7641 24.168 69.9321 24.168Z"
                    transform="translate(39 4)"
                    fill={isThemeDark ? "white" : "black"}
                  />
                </g>
              </svg>
              <MenuWithLinks
                options={[
                  {
                    text: "Team Settings",
                    href: `/team-settings?teamSlug=${store.currentTeam.slug}`,
                    as: `/team/${store.currentTeam.slug}/team-settings`,
                    simple: true,
                  },
                  {
                    text: "Billing",
                    href: `/billing?teamSlug=${store.currentTeam.slug}`,
                    as: `/team/${store.currentTeam.slug}/billing`,
                    simple: true,
                  },
                  {
                    text: "Your Settings",
                    href: "/your-settings",
                    highlighterSlug: "/your-settings",
                  },
                  {
                    separator: true,
                  },
                  {
                    text: "Log out",
                    href: `${process.env.NEXT_PUBLIC_URL_API}/logout`,
                    as: `${process.env.NEXT_PUBLIC_URL_API}/logout`,
                    externalServer: true,
                  },
                ]}
              >
                <Avatar
                  src={store.currentUser.avatarUrl}
                  alt="Add username here later in the book"
                  style={{
                    margin: "20px auto",
                    cursor: "pointer",
                    display: "inline-flex",
                    width: "40px",
                    height: "40px",
                  }}
                />

                <i className="material-icons" color="action" style={{ verticalAlign: "super" }}>
                  arrow_drop_down
                </i>
              </MenuWithLinks>
            </div>
            <hr />
            <p />
            <p />
            <DiscussionList store={store} team={store.currentTeam} isMobile={isMobile} />
          </Grid>
        ) : null}

        {children}
      </Grid>
      <Notifier />
      <Confirmer />
    </React.Fragment>
  );
}

type Props = {
  children: React.ReactNode;
  isMobile?: boolean;
  firstGridItem?: boolean;
  store?: Store;
  teamRequired?: boolean;
};

class Layout extends React.Component<Props> {
  public render() {
    const { children, isMobile, firstGridItem, store, teamRequired } = this.props;

    const { currentUser, currentTeam } = store;

    // console.log(this.props.store.currentUser.darkTheme);

    // const isThemeDark = false;

    // console.log(isMobile);

    // console.log(currentTeam);

    if (!currentUser) {
      return (
        <LayoutWrapper firstGridItem={firstGridItem} isMobile={isMobile} store={store}>
          <Grid item sm={12} xs={12}>
            {children}
          </Grid>
        </LayoutWrapper>
      );
    }

    if (!currentTeam) {
      if (teamRequired) {
        return (
          <LayoutWrapper firstGridItem={firstGridItem} isMobile={isMobile} store={store}>
            <Grid item sm={10} xs={12} style={{ padding: "0px 35px", overflow: "auto", height: "auto" }}>
              <div style={{ padding: "20px" }}>
                Select existing team or create a new team.
                <p />
                <Link href="/create-team" as="/create-team">
                  <Button variant="outlined" color="primary">
                    Create new team
                  </Button>
                </Link>
              </div>
            </Grid>
          </LayoutWrapper>
        );
      } else {
        console.log("team not required");
        return (
          <LayoutWrapper firstGridItem={firstGridItem} isMobile={isMobile} store={store}>
            <Grid item sm={10} xs={12} style={{ padding: "0px 35px", overflow: "auto", height: "auto" }}>
              {children}
            </Grid>
          </LayoutWrapper>
        );
      }
    }

    return (
      <LayoutWrapper firstGridItem={firstGridItem} isMobile={isMobile} store={store}>
        <Grid
          item
          sm={firstGridItem ? 10 : 12}
          xs={12}
          style={{ padding: "0px 35px", overflowY: "auto", height: "inherit" }}
        >
          <div>
            {isMobile || store.currentUrl.includes("create-team") ? null : (
              <React.Fragment>
                <i
                  style={{
                    float: "left",
                    margin: "15px 0px 10px 25px",
                    opacity: 0.8,
                    fontSize: "18px",
                    cursor: "pointer",
                    verticalAlign: "top",
                  }}
                  className="material-icons"
                  onClick={async () => {
                    await store.currentUser.toggleTheme(!store.currentUser.darkTheme);
                  }}
                >
                  lens
                </i>
              </React.Fragment>
            )}
            <div style={{ clear: "both" }} />
          </div>
          {children}
        </Grid>
      </LayoutWrapper>
    );
  }
}

export default Layout;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\components\posts\PostContent.tsx -----

import React from 'react';

type Props = { html: string };

class PostContent extends React.Component<Props> {
  public render() {
    const { html } = this.props;

    return (
      <div
        style={{ fontSize: '15px', lineHeight: '2em', fontWeight: 300, wordBreak: 'break-all' }}
        dangerouslySetInnerHTML={{ __html: html }}
      />
    );
  }
}

export default PostContent;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\components\posts\PostDetail.tsx -----

import Avatar from "@mui/material/Avatar";
import Paper from "@mui/material/Paper";
import Tooltip from "@mui/material/Tooltip";
import { observer } from "mobx-react";
import moment from "moment";
import React from "react";

import confirm from "../../lib/confirm";
import notify from "../../lib/notify";
import { Store } from "../../lib/store";
import { Post } from "../../lib/store/post";
import { User } from "../../lib/store/user";

import MenuWithMenuItems from "../common/MenuWithMenuItems";

import PostContent from "./PostContent";

const stylePaper = {
  margin: "10px 0px",
  padding: "20px",
};

const styleLineSeparator = {
  verticalAlign: "text-bottom",
  fontWeight: 300,
  fontSize: "16px",
  margin: "0px 5px",
  opacity: 0.75,
};

const getMenuOptions = (post) => ({
  dataId: post._id,
  id: `post-menu-${post._id}`,
});

const getMenuItemOptions = (post: Post, currentUser: User, component) => {
  const items = [];

  if (post.createdUserId !== currentUser._id) {
    items.push({
      text: "Show Markdown",
      dataId: post._id,
      onClick: component.showMarkdown,
    });
  }

  if (post.createdUserId === currentUser._id) {
    const isFirstPost = post.discussion.posts.indexOf(post) === 0;

    items.push({
      text: "Edit",
      dataId: post._id,
      onClick: component.editPost,
    });

    if (!isFirstPost) {
      items.push({
        text: "Delete",
        dataId: post._id,
        onClick: component.deletePost,
      });
    }
  }

  return items;
};

type Props = {
  post: Post;
  store: Store;
  isMobile: boolean;
  onEditClick: (post) => void;
  onShowMarkdownClick: (post) => void;
};

class PostDetail extends React.Component<Props> {
  public render() {
    const { post, isMobile } = this.props;

    return <Paper style={stylePaper}>{this.renderPostDetail(post, isMobile)}</Paper>;
  }

  public renderPostDetail(post: Post, isMobile) {
    const createdDate = moment(post.createdAt).local().format("MMM Do YYYY");
    const lastUpdatedDate = moment(post.lastUpdatedAt).fromNow();

    return (
      <React.Fragment>
        <div
          style={{
            float: "left",
            margin: "-12px 10px 0px -15px",
            zIndex: 1000,
          }}
        >
          {this.renderMenu()}
        </div>
        <div id={`post-${post._id}`}>
          {post.user && (
            <Tooltip title={post.user.displayName} placement="top" disableFocusListener disableTouchListener>
              <Avatar
                src={post.user.avatarUrl}
                alt={post.user.displayName}
                style={{
                  width: "40px",
                  height: "40px",
                  margin: "0px 10px 0px 5px",
                  cursor: "pointer",
                  float: "left",
                }}
              />
            </Tooltip>
          )}
          <div
            style={{
              margin: isMobile ? "0px" : "0px 20px 0px 70px",
              fontWeight: 300,
              lineHeight: "1em",
            }}
          >
            <span style={{ fontSize: "12px", fontWeight: 400 }}>
              {`By: ${post.user && post.user.displayName}` || "User"}
              <span style={styleLineSeparator}>|</span>
              {`Created: ${post.createdAt && createdDate}` || ""}

              {post.isEdited ? (
                <React.Fragment>
                  <span style={styleLineSeparator}>|</span>
                  Last edited: {lastUpdatedDate}
                </React.Fragment>
              ) : null}
            </span>

            <PostContent html={post.htmlContent} />
          </div>
        </div>
      </React.Fragment>
    );
  }

  public renderMenu() {
    const { post, store } = this.props;
    const { currentUser } = store;

    if (!post.user || !currentUser) {
      return null;
    }

    return (
      <MenuWithMenuItems
        menuOptions={getMenuOptions(post)}
        itemOptions={getMenuItemOptions(post, store.currentUser, this)}
      />
    );
  }

  public showMarkdown = () => {
    const { post, onShowMarkdownClick } = this.props;
    if (onShowMarkdownClick) {
      onShowMarkdownClick(post);
    }
  };

  public editPost = () => {
    const { post, onEditClick } = this.props;
    if (onEditClick) {
      onEditClick(post);
    }
    console.log(`PostDetail: ${post._id}`);
  };

  public deletePost = () => {
    confirm({
      title: "Are you sure?",
      message: "",
      onAnswer: async (answer) => {
        if (answer) {
          const { post } = this.props;
          await post.discussion.deletePost(post);
          notify("You successfully deleted Post.");
        }
      },
    });
  };
}

export default observer(PostDetail);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\components\posts\PostEditor.tsx -----

import Avatar from "@mui/material/Avatar";
import Button from "@mui/material/Button";
import he from "he";
import { marked } from "marked";
import { observer } from "mobx-react";
import NProgress from "nprogress";
import React from "react";
import { Mention, MentionsInput } from "react-mentions";

import {
  getSignedRequestForUploadApiMethod,
  uploadFileUsingSignedPutRequestApiMethod,
} from "../../lib/api/team-member";
import notify from "../../lib/notify";
import { resizeImage } from "../../lib/resizeImage";
import { Store } from "../../lib/store";
import { User } from "../../lib/store/user";

import PostContent from "./PostContent";

function getImageDimension(file): Promise<{ width: number; height: number }> {
  const reader = new FileReader();
  const img = new Image();

  return new Promise((resolve) => {
    reader.readAsDataURL(file);

    reader.onload = (e) => {
      img.onload = () => {
        resolve({ width: img.width, height: img.height });
      };

      img.src = e.target.result.toString();
    };
  });
}

type Props = {
  store: Store;
  onChanged: (content) => void;
  content: string;
  members: User[];
  textareaHeight?: string;
  placeholder?: string;
  parentComponent: string;
};

type State = { htmlContent: string };

class PostEditor extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      htmlContent: "",
    };
  }

  public render() {
    const { htmlContent } = this.state;
    const { content, members, store, parentComponent } = this.props;
    const { currentUser } = store;

    const membersMinusCurrentUser = members.filter((member) => member._id !== currentUser._id);

    const isThemeDark = store && store.currentUser && store.currentUser.darkTheme === true;
    const textareaBackgroundColor = isThemeDark ? "#0d1117" : "#fff";

    return (
      <div style={{ marginTop: "20px" }}>
        <div style={{ display: "inline-flex" }}>
          <Button
            onClick={this.showMarkdownContent}
            variant="text"
            style={{ fontWeight: htmlContent ? 300 : 600, color: "#58a6ff" }}
          >
            Markdown
          </Button>{" "}
          <Button
            onClick={this.showHtmlContent}
            variant="text"
            style={{ fontWeight: htmlContent ? 600 : 300, color: "#58a6ff" }}
          >
            HTML
          </Button>
        </div>

        <div style={{ display: "inline", float: "left" }}>
          <label htmlFor={"upload-file-post-editor-" + parentComponent}>
            <Button component="span">
              <i className="material-icons" style={{ fontSize: "22px", color: "#58a6ff" }}>
                insert_photo
              </i>
            </Button>
          </label>
          <input
            accept="image/*"
            name={"upload-file-post-editor-" + parentComponent}
            id={"upload-file-post-editor-" + parentComponent}
            type="file"
            style={{ display: "none" }}
            onChange={async (event) => {
              const file = event.target.files[0];
              await this.uploadFile(file);
              event.target.value = "";
            }}
          />
        </div>
        <br />
        <div
          style={{
            width: "100%",
            height: "100vh",
            padding: "10px 15px",
            border: isThemeDark ? "1px solid rgba(255, 255, 255, 0.5)" : "1px solid rgba(0, 0, 0, 0.5)",
          }}
        >
          {htmlContent ? (
            <PostContent html={htmlContent} />
          ) : (
            <MentionsInput
              style={{
                input: {
                  border: "none",
                  outline: "none",
                  color: isThemeDark ? "#fff" : "#000",
                  fontWeight: 300,
                  height: "100vh",
                  lineHeight: "1.5em",
                  backgroundColor: content ? textareaBackgroundColor : "transparent",
                },
                suggestions: {
                  list: {
                    backgroundColor: "#222",
                    color: "#fff",
                  },

                  item: {
                    padding: "5px 15px",
                    borderBottom: "1px solid rgba(0,0,0,0.15)",

                    "&focused": {
                      backgroundColor: "rgba(255, 255, 255, 0.1)",
                    },
                  },
                },
              }}
              autoFocus
              value={content}
              placeholder={this.props.placeholder ? this.props.placeholder : "Compose new post"}
              onChange={(event) => {
                this.props.onChanged(event.target.value);
              }}
            >
              <Mention
                trigger="@"
                data={membersMinusCurrentUser.map((u) => ({
                  id: u.avatarUrl,
                  display: u.displayName,
                  // you: u._id === currentUser._id ? true : false,
                }))}
                markup={"[`@#__display__`](__id__)"}
                displayTransform={(_, display) => {
                  return `@${display}`;
                }}
                renderSuggestion={(suggestion) => (
                  <React.Fragment>
                    <Avatar
                      role="presentation"
                      src={suggestion.id}
                      alt={suggestion.display}
                      style={{
                        width: "24px",
                        height: "24px",
                        marginRight: "10px",
                        display: "inline-flex",
                        verticalAlign: "middle",
                      }}
                    />
                    <span style={{ marginRight: "5px" }}>{suggestion.display}</span>
                  </React.Fragment>
                )}
              />
            </MentionsInput>
          )}
        </div>
      </div>
    );
  }

  public showMarkdownContent = () => {
    this.setState({ htmlContent: "" });
  };

  public showHtmlContent = async () => {
    const { content } = this.props;

    function markdownToHtml(postContent) {
      const renderer = new marked.Renderer();

      renderer.link = (href, title, text) => {
        const t = title ? ` title="${title}"` : "";

        if (text.startsWith("<code>@#")) {
          return `${text.replace("<code>@#", "<code>@")} `;
        }

        return `
          <a target="_blank" href="${href}" rel="noopener noreferrer"${t}>
            ${text}
          </a>
        `;
      };

      marked.setOptions({
        renderer,
        breaks: true,
      });

      return marked(he.decode(postContent));
    }

    const htmlContent = content ? markdownToHtml(content) : "<span>Nothing to preview.</span>";
    this.setState({ htmlContent });
  };

  private uploadFile = async (file: File) => {
    if (!file) {
      notify("No file selected.");
      return;
    }

    if (!file.type || (!file.type.startsWith("image/") && file.type !== "application/pdf")) {
      notify("Wrong file.");
      return;
    }

    const { store } = this.props;
    const { currentTeam } = store;

    NProgress.start();

    const bucket = process.env.NEXT_PUBLIC_BUCKET_FOR_POSTS;
    const prefix = `${currentTeam.slug}`;
    const fileName = file.name;
    const fileType = file.type;

    try {
      const responseFromApiServerForUpload = await getSignedRequestForUploadApiMethod({
        fileName,
        fileType,
        prefix,
        bucket,
      });

      let fileHtmlOrMarkdown;
      let fileUrl;

      if (file.type.startsWith("image/")) {
        const { width } = await getImageDimension(file);
        const resizedFile = await resizeImage(file, 1024, 1024);

        await uploadFileUsingSignedPutRequestApiMethod(resizedFile, responseFromApiServerForUpload.signedRequest);

        fileUrl = responseFromApiServerForUpload.url;

        console.log(fileUrl);

        const finalWidth = width > 768 ? "100%" : `${width}px`;

        fileHtmlOrMarkdown = `
          <div>
            <img style="max-width: ${finalWidth}; width:100%" src="${fileUrl}" alt="Async" class="s3-image" />
          </div>`;
      } else {
        await uploadFileUsingSignedPutRequestApiMethod(file, responseFromApiServerForUpload.signedRequest);

        fileUrl = responseFromApiServerForUpload.url;
        fileHtmlOrMarkdown = `[${file.name}](${fileUrl})`;
      }

      const content = `${this.props.content}\n${fileHtmlOrMarkdown.replace(/\s+/g, " ")}`;

      this.props.onChanged(content);

      notify("You successfully uploaded file.");
    } catch (error) {
      console.log(error);
      notify(error);
    } finally {
      NProgress.done();
    }
  };
}

export default observer(PostEditor);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\components\posts\PostForm.tsx -----

import Button from "@mui/material/Button";
import he from "he";
import { marked } from "marked";
import { observer } from "mobx-react";
import NProgress from "nprogress";
import React from "react";

import notify from "../../lib/notify";
import { Store } from "../../lib/store";
import { Discussion } from "../../lib/store/discussion";
import { Post } from "../../lib/store/post";
import { User } from "../../lib/store/user";

import PostEditor from "./PostEditor";

type Props = {
  store: Store;
  isMobile: boolean;
  members: User[];
  post: Post;
  discussion: Discussion;
  showMarkdownToNonCreator?: boolean;
  onFinished?: () => void;
};

type State = {
  postId: string;
  content: string;
  disabled: boolean;
};

class PostForm extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      postId: null,
      content: "",
      disabled: false,
    };
  }

  public static getDerivedStateFromProps(props: Props, state: State) {
    const { post } = props;

    if (!post && !state.postId) {
      return null;
    }

    if (post && post._id === state.postId) {
      return null;
    }

    return {
      postId: (post && post._id) || null,
      content: (post && post.content) || "",
    };
  }

  public render() {
    const { store, members, post, isMobile, showMarkdownToNonCreator } = this.props;
    const isEditingPost = !!post;

    let title = "Add Post";
    if (showMarkdownToNonCreator) {
      title = "Showing Markdown";
    } else if (isEditingPost) {
      title = "Edit Post";
    }

    return (
      <div style={{ height: "100%", margin: "0px 20px" }}>
        <p />
        <br />
        <h3>{title}</h3>
        <form style={{ width: "100%", height: "100%" }} onSubmit={this.onSubmit} autoComplete="off">
          <p />
          <br />
          <div>
            {showMarkdownToNonCreator ? null : (
              <React.Fragment>
                <Button type="submit" variant="contained" color="primary" disabled={this.state.disabled}>
                  {isEditingPost ? "Save changes" : "Publish Post"}
                </Button>
                {isMobile ? <p /> : null}
              </React.Fragment>
            )}
            {isEditingPost ? (
              <Button
                variant="outlined"
                onClick={this.closeForm}
                disabled={this.state.disabled}
                style={{ marginLeft: "10px" }}
              >
                {showMarkdownToNonCreator ? "Go back" : "Cancel"}
              </Button>
            ) : null}
          </div>
          <p />
          <br />
          <PostEditor
            content={this.state.content}
            onChanged={this.onContentChanged}
            members={members}
            store={store}
            textareaHeight="100%"
            parentComponent="PF"
          />
          <p />
          <div style={{ margin: "20px 0px" }}>
            {isEditingPost ? (
              <Button
                variant="outlined"
                onClick={this.closeForm}
                disabled={this.state.disabled}
                style={{ marginLeft: "10px" }}
              >
                {showMarkdownToNonCreator ? "Go back" : "Cancel"}
              </Button>
            ) : null}
          </div>
          <p />
          <br />
        </form>
      </div>
    );
  }

  private onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();

    const { content } = this.state;
    const htmlContent = marked(he.decode(content));
    const { post, onFinished, store, discussion } = this.props;
    const isEditingPost = !!post;

    if (!content) {
      notify("Add content to your Post");
      return;
    }

    if (isEditingPost) {
      this.setState({ disabled: true });
      NProgress.start();
      try {
        await post.editPost({ content, htmlContent });
        notify("You successfully edited Post");
      } catch (error) {
        console.log(error);
        notify(error);
      } finally {
        this.setState({ disabled: false });
        NProgress.done();
      }

      if (onFinished) {
        onFinished();
      }

      return;
    }

    const { currentTeam } = store;
    if (!currentTeam) {
      notify("Team is not selected or does not exist.");
      return;
    }

    NProgress.start();
    this.setState({ disabled: true });

    try {
      const post = await discussion.addPost(content);

      if (discussion.notificationType === "email") {
        const userIdsForLambda = discussion.memberIds.filter((m) => m !== store.currentUser._id);

        await discussion.sendDataToLambda({
          discussionName: discussion.name,
          discussionLink: `${process.env.NEXT_PUBLIC_URL_APP}/team/${discussion.team.slug}/discussions/${discussion.slug}`,
          postContent: post.content,
          authorName: post.user.displayName,
          userIds: userIdsForLambda,
        });
      }

      this.setState({ content: "" });

      notify("You successfully published new Post.");
    } catch (error) {
      console.log(error);
      notify(error);
    } finally {
      this.setState({ disabled: false });
      NProgress.done();
    }

    if (onFinished) {
      onFinished();
    }
  };

  private onContentChanged = (content: string) => {
    this.setState({ content });
  };

  private closeForm = () => {
    this.setState({ postId: null, content: "" });

    const { onFinished } = this.props;
    if (onFinished) {
      onFinished();
    }
  };
}

export default observer(PostForm);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\components\teams\InviteMember.tsx -----

import Button from "@mui/material/Button";
import Dialog from "@mui/material/Dialog";
import DialogContent from "@mui/material/DialogContent";
import DialogTitle from "@mui/material/DialogTitle";
import TextField from "@mui/material/TextField";
import { inject, observer } from "mobx-react";
import NProgress from "nprogress";
import React from "react";

import notify from "../../lib/notify";
import { Store } from "../../lib/store";

type Props = {
  store: Store;
  onClose: () => void;
  open: boolean;
};

type State = {
  email: string;
  disabled: boolean;
};

class InviteMember extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      email: "",
      disabled: false,
    };
  }

  public render() {
    const { open } = this.props;

    return (
      <Dialog onClose={this.handleClose} aria-labelledby="invite-member-dialog-title" open={open}>
        <DialogTitle id="invite-member-dialog-title">Invite member</DialogTitle>
        <DialogContent>
          <form onSubmit={this.onSubmit} style={{ padding: "20px" }}>
            <TextField
              autoComplete="off"
              value={this.state.email}
              placeholder="Email"
              onChange={(event) => {
                this.setState({ email: event.target.value });
              }}
            />
            <p />
            <br />
            <Button variant="outlined" onClick={this.handleClose} disabled={this.state.disabled}>
              Cancel
            </Button>{" "}
            <Button type="submit" variant="contained" color="primary" disabled={this.state.disabled}>
              Invite
            </Button>
          </form>
        </DialogContent>
      </Dialog>
    );
  }

  private handleClose = () => {
    this.setState({ email: "", disabled: false });
    this.props.onClose();
  };

  private onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();

    const { store } = this.props;

    if (!store.currentTeam) {
      notify("Team have not selected");
      return;
    }

    const { email } = this.state;

    if (!email) {
      notify("Email is required");
      return;
    }

    NProgress.start();
    try {
      this.setState({ disabled: true });
      await store.currentTeam.inviteMember(email);

      this.setState({ email: "" });
      notify("You successfully sent invitation.");
      NProgress.done();
    } catch (error) {
      console.log(error);
      notify(error);
    } finally {
      this.props.onClose();
      this.setState({ disabled: false });
      NProgress.done();
    }
  };
}

export default inject("store")(observer(InviteMember));

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\lib\api\makeQueryString.ts -----

function makeQueryString(params) {
  const query = Object.keys(params)
    .filter((k) => !!params[k])
    .map((k) => `${encodeURIComponent(k)}=${encodeURIComponent(params[k])}`)
    .join('&');

  return query;
}

export { makeQueryString };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\lib\api\public.ts -----

import sendRequestAndGetResponse from './sendRequestAndGetResponse';

const BASE_PATH = '/api/v1/public';

export const getUserApiMethod = (request) =>
  sendRequestAndGetResponse(`${BASE_PATH}/get-user`, {
    request,
    method: 'GET',
  });

export const getUserBySlugApiMethod = (slug) =>
  sendRequestAndGetResponse(`${BASE_PATH}/get-user-by-slug`, {
    body: JSON.stringify({ slug }),
  });

export const emailLoginLinkApiMethod = ({
  email,
  invitationToken,
}: {
  email: string;
  invitationToken?: string;
}) =>
  sendRequestAndGetResponse('/auth/email-login-link', {
    qs: { invitationToken },
    body: JSON.stringify({ user: email }),
  });

export const getTeamByTokenApiMethod = (token: string, request) =>
  sendRequestAndGetResponse(`${BASE_PATH}/invitations/get-team-by-token`, {
    request,
    method: 'GET',
    qs: { token },
  });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\lib\api\sendRequestAndGetResponse.ts -----

import 'isomorphic-unfetch';

import { makeQueryString } from './makeQueryString';

export default async function sendRequestAndGetResponse(path, opts: any = {}) {
  const headers = Object.assign(
    {},
    opts.headers || {},
    opts.externalServer
      ? {}
      : {
          'Content-type': 'application/json; charset=UTF-8',
        },
  );

  const { request } = opts;

  if (request && request.headers && request.headers.cookie) {
    headers.cookie = request.headers.cookie;
  }

  // const qs = opts.qs || '';

  const qs = (opts.qs && `?${makeQueryString(opts.qs)}`) || '';

  // console.log(`before: ${process.env.NEXT_PUBLIC_URL_API}${path}${qs}`);

  const response = await fetch(
    opts.externalServer ? `${path}${qs}` : `${process.env.NEXT_PUBLIC_URL_API}${path}${qs}`,
    Object.assign({ method: 'POST', credentials: 'include' }, opts, { headers }),
  );

  // console.log(`after: ${process.env.NEXT_PUBLIC_URL_API}${path}${qs}`);

  // console.log(response.status);
  // console.log(response.statusText);

  const text = await response.text();

  if (response.status >= 400) {
    console.error(text);
    throw new Error(response.status.toString());
  }

  try {
    const data = JSON.parse(text);

    return data;
  } catch (err) {
    if (err instanceof SyntaxError) {
      return text;
    }

    throw err;
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\lib\api\team-leader.ts -----

import sendRequestAndGetResponse from './sendRequestAndGetResponse';

const BASE_PATH = '/api/v1/team-leader';

export const addTeamApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams/add`, {
    body: JSON.stringify(data),
  });

export const updateTeamApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams/update`, {
    body: JSON.stringify(data),
  });

export const getTeamInvitationsApiMethod = (teamId: string) =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams/get-invitations-for-team`, {
    method: 'GET',
    qs: { teamId },
  });

export const inviteMemberApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams/invite-member`, {
    body: JSON.stringify(data),
  });

export const removeMemberApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams/remove-member`, {
    body: JSON.stringify(data),
  });

export const fetchCheckoutSessionApiMethod = ({ mode, teamId }: { mode: string; teamId: string }) =>
  sendRequestAndGetResponse(`${BASE_PATH}/stripe/fetch-checkout-session`, {
    body: JSON.stringify({ mode, teamId }),
  });

export const cancelSubscriptionApiMethod = ({ teamId }: { teamId: string }) =>
  sendRequestAndGetResponse(`${BASE_PATH}/cancel-subscription`, {
    body: JSON.stringify({ teamId }),
  });

export const getListOfInvoicesApiMethod = () =>
  sendRequestAndGetResponse(`${BASE_PATH}/get-list-of-invoices-for-customer`, {
    method: 'GET',
  });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\lib\api\team-member.ts -----

import sendRequestAndGetResponse from './sendRequestAndGetResponse';

const BASE_PATH = '/api/v1/team-member';

export const getSignedRequestForUploadApiMethod = ({ fileName, fileType, prefix, bucket }) =>
  sendRequestAndGetResponse(`${BASE_PATH}/aws/get-signed-request-for-upload-to-s3`, {
    body: JSON.stringify({ fileName, fileType, prefix, bucket }),
  });

export const uploadFileUsingSignedPutRequestApiMethod = (file, signedRequest, headers = {}) =>
  sendRequestAndGetResponse(signedRequest, {
    externalServer: true,
    method: 'PUT',
    body: file,
    headers,
  });

export const updateProfileApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/user/update-profile`, {
    body: JSON.stringify(data),
  });

export const toggleThemeApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/user/toggle-theme`, {
    body: JSON.stringify(data),
  });

export const getInitialDataApiMethod = (options: any = {}) =>
  sendRequestAndGetResponse(
    `${BASE_PATH}/get-initial-data`,
    Object.assign(
      {
        body: JSON.stringify(options.data || {}),
      },
      options,
    ),
  );

export const getTeamListApiMethod = () =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams`, {
    method: 'GET',
  });

export const getTeamMembersApiMethod = (teamId: string) =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams/get-members`, {
    method: 'GET',
    qs: { teamId },
  });

// Discussion and Post

export const getDiscussionListApiMethod = (params): Promise<{ discussions: any[] }> =>
  sendRequestAndGetResponse(`${BASE_PATH}/discussions/list`, {
    method: 'GET',
    qs: params,
  });

export const addDiscussionApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/discussions/add`, {
    body: JSON.stringify(data),
  });

export const editDiscussionApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/discussions/edit`, {
    body: JSON.stringify(data),
  });

export const deleteDiscussionApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/discussions/delete`, {
    body: JSON.stringify(data),
  });

export const getPostListApiMethod = (discussionId: string) =>
  sendRequestAndGetResponse(`${BASE_PATH}/posts/list`, {
    method: 'GET',
    qs: { discussionId },
  });

export const addPostApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/posts/add`, {
    body: JSON.stringify(data),
  });

export const editPostApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/posts/edit`, {
    body: JSON.stringify(data),
  });

export const deletePostApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/posts/delete`, {
    body: JSON.stringify(data),
  });

export const sendDataToLambdaApiMethod = (data) =>
  sendRequestAndGetResponse(`${process.env.NEXT_PUBLIC_API_GATEWAY_ENDPOINT}/`, {
    externalServer: true,
    body: JSON.stringify(data),
  });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\lib\store\discussion.ts -----

import { action, decorate, IObservableArray, observable, runInAction, computed } from 'mobx';

import {
  addPostApiMethod,
  deletePostApiMethod,
  editDiscussionApiMethod,
  getPostListApiMethod,
  sendDataToLambdaApiMethod,
} from '../api/team-member';
import { Store } from './index';
import { Team } from './team';
import { Post } from './post';

class Discussion {
  public _id: string;
  public createdUserId: string;
  public store: Store;
  public team: Team;

  public name: string;
  public slug: string;
  public memberIds: IObservableArray<string> = observable([]);
  public posts: IObservableArray<Post> = observable([]);
  public isLoadingPosts = false;

  public notificationType: string;

  constructor(params) {
    this._id = params._id;
    this.createdUserId = params.createdUserId;
    this.store = params.store;
    this.team = params.team;

    this.name = params.name;
    this.slug = params.slug;
    this.memberIds.replace(params.memberIds || []);

    this.notificationType = params.notificationType;

    if (params.initialPosts) {
      this.setInitialPosts(params.initialPosts);
      console.log(params.initialPosts[0]);
    } else {
      this.loadPosts();
    }
  }

  public async editDiscussion(data) {
    try {
      await editDiscussionApiMethod({
        id: this._id,
        ...data,
        socketId: (this.store.socket && this.store.socket.id) || null,
      });

      runInAction(() => {
        this.changeLocalCache(data);
      });
    } catch (error) {
      console.error(error);
      throw error;
    }
  }

  public changeLocalCache(data) {
    this.name = data.name;
    this.memberIds.replace(data.memberIds || []);
  }

  get members() {
    return this.memberIds.map((id) => this.team.members.get(id)).filter((u) => !!u);
  }

  public setInitialPosts(posts) {
    const postObjs = posts.map((p) => new Post({ discussion: this, store: this.store, ...p }));
    this.posts.replace(postObjs);
  }

  public async loadPosts() {
    if (this.store.isServer || this.isLoadingPosts) {
      return;
    }

    this.isLoadingPosts = true;

    try {
      const { posts = [] } = await getPostListApiMethod(this._id);

      runInAction(() => {
        const postObjs = posts.map((t) => new Post({ discussion: this, store: this.store, ...t }));
        this.posts.replace(postObjs);
      });
    } finally {
      runInAction(() => {
        this.isLoadingPosts = false;
      });
    }
  }

  public async addPost(content: string): Promise<Post> {
    const { post } = await addPostApiMethod({
      discussionId: this._id,
      content,
      socketId: (this.store.socket && this.store.socket.id) || null,
    });

    return new Promise<Post>((resolve) => {
      runInAction(() => {
        const obj = this.addPostToLocalCache(post);
        resolve(obj);
      });
    });
  }

  public addPostToLocalCache(data) {
    const postObj = new Post({ discussion: this, store: this.store, ...data });

    this.posts.push(postObj);

    return postObj;
  }

  public async deletePost(post: Post) {
    await deletePostApiMethod({
      id: post._id,
      discussionId: this._id,
      socketId: (this.store.socket && this.store.socket.id) || null,
    });

    runInAction(() => {
      this.posts.remove(post);
    });
  }

  public joinSocketRooms() {
    if (this.store.socket) {
      console.log('joining socket discussion room', this.name);
      this.store.socket.emit('joinTeamRoom', this.team._id);
      this.store.socket.emit('joinDiscussionRoom', this._id);
    }
  }

  public leaveSocketRooms() {
    if (this.store.socket) {
      console.log('leaving socket discussion room', this.name);
      this.store.socket.emit('leaveTeamRoom', this.team._id);
      this.store.socket.emit('leaveDiscussionRoom', this._id);
    }
  }

  public handleDiscussionRealtimeEvent = (data) => {
    console.log('discussion realtime event', data);
    const { actionType } = data;

    if (actionType === 'added') {
      this.addDiscussionToLocalCache(data.discussion);
    } else if (actionType === 'edited') {
      this.editDiscussionFromLocalCache(data.discussion);
    } else if (actionType === 'deleted') {
      this.deleteDiscussionFromLocalCache(data.id);
    }
  };

  public addDiscussionToLocalCache(data): Discussion {
    const obj = new Discussion({ team: this.team, store: this.store, ...data });

    if (obj.memberIds.includes(this.store.currentUser._id)) {
      this.team.discussions.push(obj);
    }

    return obj;
  }

  public editDiscussionFromLocalCache(data) {
    const discussion = this.team.discussions.find((item) => item._id === data._id);
    if (discussion) {
      if (data.memberIds && data.memberIds.includes(this.store.currentUser._id)) {
        discussion.changeLocalCache(data);
      } else {
        this.deleteDiscussionFromLocalCache(data._id);
      }
    } else if (data.memberIds && data.memberIds.includes(this.store.currentUser._id)) {
      this.addDiscussionToLocalCache(data);
    }
  }

  public deleteDiscussionFromLocalCache(discussionId: string) {
    const discussion = this.team.discussions.find((item) => item._id === discussionId);
    this.team.discussions.remove(discussion);
  }

  public handlePostRealtimeEvent(data) {
    const { actionType } = data;

    if (actionType === 'added') {
      this.addPostToLocalCache(data.post);
    } else if (actionType === 'edited') {
      this.editPostFromLocalCache(data.post);
    } else if (actionType === 'deleted') {
      this.deletePostFromLocalCache(data.id);
    }
  }

  public editPostFromLocalCache(data) {
    const post = this.posts.find((t) => t._id === data._id);
    if (post) {
      post.changeLocalCache(data);
    }
  }

  public deletePostFromLocalCache(postId) {
    const post = this.posts.find((t) => t._id === postId);
    this.posts.remove(post);
  }

  public async sendDataToLambda({
    discussionName,
    discussionLink,
    postContent,
    authorName,
    userIds,
  }) {
    console.log(discussionName, discussionLink, authorName, postContent, userIds);
    try {
      await sendDataToLambdaApiMethod({
        discussionName,
        discussionLink,
        postContent,
        authorName,
        userIds,
      });
    } catch (error) {
      console.error(error);
      throw error;
    }
  }
}

decorate(Discussion, {
  name: observable,
  slug: observable,
  memberIds: observable,
  posts: observable,
  isLoadingPosts: observable,

  editDiscussion: action,
  changeLocalCache: action,

  setInitialPosts: action,
  loadPosts: action,
  addPost: action,
  addPostToLocalCache: action,
  deletePost: action,

  addDiscussionToLocalCache: action,
  editDiscussionFromLocalCache: action,
  deleteDiscussionFromLocalCache: action,
  editPostFromLocalCache: action,
  deletePostFromLocalCache: action,

  members: computed,
});

export { Discussion };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\lib\store\index.ts -----

import * as mobx from 'mobx';
import { action, decorate, IObservableArray, observable } from 'mobx';
import { useStaticRendering } from 'mobx-react';
// @ts-expect-error no exported member io socket.io-client
import { io } from 'socket.io-client';

import { addTeamApiMethod, getTeamInvitationsApiMethod } from '../api/team-leader';
import { getTeamListApiMethod, getTeamMembersApiMethod } from '../api/team-member';

import { User } from './user';
import { Team } from './team';

useStaticRendering(typeof window === 'undefined');

mobx.configure({ enforceActions: 'observed' });

class Store {
  public isServer: boolean;

  public currentUser?: User = null;
  public currentUrl = '';

  public currentTeam?: Team;

  public teams: IObservableArray<Team> = observable([]);

  public socket: SocketIOClient.Socket;

  constructor({
    initialState = {},
    isServer,
    socket = null,
  }: {
    initialState?: any;
    isServer: boolean;
    socket?: SocketIOClient.Socket;
  }) {
    this.isServer = !!isServer;

    this.setCurrentUser(initialState.user);

    this.currentUrl = initialState.currentUrl || '';

    // console.log(initialState.user);

    if (initialState.teamSlug || (initialState.user && initialState.user.defaultTeamSlug)) {
      this.setCurrentTeam(
        initialState.teamSlug || initialState.user.defaultTeamSlug,
        initialState.teams,
      );
    }

    if (initialState.teams && initialState.teams.length > 0) {
      this.setInitialTeamsStoreMethod(initialState.teams);
    }

    this.socket = socket;

    if (socket) {
      socket.on('disconnect', () => {
        console.log('socket: ## disconnected');
      });

      socket.on('reconnect', (attemptNumber) => {
        console.log('socket: $$ reconnected', attemptNumber);
      });
    }
  }

  public changeCurrentUrl(url: string) {
    this.currentUrl = url;
  }

  public async setCurrentUser(user) {
    if (user) {
      this.currentUser = new User({ store: this, ...user });
    } else {
      this.currentUser = null;
    }
  }

  public async addTeam({ name, avatarUrl }: { name: string; avatarUrl: string }): Promise<Team> {
    const data = await addTeamApiMethod({ name, avatarUrl });
    const team = new Team({ store: this, ...data });

    return team;
  }

  public async setCurrentTeam(slug: string, initialTeams: any[]) {
    if (this.currentTeam) {
      if (this.currentTeam.slug === slug) {
        return;
      }
    }

    let found = false;

    const teams = initialTeams || (await getTeamListApiMethod()).teams;

    for (const team of teams) {
      if (team.slug === slug) {
        found = true;
        this.currentTeam = new Team({ ...team, store: this });

        const users =
          team.initialMembers || (await getTeamMembersApiMethod(this.currentTeam._id)).users;

        const invitations =
          team.initialInvitations ||
          (await getTeamInvitationsApiMethod(this.currentTeam._id)).invitations;

        this.currentTeam.setInitialMembersAndInvitations(users, invitations);

        break;
      }
    }

    if (!found) {
      this.currentTeam = null;
    }
  }

  private setInitialTeamsStoreMethod(teams: any[]) {
    // console.log(initialTeams);

    const teamObjs = teams.map((t) => new Team({ store: this, ...t }));

    this.teams.replace(teamObjs);
  }
}

decorate(Store, {
  currentUser: observable,
  currentUrl: observable,
  currentTeam: observable,

  changeCurrentUrl: action,
  setCurrentUser: action,
  setCurrentTeam: action,
});

let store: Store = null;

function initializeStore(initialState = {}) {
  const isServer = typeof window === 'undefined';

  const socket = isServer
    ? null
    : io(process.env.NEXT_PUBLIC_URL_API, {
        reconnection: true,
        autoConnect: true,
        transports: ['polling', 'websocket'],
        withCredentials: true,
      });

  const _store =
    store !== null && store !== undefined ? store : new Store({ initialState, isServer, socket });

  // For SSG and SSR always create a new store
  if (typeof window === 'undefined') {
    return _store;
  }
  // Create the store once in the client
  if (!store) {
    store = _store;
  }

  // console.log(_store);

  return _store;
}

function getStore() {
  return store;
}

export { Store, initializeStore, getStore };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\lib\store\invitation.ts -----

class Invitation {
  public _id: string;
  public teamId: string;
  public email: string;
  public createdAt: Date;

  constructor(params) {
    Object.assign(this, params);
  }
}

export { Invitation };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\lib\store\post.ts -----

import { action, computed, decorate, observable, runInAction } from 'mobx';

import { editPostApiMethod } from '../api/team-member';

import { Store } from './index';
import { User } from './user';
import { Discussion } from './discussion';

export class Post {
  public _id: string;
  public createdUserId: string;
  public createdAt: Date;
  public discussionId: string;

  public discussion: Discussion;
  public store: Store;

  public content: string;
  public htmlContent: string;

  public isEdited: boolean;
  public lastUpdatedAt: Date;

  constructor(params) {
    this._id = params._id;
    this.createdUserId = params.createdUserId;
    this.createdAt = params.createdAt;
    this.discussionId = params.discussionId;

    this.content = params.content;
    this.htmlContent = params.htmlContent;

    this.discussion = params.discussion;
    this.store = params.store;

    this.isEdited = params.isEdited;
    this.lastUpdatedAt = params.lastUpdatedAt;
  }

  public async editPost(data) {
    try {
      await editPostApiMethod({
        id: this._id,
        content: data.content,
        socketId: (this.store.socket && this.store.socket.id) || null,
      });

      runInAction(() => {
        this.changeLocalCache(data);
      });
    } catch (error) {
      console.error(error);
      throw error;
    }
  }

  public changeLocalCache(data) {
    this.content = data.content;
    this.htmlContent = data.htmlContent;
    this.isEdited = true;
    this.lastUpdatedAt = data.lastUpdatedAt;
  }

  get user(): User {
    return this.discussion.team.members.get(this.createdUserId) || null;
  }
}

decorate(Post, {
  content: observable,
  htmlContent: observable,
  isEdited: observable,
  lastUpdatedAt: observable,

  editPost: action,
  changeLocalCache: action,

  user: computed,
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\lib\store\team.ts -----

import { action, computed, decorate, IObservableArray, observable, runInAction } from 'mobx';
import Router from 'next/router';
import {
  cancelSubscriptionApiMethod,
  inviteMemberApiMethod,
  removeMemberApiMethod,
  updateTeamApiMethod,
} from '../api/team-leader';
import {
  addDiscussionApiMethod,
  deleteDiscussionApiMethod,
  getDiscussionListApiMethod,
} from '../api/team-member';
import { Store } from './index';
import { User } from './user';
import { Invitation } from './invitation';
import { Discussion } from './discussion';

class Team {
  public store: Store;

  public _id: string;
  public teamLeaderId: string;

  public name: string;
  public slug: string;
  public avatarUrl: string;
  public memberIds: IObservableArray<string> = observable([]);
  public members: Map<string, User> = new Map();
  public invitations: Map<string, Invitation> = new Map();

  public currentDiscussion?: Discussion;
  public currentDiscussionSlug?: string;
  public discussions: IObservableArray<Discussion> = observable([]);
  public isLoadingDiscussions = false;

  public stripeSubscription: {
    id: string;
    object: string;
    application_fee_percent: number;
    billing: string;
    cancel_at_period_end: boolean;
    billing_cycle_anchor: number;
    canceled_at: number;
    created: number;
  };
  public isSubscriptionActive: boolean;
  public isPaymentFailed: boolean;

  constructor(params) {
    this._id = params._id;
    this.teamLeaderId = params.teamLeaderId;
    this.slug = params.slug;
    this.name = params.name;
    this.avatarUrl = params.avatarUrl;
    this.memberIds.replace(params.memberIds || []);
    this.currentDiscussionSlug = params.currentDiscussionSlug || null;

    this.stripeSubscription = params.stripeSubscription;
    this.isSubscriptionActive = params.isSubscriptionActive;
    this.isPaymentFailed = params.isPaymentFailed;

    this.store = params.store;

    if (params.initialDiscussions) {
      this.setInitialDiscussions(params.initialDiscussions);
    } else {
      this.loadDiscussions();
    }
  }

  public setInitialMembersAndInvitations(users, invitations) {
    this.members.clear();
    this.invitations.clear();

    for (const user of users) {
      if (this.store.currentUser && this.store.currentUser._id === user._id) {
        this.members.set(user._id, this.store.currentUser);
      } else {
        this.members.set(user._id, new User(user));
      }
    }

    for (const invitation of invitations || []) {
      this.invitations.set(invitation._id, new Invitation(invitation));
    }

    // console.log(this.members);
  }

  public async updateTheme({ name, avatarUrl }: { name: string; avatarUrl: string }) {
    try {
      const { slug } = await updateTeamApiMethod({
        teamId: this._id,
        name,
        avatarUrl,
      });

      runInAction(() => {
        this.name = name;
        this.avatarUrl = avatarUrl;
        this.slug = slug;
      });
    } catch (error) {
      console.error(error);
      throw error;
    }
  }

  public async inviteMember(email: string) {
    try {
      const { newInvitation } = await inviteMemberApiMethod({ teamId: this._id, email });

      runInAction(() => {
        this.invitations.set(newInvitation._id, new Invitation(newInvitation));
      });
    } catch (error) {
      console.error(error);
      throw error;
    }
  }

  public async removeMember(userId: string) {
    try {
      await removeMemberApiMethod({ teamId: this._id, userId });

      runInAction(() => {
        this.members.delete(userId);
        this.memberIds.remove(userId);
      });
    } catch (error) {
      console.error(error);
      throw error;
    }
  }

  public setCurrentDiscussion({ slug }: { slug: string }) {
    this.currentDiscussionSlug = slug;
    for (const discussion of this.discussions) {
      if (discussion && discussion.slug === slug) {
        this.currentDiscussion = discussion;
        break;
      }
    }
  }

  public setInitialDiscussions(discussions) {
    const discussionObjs = discussions.map(
      (d) => new Discussion({ team: this, store: this.store, ...d }),
    );

    this.discussions.replace(discussionObjs);

    if (!this.currentDiscussionSlug && this.discussions.length > 0) {
      this.currentDiscussionSlug = this.orderedDiscussions[0].slug;
    }

    if (this.currentDiscussionSlug) {
      this.setCurrentDiscussion({ slug: this.currentDiscussionSlug });
    }
  }

  public async loadDiscussions() {
    if (this.store.isServer || this.isLoadingDiscussions) {
      return;
    }

    this.isLoadingDiscussions = true;

    try {
      const { discussions = [] } = await getDiscussionListApiMethod({
        teamId: this._id,
      });
      const newList: Discussion[] = [];

      runInAction(() => {
        discussions.forEach((d) => {
          const disObj = this.discussions.find((obj) => obj._id === d._id);
          if (disObj) {
            disObj.changeLocalCache(d);
            newList.push(disObj);
          } else {
            newList.push(new Discussion({ team: this, store: this.store, ...d }));
          }
        });

        this.discussions.replace(newList);
      });
    } finally {
      runInAction(() => {
        this.isLoadingDiscussions = false;
      });
    }
  }

  public changeLocalCache(data) {
    this.name = data.name;
    this.memberIds.replace(data.memberIds || []);
  }

  public async addDiscussion(data): Promise<Discussion> {
    const { discussion } = await addDiscussionApiMethod({
      teamId: this._id,
      socketId: (this.store.socket && this.store.socket.id) || null,
      ...data,
    });

    return new Promise<Discussion>((resolve) => {
      runInAction(() => {
        const obj = this.addDiscussionToLocalCache(discussion);
        resolve(obj);
      });
    });
  }

  public addDiscussionToLocalCache(data): Discussion {
    const obj = new Discussion({ team: this, store: this.store, ...data });

    if (obj.memberIds.includes(this.store.currentUser._id)) {
      this.discussions.push(obj);
    }

    return obj;
  }

  public async deleteDiscussion(id: string) {
    await deleteDiscussionApiMethod({
      id,
      socketId: (this.store.socket && this.store.socket.id) || null,
    });

    runInAction(() => {
      this.deleteDiscussionFromLocalCache(id);

      const discussion = this.discussions.find((d) => d._id === id);

      if (this.currentDiscussion === discussion) {
        this.currentDiscussion = null;
        this.currentDiscussionSlug = null;

        if (this.discussions.length > 0) {
          const d = this.discussions[0];

          Router.push(
            `/discussion?teamSlug=${this.slug}&discussionSlug=${d.slug}`,
            `/team/${this.slug}/discussions/${d.slug}`,
          );
        } else {
          Router.push(`/discussion?teamSlug=${this.slug}`, `/team/${this.slug}/discussions`);
        }
      }
    });
  }

  public deleteDiscussionFromLocalCache(discussionId: string) {
    const discussion = this.discussions.find((item) => item._id === discussionId);
    this.discussions.remove(discussion);
  }

  public getDiscussionBySlug(slug: string): Discussion {
    return this.discussions.find((d) => d.slug === slug);
  }

  public async cancelSubscription({ teamId }: { teamId: string }) {
    try {
      const { isSubscriptionActive } = await cancelSubscriptionApiMethod({ teamId });

      runInAction(() => {
        this.isSubscriptionActive = isSubscriptionActive;
      });
    } catch (error) {
      console.error(error);
      throw error;
    }
  }

  public async checkIfTeamLeaderMustBeCustomer() {
    let ifTeamLeaderMustBeCustomerOnClient: boolean;

    if (this && this.memberIds.length < 2) {
      ifTeamLeaderMustBeCustomerOnClient = false;
    } else if (this && this.memberIds.length >= 2 && this.isSubscriptionActive) {
      ifTeamLeaderMustBeCustomerOnClient = false;
    } else if (this && this.memberIds.length >= 2 && !this.isSubscriptionActive) {
      ifTeamLeaderMustBeCustomerOnClient = true;
    }

    return ifTeamLeaderMustBeCustomerOnClient;
  }

  get orderedDiscussions() {
    return this.discussions.slice().sort();
  }
}

decorate(Team, {
  name: observable,
  slug: observable,
  avatarUrl: observable,
  memberIds: observable,
  members: observable,
  invitations: observable,
  currentDiscussion: observable,
  currentDiscussionSlug: observable,
  isLoadingDiscussions: observable,
  discussions: observable,

  setInitialMembersAndInvitations: action,
  updateTheme: action,
  inviteMember: action,
  removeMember: action,
  setInitialDiscussions: action,
  loadDiscussions: action,
  addDiscussion: action,
  addDiscussionToLocalCache: action,
  deleteDiscussion: action,
  deleteDiscussionFromLocalCache: action,
  getDiscussionBySlug: action,

  orderedDiscussions: computed,
});

export { Team };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\lib\store\user.ts -----

import { action, decorate, observable, runInAction } from 'mobx';

import * as NProgress from 'nprogress';

import { getListOfInvoicesApiMethod } from '../api/team-leader';
import { toggleThemeApiMethod, updateProfileApiMethod } from '../api/team-member';
import { Store } from './index';

class User {
  public store: Store;

  public _id: string;
  public slug: string;
  public email: string | null;
  public displayName: string | null;
  public avatarUrl: string | null;
  public isSignedupViaGoogle: boolean;

  public darkTheme = false;
  public defaultTeamSlug: string;

  public stripeCard: {
    brand: string;
    funding: string;
    last4: string;
    exp_month: number;
    exp_year: number;
  };
  public hasCardInformation: boolean;
  public stripeListOfInvoices: {
    object: string;
    data: [
      {
        amount_paid: number;
        teamName: string;
        created: number;
        hosted_invoice_url: string;
      },
    ];
    has_more: boolean;
  };

  constructor(params) {
    this.store = params.store;
    this._id = params._id;
    this.slug = params.slug;
    this.email = params.email;
    this.displayName = params.displayName;
    this.avatarUrl = params.avatarUrl;
    this.isSignedupViaGoogle = !!params.isSignedupViaGoogle;
    this.darkTheme = !!params.darkTheme;
    this.defaultTeamSlug = params.defaultTeamSlug;

    this.stripeCard = params.stripeCard;
    this.hasCardInformation = params.hasCardInformation;
    this.stripeListOfInvoices = params.stripeListOfInvoices;
  }

  public async updateProfile({ name, avatarUrl }: { name: string; avatarUrl: string }) {
    const { updatedUser } = await updateProfileApiMethod({
      name,
      avatarUrl,
    });

    runInAction(() => {
      this.displayName = updatedUser.displayName;
      this.avatarUrl = updatedUser.avatarUrl;
      this.slug = updatedUser.slug;
    });
  }

  public async toggleTheme(darkTheme: boolean) {
    await toggleThemeApiMethod({ darkTheme });
    runInAction(() => {
      this.darkTheme = darkTheme;
    });
    NProgress.start();
    NProgress.set(0.5);
    window.location.reload();
  }

  public async getListOfInvoices() {
    try {
      const { stripeListOfInvoices } = await getListOfInvoicesApiMethod();
      runInAction(() => {
        this.stripeListOfInvoices = stripeListOfInvoices;
      });
    } catch (error) {
      console.error(error);
      throw error;
    }
  }
}

decorate(User, {
  slug: observable,
  email: observable,
  displayName: observable,
  avatarUrl: observable,
  // darkTheme: observable,
  defaultTeamSlug: observable,
  stripeCard: observable,
  stripeListOfInvoices: observable,

  updateProfile: action,
  toggleTheme: action,
  getListOfInvoices: action,
});

export { User };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\lib\confirm.ts -----

import { openConfirmDialogExternal } from '../components/common/Confirmer';

export default function confirm({
  title,
  message,
  onAnswer,
}: {
  title: string;
  message: string;
  onAnswer: (answer) => void;
}) {
  openConfirmDialogExternal({ title, message, onAnswer });
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\lib\isMobile.ts -----

const mobileRE = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i;

export function isMobile(opts) {
  if (!opts) {
    opts = {};
  }

  let ua = opts.ua;

  if (!ua && typeof navigator !== 'undefined') {
    ua = navigator.userAgent;
  }

  if (!ua && opts.req && opts.req.headers && typeof opts.req.headers['user-agent'] === 'string') {
    ua = opts.req.headers['user-agent'];
    // console.log(ua);
  }

  if (typeof ua !== 'string') {
    return false;
  }

  return mobileRE.test(ua);
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\lib\notify.ts -----

import { openSnackbarExternal } from '../components/common/Notifier';

export default function notify(obj) {
  openSnackbarExternal({ message: obj.message || obj.toString() });
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\lib\resizeImage.ts -----

function resizeImage(file: File, MAX_WIDTH, MAX_HEIGHT) {
  const image = document.createElement('img');

  const resize = (resolve) => () => {
    let isResizeNeeded = false;
    let width = image.width;
    let height = image.height;

    if (width > height) {
      if (width > MAX_WIDTH) {
        isResizeNeeded = true;
        height *= MAX_WIDTH / width;
        width = MAX_WIDTH;
      }
    } else {
      if (height > MAX_HEIGHT) {
        isResizeNeeded = true;
        width *= MAX_HEIGHT / height;
        height = MAX_HEIGHT;
      }
    }

    if (isResizeNeeded) {
      const canvas = document.createElement('canvas');

      canvas.width = width;
      canvas.height = height;

      console.log(width, height);

      const ctx = canvas.getContext('2d');
      ctx.drawImage(image, 0, 0, width, height);

      canvas.toBlob((blob) => {
        resolve(blob);
      }, file.type);
    } else {
      resolve(file);
    }
  };

  return new Promise((resolve) => {
    const reader = new FileReader();

    console.log(`before ${image.src}`);

    reader.readAsDataURL(file);

    reader.onload = (e) => {
      image.src = e.target.result.toString();

      image.onload = resize(resolve);

      console.log(`after ${image.src}`);
    };
  });
}

export { resizeImage };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\lib\sharedStyles.ts -----

const styleBigAvatar = {
  width: '80px',
  height: '80px',
  margin: '0px auto 15px',
};

const styleRaisedButton = {
  margin: '15px',
  font: '14px Roboto',
};

const styleToolbar = {
  background: '#FFF',
  height: '64px',
  paddingRight: '20px',
};

const styleTextField = {
  font: '15px Roboto',
  color: '#222',
  fontWeight: '300',
};

const styleForm = {
  margin: '7% auto',
  width: '360px',
};

export { styleBigAvatar, styleRaisedButton, styleToolbar, styleTextField, styleForm };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\lib\theme.ts -----

import { createMuiTheme } from "@mui/material/styles";

const themeDark = createMuiTheme({
  palette: {
    primary: { main: "#238636" },
    secondary: { main: "#b62324" },
    type: "dark",
    background: { default: "#0d1117" },
    text: {
      primary: "#c9d1d9",
    },
  },
  typography: {
    button: {
      textTransform: "none",
    },
  },
});

const themeLight = createMuiTheme({
  palette: {
    primary: { main: "#238636" },
    secondary: { main: "#b62324" },
    type: "light",
    background: { default: "#fff" },
    text: {
      primary: "#222",
    },
  },
  typography: {
    button: {
      textTransform: "none",
    },
  },
});

export { themeDark, themeLight };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\lib\withAuth.tsx -----

import { observer } from 'mobx-react';
import Router from 'next/router';
import React from 'react';

import * as NProgress from 'nprogress';

import { Store, getStore } from './store';

Router.events.on('routeChangeStart', () => {
  NProgress.start();
});

Router.events.on('routeChangeComplete', (url) => {
  const store = getStore();
  if (store) {
    store.changeCurrentUrl(url);
  }

  NProgress.done();
});

Router.events.on('routeChangeError', () => NProgress.done());

export default function withAuth(Component, { loginRequired = true, logoutRequired = false } = {}) {
  class WithAuth extends React.Component<{ store: Store }> {
    public static async getInitialProps(ctx) {
      console.log('WithAuth.getInitialProps');

      const { req } = ctx;

      let pageComponentProps = {};

      if (Component.getInitialProps) {
        pageComponentProps = await Component.getInitialProps(ctx);
      }

      return {
        ...pageComponentProps,
        isServer: !!req,
      };
    }

    public componentDidMount() {
      console.log('WithAuth.componentDidMount');

      const { store } = this.props;
      const user = store.currentUser;

      if (loginRequired && !logoutRequired && !user) {
        Router.push('/login');
        return;
      }

      let redirectUrl = '/login';
      let asUrl = '/login';
      if (user) {
        if (!user.defaultTeamSlug) {
          redirectUrl = '/create-team';
          asUrl = '/create-team';
        } else {
          redirectUrl = `/your-settings`;
          asUrl = `/your-settings`;
        }
      }

      if (logoutRequired && user) {
        Router.push(redirectUrl, asUrl);
      }
    }

    public render() {
      const { store } = this.props;
      const user = store.currentUser;

      if (loginRequired && !logoutRequired && !user) {
        return null;
      }

      if (logoutRequired && user) {
        return null;
      }

      return <Component {...this.props} />;
    }
  }

  return observer(WithAuth);
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\pages\billing.tsx -----

import { observer } from "mobx-react";
import moment from "moment";
import Head from "next/head";
import * as React from "react";
import { loadStripe } from "@stripe/stripe-js";
import Button from "@mui/material/Button";
import NProgress from "nprogress";

import Layout from "../components/layout";
import notify from "../lib/notify";
import { Store } from "../lib/store";
import withAuth from "../lib/withAuth";
import { fetchCheckoutSessionApiMethod } from "../lib/api/team-leader";

const dev = process.env && process.env.NODE_ENV && process.env.NODE_ENV !== "production";

const stripePromise = loadStripe(
  dev ? process.env.NEXT_PUBLIC_STRIPE_TEST_PUBLISHABLEKEY : process.env.NEXT_PUBLIC_STRIPE_LIVE_PUBLISHABLEKEY
);

type Props = {
  store: Store;
  isMobile: boolean;
  teamSlug: string;
  redirectMessage?: string;
};

type State = { disabled: boolean; showInvoices: boolean };

class Billing extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = { disabled: false, showInvoices: false };
  }

  public render() {
    const { store, isMobile } = this.props;
    const { currentTeam, currentUser } = store;
    const isTeamLeader = currentTeam && currentUser && currentUser._id === currentTeam.teamLeaderId;

    if (!currentTeam || currentTeam.slug !== this.props.teamSlug) {
      return (
        <Layout {...this.props}>
          <div style={{ padding: isMobile ? "0px" : "0px 30px" }}>
            <p>You did not select any team.</p>
            <p>To access this page, please select existing team or create new team if you have no teams.</p>
          </div>
        </Layout>
      );
    }

    if (!isTeamLeader) {
      return (
        <Layout {...this.props}>
          <div style={{ padding: isMobile ? "0px" : "0px 30px" }}>
            <p>Only the Team Leader can access this page.</p>
            <p>Create your own team to become a Team Leader.</p>
          </div>
        </Layout>
      );
    }

    return (
      <Layout {...this.props}>
        <Head>
          <title>Your Billing</title>
        </Head>
        <div style={{ padding: isMobile ? "0px" : "0px 30px" }}>
          <h3>Your Billing</h3>
          <p />
          <h4 style={{ marginTop: "40px" }}>Paid plan</h4>
          {this.renderSubscriptionButton()}
          <p />
          <br />
          <h4>Card information</h4>
          {this.renderCardInfo()}
          <p />
          <br />
          <h4>Payment history</h4>
          <Button
            variant="outlined"
            color="primary"
            onClick={this.showListOfInvoicesOnClick}
            disabled={this.state.disabled}
          >
            Show payment history
          </Button>
          <p />
          {this.renderInvoices()}
          <p />
          <br />
        </div>
      </Layout>
    );
  }

  public async componentDidMount() {
    if (this.props.redirectMessage) {
      notify(this.props.redirectMessage);
    }
  }

  private renderSubscriptionButton() {
    const { currentTeam } = this.props.store;

    let subscriptionDate;
    let billingDay;
    if (currentTeam && currentTeam.stripeSubscription) {
      subscriptionDate = moment(currentTeam.stripeSubscription.billing_cycle_anchor * 1000).format("MMM Do YYYY");
      billingDay = moment(currentTeam.stripeSubscription.billing_cycle_anchor * 1000).format("Do");
    }

    if (currentTeam && !currentTeam.isSubscriptionActive && currentTeam.isPaymentFailed) {
      return (
        <>
          <p>You are not a paying customer.</p>
          <Button
            variant="contained"
            color="primary"
            onClick={() => this.handleCheckoutClick("subscription")}
            disabled={this.state.disabled}
          >
            Buy subscription
          </Button>
          <p />
          <p>
            Team was automatically unsubscribed due to failed payment. You will be prompt to update card information if
            you choose to re-subscribe Team.
          </p>
        </>
      );
    } else if (currentTeam && !currentTeam.isSubscriptionActive && !currentTeam.isPaymentFailed) {
      return (
        <React.Fragment>
          <p>You are not a paying customer.</p>
          <p>Buy subscription using your current card, see below section for current card information.</p>
          <Button
            variant="contained"
            color="primary"
            onClick={() => this.handleCheckoutClick("subscription")}
            disabled={this.state.disabled}
          >
            Buy subscription
          </Button>
        </React.Fragment>
      );
    } else {
      return (
        <React.Fragment>
          <span>
            {" "}
            <i className="material-icons" color="action" style={{ verticalAlign: "text-bottom" }}>
              done
            </i>{" "}
            Subscription is active.
            <p>
              You subscribed <b>{currentTeam.name}</b> on <b>{subscriptionDate}</b>.
            </p>
            <p>
              You will be billed $50 on <b>{billingDay} day</b> of each month unless you cancel subscription or
              subscription is cancelled automatically due to failed payment.
            </p>
          </span>
          <p />
          <Button
            variant="outlined"
            color="primary"
            onClick={this.cancelSubscriptionOnClick}
            disabled={this.state.disabled}
          >
            Unsubscribe Team
          </Button>
          <br />
        </React.Fragment>
      );
    }
  }

  private handleCheckoutClick = async (mode: "subscription" | "setup") => {
    try {
      const { currentTeam } = this.props.store;

      NProgress.start();
      this.setState({ disabled: true });

      const { sessionId } = await fetchCheckoutSessionApiMethod({ mode, teamId: currentTeam._id });

      // When the customer clicks on the button, redirect them to Checkout.
      const stripe = await stripePromise;
      const { error } = await stripe.redirectToCheckout({ sessionId });

      if (error) {
        notify(error);
        console.error(error);
      }
    } catch (err) {
      notify(err);
      console.error(err);
    } finally {
      this.setState({ disabled: false });
      NProgress.done();
    }
  };

  private cancelSubscriptionOnClick = async () => {
    const { currentTeam } = this.props.store;

    NProgress.start();
    this.setState({ disabled: true });

    try {
      await currentTeam.cancelSubscription({ teamId: currentTeam._id });
      notify("Success!");
    } catch (err) {
      notify(err);
    } finally {
      this.setState({ disabled: false });
      NProgress.done();
    }
  };

  private renderCardInfo() {
    const { currentUser } = this.props.store;

    if (currentUser && currentUser.hasCardInformation) {
      return (
        <span>
          {" "}
          <i className="material-icons" color="action" style={{ verticalAlign: "text-bottom" }}>
            done
          </i>{" "}
          Your default payment method:
          <li>
            {currentUser.stripeCard.brand}, {currentUser.stripeCard.funding} card
          </li>
          <li>Last 4 digits: *{currentUser.stripeCard.last4}</li>
          <li>
            Expiration: {currentUser.stripeCard.exp_month}/{currentUser.stripeCard.exp_year}
          </li>
          <p />
          <Button
            variant="outlined"
            color="primary"
            onClick={() => this.handleCheckoutClick("setup")}
            disabled={this.state.disabled}
          >
            Update card
          </Button>
        </span>
      );
    } else {
      return "You have not added a card.";
    }
  }

  private renderInvoices() {
    const { currentUser } = this.props.store;
    const { showInvoices } = this.state;

    if (!showInvoices) {
      return null;
    }

    if (currentUser && currentUser.stripeCard) {
      return (
        <React.Fragment>
          {currentUser.stripeListOfInvoices.data.map((invoice, i) => (
            <React.Fragment key={i}>
              <p>Your history of payments:</p>
              <li>
                ${invoice.amount_paid / 100} was paid on {moment(invoice.created * 1000).format("MMM Do YYYY")} for Team
                '{invoice.teamName}' -{" "}
                <a href={invoice.hosted_invoice_url} target="_blank" rel="noopener noreferrer">
                  See invoice
                </a>
              </li>
            </React.Fragment>
          ))}
        </React.Fragment>
      );
    } else {
      return "You have no history of payments.";
    }
  }

  private showListOfInvoicesOnClick = async () => {
    const { currentUser } = this.props.store;
    NProgress.start();
    this.setState({ disabled: true });
    try {
      await currentUser.getListOfInvoices();
      this.setState({ showInvoices: true });
    } catch (err) {
      notify(err);
    } finally {
      this.setState({ disabled: false });
      NProgress.done();
    }
  };
}

export default withAuth(observer(Billing));

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\pages\create-team.tsx -----

import { inject, observer } from "mobx-react";
import * as React from "react";

import Avatar from "@mui/material/Avatar";
import Button from "@mui/material/Button";
import Grid from "@mui/material/Grid";
import TextField from "@mui/material/TextField";
import Head from "next/head";
import Router from "next/router";

import { getSignedRequestForUploadApiMethod, uploadFileUsingSignedPutRequestApiMethod } from "../lib/api/team-member";
import notify from "../lib/notify";
import { resizeImage } from "../lib/resizeImage";
import { Store } from "../lib/store";
import withAuth from "../lib/withAuth";

import Layout from "../components/layout";

const styleGrid = {
  height: "100%",
};

type Props = { store: Store; isMobile: boolean; teamRequired: boolean };

type State = { newName: string; newAvatarUrl: string; disabled: boolean };

class CreateTeam extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      newName: "",
      newAvatarUrl: "https://storage.googleapis.com/async-await/default-user.png?v=1",
      disabled: false,
    };
  }

  public render() {
    const { newAvatarUrl } = this.state;

    console.log(this.props.store);

    return (
      <Layout {...this.props}>
        <Head>
          <title>Create Team</title>
          <meta name="description" content="Create a new Team at SaaS Boilerplate" />
        </Head>
        <div style={{ padding: "0px", fontSize: "14px", height: "100%" }}>
          <Grid container style={styleGrid}>
            <Grid item sm={12} xs={12} style={{ padding: this.props.isMobile ? "0px" : "0px 30px" }}>
              <h3>Create team</h3>
              <p />
              <form onSubmit={this.onSubmit}>
                <h4>Team name</h4>
                <TextField
                  value={this.state.newName}
                  label="Type your team's name."
                  helperText="Team name as seen by your team members."
                  onChange={(event) => {
                    this.setState({ newName: event.target.value });
                  }}
                />
                <p />
                <h4 style={{ marginTop: "40px" }}>Team logo (optional)</h4>
                <Avatar
                  src={newAvatarUrl}
                  style={{
                    display: "inline-flex",
                    verticalAlign: "middle",
                    marginRight: 20,
                    width: 60,
                    height: 60,
                  }}
                />
                <label htmlFor="upload-file">
                  <Button variant="outlined" color="primary" component="span">
                    Select team logo
                  </Button>
                </label>
                <input
                  accept="image/*"
                  name="upload-file"
                  id="upload-file"
                  type="file"
                  style={{ display: "none" }}
                  onChange={this.previewTeamLogo}
                />
                <p />
                <br />
                <br />
                <Button variant="contained" color="primary" type="submit" disabled={this.state.disabled}>
                  Create new team
                </Button>
              </form>
            </Grid>
          </Grid>
          <br />
        </div>
      </Layout>
    );
  }

  private onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();

    const { newName } = this.state;

    const { store } = this.props;

    if (!newName) {
      notify("Team name is required.");
      return;
    }

    const file = (document.getElementById("upload-file") as HTMLFormElement).files[0];

    try {
      this.setState({ disabled: true });

      const defaultAvatarUrl = "https://storage.googleapis.com/async-await/default-user.png?v=1";
      const team = await store.addTeam({
        name: newName,
        avatarUrl: defaultAvatarUrl,
      });

      console.log(`Returned to client: ${team._id}, ${team.name}, ${team.slug}`);

      if (file == null) {
        Router.push(`/team/${team.slug}/team-settings`);
        notify("You successfully created Team.<p />Redirecting...");
        return;
      }

      const fileName = file.name;
      const fileType = file.type;
      const bucket = process.env.NEXT_PUBLIC_BUCKET_FOR_TEAM_LOGOS;
      const prefix = team.slug;

      const responseFromApiServerForUpload = await getSignedRequestForUploadApiMethod({
        fileName,
        fileType,
        prefix,
        bucket,
      });

      const resizedFile = await resizeImage(file, 128, 128);

      await uploadFileUsingSignedPutRequestApiMethod(resizedFile, responseFromApiServerForUpload.signedRequest, {
        "Cache-Control": "max-age=2592000",
      });

      const uploadedAvatarUrl = responseFromApiServerForUpload.url;

      await team.updateTheme({ name: team.name, avatarUrl: uploadedAvatarUrl });

      this.setState({
        newName: "",
        newAvatarUrl: "https://storage.googleapis.com/async-await/default-user.png?v=1",
      });

      (document.getElementById("upload-file") as HTMLFormElement).value = "";

      Router.push(`/team/${team.slug}/team-settings`);

      notify("You successfully created Team. Redirecting ...");
    } catch (error) {
      console.log(error);
      notify(error);
    } finally {
      this.setState({ disabled: false });
    }
  };

  private previewTeamLogo = () => {
    const file = (document.getElementById("upload-file") as HTMLFormElement).files[0];
    if (!file) {
      return;
    }

    const reader = new FileReader();

    reader.readAsDataURL(file);

    reader.onload = (e) => {
      this.setState({ newAvatarUrl: e.target.result as string });
    };
  };
}

export default withAuth(inject("store")(observer(CreateTeam)));

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\pages\discussion.tsx -----

import Avatar from "@mui/material/Avatar";
import Tooltip from "@mui/material/Tooltip";
import Head from "next/head";
import Router from "next/router";
import * as React from "react";

import { observer } from "mobx-react";

import Layout from "../components/layout";
import PostDetail from "../components/posts/PostDetail";
import PostForm from "../components/posts/PostForm";
import notify from "../lib/notify";
import { Store } from "../lib/store";
import { Discussion } from "../lib/store/discussion";
import withAuth from "../lib/withAuth";
import { Post } from "lib/store/post";

type Props = {
  store: Store;
  teamSlug: string;
  discussionSlug: string;
  isServer: boolean;
  isMobile: boolean;
  teamRequired: boolean;
};

type State = {
  selectedPost: Post;
  showMarkdownClicked: boolean;
};

class DiscussionPageComp extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      selectedPost: null,
      showMarkdownClicked: false,
    };
  }

  public render() {
    const { store, isMobile, discussionSlug } = this.props;
    const { currentTeam } = store;
    const { selectedPost } = this.state;

    if (!currentTeam || currentTeam.slug !== this.props.teamSlug) {
      return (
        <Layout {...this.props}>
          <Head>
            <title>No Team is found.</title>
          </Head>
          <div style={{ padding: isMobile ? "0px" : "0px 30px" }}>No Team is found.</div>
        </Layout>
      );
    }

    const discussion = this.getDiscussion(discussionSlug);

    if (!discussion) {
      if (currentTeam.isLoadingDiscussions) {
        return (
          <Layout {...this.props}>
            <Head>
              <title>Loading...</title>
            </Head>
            <div style={{ padding: isMobile ? "0px" : "0px 30px" }}>
              <p>Loading Discussions...</p>
            </div>
          </Layout>
        );
      } else {
        return (
          <Layout {...this.props}>
            <Head>
              <title>No Discussion is found.</title>
            </Head>
            <div style={{ padding: isMobile ? "0px" : "0px 30px" }}>
              <p>No Discussion is found.</p>
            </div>
          </Layout>
        );
      }
    }

    const title = discussion ? `${discussion.name}  Discussion` : "Discussions";

    return (
      <Layout {...this.props}>
        <Head>
          <title>{title}</title>
        </Head>
        <div style={{ padding: isMobile ? "0px" : "0px 30px", height: "100vh" }}>
          <h4>
            <span style={{ fontWeight: 300 }}>Discussion : </span>
            {(discussion && discussion.name) || "No Discussion is found."}
          </h4>{" "}
          Visible to :{" "}
          {discussion
            ? discussion.members.map((m) => (
                <Tooltip title={m.displayName} placement="right" disableFocusListener disableTouchListener key={m._id}>
                  <Avatar
                    role="presentation"
                    src={m.avatarUrl}
                    alt={m.avatarUrl}
                    key={m._id}
                    style={{
                      margin: "0px 5px",
                      display: "inline-flex",
                      width: "30px",
                      height: "30px",
                      verticalAlign: "middle",
                    }}
                  />
                </Tooltip>
              ))
            : null}
          <p />
          {this.renderPosts()}
          {discussion && !discussion.isLoadingPosts ? (
            <React.Fragment>
              {selectedPost ? null : (
                <PostForm
                  post={null}
                  discussion={discussion}
                  members={discussion.members}
                  isMobile={this.props.isMobile}
                  store={store}
                />
              )}
            </React.Fragment>
          ) : null}
          <p />
          <br />
        </div>
      </Layout>
    );
  }

  public getDiscussion(slug: string): Discussion {
    const { store, teamSlug } = this.props;
    const { currentTeam } = store;

    if (!currentTeam) {
      return;
    }

    if (!slug && currentTeam.discussions.length > 0) {
      Router.replace(
        `/discussion?teamSlug=${teamSlug}&discussionSlug=${currentTeam.orderedDiscussions[0].slug}`,
        `/team/${teamSlug}/discussions/${currentTeam.orderedDiscussions[0].slug}`
      );
      return;
    }

    if (slug && currentTeam) {
      return currentTeam.getDiscussionBySlug(slug);
    }

    return null;
  }

  public renderPosts() {
    const { isServer, store, isMobile } = this.props;
    const { selectedPost, showMarkdownClicked } = this.state;
    const discussion = this.getDiscussion(this.props.discussionSlug);

    if (!discussion.isLoadingPosts && discussion.posts.length === 0) {
      return <p>Empty Discussion.</p>;
    }

    let loading = "loading Posts ...";
    if (discussion.posts.length > 0) {
      loading = "checking for newer Posts ...";
    }

    return (
      <React.Fragment>
        {discussion
          ? discussion.posts.map((p) =>
              selectedPost && selectedPost._id === p._id ? (
                <PostForm
                  store={store}
                  isMobile={isMobile}
                  key={p._id}
                  post={p}
                  showMarkdownToNonCreator={showMarkdownClicked}
                  discussion={discussion}
                  members={discussion.members}
                  onFinished={() => {
                    this.setState({
                      selectedPost: null,
                      showMarkdownClicked: false,
                    });
                  }}
                />
              ) : (
                <PostDetail
                  key={p._id}
                  post={p}
                  onEditClick={this.onEditClickCallback}
                  onShowMarkdownClick={this.onSnowMarkdownClickCallback}
                  isMobile={this.props.isMobile}
                  store={store}
                />
              )
            )
          : null}

        {discussion && discussion.isLoadingPosts && !isServer ? <p>{loading}</p> : null}
      </React.Fragment>
    );
  }

  public onEditClickCallback = (post) => {
    this.setState({ selectedPost: post, showMarkdownClicked: false });
  };

  public onSnowMarkdownClickCallback = (post) => {
    this.setState({ selectedPost: post, showMarkdownClicked: true });
  };

  public componentDidMount() {
    const { discussionSlug, store, isServer } = this.props;

    if (store.currentTeam && (!isServer || !discussionSlug)) {
      store.currentTeam.loadDiscussions().catch((err) => notify(err));
    }

    const discussion = this.getDiscussion(discussionSlug);

    if (discussion) {
      discussion.joinSocketRooms();
    }

    console.log(store.socket);

    store.socket.on("discussionEvent", this.handleDiscussionEvent);
    store.socket.on("postEvent", this.handlePostEvent);
    store.socket.on("reconnect", this.handleSocketReconnect);
  }

  public componentWillUnmount() {
    const { discussionSlug, store } = this.props;

    const discussion = this.getDiscussion(discussionSlug);

    if (discussion) {
      discussion.leaveSocketRooms();
    }

    store.socket.off("discussionEvent", this.handleDiscussionEvent);
    store.socket.off("postEvent", this.handlePostEvent);
    store.socket.off("reconnect", this.handleSocketReconnect);
  }

  public componentDidUpdate(prevProps: Props) {
    const { discussionSlug, isServer } = this.props;

    if (prevProps.discussionSlug !== discussionSlug) {
      if (prevProps.discussionSlug) {
        const prevDiscussion = this.getDiscussion(prevProps.discussionSlug);
        if (prevDiscussion) {
          prevDiscussion.leaveSocketRooms();
        }
      }

      const discussion = this.getDiscussion(discussionSlug);

      if (!isServer && discussion) {
        discussion.loadPosts().catch((err) => notify(err));
      }

      if (discussion) {
        discussion.joinSocketRooms();
      }
    }
  }

  private handleDiscussionEvent = (data) => {
    console.log("discussion realtime event", data);

    const discussion = this.getDiscussion(this.props.discussionSlug);
    if (discussion) {
      discussion.handleDiscussionRealtimeEvent(data);
    }
  };

  private handlePostEvent = (data) => {
    console.log("post realtime event", data);

    const discussion = this.getDiscussion(this.props.discussionSlug);
    if (discussion) {
      discussion.handlePostRealtimeEvent(data);
    }
  };

  private handleSocketReconnect = () => {
    console.log("pages/discussion.tsx: socket re-connected");

    const discussion = this.getDiscussion(this.props.discussionSlug);
    if (discussion) {
      discussion.loadPosts().catch((err) => notify(err));
      discussion.joinSocketRooms();
    }
  };
}

export default withAuth(observer(DiscussionPageComp));

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\pages\invitation.tsx -----

import Avatar from "@mui/material/Avatar";
import { observer } from "mobx-react";
import Error from "next/error";
import Head from "next/head";
import Router from "next/router";
// import { NextPageContext } from 'next';
import React from "react";

import LoginButton from "../components/common/LoginButton";
import Layout from "../components/layout";
import { getTeamByTokenApiMethod } from "../lib/api/public";
import { Team } from "../lib/store/team";
import { Store } from "../lib/store";
import withAuth from "../lib/withAuth";

class InvitationPageComp extends React.Component<{ store: Store; team: Team; token: string }> {
  public static async getInitialProps(ctx) {
    const { token } = ctx.query;
    if (!token) {
      return {};
    }

    try {
      const { team } = await getTeamByTokenApiMethod(token, ctx.req);

      return { team, token };
    } catch (error) {
      console.log(error);
      return {};
    }
  }

  public render() {
    const { team, token, store } = this.props;

    if (!team) {
      return <Error statusCode={404} />;
    }

    const user = store.currentUser;

    if (user) {
      return null;
    }

    return (
      <Layout {...this.props}>
        <Head>
          <title>Invitation to {team.name}</title>
          <meta name="description" content={`Invitation to join ${team.name}`} />
        </Head>
        <div style={{ textAlign: "center", margin: "0 20px" }}>
          <br />
          <Avatar
            src={`${team.avatarUrl || "https://storage.googleapis.com/async-await/default-user.png?v=1"}`}
            alt="Team logo"
            style={{
              verticalAlign: "middle",
              display: "inline-flex",
            }}
          />{" "}
          <h2>{team.name}</h2>
          <p>
            Join <b>{team.name}</b> by logging in or signing up.
          </p>
          <br />
          <LoginButton invitationToken={token} />
        </div>
      </Layout>
    );
  }

  public async componentDidMount() {
    const { store, team, token } = this.props;

    const user = store.currentUser;

    if (user && team) {
      Router.push(
        `${process.env.NEXT_PUBLIC_URL_API}/logout?invitationToken=${token}`,
        `${process.env.NEXT_PUBLIC_URL_API}/logout`
      );
    }
  }
}

// export async function getServerSideProps(context: NextPageContext) {
//   const { token } = context.query;

//   try {
//     const { team } = await getTeamByTokenApiMethod(token as string, context.req);

//     if (team && token) {
//       return { props: { team, token } };
//     } else {
//       return { props: {} };
//     }
//   } catch (error) {
//     console.log(error);
//     return { props: {} };
//   }
// }

// see our explanation for not using getServerSideProps at this time: https://github.com/async-labs/saas/issues/193

export default withAuth(observer(InvitationPageComp), { loginRequired: false });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\pages\login.tsx -----

import Head from 'next/head';
import React from 'react';
import LoginButton from '../components/common/LoginButton';
import Layout from '../components/layout';
import withAuth from '../lib/withAuth';

class Login extends React.Component {
  public render() {
    return (
      <Layout {...this.props}>
        <div style={{ textAlign: 'center', margin: '0 20px' }}>
          <Head>
            <title>Log in to SaaS boilerplate by Async</title>
            <meta
              name="description"
              content="Login and signup page for SaaS boilerplate demo by Async"
            />
          </Head>
          <br />
          <p style={{ margin: '45px auto', fontSize: '44px', fontWeight: 400 }}>Log in</p>
          <p>Youll be logged in for 14 days unless you log out manually.</p>
          <br />

          <LoginButton />
        </div>
      </Layout>
    );
  }
}

export default withAuth(Login, { logoutRequired: true });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\pages\team-settings.tsx -----

import Avatar from "@mui/material/Avatar";
import Button from "@mui/material/Button";
import Hidden from "@mui/material/Hidden";
import TextField from "@mui/material/TextField";
import { inject, observer } from "mobx-react";
import Head from "next/head";
import NProgress from "nprogress";
import * as React from "react";
import Table from "@mui/material/Table";
import TableBody from "@mui/material/TableBody";
import TableCell from "@mui/material/TableCell";
import TableContainer from "@mui/material/TableContainer";
import TableHead from "@mui/material/TableHead";
import TableRow from "@mui/material/TableRow";

import Layout from "../components/layout";
import InviteMember from "../components/teams/InviteMember";
import { getSignedRequestForUploadApiMethod, uploadFileUsingSignedPutRequestApiMethod } from "../lib/api/team-member";
import confirm from "../lib/confirm";
import notify from "../lib/notify";
import { resizeImage } from "../lib/resizeImage";
import { Store } from "../lib/store";
import withAuth from "../lib/withAuth";

type Props = { isMobile: boolean; store: Store; teamSlug: string };

type State = {
  newName: string;
  newAvatarUrl: string;
  disabled: boolean;
  inviteMemberOpen: boolean;
};

class TeamSettings extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      newName: this.props.store.currentTeam.name,
      newAvatarUrl: this.props.store.currentTeam.avatarUrl,
      disabled: false,
      inviteMemberOpen: false,
    };
  }

  public render() {
    const { store, isMobile } = this.props;
    const { currentTeam, currentUser } = store;
    const { newName, newAvatarUrl } = this.state;
    const isTeamLeader = currentTeam && currentUser && currentUser._id === currentTeam.teamLeaderId;

    // console.log(this.props.firstGridItem);

    if (!currentTeam || currentTeam.slug !== this.props.teamSlug) {
      return (
        <Layout {...this.props}>
          <div style={{ padding: isMobile ? "0px" : "0px 30px" }}>
            <p>You did not select any team.</p>
            <p>To access this page, please select existing team or create new team if you have no teams.</p>
          </div>
        </Layout>
      );
    }

    if (!isTeamLeader) {
      return (
        <Layout {...this.props}>
          <div style={{ padding: isMobile ? "0px" : "0px 30px" }}>
            <p>Only the Team Leader can access this page.</p>
            <p>Create your own team to become a Team Leader.</p>
          </div>
        </Layout>
      );
    }

    return (
      <Layout {...this.props}>
        <Head>
          <title>Team Settings</title>
        </Head>
        <div style={{ padding: isMobile ? "0px" : "0px 30px", fontSize: "15px", height: "100%" }}>
          <h3>Team Settings</h3>
          <p />
          <br />
          <form onSubmit={this.onSubmit}>
            <h4>Team name</h4>
            <TextField
              value={newName}
              helperText="Team name as seen by your team members"
              onChange={(event) => {
                this.setState({ newName: event.target.value });
              }}
            />
            <br />
            <br />
            <Button variant="contained" color="primary" type="submit" disabled={this.state.disabled}>
              Update username
            </Button>
          </form>
          <p />
          <br />
          <h4>Team logo</h4>
          <Avatar
            src={newAvatarUrl}
            style={{
              display: "inline-flex",
              verticalAlign: "middle",
              marginRight: 20,
              width: 60,
              height: 60,
            }}
          />
          <label htmlFor="upload-file-team-logo">
            <Button variant="contained" color="primary" component="span" disabled={this.state.disabled}>
              Update logo
            </Button>
          </label>
          <input
            accept="image/*"
            name="upload-file-team-logo"
            id="upload-file-team-logo"
            type="file"
            style={{ display: "none" }}
            onChange={this.uploadFile}
          />
          <p />
          <br />
          <br />
          <h4 style={{ marginRight: 20, display: "inline" }}>
            Team Members ( {Array.from(currentTeam.members.values()).length} / 20 )
          </h4>
          <Button
            onClick={this.openInviteMember}
            variant="contained"
            color="primary"
            style={{ float: "right", marginTop: "-20px" }}
            disabled={this.state.disabled}
          >
            Invite member
          </Button>
          <p />
          <TableContainer>
            <Table>
              <TableHead>
                <TableRow>
                  <TableCell>Person</TableCell>
                  <TableCell>Role</TableCell>
                  <TableCell>Action</TableCell>
                </TableRow>
              </TableHead>

              <TableBody>
                {currentTeam.memberIds
                  .map((userId) => currentTeam.members.get(userId))
                  .map((m) => (
                    <TableRow key={m._id}>
                      <TableCell style={{ width: "300px" }}>
                        <Hidden smDown>
                          <Avatar
                            role="presentation"
                            src={m.avatarUrl}
                            alt={(m.displayName || m.email)[0]}
                            key={m._id}
                            style={{
                              margin: "0px 5px",
                              display: "inline-flex",
                              width: "30px",
                              height: "30px",
                              verticalAlign: "middle",
                            }}
                          />
                        </Hidden>
                        {m.email}
                      </TableCell>
                      <TableCell>{isTeamLeader && m._id !== currentUser._id ? "Team Member" : "Team Leader"}</TableCell>
                      <TableCell>
                        {isTeamLeader && m._id !== currentUser._id ? (
                          <i
                            color="action"
                            data-id={m._id}
                            onClick={this.removeMember}
                            style={{
                              marginLeft: "20px",
                              fontSize: "16px",
                              opacity: 0.6,
                              cursor: "pointer",
                              verticalAlign: "middle",
                            }}
                            className="material-icons"
                          >
                            delete
                          </i>
                        ) : null}
                      </TableCell>
                    </TableRow>
                  ))}
              </TableBody>
            </Table>
          </TableContainer>

          <p />
          <br />

          {Array.from(currentTeam.invitations.values()).length > 0 ? (
            <React.Fragment>
              <h4>Invited users</h4>
              <p />
              <TableContainer>
                <Table>
                  <TableHead>
                    <TableRow>
                      <TableCell>Email</TableCell>
                      <TableCell>Status</TableCell>
                    </TableRow>
                  </TableHead>

                  <TableBody>
                    {Array.from(currentTeam.invitations.values()).map((i) => (
                      <TableRow key={i._id}>
                        <TableCell style={{ width: "300px" }}>{i.email}</TableCell>
                        <TableCell>Sent</TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              </TableContainer>
            </React.Fragment>
          ) : null}
          <p />
          <br />
          <InviteMember
            open={this.state.inviteMemberOpen}
            onClose={this.handleInviteMemberClose}
            store={this.props.store}
          />
          <br />
        </div>
      </Layout>
    );
  }

  private onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    const { newName, newAvatarUrl } = this.state;
    const { currentTeam } = this.props.store;

    if (!newName) {
      notify("Team name is required");
      return;
    }

    NProgress.start();

    try {
      this.setState({ disabled: true });

      await currentTeam.updateTheme({ name: newName, avatarUrl: newAvatarUrl });

      notify("You successfully updated Team name.");
    } catch (error) {
      notify(error);
    } finally {
      this.setState({ disabled: false });
      NProgress.done();
    }
  };

  private uploadFile = async () => {
    const { store } = this.props;
    const { currentTeam } = store;

    const fileElement = document.getElementById("upload-file-team-logo") as HTMLFormElement;
    const file = fileElement.files[0];

    if (file == null) {
      notify("No file selected for upload.");
      return;
    }

    const fileName = file.name;
    const fileType = file.type;

    NProgress.start();
    this.setState({ disabled: true });

    const bucket = process.env.NEXT_PUBLIC_BUCKET_FOR_TEAM_LOGOS;
    const prefix = `${currentTeam.slug}`;

    console.log(bucket);

    try {
      const responseFromApiServerForUpload = await getSignedRequestForUploadApiMethod({
        fileName,
        fileType,
        prefix,
        bucket,
      });

      const resizedFile = await resizeImage(file, 128, 128);

      await uploadFileUsingSignedPutRequestApiMethod(resizedFile, responseFromApiServerForUpload.signedRequest, {
        "Cache-Control": "max-age=2592000",
      });

      this.setState({
        newAvatarUrl: responseFromApiServerForUpload.url,
      });

      await currentTeam.updateTheme({
        name: this.state.newName,
        avatarUrl: this.state.newAvatarUrl,
      });

      notify("You successfully uploaded new Team logo.");
    } catch (error) {
      notify(error);
    } finally {
      this.setState({ disabled: false });
      NProgress.done();
    }
  };

  private openInviteMember = async () => {
    const { currentTeam } = this.props.store;
    if (!currentTeam) {
      notify("You have not selected a Team.");
      return;
    }

    const ifTeamLeaderMustBeCustomer = await currentTeam.checkIfTeamLeaderMustBeCustomer();

    if (ifTeamLeaderMustBeCustomer) {
      notify(
        "To add a third team member, you have to become a paid customer." +
          "<p />" +
          " To become a paid customer," +
          " navigate to Billing page."
      );
      return;
    }

    this.setState({ inviteMemberOpen: true });
  };

  private handleInviteMemberClose = () => {
    this.setState({ inviteMemberOpen: false });
  };

  private removeMember = (event) => {
    const { currentTeam } = this.props.store;
    if (!currentTeam) {
      notify("You have not selected a Team.");
      return;
    }

    const userId = event.currentTarget.dataset.id;
    if (!userId) {
      notify("Select user.");
      return;
    }

    confirm({
      title: "Are you sure?",
      message: "",
      onAnswer: async (answer) => {
        if (answer) {
          try {
            await currentTeam.removeMember(userId);
          } catch (error) {
            notify(error);
          }
        }
      },
    });
  };
}

export default withAuth(inject("store")(observer(TeamSettings)));

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\pages\your-settings.tsx -----

import Avatar from "@mui/material/Avatar";
import Button from "@mui/material/Button";
import TextField from "@mui/material/TextField";
import { inject, observer } from "mobx-react";
import Head from "next/head";
import NProgress from "nprogress";
import * as React from "react";

import Layout from "../components/layout";

import { getSignedRequestForUploadApiMethod, uploadFileUsingSignedPutRequestApiMethod } from "../lib/api/team-member";

import notify from "../lib/notify";
import { resizeImage } from "../lib/resizeImage";
import { Store } from "../lib/store";
import withAuth from "../lib/withAuth";

type Props = { isMobile: boolean; store: Store };

type State = { newName: string; newAvatarUrl: string; disabled: boolean };

class YourSettings extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      newName: this.props.store.currentUser.displayName,
      newAvatarUrl: this.props.store.currentUser.avatarUrl,
      disabled: false,
    };
  }

  public render() {
    const { currentUser } = this.props.store;
    const { newName, newAvatarUrl } = this.state;

    return (
      <Layout {...this.props}>
        <Head>
          <title>Your Settings at Async</title>
        </Head>
        <div
          style={{
            padding: this.props.isMobile ? "0px" : "0px 30px",
            fontSize: "15px",
            height: "100%",
          }}
        >
          <h3>Your Settings</h3>
          <h4 style={{ marginTop: "40px" }}>Your account</h4>
          <div>
            <i className="material-icons" color="action" style={{ verticalAlign: "text-bottom" }}>
              done
            </i>{" "}
            {currentUser.isSignedupViaGoogle
              ? "You signed up on Async using your Google account."
              : "You signed up on Async using your email."}
            <p />
            <li>
              Your email: <b>{currentUser.email}</b>
            </li>
            <li>
              Your username: <b>{currentUser.displayName}</b>
            </li>
          </div>
          <form onSubmit={this.onSubmit} autoComplete="off">
            <h4>Your username</h4>
            <TextField
              autoComplete="off"
              value={newName}
              helperText="Your username as seen by your team members"
              onChange={(event) => {
                this.setState({ newName: event.target.value });
              }}
            />
            <br />
            <br />
            <Button variant="contained" color="primary" type="submit" disabled={this.state.disabled}>
              Update username
            </Button>
          </form>

          <br />
          <h4>Your photo</h4>
          <Avatar
            src={newAvatarUrl}
            style={{
              display: "inline-flex",
              verticalAlign: "middle",
              marginRight: 20,
              width: 60,
              height: 60,
            }}
          />
          <label htmlFor="upload-file-user-avatar">
            <Button variant="outlined" color="primary" component="span" disabled={this.state.disabled}>
              Update avatar
            </Button>
          </label>
          <input
            accept="image/*"
            name="upload-file-user-avatar"
            id="upload-file-user-avatar"
            type="file"
            style={{ display: "none" }}
            onChange={this.uploadFile}
          />
          <p />
          <br />
        </div>
      </Layout>
    );
  }

  private onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();

    const { currentUser } = this.props.store;

    const { newName, newAvatarUrl } = this.state;

    console.log(newName);

    if (!newName) {
      notify("Name is required");
      return;
    }

    NProgress.start();
    this.setState({ disabled: true });

    try {
      await currentUser.updateProfile({ name: newName, avatarUrl: newAvatarUrl });

      notify("You successfully updated your profile.");
    } catch (error) {
      notify(error);
    } finally {
      this.setState({ disabled: false });
      NProgress.done();
    }
  };

  private uploadFile = async () => {
    const fileElement = document.getElementById("upload-file-user-avatar") as HTMLFormElement;
    const file = fileElement.files[0];

    const { currentUser } = this.props.store;

    if (file == null) {
      notify("No file selected for upload.");
      return;
    }

    const fileName = file.name;
    const fileType = file.type;

    NProgress.start();
    this.setState({ disabled: true });

    const bucket = process.env.NEXT_PUBLIC_BUCKET_FOR_AVATARS;

    const prefix = `${currentUser.slug}`;

    try {
      const responseFromApiServerForUpload = await getSignedRequestForUploadApiMethod({
        fileName,
        fileType,
        prefix,
        bucket,
      });

      const resizedFile = await resizeImage(file, 128, 128);

      console.log(file);
      console.log(resizedFile);

      await uploadFileUsingSignedPutRequestApiMethod(resizedFile, responseFromApiServerForUpload.signedRequest, {
        "Cache-Control": "max-age=2592000",
      });

      this.setState({
        newAvatarUrl: responseFromApiServerForUpload.url,
      });

      await currentUser.updateProfile({
        name: this.state.newName,
        avatarUrl: this.state.newAvatarUrl,
      });

      notify("You successfully uploaded new avatar.");
    } catch (error) {
      notify(error);
    } finally {
      fileElement.value = "";
      this.setState({ disabled: false });
      NProgress.done();
    }
  };
}

export default withAuth(inject("store")(observer(YourSettings)));

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\pages\_app.tsx -----

import CssBaseline from "@mui/material/CssBaseline";
import { ThemeProvider } from "@mui/material";
import { Provider } from "mobx-react";
import App from "next/app";
import Head from "next/head";
import React from "react";

import { themeDark, themeLight } from "../lib/theme";
import { getUserApiMethod } from "../lib/api/public";
import { getInitialDataApiMethod } from "../lib/api/team-member";
import { isMobile } from "../lib/isMobile";
import { getStore, initializeStore, Store } from "../lib/store";

class MyApp extends App {
  public static async getInitialProps({ Component, ctx }) {
    let firstGridItem = true;
    let teamRequired = false;

    if (
      ctx.pathname.includes("/login") ||
      ctx.pathname.includes("/create-team") ||
      ctx.pathname.includes("/invitation")
    ) {
      firstGridItem = false;
    }

    if (
      ctx.pathname.includes("/team-settings") ||
      ctx.pathname.includes("/discussion") ||
      ctx.pathname.includes("/billing")
    ) {
      teamRequired = true;
    }

    const { teamSlug, discussionSlug, redirectMessage } = ctx.query;

    const pageProps = {
      isMobile: isMobile({ req: ctx.req }),
      firstGridItem,
      teamRequired,
      teamSlug,
      discussionSlug,
      redirectMessage,
    };

    if (Component.getInitialProps) {
      Object.assign(pageProps, await Component.getInitialProps(ctx));
    }

    const appProps = { pageProps };

    const store = getStore();
    if (store) {
      return appProps;
    }

    let userObj = null;
    try {
      const { user } = await getUserApiMethod(ctx.req);
      userObj = user;
    } catch (error) {
      console.log(error);
    }

    let initialData = {};

    if (userObj) {
      try {
        initialData = await getInitialDataApiMethod({
          request: ctx.req,
          data: { teamSlug, discussionSlug },
        });
      } catch (error) {
        console.error(error);
      }
    }

    // console.log(initialData);

    // console.log(teamSlug);

    return {
      ...appProps,
      initialState: { user: userObj, currentUrl: ctx.asPath, teamSlug, ...initialData },
    };
  }

  public componentDidMount() {
    // Remove the server-side injected CSS.
    const jssStyles = document.querySelector("#jss-server-side");
    if (jssStyles && jssStyles.parentNode) {
      jssStyles.parentNode.removeChild(jssStyles);
    }
  }

  private store: Store;

  constructor(props) {
    super(props);

    console.log("MyApp.constructor");

    this.store = initializeStore(props.initialState);
  }

  public render() {
    const { Component, pageProps } = this.props;
    const store = this.store;

    const isThemeDark = store.currentUser ? store.currentUser.darkTheme : true;

    return (
      <ThemeProvider theme={isThemeDark ? themeDark : themeLight}>
        <Head>
          <meta name="viewport" content="width=device-width, initial-scale=1.0" />

          <link
            rel="stylesheet"
            href={
              isThemeDark
                ? "https://storage.googleapis.com/async-await/nprogress-light.min.css?v=1"
                : "https://storage.googleapis.com/async-await/nprogress-dark.min.css?v=1"
            }
          />
        </Head>
        <CssBaseline />
        <Provider store={store}>
          <Component {...pageProps} store={store} />
        </Provider>
      </ThemeProvider>
    );
  }
}

export default MyApp;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\pages\_document.tsx -----

import Document, { Head, Html, Main, NextScript } from "next/document";
import React from "react";

class MyDocument extends Document {
  public static getInitialProps = async (ctx) => {
    const initialProps = await Document.getInitialProps(ctx);

    return {
      ...initialProps,
    };
  };

  public render() {
    // console.log('rendered on the server');

    const isThemeDark = this.props.__NEXT_DATA__.props.initialState.user
      ? this.props.__NEXT_DATA__.props.initialState.user.darkTheme
      : true;

    return (
      <Html lang="en">
        <Head>
          <meta charSet="utf-8" />
          <meta name="google" content="notranslate" />
          <meta name="theme-color" content="#303030" />

          <link rel="shortcut icon" href="https://storage.googleapis.com/async-await/async-favicon32.png" />

          <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons" />

          <link
            rel="stylesheet"
            href={
              isThemeDark
                ? "https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/a11y-dark.min.css"
                : "https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/a11y-light.min.css"
            }
          />

          <style>
            {`
              #__next {
                width: 100%;
                height: 100%;
              }
              a {
                font-weight: 400;
                color: #58a6ff;
                text-decoration: none;
                outline: none;
              }
              hr {
                border: 0.5px #707070 solid;
                color: #000;
              }
              blockquote {
                padding: 0 0.5em;
                margin: 20px 1em;
                border-left: 0.25em solid #dfe2e5;
                color: #000;
              }
              pre {
                display: block;
                overflow-x: auto;
                padding: 0.5em;
                background: #d0d0d0;
                border: 1px solid #ddd;
                font-size: 14px;
                color: #000;
              }
              pre code {
                font-size: 13px;
                background: #d0d0d0;
                padding: 0px;
                color: #000;
              }
              code {
                font-size: 13px;
                background: #d0d0d0;
                padding: 3px 5px;
                color: #000;
              }
              mark {
                background-color: #ffff0060;
              }
              summary:focus {
                outline: none;
              }
              table {
                border-collapse: collapse;
                margin: 15px 0px;
              }
              table, th, td {
                border: 1px solid #a1a1a1;
              }
              th, td {
                line-height: 1.5em;
                padding: 10px;
              }
            `}
          </style>
        </Head>
        <body>
          <Main />
          <NextScript />
        </body>
      </Html>
    );
  }
}

export default MyDocument;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\server\server.ts -----

import express from 'express';
import next from 'next';

const NODE_ENV = process.env.NODE_ENV || 'development';
const IS_DEV = NODE_ENV !== 'production';

const app = next({ dev: IS_DEV });
const handle = app.getRequestHandler();

app.prepare().then(() => {
  const server = express();

  // give all Nextjs's request to Nextjs before anything else
  server.get('/_next/*', (req, res) => {
    // console.log('next server, page');
    handle(req, res);
  });

  server.use(express.json());

  // server.get('/api/v1/public/get-user', (_, res) => {
  //   res.json({ user: { email: 'team@builderbook.org' } });
  // });

  server.get('/team/:teamSlug/team-settings', (req, res) => {
    const { teamSlug } = req.params;
    app.render(req, res, '/team-settings', { teamSlug });
  });

  server.get('/team/:teamSlug/discussions/:discussionSlug', (req, res) => {
    const { teamSlug, discussionSlug } = req.params;
    app.render(req, res, '/discussion', { teamSlug, discussionSlug });
  });

  server.get('/team/:teamSlug/discussions', (req, res) => {
    const { teamSlug } = req.params;
    app.render(req, res, '/discussion', { teamSlug });
  });

  server.get('/team/:teamSlug/billing', (req, res) => {
    const { teamSlug } = req.params;
    app.render(req, res, '/billing', { teamSlug, ...(req.query || {}) });
  });

  server.get('/invitation', (req, res) => {
    app.render(req, res, '/invitation', { token: req.query.token as string });
  });

  server.all('*', (req, res) => {
    handle(req, res);
  });

  server.listen(process.env.NEXT_PUBLIC_PORT_APP, () => {
    console.log(`> Ready on ${process.env.NEXT_PUBLIC_URL_APP}`);
  });
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\.eslintrc.js -----

module.exports = {
  settings: {
    react: { version: 'detect' },
  },
  parser: '@typescript-eslint/parser',
  extends: ['plugin:react/recommended', 'plugin:@typescript-eslint/recommended', 'prettier'],
  env: {
    es6: true,
    node: true,
  },
  plugins: ['prettier', 'react'],
  rules: {
    'prettier/prettier': [
      'error',
      {
        singleQuote: true,
        trailingComma: 'all',
        arrowParens: 'always',
        printWidth: 100,
        semi: true,
      },
    ],
    '@typescript-eslint/camelcase': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    'react/no-unescaped-entities': 'off',
    'react/jsx-filename-extension': ['error', { extensions: ['.tsx'] }],
    '@typescript-eslint/no-explicit-any': 'off',
    'prefer-arrow-callback': 'error',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
  },
};

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\next-env.d.ts -----

/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/pages/api-reference/config/typescript for more information.

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\next.config.js -----

module.exports = {
  poweredByHeader: false,
  webpack5: true,
  typescript: {
    ignoreBuildErrors: true,
  },
};

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\nodemon.json -----

{
  "watch": ["server"],
  "exec": "ts-node --project tsconfig.server.json",
  "ext": "ts"
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\package.json -----

{
  "name": "10-begin-app",
  "version": "1",
  "license": "MIT",
  "scripts": {
    "dev": "nodemon server/server.ts",
    "build": "next build",
    "lint": "eslint . --ext .ts,.tsx"
  },
  "dependencies": {
    "@emotion/react": "^11.14.0",
    "@emotion/styled": "^11.14.0",
    "@material-ui/lab": "^4.0.0-alpha.56",
    "@mui/material": "^6.4.8",
    "@mui/system": "^6.4.8",
    "@stripe/stripe-js": "^6.1.0",
    "dotenv": "^16.4.7",
    "express": "^4.21.2",
    "he": "^1.2.0",
    "isomorphic-unfetch": "^4.0.2",
    "keycode": "^2.2.0",
    "marked": "^15.0.7",
    "mobx": "5.15.7",
    "mobx-react": "6.3.1",
    "moment": "^2.30.1",
    "next": "^15.2.3",
    "nprogress": "^0.2.0",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-mentions": "^4.4.10",
    "socket.io-client": "^4.8.1",
    "typescript": "^5.8.2"
  },
  "devDependencies": {
    "@types/express": "^5.0.1",
    "@types/he": "^1.2.3",
    "@types/marked": "^6.0.0",
    "@types/node": "^22.13.11",
    "@types/react": "^19.0.12",
    "@types/react-dom": "^19.0.4",
    "@types/socket.io-client": "^3.0.0",
    "@typescript-eslint/eslint-plugin": "^8.27.0",
    "@typescript-eslint/parser": "^8.27.0",
    "eslint": "^9.22.0",
    "eslint-config-prettier": "^10.1.1",
    "eslint-plugin-prettier": "^5.2.3",
    "eslint-plugin-react": "^7.37.4",
    "nodemon": "^3.1.9",
    "prettier": "^3.5.3",
    "ts-node": "^10.9.2"
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\tsconfig.json -----

{
  "compileOnSave": false,
  "compilerOptions": {
    "target": "esnext",
    "module": "esnext",
    "jsx": "preserve",
    "allowJs": true,
    "alwaysStrict": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "removeComments": true,
    "preserveConstEnums": true,
    "sourceMap": false,
    "skipLibCheck": true,
    "baseUrl": ".",
    "typeRoots": [
      "./node_modules/@types"
    ],
    "lib": [
      "dom",
      "es2017"
    ],
    "strict": false,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "incremental": true
  },
  "include": [
    "next-env.d.ts",
    "./**/*.tsx",
    "./**/*.ts"
  ],
  "exclude": [
    "dist",
    "production-server",
    ".next",
    "out",
    "next.config.js",
    "node_modules"
  ]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\app\tsconfig.server.json -----

{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "module": "commonjs",
    "outDir": "production-server/",
    "target": "es2017",
    "isolatedModules": false,
    "noEmit": false
  },
  "exclude": ["./server/types.d.ts"],
  "include": ["./server/**/*.ts"],
  "typeRoots": ["./node_modules/@types", "./server/types.d.ts"]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\lambda\.eslintrc.js -----

module.exports = {
  parser: "@typescript-eslint/parser",
  extends: ["plugin:@typescript-eslint/recommended", "prettier"],
  env: {
    "es6": true,
    "node": true,
  },
  rules: {
    'prettier/prettier': [
      'error',
      {
        singleQuote: true,
        trailingComma: 'all',
        arrowParens: 'always',
        printWidth: 100,
        semi: true,
      },
    ],
    '@typescript-eslint/no-unused-vars': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    'prefer-arrow-callback': 'error',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
 },
  plugins: [
    "prettier"
  ]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\lambda\handler.ts -----

import * as mongoose from 'mongoose';

import sendEmail from './api/server/aws-ses';
import getEmailTemplate from './api/server/models/EmailTemplate';
import User from './api/server/models/User';

export const sendEmailForNewPost = async (event) => {
  console.log('Received event (request representation):', JSON.stringify(event));

  const reqBody = JSON.parse(event.body);

  const { discussionName, discussionLink, postContent, authorName, userIds } = reqBody;

  if (
    discussionName === undefined ||
    discussionLink === undefined ||
    postContent === undefined ||
    authorName === undefined ||
    userIds === undefined
  ) {
    throw new Error('Missing data');
  }

  console.log(discussionName, discussionLink, postContent, authorName, userIds);

  await mongoose.connect(process.env.MONGO_URL);

  try {
    const emailTemplate = await getEmailTemplate('newPost', {
      discussionName,
      discussionLink,
      postContent,
      authorName,
    });

    if (!emailTemplate) {
      throw new Error('newPost Email template not found');
    }

    const usersToNotify = await User.find({ _id: { $in: userIds } })
      .select('email')
      .setOptions({ lean: true });

    console.log('usersToNotify', usersToNotify);

    const jobs = usersToNotify
      .filter((user) => !!user.email)
      .map(async (user) => {
        try {
          await sendEmail({
            from: `From async-await.com <${process.env.EMAIL_SUPPORT_FROM_ADDRESS}>`,
            to: [user.email],
            subject: emailTemplate.subject,
            body: emailTemplate.message,
          });
          console.log('email is sent');
        } catch (err) {
          console.error(err.stack);
        }
      });

    await Promise.all(jobs);
  } catch (error) {
    console.error(error.stack);
    return { error: error.message, event };
  } finally {
    await mongoose.disconnect();
  }

  // const dev = process.env.NODE_ENV !== 'production';

  const response = {
    statusCode: 200,
    headers: {
      'Access-Control-Allow-Headers': 'Content-Type',
      'Access-Control-Allow-Origin': 'http://localhost:3000',
      'Access-Control-Allow-Methods': 'OPTIONS,POST,GET',
      'Access-Control-Allow-Credentials': true,
    },
    body: JSON.stringify({
      message: 'Email notification was sent!',
      input: event,
    }),
  };

  return response;
};

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\lambda\package.json -----

{
  "name": "lambda",
  "version": "1",
  "license": "MIT",
  "scripts": {
    "lint": "eslint . --ext .ts,.tsx",
    "trigger": "ts-node handler.ts"
  },
  "dependencies": {
    "aws-sdk": "^2.1512.0",
    "bcrypt": "^5.1.1",
    "connect-mongo": "^5.1.0",
    "cors": "^2.8.5",
    "dotenv": "^16.3.1",
    "express": "^4.18.2",
    "express-session": "^1.17.3",
    "he": "^1.2.0",
    "highlight.js": "^11.9.0",
    "lodash": "^4.17.21",
    "marked": "^11.0.0",
    "mongoose": "^8.0.2",
    "node-fetch": "2.6.1",
    "passport": "^0.7.0",
    "passport-google-oauth": "^2.0.0",
    "passwordless": "^1.1.3",
    "passwordless-tokenstore": "^0.0.10",
    "socket.io": "^4.7.2",
    "stripe": "^14.7.0",
    "typescript": "^5.3.2"
  },
  "devDependencies": {
    "@types/connect-mongo": "^3.1.3",
    "@types/dotenv": "^8.2.0",
    "@types/express": "^4.17.21",
    "@types/express-session": "^1.17.10",
    "@types/jest": "^29.5.11",
    "@types/lodash": "^4.14.202",
    "@types/mongoose": "^5.11.97",
    "@types/node": "^20.10.3",
    "@types/node-fetch": "^2.6.9",
    "@types/passport": "^1.0.16",
    "@types/socket.io": "^3.0.2",
    "@typescript-eslint/eslint-plugin": "^6.13.2",
    "@typescript-eslint/parser": "^6.13.2",
    "eslint": "^8.55.0",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-prettier": "^5.0.1",
    "jest": "^29.7.0",
    "prettier": "^3.1.0",
    "serverless-dotenv-plugin": "^6.0.0",
    "serverless-plugin-typescript": "^2.1.5",
    "ts-jest": "^29.1.1",
    "ts-node-dev": "^2.0.0"
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-begin\lambda\tsconfig.json -----

{
  "compileOnSave": false,
  "compilerOptions": {
    "jsx": "preserve",
    "allowJs": true,
    "alwaysStrict": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "removeComments": false,
    "preserveConstEnums": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "sourceMap": true,
    "skipLibCheck": true,
    "baseUrl": ".",
    "experimentalDecorators": true,
    "typeRoots": ["./node_modules/@types"],
    "lib": ["es2015", "es2016"],
    "module": "commonjs",
    "outDir": ".build/",
    "rootDir": "./"
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\server\api\index.ts -----

import * as express from 'express';

import publicExpressRoutes from './public';
import teamMemberExpressRoutes from './team-member';
import teamLeaderApi from './team-leader';

function handleError(err, _, res, __) {
  console.error(err.stack);

  res.json({ error: err.message || err.toString() });
}

export default function api(server: express.Express) {
  server.use('/api/v1/public', publicExpressRoutes, handleError);
  server.use('/api/v1/team-member', teamMemberExpressRoutes, handleError);
  server.use('/api/v1/team-leader', teamLeaderApi, handleError);
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\server\api\public.ts -----

import * as express from 'express';

import User from '../models/User';
import Invitation from '../models/Invitation';

const router = express.Router();

router.get('/get-user', (req, res) => {
  console.log(req.user);
  res.json({ user: req.user || null });
});

router.post('/get-user-by-slug', async (req, res, next) => {
  console.log('Express route: /get-user-by-slug');

  // req.session.foo = 'bar';

  try {
    const { slug } = req.body;

    const user = await User.getUserBySlug({ slug });

    res.json({ user });
  } catch (err) {
    next(err);
  }
});

router.get('/invitations/get-team-by-token', async (req, res, next) => {
  const token = req.query.token as string;

  try {
    const team = await Invitation.getTeamByToken({ token });

    res.json({ team });
  } catch (err) {
    next(err);
  }
});

export default router;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\server\api\team-leader.ts -----

import * as express from 'express';

import Invitation from '../models/Invitation';
import Team from '../models/Team';
import User from '../models/User';
import { createSession } from '../stripe';

const router = express.Router();

router.use((req, res, next) => {
  console.log('team leader API', req.path);

  if (!req.user) {
    res.status(401).json({ error: 'Unauthorized' });
    return;
  }

  next();
});

router.post('/teams/add', async (req: any, res, next) => {
  try {
    const { name, avatarUrl } = req.body;

    console.log(`Express route: ${name}, ${avatarUrl}`);

    const team = await Team.addTeam({ userId: req.user.id, name, avatarUrl });

    res.json(team);
  } catch (err) {
    next(err);
  }
});

router.post('/teams/update', async (req: any, res, next) => {
  try {
    const { teamId, name, avatarUrl } = req.body;

    // console.log(req.user.id, typeof req.user.id);
    // console.log(req.user._id, typeof req.user._id);

    const team = await Team.updateTeam({
      userId: req.user.id,
      teamId,
      name,
      avatarUrl,
    });

    res.json(team);
  } catch (err) {
    next(err);
  }
});

router.get('/teams/get-invitations-for-team', async (req: any, res, next) => {
  try {
    const invitations = await Invitation.getTeamInvitations({
      userId: req.user.id,
      teamId: req.query.teamId as string,
    });

    res.json({ invitations });
  } catch (err) {
    next(err);
  }
});

router.post('/teams/invite-member', async (req: any, res, next) => {
  try {
    const { teamId, email } = req.body;

    const newInvitation = await Invitation.add({ userId: req.user.id, teamId, email });

    res.json({ newInvitation });
  } catch (err) {
    next(err);
  }
});

router.post('/teams/remove-member', async (req: any, res, next) => {
  try {
    const { teamId, userId } = req.body;

    await Team.removeMember({ teamLeaderId: req.user.id, teamId, userId });

    res.json({ done: 1 });
  } catch (err) {
    next(err);
  }
});

router.post('/stripe/fetch-checkout-session', async (req: any, res, next) => {
  try {
    const { mode, teamId } = req.body;

    const user = await User.findById(req.user.id)
      .select(['stripeCustomer', 'email'])
      .setOptions({ lean: true });

    const team = await Team.findById(teamId)
      .select(['stripeSubscription', 'slug', 'teamLeaderId'])
      .setOptions({ lean: true });

    if (!user || !team || team.teamLeaderId !== req.user.id) {
      throw new Error('Permission denied');
    }

    const session = await createSession({
      mode,
      userId: user._id.toString(),
      userEmail: user.email,
      teamId,
      teamSlug: team.slug,
      customerId: (user.stripeCustomer && user.stripeCustomer.id) || undefined,
      subscriptionId: (team.stripeSubscription && team.stripeSubscription.id) || undefined,
    });

    res.json({ sessionId: session.id });
  } catch (err) {
    next(err);
  }
});

router.post('/cancel-subscription', async (req: any, res, next) => {
  const { teamId } = req.body;

  try {
    const { isSubscriptionActive } = await Team.cancelSubscription({
      teamLeaderId: req.user.id,
      teamId,
    });

    res.json({ isSubscriptionActive });
  } catch (err) {
    next(err);
  }
});

router.get('/get-list-of-invoices-for-customer', async (req: any, res, next) => {
  try {
    const { stripeListOfInvoices } = await User.getListOfInvoicesForCustomer({
      userId: req.user.id,
    });
    res.json({ stripeListOfInvoices });
  } catch (err) {
    next(err);
  }
});

export default router;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\server\api\team-member.ts -----

import * as express from "express";

import { signRequestForUpload } from "../aws-s3";

import User from "../models/User";
import Team from "../models/Team";
import Invitation from "../models/Invitation";
import Discussion from "../models/Discussion";
import Post from "../models/Post";

import { discussionAdded, discussionDeleted, discussionEdited, postAdded, postDeleted, postEdited } from "../sockets";

const router = express.Router();

router.use((req, res, next) => {
  console.log("team member API", req.path);
  if (!req.user) {
    res.status(401).json({ error: "Unauthorized" });
    return;
  }

  next();
});

// Get signed request from AWS S3 server
router.post("/aws/get-signed-request-for-upload-to-s3", async (req, res, next) => {
  try {
    const { fileName, fileType, prefix, bucket } = req.body;

    const returnData = await signRequestForUpload({
      fileName,
      fileType,
      prefix,
      bucket,
    });

    console.log(bucket);

    res.json(returnData);
  } catch (err) {
    next(err);
  }
});

router.post("/user/update-profile", async (req: any, res, next) => {
  try {
    const { name, avatarUrl } = req.body;

    const updatedUser = await User.updateProfile({
      userId: req.user.id,
      name,
      avatarUrl,
    });

    res.json({ updatedUser });
  } catch (err) {
    next(err);
  }
});

router.post("/user/toggle-theme", async (req: any, res, next) => {
  try {
    const { darkTheme } = req.body;

    await User.toggleTheme({ userId: req.user.id, darkTheme });

    res.json({ done: 1 });
  } catch (err) {
    next(err);
  }
});

async function loadDiscussionsData(team, userId, body) {
  const { discussionSlug } = body;

  if (!discussionSlug) {
    return [];
  }

  const { discussions } = await Discussion.getList({
    userId,
    teamId: team._id,
  });

  for (const discussion of discussions) {
    if (discussion.slug === discussionSlug) {
      Object.assign(discussion, {
        initialPosts: await Post.getList({
          userId,
          discussionId: discussion._id.toString(),
        }),
      });

      break;
    }
  }

  return discussions;
}

async function loadTeamData(team, userId, body) {
  const initialMembers = await User.getMembersForTeam({
    userId,
    teamId: team._id,
  });

  let initialInvitations = [];
  if (userId === team.teamLeaderId) {
    initialInvitations = await Invitation.getTeamInvitations({
      userId,
      teamId: team._id,
    });
  }

  console.log(`initialMembers:${initialMembers}`);

  const initialDiscussions = await loadDiscussionsData(team, userId, body);

  const data: any = { initialMembers, initialInvitations, initialDiscussions };

  // console.log(`Express route:${data.initialPosts}`);

  return data;
}

router.post("/get-initial-data", async (req: any, res, next) => {
  try {
    const teams = await Team.getAllTeamsForUser(req.user.id);

    let selectedTeamSlug = req.body.teamSlug;
    if (!selectedTeamSlug && teams && teams.length > 0) {
      selectedTeamSlug = teams[0].slug;
    }

    for (const team of teams) {
      if (team.slug === selectedTeamSlug) {
        Object.assign(team, await loadTeamData(team, req.user.id, req.body));
        break;
      }
    }

    res.json({ teams });
  } catch (err) {
    next(err);
  }
});

// router.get('/teams', async (req, res, next) => {
//   try {
//     const teams = await Team.getAllTeamsForUser(req.user.id);

//     console.log(teams);

//     res.json({ teams });
//   } catch (err) {
//     next(err);
//   }
// });

router.get("/teams/get-members", async (req: any, res, next) => {
  try {
    const users = await User.getMembersForTeam({
      userId: req.user.id,
      teamId: req.query.teamId as string,
    });

    res.json({ users });
  } catch (err) {
    next(err);
  }
});

router.post("/discussions/add", async (req: any, res, next) => {
  try {
    const { name, teamId, memberIds = [], socketId, notificationType } = req.body;

    const discussion = await Discussion.add({
      userId: req.user.id,
      name,
      teamId,
      memberIds,
      notificationType,
    });

    discussionAdded({ socketId, discussion });

    res.json({ discussion });
  } catch (err) {
    next(err);
  }
});

router.post("/discussions/edit", async (req: any, res, next) => {
  try {
    const { name, id, memberIds = [], socketId, notificationType } = req.body;

    const updatedDiscussion = await Discussion.edit({
      userId: req.user.id,
      name,
      id,
      memberIds,
      notificationType,
    });

    discussionEdited({ socketId, discussion: updatedDiscussion });

    res.json({ done: 1 });
  } catch (err) {
    next(err);
  }
});

router.post("/discussions/delete", async (req: any, res, next) => {
  try {
    const { id, socketId } = req.body;

    const { teamId } = await Discussion.delete({ userId: req.user.id, id });

    discussionDeleted({ socketId, teamId, id });

    res.json({ done: 1 });
  } catch (err) {
    next(err);
  }
});

router.get("/discussions/list", async (req: any, res, next) => {
  try {
    const { discussions } = await Discussion.getList({
      userId: req.user.id,
      teamId: req.query.teamId as string,
    });

    res.json({ discussions });
  } catch (err) {
    next(err);
  }
});

router.get("/posts/list", async (req: any, res, next) => {
  try {
    const posts = await Post.getList({
      userId: req.user.id,
      discussionId: req.query.discussionId as string,
    });

    res.json({ posts });
  } catch (err) {
    next(err);
  }
});

router.post("/posts/add", async (req: any, res, next) => {
  try {
    const { content, discussionId, socketId } = req.body;

    const post = await Post.add({ userId: req.user.id, content, discussionId });

    postAdded({ socketId, post });

    res.json({ post });
  } catch (err) {
    next(err);
  }
});

router.post("/posts/edit", async (req: any, res, next) => {
  try {
    const { content, id, socketId } = req.body;

    const updatedPost = await Post.edit({ userId: req.user.id, content, id });

    postEdited({ socketId, post: updatedPost });

    res.json({ done: 1 });
  } catch (err) {
    next(err);
  }
});

router.post("/posts/delete", async (req: any, res, next) => {
  try {
    const { id, discussionId, socketId } = req.body;

    await Post.delete({ userId: req.user.id, id });

    postDeleted({ socketId, id, discussionId });

    res.json({ done: 1 });
  } catch (err) {
    next(err);
  }
});

export default router;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\server\models\Discussion.ts -----

import { uniq } from 'lodash';
import * as mongoose from 'mongoose';

import { generateRandomSlug } from '../utils/slugify';
import Team, { TeamDocument } from './Team';
import Post from './Post';

const mongoSchema = new mongoose.Schema({
  createdUserId: {
    type: String,
    required: true,
  },
  teamId: {
    type: String,
    required: true,
  },
  name: {
    type: String,
    required: true,
  },
  slug: {
    type: String,
    required: true,
  },
  memberIds: [
    {
      type: String,
    },
  ],
  createdAt: {
    type: Date,
    required: true,
    default: Date.now,
  },
  notificationType: {
    type: String,
    enum: ['default', 'email'],
    required: true,
    default: 'default',
  },
});

export interface DiscussionDocument extends mongoose.Document {
  createdUserId: string;
  teamId: string;
  name: string;
  slug: string;
  memberIds: string[];
  createdAt: Date;
  notificationType: string;
}

interface DiscussionModel extends mongoose.Model<DiscussionDocument> {
  getList({
    userId,
    teamId,
  }: {
    userId: string;
    teamId: string;
  }): Promise<{ discussions: DiscussionDocument[] }>;

  add({
    name,
    userId,
    teamId,
    memberIds,
    notificationType,
  }: {
    name: string;
    userId: string;
    teamId: string;
    memberIds: string[];
    notificationType: string;
  }): Promise<DiscussionDocument>;

  edit({
    userId,
    id,
    name,
    memberIds,
    notificationType,
  }: {
    userId: string;
    id: string;
    name: string;
    memberIds: string[];
    notificationType: string;
  }): Promise<DiscussionDocument>;

  delete({ userId, id }: { userId: string; id: string }): Promise<{ teamId: string }>;

  checkPermissionAndGetTeam({
    userId,
    teamId,
    memberIds,
  }: {
    userId: string;
    teamId: string;
    memberIds: string[];
  }): Promise<TeamDocument>;
}

class DiscussionClass extends mongoose.Model {
  public static async getList({ userId, teamId }) {
    await this.checkPermissionAndGetTeam({ userId, teamId });

    const filter: any = { teamId, memberIds: userId };

    const discussions: any[] = await this.find(filter).setOptions({ lean: true });

    return { discussions };
  }

  public static async add({ name, userId, teamId, memberIds = [], notificationType }) {
    if (!name) {
      throw new Error('Bad data');
    }

    await this.checkPermissionAndGetTeam({ userId, teamId, memberIds });

    const slug = await generateRandomSlug(this, { teamId });

    return this.create({
      createdUserId: userId,
      teamId,
      name,
      slug,
      memberIds: uniq([userId, ...memberIds]),
      createdAt: new Date(),
      notificationType,
    });
  }

  public static async edit({ userId, id, name, memberIds = [], notificationType }) {
    if (!id) {
      throw new Error('Bad data');
    }

    const discussion = await this.findById(id)
      .select('teamId createdUserId')
      .setOptions({ lean: true });

    const team = await this.checkPermissionAndGetTeam({
      userId,
      teamId: discussion.teamId,
      memberIds,
    });

    if (discussion.createdUserId !== userId && team.teamLeaderId !== userId) {
      throw new Error('Permission denied. Only author or team leader can edit Discussion.');
    }

    const updatedObj = await this.findOneAndUpdate(
      { _id: id },
      {
        name,
        memberIds: uniq([userId, ...memberIds]),
        notificationType,
      },
      { runValidators: true, new: true },
    );

    return updatedObj;
  }

  public static async delete({ userId, id }) {
    if (!id) {
      throw new Error('Bad data');
    }

    const discussion = await this.findById(id).select('teamId').setOptions({ lean: true });

    await this.checkPermissionAndGetTeam({ userId, teamId: discussion.teamId });

    await Post.deleteMany({ discussionId: id });

    await this.deleteOne({ _id: id });

    return { teamId: discussion.teamId };
  }

  private static async checkPermissionAndGetTeam({ userId, teamId, memberIds = [] }) {
    if (!userId || !teamId) {
      throw new Error('Bad data');
    }

    const team = await Team.findById(teamId)
      .select('memberIds teamLeaderId')
      .setOptions({ lean: true });

    if (!team || team.memberIds.indexOf(userId) === -1) {
      throw new Error('Team not found');
    }

    for (const id of memberIds) {
      if (team.memberIds.indexOf(id) === -1) {
        throw new Error('Permission denied');
      }
    }

    return team;
  }
}

mongoSchema.loadClass(DiscussionClass);

const Discussion = mongoose.model<DiscussionDocument, DiscussionModel>('Discussion', mongoSchema);

export default Discussion;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\server\models\EmailTemplate.ts -----

import * as _ from 'lodash';
import * as mongoose from 'mongoose';

interface EmailTemplateDocument extends mongoose.Document {
  name: string;
  subject: string;
  message: string;
}

const EmailTemplate = mongoose.model<EmailTemplateDocument>(
  'EmailTemplate',
  new mongoose.Schema({
    name: {
      type: String,
      required: true,
      unique: true,
    },
    subject: {
      type: String,
      required: true,
    },
    message: {
      type: String,
      required: true,
    },
  }),
);

export async function insertTemplates() {
  const templates = [
    {
      name: 'welcome',
      subject: 'Welcome to SaaS boilerplate by Async',
      message: `Welcome <%= userName %>,
        <p>
          Thanks for signing up on our <a href="https://github.com/async-labs/saas" target="blank">SaaS boilerplate</a>!
        </p>
        <p>
          If you are learning how to build a SaaS web app, check out our 2 books:
           <a href="https://builderbook.org" target="blank">Builder Book</a>
           and
           <a href="https://builderbook.org/book" target="blank">SaaS Boilerplate</a>.
        </p>
        <p>
          Also check out
          <a href="https://async-await.com" target="blank"> Async</a>
          , our communication tool for small teams of software developers.
        </p>
        Kelly & Timur, Team Async
      `,
    },
    {
      name: 'login',
      subject: 'Login link for saas-app.async-await.com',
      message: `
        <p>Log into your account by clicking on this link: <a href="<%= loginURL %>"><%= loginURL %></a>.</p>`,
    },
    {
      name: 'invitation',
      subject: 'You are invited to join a team at saas-app.async-await.com',
      message: `You've been invited to join <b><%= teamName%></b>.
        <br/>Click here to accept the invitation: <%= invitationURL%>
      `,
    },
    {
      name: 'newPost',
      subject: 'New Post was created in Discussion: <%= discussionName %>',
      message: `<p>New Post in Discussion: "<%= discussionName%>" by <%= authorName%></p>
        New Post: "<%= postContent %>"
        <p>---</p>
        <p>View it at <a href="<%= discussionLink %>"><%= discussionLink %></a>.</p>
      `,
    },
  ];

  for (const t of templates) {
    const et = await EmailTemplate.findOne({ name: t.name }).setOptions({ lean: true });
    const message = t.message.replace(/\n/g, '').replace(/[ ]+/g, ' ').trim();

    if (!et) {
      EmailTemplate.create(Object.assign({}, t, { message }));
    } else if (et.subject !== t.subject || et.message !== message) {
      EmailTemplate.updateOne({ _id: et._id }, { $set: { message, subject: t.subject } }).exec();
    }
  }
}

export default async function getEmailTemplate(name: string, params: any) {
  await insertTemplates();

  const et = await EmailTemplate.findOne({ name }).setOptions({ lean: true });

  if (!et) {
    throw new Error('Email Template is not found in database.');
  }

  return {
    message: _.template(et.message)(params),
    subject: _.template(et.subject)(params),
  };
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\server\models\Invitation.ts -----

import * as mongoose from 'mongoose';

import sendEmail from '../aws-ses';
import getEmailTemplate from './EmailTemplate';
import Team from './Team';
import User, { UserDocument } from './User';

const mongoSchema = new mongoose.Schema({
  teamId: {
    type: String,
    required: true,
  },
  email: {
    type: String,
    required: true,
  },
  createdAt: {
    type: Date,
    required: true,
    default: Date.now,
    expires: 60 * 60 * 24, // delete doc after 24 hours
  },
  token: {
    type: String,
    required: true,
    unique: true,
  },
});

mongoSchema.index({ teamId: 1, email: 1 }, { unique: true });

interface InvitationDocument extends mongoose.Document {
  teamId: string;
  email: string;
  createdAt: Date;
  token: string;
}

interface InvitationModel extends mongoose.Model<InvitationDocument> {
  add({
    userId,
    teamId,
    email,
  }: {
    userId: string;
    teamId: string;
    email: string;
  }): InvitationDocument;

  getTeamInvitations({ userId, teamId }: { userId: string; teamId: string });
  getTeamByToken({ token }: { token: string });
  addUserToTeam({ token, user }: { token: string; user: UserDocument });
}

function generateToken() {
  const gen = () =>
    Math.random().toString(36).substring(2, 12) + Math.random().toString(36).substring(2, 12);

  return `${gen()}`;
}

class InvitationClass extends mongoose.Model {
  public static async add({ userId, teamId, email }) {
    if (!teamId || !email) {
      throw new Error('Bad data');
    }

    const team = await Team.findById(teamId).setOptions({ lean: true });
    if (!team || team.teamLeaderId !== userId) {
      throw new Error('Team does not exist or you have no permission');
    }

    const registeredUser = await User.findOne({ email }).setOptions({ lean: true });

    if (registeredUser && team.memberIds.includes(registeredUser._id.toString())) {
      throw new Error('This user is already Team Member.');
    }

    let token;
    const invitation = await this.findOne({ teamId, email })
      .select('token')
      .setOptions({ lean: true });

    if (invitation) {
      token = invitation.token;
    } else {
      token = generateToken();
      while ((await this.countDocuments({ token })) > 0) {
        token = generateToken();
      }

      await this.create({
        teamId,
        email,
        token,
      });
    }

    const dev = process.env.NODE_ENV !== 'production';

    const emailTemplate = await getEmailTemplate('invitation', {
      teamName: team.name,
      invitationURL: `${
        dev ? process.env.URL_APP : process.env.PRODUCTION_URL_APP
      }/invitation?token=${token}`,
    });

    if (!emailTemplate) {
      throw new Error('Invitation email template not found');
    }

    try {
      await sendEmail({
        from: `Kelly from saas-app.async-await.com <${process.env.EMAIL_SUPPORT_FROM_ADDRESS}>`,
        to: [email],
        subject: emailTemplate.subject,
        body: emailTemplate.message,
      });
    } catch (err) {
      console.log('Email sending error:', err);
    }

    return await this.findOne({ teamId, email }).setOptions({ lean: true });
  }

  public static async getTeamInvitations({ userId, teamId }) {
    const team = await Team.findOne({ _id: teamId })
      .select('teamLeaderId')
      .setOptions({ lean: true });

    if (userId !== team.teamLeaderId) {
      throw new Error('You have no permission.');
    }

    return this.find({ teamId }).select('email').setOptions({ lean: true });
  }

  public static async getTeamByToken({ token }) {
    if (!token) {
      throw new Error('Bad data');
    }

    const invitation = await this.findOne({ token }).setOptions({ lean: true });

    if (!invitation) {
      throw new Error('Invitation not found');
    }

    const team = await Team.findById(invitation.teamId)
      .select('name slug avatarUrl memberIds')
      .setOptions({ lean: true });

    if (!team) {
      throw new Error('Team does not exist');
    }

    return team;
  }

  public static async addUserToTeam({ token, user }) {
    if (!token || !user) {
      throw new Error('Bad data');
    }

    const invitation = await this.findOne({ token }).setOptions({ lean: true });

    if (!invitation || invitation.email !== user.email) {
      throw new Error('Invitation not found');
    }

    await this.deleteOne({ token });

    const team = await Team.findById(invitation.teamId)
      .select('memberIds slug teamLeaderId')
      .setOptions({ lean: true });

    if (!team) {
      throw new Error('Team does not exist');
    }

    if (team && !team.memberIds.includes(user._id)) {
      await Team.updateOne({ _id: team._id }, { $addToSet: { memberIds: user._id } });

      if (user._id !== team.teamLeaderId) {
        await User.findByIdAndUpdate(user._id, { $set: { defaultTeamSlug: team.slug } });
      }
    }

    return team.slug;
  }
}

mongoSchema.loadClass(InvitationClass);

const Invitation = mongoose.model<InvitationDocument, InvitationModel>('Invitation', mongoSchema);

export default Invitation;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\server\models\Post.ts -----

import * as mongoose from "mongoose";

import * as he from "he";
import hljs from "highlight.js";
import { marked } from "marked";

import Discussion from "./Discussion";
import Team from "./Team";

const mongoSchema = new mongoose.Schema({
  createdUserId: {
    type: String,
    required: true,
  },
  discussionId: {
    type: String,
    required: true,
  },
  content: {
    type: String,
    required: true,
  },
  htmlContent: {
    type: String,
    required: true,
  },
  isEdited: {
    type: Boolean,
    default: false,
  },
  lastUpdatedAt: Date,
  createdAt: {
    type: Date,
    required: true,
  },
});

function markdownToHtml(content) {
  const renderer = new marked.Renderer();

  renderer.link = ({ href, title, text }) => {
    const t = title ? ` title="${title}"` : "";

    if (text.startsWith("<code>@#")) {
      return `${text.replace("<code>@#", "<code>@")} `;
    }

    return `
      <a target="_blank" href="${href}" rel="noopener noreferrer"${t}>
        ${text}
      </a>
    `;
  };

  renderer.code = ({ text, lang }) => {
    const language = hljs.getLanguage(lang) ? lang : "plaintext";

    return `<pre><code class="hljs language-${lang}">${hljs.highlight(text, { language }).value}</code></pre>`;
  };

  marked.setOptions({
    renderer,
    breaks: true,
  });

  return marked(he.decode(content));
}

export interface PostDocument extends mongoose.Document {
  createdUserId: string;
  discussionId: string;
  content: string;
  isEdited: boolean;
  lastUpdatedAt: Date;
  createdAt: Date;
}

interface PostModel extends mongoose.Model<PostDocument> {
  getList({ userId, discussionId }: { userId: string; discussionId: string }): Promise<PostDocument[]>;

  add({
    content,
    userId,
    discussionId,
  }: {
    content: string;
    userId: string;
    discussionId: string;
  }): Promise<PostDocument>;

  edit({ content, userId, id }: { content: string; userId: string; id: string }): Promise<PostDocument>;

  delete({ userId, id }: { userId: string; id: string }): Promise<void>;

  checkPermissionAndGetTeamAndDiscussion({
    userId,
    discussionId,
    post,
  }: {
    userId: string;
    discussionId: string;
    post: PostDocument;
  }): Promise<{ TeamDocument; DiscussionDocument }>;
}

class PostClass extends mongoose.Model {
  public static async getList({ userId, discussionId }) {
    await this.checkPermissionAndGetTeamAndDiscussion({ userId, discussionId });

    const filter: any = { discussionId };

    const posts: any[] = await this.find(filter).sort({ createdAt: 1 }).setOptions({ lean: true });

    return posts;
  }

  public static async add({ content, userId, discussionId }) {
    if (!content) {
      throw new Error("Bad data");
    }

    await this.checkPermissionAndGetTeamAndDiscussion({ userId, discussionId });

    const htmlContent = markdownToHtml(content);

    const post = await this.create({
      createdUserId: userId,
      discussionId,
      content,
      htmlContent,
      createdAt: new Date(),
    });

    return post;
  }

  public static async edit({ content, userId, id }) {
    if (!content || !id) {
      throw new Error("Bad data");
    }

    const post = await this.findById(id).select("createdUserId discussionId").setOptions({ lean: true });

    await this.checkPermissionAndGetTeamAndDiscussion({
      userId,
      discussionId: post.discussionId,
      post,
    });

    const htmlContent = markdownToHtml(content);

    const updatedObj = await this.findOneAndUpdate(
      { _id: id },
      { content, htmlContent, isEdited: true, lastUpdatedAt: new Date() },
      { runValidators: true, new: true }
    );

    return updatedObj;
  }

  public static async delete({ userId, id }) {
    if (!id) {
      throw new Error("Bad data");
    }

    const post = await this.findById(id).select("createdUserId discussionId content").setOptions({ lean: true });

    await this.checkPermissionAndGetTeamAndDiscussion({
      userId,
      discussionId: post.discussionId,
      post,
    });

    await this.deleteOne({ _id: id });
  }

  private static async checkPermissionAndGetTeamAndDiscussion({ userId, discussionId, post = null }) {
    if (!userId || !discussionId) {
      throw new Error("Bad data");
    }

    if (post && post.createdUserId !== userId) {
      throw new Error("Permission denied");
    }

    const discussion = await Discussion.findById(discussionId)
      .select("teamId memberIds slug")
      .setOptions({ lean: true });

    if (!discussion) {
      throw new Error("Discussion not found");
    }

    if (discussion.memberIds.indexOf(userId) === -1) {
      throw new Error("Permission denied");
    }

    const team = await Team.findById(discussion.teamId).select("memberIds slug").setOptions({ lean: true });

    if (!team || team.memberIds.indexOf(userId) === -1) {
      throw new Error("Team not found");
    }

    return { team, discussion };
  }
}

mongoSchema.loadClass(PostClass);

const Post = mongoose.model<PostDocument, PostModel>("Post", mongoSchema);

export default Post;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\server\models\Team.ts -----

import * as mongoose from 'mongoose';
import Stripe from 'stripe';

import { cancelSubscription } from '../stripe';
import { generateRandomSlug } from '../utils/slugify';
import User from './User';

const mongoSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
  },
  slug: {
    type: String,
    required: true,
    unique: true,
  },
  avatarUrl: String,
  createdAt: {
    type: Date,
    required: true,
  },
  teamLeaderId: {
    type: String,
    required: true,
  },
  memberIds: [
    {
      type: String,
      required: true,
    },
  ],
  defaultTeam: {
    type: Boolean,
    default: false,
  },
  stripeSubscription: {
    id: String,
    object: String,
    application_fee_percent: Number,
    billing: String,
    cancel_at_period_end: Boolean,
    billing_cycle_anchor: Number,
    canceled_at: Number,
    created: Number,
  },
  isSubscriptionActive: {
    type: Boolean,
    default: false,
  },
  isPaymentFailed: {
    type: Boolean,
    default: false,
  },
});

export interface TeamDocument extends mongoose.Document {
  name: string;
  slug: string;
  avatarUrl: string;
  createdAt: Date;

  teamLeaderId: string;
  memberIds: string[];
  defaultTeam: boolean;

  stripeSubscription: {
    id: string;
    object: string;
    application_fee_percent: number;
    billing: string;
    cancel_at_period_end: boolean;
    billing_cycle_anchor: number;
    canceled_at: number;
    created: number;
  };
  isSubscriptionActive: boolean;
  isPaymentFailed: boolean;
}

interface TeamModel extends mongoose.Model<TeamDocument> {
  addTeam({
    name,
    userId,
  }: {
    userId: string;
    name: string;
    avatarUrl: string;
  }): Promise<TeamDocument>;

  updateTeam({
    userId,
    teamId,
    name,
    avatarUrl,
  }: {
    userId: string;
    teamId: string;
    name: string;
    avatarUrl: string;
  }): Promise<TeamDocument>;

  getAllTeamsForUser(userId: string): Promise<TeamDocument[]>;

  removeMember({
    teamId,
    teamLeaderId,
    userId,
  }: {
    teamId: string;
    teamLeaderId: string;
    userId: string;
  }): Promise<void>;

  subscribeTeam({
    session,
    team,
  }: {
    session: Stripe.Checkout.Session;
    team: TeamDocument;
  }): Promise<void>;

  cancelSubscription({
    teamLeaderId,
    teamId,
  }: {
    teamLeaderId: string;
    teamId: string;
  }): Promise<TeamDocument>;

  cancelSubscriptionAfterFailedPayment({
    subscriptionId,
  }: {
    subscriptionId: string;
  }): Promise<TeamDocument>;
}

class TeamClass extends mongoose.Model {
  public static async addTeam({ userId, name, avatarUrl }) {
    console.log(`Static method: ${name}, ${avatarUrl}`);

    if (!userId || !name || !avatarUrl) {
      throw new Error('Bad data');
    }

    const slug = await generateRandomSlug(this);

    let defaultTeam = false;
    if ((await this.countDocuments({ teamLeaderId: userId })) === 0) {
      await User.findByIdAndUpdate(userId, { $set: { defaultTeamSlug: slug } });
      defaultTeam = true;
    }

    const team = await this.create({
      teamLeaderId: userId,
      name,
      slug,
      avatarUrl,
      memberIds: [userId],
      createdAt: new Date(),
      defaultTeam,
    });

    return team;
  }

  public static async updateTeam({ userId, teamId, name, avatarUrl }) {
    const team = await this.findById(teamId, 'name teamLeaderId');

    if (!team) {
      throw new Error('Team not found');
    }

    if (team.teamLeaderId !== userId) {
      throw new Error('Permission denied');
    }

    const modifier = { name: team.name, avatarUrl };

    if (name !== team.name) {
      modifier.name = name;
    }

    await this.updateOne({ _id: teamId }, { $set: modifier }, { runValidators: true });

    return this.findById(teamId, 'name avatarUrl slug defaultTeam').setOptions({ lean: true });
  }

  public static getAllTeamsForUser(userId: string) {
    console.log(`userId:${userId}`);
    return this.find({ memberIds: userId }).setOptions({ lean: true });
  }

  public static async removeMember({ teamId, teamLeaderId, userId }) {
    const team = await this.findById(teamId).select('memberIds teamLeaderId');

    if (!team) {
      throw new Error('Team does not exist');
    }

    if (team.teamLeaderId !== teamLeaderId || teamLeaderId === userId) {
      throw new Error('Permission denied');
    }

    await this.findByIdAndUpdate(teamId, { $pull: { memberIds: userId } });
  }

  public static async subscribeTeam({
    session,
    team,
  }: {
    session: Stripe.Checkout.Session;
    team: TeamDocument;
  }) {
    if (!session.subscription) {
      throw new Error('Not subscribed');
    }

    if (!team) {
      throw new Error('User not found.');
    }

    if (team.isSubscriptionActive) {
      throw new Error('Team is already subscribed.');
    }

    const stripeSubscription = session.subscription as Stripe.Subscription;
    if (stripeSubscription.canceled_at) {
      throw new Error('Unsubscribed');
    }

    await this.updateOne({ _id: team._id }, { stripeSubscription, isSubscriptionActive: true });
  }

  public static async cancelSubscription({ teamLeaderId, teamId }) {
    const team = await this.findById(teamId).select(
      'teamLeaderId isSubscriptionActive stripeSubscription',
    );

    if (team.teamLeaderId !== teamLeaderId) {
      throw new Error('You do not have permission to subscribe Team.');
    }

    if (!team.isSubscriptionActive) {
      throw new Error('Team is already unsubscribed.');
    }

    const cancelledSubscriptionObj = await cancelSubscription({
      subscriptionId: team.stripeSubscription.id,
    });

    return this.findByIdAndUpdate(
      teamId,
      {
        stripeSubscription: cancelledSubscriptionObj,
        isSubscriptionActive: false,
      },
      { new: true, runValidators: true },
    )
      .select('isSubscriptionActive stripeSubscription')
      .setOptions({ lean: true });
  }

  public static async cancelSubscriptionAfterFailedPayment({ subscriptionId }) {
    const team: any = await this.find({ 'stripeSubscription.id': subscriptionId })
      .select('teamLeaderId isSubscriptionActive stripeSubscription isPaymentFailed')
      .setOptions({ lean: true });
    if (!team.isSubscriptionActive) {
      throw new Error('Team is already unsubscribed.');
    }
    if (team.isPaymentFailed) {
      throw new Error('Team is already unsubscribed after failed payment.');
    }
    const cancelledSubscriptionObj = await cancelSubscription({
      subscriptionId,
    });
    return this.findByIdAndUpdate(
      team._id,
      {
        stripeSubscription: cancelledSubscriptionObj,
        isSubscriptionActive: false,
        isPaymentFailed: true,
      },
      { new: true, runValidators: true },
    )
      .select('isSubscriptionActive stripeSubscription isPaymentFailed')
      .setOptions({ lean: true });
  }
}

mongoSchema.loadClass(TeamClass);

const Team = mongoose.model<TeamDocument, TeamModel>('Team', mongoSchema);

export default Team;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\server\models\User.ts -----

import * as _ from 'lodash';
import * as mongoose from 'mongoose';
import Stripe from 'stripe';

import sendEmail from '../aws-ses';
import { addToMailchimp } from '../mailchimp';
import { generateSlug } from '../utils/slugify';
import getEmailTemplate from './EmailTemplate';
import Team, { TeamDocument } from './Team';

import { getListOfInvoices } from '../stripe';

const mongoSchema = new mongoose.Schema({
  slug: {
    type: String,
    required: true,
    unique: true,
  },
  createdAt: {
    type: Date,
    required: true,
  },
  email: {
    type: String,
    required: true,
    unique: true,
  },
  displayName: String,
  avatarUrl: String,
  googleId: {
    type: String,
    unique: true,
    sparse: true,
  },
  googleToken: {
    accessToken: String,
    refreshToken: String,
  },
  isSignedupViaGoogle: {
    type: Boolean,
    required: true,
    default: false,
  },
  darkTheme: Boolean,
  defaultTeamSlug: {
    type: String,
    default: '',
  },
  stripeCustomer: {
    id: String,
    object: String,
    created: Number,
    currency: String,
    default_source: String,
    description: String,
  },
  stripeCard: {
    id: String,
    object: String,
    brand: String,
    funding: String,
    country: String,
    last4: String,
    exp_month: Number,
    exp_year: Number,
  },
  hasCardInformation: {
    type: Boolean,
    default: false,
  },
  stripeListOfInvoices: {
    object: String,
    has_more: Boolean,
    data: [
      {
        id: String,
        object: String,
        amount_paid: Number,
        created: Number,
        customer: String,
        subscription: String,
        hosted_invoice_url: String,
        billing: String,
        paid: Boolean,
        number: String,
        teamId: String,
        teamName: String,
      },
    ],
  },
});

export interface UserDocument extends mongoose.Document {
  slug: string;
  createdAt: Date;
  email: string;
  displayName: string;
  avatarUrl: string;
  googleId: string;
  googleToken: { accessToken: string; refreshToken: string };
  isSignedupViaGoogle: boolean;
  darkTheme: boolean;
  defaultTeamSlug: string;
  stripeCustomer: {
    id: string;
    default_source: string;
    created: number;
    object: string;
    description: string;
  };
  stripeCard: {
    id: string;
    object: string;
    brand: string;
    country: string;
    last4: string;
    exp_month: number;
    exp_year: number;
    funding: string;
  };
  hasCardInformation: boolean;
  stripeListOfInvoices: {
    object: string;
    has_more: boolean;
    data: [
      {
        id: string;
        object: string;
        amount_paid: number;
        date: number;
        customer: string;
        subscription: string;
        hosted_invoice_url: string;
        billing: string;
        paid: boolean;
        number: string;
        teamId: string;
        teamName: string;
      },
    ];
  };
}

interface UserModel extends mongoose.Model<UserDocument> {
  getUserBySlug({ slug }: { slug: string }): Promise<UserDocument>;

  updateProfile({
    userId,
    name,
    avatarUrl,
  }: {
    userId: string;
    name: string;
    avatarUrl: string;
  }): Promise<UserDocument[]>;

  publicFields(): string[];

  signInOrSignUpViaGoogle({
    googleId,
    email,
    displayName,
    avatarUrl,
    googleToken,
  }: {
    googleId: string;
    email: string;
    displayName: string;
    avatarUrl: string;
    googleToken: { accessToken?: string; refreshToken?: string };
  }): Promise<UserDocument>;

  signInOrSignUpByPasswordless({
    uid,
    email,
  }: {
    uid: string;
    email: string;
  }): Promise<UserDocument>;

  toggleTheme({ userId, darkTheme }: { userId: string; darkTheme: boolean }): Promise<void>;

  getMembersForTeam({
    userId,
    teamId,
  }: {
    userId: string;
    teamId: string;
  }): Promise<UserDocument[]>;

  checkPermissionAndGetTeam({
    userId,
    teamId,
  }: {
    userId: string;
    teamId: string;
  }): Promise<TeamDocument>;

  saveStripeCustomerAndCard({
    user,
    session,
  }: {
    session: Stripe.Checkout.Session;
    user: UserDocument;
  }): Promise<void>;

  changeStripeCard({
    session,
    user,
  }: {
    session: Stripe.Checkout.Session;
    user: UserDocument;
  }): Promise<void>;

  getListOfInvoicesForCustomer({ userId }: { userId: string }): Promise<UserDocument>;
}

class UserClass extends mongoose.Model {
  public static async getUserBySlug({ slug }) {
    console.log('Static method: getUserBySlug');

    return this.findOne({ slug }, 'email displayName avatarUrl').setOptions({ lean: true });
  }

  public static async updateProfile({ userId, name, avatarUrl }) {
    console.log('Static method: updateProfile');

    const user = await this.findById(userId, 'slug displayName');

    const modifier = { displayName: user.displayName, avatarUrl, slug: user.slug };

    console.log(user.slug);

    if (name !== user.displayName) {
      modifier.displayName = name;
      modifier.slug = await generateSlug(this, name);
    }

    return this.findByIdAndUpdate(userId, { $set: modifier }, { new: true, runValidators: true })
      .select('displayName avatarUrl slug')
      .setOptions({ lean: true });
  }

  public static publicFields(): string[] {
    return [
      '_id',
      'id',
      'displayName',
      'email',
      'avatarUrl',
      'slug',
      'isSignedupViaGoogle',
      'darkTheme',
      'defaultTeamSlug',
      'stripeCard',
      'hasCardInformation',
      'stripeListOfInvoices',
    ];
  }

  public static async signInOrSignUpViaGoogle({
    googleId,
    email,
    displayName,
    avatarUrl,
    googleToken,
  }) {
    const user = await this.findOne({ email })
      .select([...this.publicFields(), 'googleId'].join(' '))
      .setOptions({ lean: true });

    if (user) {
      if (_.isEmpty(googleToken) && user.googleId) {
        return user;
      }

      const modifier = { googleId };
      if (googleToken.accessToken) {
        modifier['googleToken.accessToken'] = googleToken.accessToken;
      }

      if (googleToken.refreshToken) {
        modifier['googleToken.refreshToken'] = googleToken.refreshToken;
      }

      await this.updateOne({ email }, { $set: modifier });

      return user;
    }

    const slug = await generateSlug(this, displayName);

    const newUser = await this.create({
      createdAt: new Date(),
      googleId,
      email,
      googleToken,
      displayName,
      avatarUrl,
      slug,
      isSignedupViaGoogle: true,
      defaultTeamSlug: '',
      darkTheme: false,
    });

    const emailTemplate = await getEmailTemplate('welcome', { userName: displayName });

    if (!emailTemplate) {
      throw new Error('Welcome email template not found');
    }

    try {
      await sendEmail({
        from: `Kelly from saas-app.async-await.com <${process.env.EMAIL_SUPPORT_FROM_ADDRESS}>`,
        to: [email],
        subject: emailTemplate.subject,
        body: emailTemplate.message,
      });
    } catch (err) {
      console.error('Email sending error:', err);
    }

    try {
      await addToMailchimp({ email, listName: 'signups' });
    } catch (error) {
      console.error('Mailchimp error:', error);
    }

    return _.pick(newUser, this.publicFields());
  }

  public static async signInOrSignUpByPasswordless({ uid, email }) {
    const user = await this.findOne({ email })
      .select(this.publicFields().join(' '))
      .setOptions({ lean: true });

    if (user) {
      throw Error('User already exists');
    }

    const slug = await generateSlug(this, email);

    const newUser = await this.create({
      _id: uid,
      createdAt: new Date(),
      email,
      slug,
      defaultTeamSlug: '',
    });

    const emailTemplate = await getEmailTemplate('welcome', { userName: email });

    if (!emailTemplate) {
      throw new Error('Email template "welcome" not found in database.');
    }

    try {
      await sendEmail({
        from: `Kelly from saas-app.async-await.com <${process.env.EMAIL_SUPPORT_FROM_ADDRESS}>`,
        to: [email],
        subject: emailTemplate.subject,
        body: emailTemplate.message,
      });
    } catch (err) {
      console.error('Email sending error:', err);
    }

    try {
      await addToMailchimp({ email, listName: 'signups' });
    } catch (error) {
      console.error('Mailchimp error:', error);
    }

    return _.pick(newUser, this.publicFields());
  }

  public static toggleTheme({ userId, darkTheme }) {
    return this.updateOne({ _id: userId }, { darkTheme: !!darkTheme });
  }

  public static async getMembersForTeam({ userId, teamId }) {
    const team = await this.checkPermissionAndGetTeam({ userId, teamId });

    return this.find({ _id: { $in: team.memberIds } })
      .select(this.publicFields().join(' '))
      .setOptions({ lean: true });
  }

  public static async saveStripeCustomerAndCard({
    user,
    session,
  }: {
    session: Stripe.Checkout.Session;
    user: UserDocument;
  }) {
    if (!user) {
      throw new Error('User not found.');
    }

    const stripeSubscription = session.subscription as Stripe.Subscription;

    const stripeCard =
      (stripeSubscription.default_payment_method &&
        (stripeSubscription.default_payment_method as Stripe.PaymentMethod).card) ||
      undefined;

    const hasCardInformation = !!stripeCard;

    await this.updateOne(
      { _id: user._id },
      {
        stripeCustomer: session.customer,
        stripeCard,
        hasCardInformation,
      },
    );
  }

  public static async changeStripeCard({
    session,
    user,
  }: {
    session: Stripe.Checkout.Session;
    user: UserDocument;
  }): Promise<void> {
    if (!user) {
      throw new Error('User not found.');
    }

    const si: Stripe.SetupIntent = session.setup_intent as Stripe.SetupIntent;
    const pm: Stripe.PaymentMethod = si.payment_method as Stripe.PaymentMethod;

    if (!pm.card) {
      throw new Error('No card found.');
    }
    await this.updateOne({ _id: user._id }, { stripeCard: pm.card, hasCardInformation: true });
  }

  public static async getListOfInvoicesForCustomer({ userId }) {
    const user = await this.findById(userId, 'stripeCustomer');

    if (!user.stripeCustomer.id) {
      throw new Error('You are not a customer and you have no payment history.');
    }

    const newListOfInvoices = await getListOfInvoices({
      customerId: user.stripeCustomer.id,
    });

    if (newListOfInvoices.data === undefined || newListOfInvoices.data.length === 0) {
      throw new Error('You are a customer. But there is no payment history.');
    }

    const modifier = {
      stripeListOfInvoices: newListOfInvoices,
    };

    return this.findByIdAndUpdate(userId, { $set: modifier }, { new: true, runValidators: true })
      .select('stripeListOfInvoices')
      .setOptions({ lean: true });
  }

  private static async checkPermissionAndGetTeam({ userId, teamId }) {
    console.log(userId, teamId);

    if (!userId || !teamId) {
      throw new Error('Bad data');
    }

    const team = await Team.findById(teamId).select('memberIds').setOptions({ lean: true });

    if (!team || team.memberIds.indexOf(userId) === -1) {
      throw new Error('Team not found');
    }

    return team;
  }
}

mongoSchema.loadClass(UserClass);

const User = mongoose.model<UserDocument, UserModel>('User', mongoSchema);

export default User;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\server\utils\slugify.ts -----

import * as _ from 'lodash';

const slugify = (text) => _.kebabCase(text);

async function createUniqueSlug(Model, slug, count, filter) {
  const obj = await Model.findOne({ slug: `${slug}-${count}`, ...filter })
    .select('_id')
    .setOptions({ lean: true });

  if (!obj) {
    return `${slug}-${count}`;
  }

  return createUniqueSlug(Model, slug, count + 1, filter);
}

async function generateSlug(Model, name, filter = {}) {
  const origSlug = slugify(name);

  const obj = await Model.findOne({ slug: origSlug, ...filter })
    .select('_id')
    .setOptions({ lean: true });

  if (!obj) {
    return origSlug;
  }

  return createUniqueSlug(Model, origSlug, 1, filter);
}

async function generateRandomSlug(Model, filter = {}) {
  const randomString12 =
    Math.random().toString(36).substring(2, 8) + Math.random().toString(36).substring(2, 8);

  const obj = await Model.findOne({ slug: randomString12, ...filter })
    .select('_id')
    .setOptions({ lean: true });

  if (!obj) {
    return randomString12;
  }

  return generateRandomSlug(Model, filter);
}

export { generateSlug, generateRandomSlug };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\server\utils\sum.ts -----

function sum(a, b) {
  return a + b;
}

export { sum };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\server\aws-s3.ts -----

import * as url from 'url';
import * as aws from 'aws-sdk';

async function signRequestForUpload({
  fileName,
  fileType,
  prefix,
  bucket,
}: {
  fileName: string;
  fileType: string;
  prefix: string;
  bucket: string;
}) {
  const randomStringForPrefix =
    Math.random().toString(36).substring(2, 12) + Math.random().toString(36).substring(2, 12);

  const key = `${prefix}/${randomStringForPrefix}/${fileName}`;

  const acl = 'public-read';

  const params = {
    Bucket: bucket,
    Key: key,
    Expires: 60,
    ContentType: fileType,
    ACL: acl,
  };

  console.log(key, bucket);

  const s3 = new aws.S3({
    apiVersion: 'latest',
    region: process.env.AWS_REGION,
    accessKeyId: process.env.AWS_ACCESSKEYID,
    secretAccessKey: process.env.AWS_SECRETACCESSKEY,
  });

  return new Promise((resolve, reject) => {
    s3.getSignedUrl('putObject', params, (err, data) => {
      const parsedUrl = url.parse(data);

      const returnData = {
        signedRequest: data,
        url: `${parsedUrl.protocol}//${parsedUrl.hostname}${parsedUrl.pathname}`,
      };

      console.log(returnData);

      if (err) {
        console.error(err);
        reject(err);
      } else {
        resolve(returnData);
      }
    });
  });
}

export { signRequestForUpload };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\server\aws-ses.ts -----

import * as aws from 'aws-sdk';

export default function sendEmail(options) {
  const ses = new aws.SES({
    apiVersion: 'latest',
    region: process.env.AWS_REGION,
    accessKeyId: process.env.AWS_ACCESSKEYID,
    secretAccessKey: process.env.AWS_SECRETACCESSKEY,
  });

  return new Promise((resolve, reject) => {
    ses.sendEmail(
      {
        Source: options.from,
        Destination: {
          CcAddresses: options.cc,
          ToAddresses: options.to,
        },
        Message: {
          Subject: {
            Data: options.subject,
          },
          Body: {
            Html: {
              Data: options.body,
            },
          },
        },
        ReplyToAddresses: options.replyTo,
      },
      (err, info) => {
        if (err) {
          reject(err);
        } else {
          resolve(info);
        }
      },
    );
  });
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\server\google-auth.ts -----

import * as passport from 'passport';
import { OAuth2Strategy as Strategy } from 'passport-google-oauth';

import User, { UserDocument } from './models/User';
import Invitation from './models/Invitation';

const dev = process.env.NODE_ENV !== 'production';

function setupGoogle({ server }) {
  if (!process.env.GOOGLE_CLIENTID) {
    return;
  }

  const verify = async (req, accessToken, refreshToken, profile, done) => {
    let email;
    let avatarUrl;

    if (profile.emails) {
      email = profile.emails[0].value;
    }

    if (profile.photos && profile.photos.length > 0) {
      avatarUrl = profile.photos[0].value.replace('sz=50', 'sz=128');
    }

    try {
      const user = await User.signInOrSignUpViaGoogle({
        googleId: profile.id,
        email,
        googleToken: { accessToken, refreshToken },
        displayName: profile.displayName,
        avatarUrl,
      });

      let teamSlugOfInvitedTeam;
      if (user && req.session.invitationToken) {
        teamSlugOfInvitedTeam = await Invitation.addUserToTeam({
          token: req.session.invitationToken,
          user,
        }).catch((err) => console.error(err));
      }

      user.defaultTeamSlug = teamSlugOfInvitedTeam ? teamSlugOfInvitedTeam : user.defaultTeamSlug;

      done(null, user);
    } catch (err) {
      done(err);
      console.error(err);
    }
  };

  passport.use(
    new Strategy(
      {
        clientID: process.env.GOOGLE_CLIENTID,
        clientSecret: process.env.GOOGLE_CLIENTSECRET,
        callbackURL: `${dev ? process.env.URL_API : process.env.PRODUCTION_URL_API}/oauth2callback`,
        passReqToCallback: true,
      },
      verify,
    ),
  );

  passport.serializeUser((user: UserDocument, done) => {
    done(null, user._id);
  });

  passport.deserializeUser((id, done) => {
    User.findById(id, User.publicFields())
      .then((user) => {
        done(null, user);
      })
      .catch((error) => {
        done(error, null);
      });
  });

  server.use(passport.initialize());
  server.use(passport.session());

  server.get('/auth/google', (req, res, next) => {
    const options = {
      scope: ['profile', 'email'],
      prompt: 'select_account',
    };

    if (req.query && req.query.invitationToken) {
      req.session.invitationToken = req.query.invitationToken;
    } else {
      req.session.invitationToken = null;
    }

    passport.authenticate('google', options)(req, res, next);
  });

  server.get(
    '/oauth2callback',
    passport.authenticate('google', {
      failureRedirect: '/login',
    }),
    async (req, res) => {
      let teamSlugOfInvitedTeam;

      if (req.user && req.session.invitationToken) {
        teamSlugOfInvitedTeam = await Invitation.addUserToTeam({
          token: req.session.invitationToken,
          user: req.user,
        }).catch((err) => console.error(err));

        req.session.invitationToken = null;
      }

      let redirectUrlAfterLogin;
      const defaultTeamSlug = req.user && req.user.defaultTeamSlug;

      if (teamSlugOfInvitedTeam || defaultTeamSlug) {
        redirectUrlAfterLogin = `/your-settings`;
      } else {
        redirectUrlAfterLogin = `/create-team`;
      }

      res.redirect(
        `${dev ? process.env.URL_APP : process.env.PRODUCTION_URL_APP}${redirectUrlAfterLogin}`,
      );
    },
  );
}

export { setupGoogle };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\server\logger.ts -----

import * as winston from 'winston';

const dev = process.env.NODE_ENV !== 'production';

const logger = winston.createLogger({
  format: winston.format.simple(),
  level: dev ? 'debug' : 'info',
  transports: [new winston.transports.Console()],
});

export default logger;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\server\mailchimp.ts -----

import fetch, { Response } from 'node-fetch';

// eslint-disable-next-line
require('dotenv').config();

const LIST_IDS = {
  signups: process.env.MAILCHIMP_SAAS_ALL_LIST_ID,
};

function callAPI({
  path,
  method,
  data,
}: {
  path: string;
  method: string;
  data: {
    email_address: string;
    status: string;
  };
}): Promise<Response> {
  const ROOT_URI = `https://${process.env.MAILCHIMP_REGION}.api.mailchimp.com/3.0`;

  return fetch(`${ROOT_URI}${path}`, {
    method,
    headers: {
      Accept: 'application/json',
      Authorization: `Basic ${Buffer.from(`apikey:${process.env.MAILCHIMP_API_KEY}`).toString(
        'base64',
      )}`,
    },
    body: JSON.stringify(data),
  });
}

async function addToMailchimp({ email, listName }: { email: string; listName: string }) {
  const data = {
    email_address: email,
    status: 'subscribed',
  };

  const path = `/lists/${LIST_IDS[listName]}/members/`;

  await callAPI({ path, method: 'POST', data });
}

export { addToMailchimp };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\server\passwordless-auth.ts -----

import * as passwordless from 'passwordless';

import sendEmail from './aws-ses';
import getEmailTemplate from './models/EmailTemplate';
import User from './models/User';
import PasswordlessMongoStore from './passwordless-token-mongostore';
import Invitation from './models/Invitation';

function setupPasswordless({ server }) {
  const mongoStore = new PasswordlessMongoStore();

  const dev = process.env.NODE_ENV !== 'production';

  passwordless.addDelivery(async (tokenToSend, uidToSend, recipient, callback) => {
    try {
      const template = await getEmailTemplate('login', {
        loginURL: `${
          dev ? process.env.URL_API : process.env.PRODUCTION_URL_API
        }/auth/logged_in?token=${tokenToSend}&uid=${encodeURIComponent(uidToSend)}`,
      });

      await sendEmail({
        from: `Kelly from saas-app.async-await.com <${process.env.EMAIL_SUPPORT_FROM_ADDRESS}>`,
        to: [recipient],
        subject: template.subject,
        body: template.message,
      });

      callback();
    } catch (err) {
      console.error('Email sending error:', err);
      callback(err);
    }
  });

  passwordless.init(mongoStore);
  server.use(passwordless.sessionSupport());

  server.use((req, __, next) => {
    if (req.user && typeof req.user === 'string') {
      User.findById(req.user, User.publicFields())
        .then((user) => {
          req.user = user;
          console.log('passwordless middleware');
          next();
        })
        .catch((err) => {
          next(err);
        });
    } else {
      next();
    }
  });

  server.post(
    '/auth/email-login-link',
    passwordless.requestToken(async (email, __, callback) => {
      try {
        const user = await User.findOne({ email }).select('_id').setOptions({ lean: true });

        if (user) {
          callback(null, user._id);
        } else {
          const id = await mongoStore.storeOrUpdateByEmail(email);
          callback(null, id);
        }
      } catch (error) {
        callback(error, null);
      }
    }),
    (req, res) => {
      if (req.query && req.query.invitationToken) {
        req.session.invitationToken = req.query.invitationToken;
      } else {
        req.session.invitationToken = null;
      }

      res.json({ done: 1 });
    },
  );

  server.get(
    '/auth/logged_in',
    passwordless.acceptToken(),
    (req, __, next) => {
      if (req.user && typeof req.user === 'string') {
        User.findById(req.user, User.publicFields())
          .then((user) => {
            req.user = user;
            next();
          })
          .catch((err) => {
            next(err);
          });
      } else {
        next();
      }
    },
    async (req, res) => {
      let teamSlugOfInvitedTeam;

      if (req.user && req.session.invitationToken) {
        teamSlugOfInvitedTeam = await Invitation.addUserToTeam({
          token: req.session.invitationToken,
          user: req.user,
        }).catch((err) => console.error(err));

        req.session.invitationToken = null;
      }

      let redirectUrlAfterLogin;
      const defaultTeamSlug = req.user && req.user.defaultTeamSlug;

      if (teamSlugOfInvitedTeam || defaultTeamSlug) {
        redirectUrlAfterLogin = `/your-settings`;
      } else {
        redirectUrlAfterLogin = `/create-team`;
      }

      res.redirect(
        `${dev ? process.env.URL_APP : process.env.PRODUCTION_URL_APP}${redirectUrlAfterLogin}`,
      );
    },
  );

  server.get('/logout', (req, res, next) => {
    req.logout((err) => {
      if (err) {
        next(err);
      }

      if (req.query && req.query.invitationToken) {
        res.redirect(
          `${dev ? process.env.URL_APP : process.env.PRODUCTION_URL_APP}/invitation?token=${
            req.query.invitationToken
          }`,
        );
      } else {
        res.redirect(`${dev ? process.env.URL_APP : process.env.PRODUCTION_URL_APP}/login`);
      }
    });
  });
}

export { setupPasswordless };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\server\passwordless-token-mongostore.ts -----

import * as bcrypt from 'bcryptjs';
import * as mongoose from 'mongoose';
import * as TokenStore from 'passwordless-tokenstore';
import * as util from 'util';

import User from './models/User';

interface TokenDocument extends mongoose.Document {
  hashedToken: string;
  uid: string;
  ttl: Date;
  originUrl: string;
  email: string;
}

const mongoSchema = new mongoose.Schema({
  hashedToken: {
    type: String,
    required: true,
  },
  uid: {
    type: String,
    required: true,
    unique: true,
  },
  ttl: {
    type: Date,
    required: true,
    expires: 0,
  },
  originUrl: String,
  email: String,
});

const PasswordlessToken = mongoose.model<TokenDocument>(
  'PasswordlessToken',
  mongoSchema,
  'passwordless-token',
);

function MongoStore(options = {}) {
  TokenStore.call(this);

  this._options = options || {};
}

util.inherits(MongoStore, TokenStore);

MongoStore.prototype.authenticate = async function (token, uid, callback) {
  if (!token || !uid || !callback) {
    throw new Error('TokenStore:authenticate called with invalid parameters');
  }

  try {
    const tokenDoc = await PasswordlessToken.findOne({ uid, ttl: { $gt: new Date() } }).setOptions({
      lean: true,
    });

    if (tokenDoc) {
      const isMatch = await bcrypt.compare(token, tokenDoc.hashedToken);
      if (isMatch) {
        if (tokenDoc.email) {
          await User.signInOrSignUpByPasswordless({ uid, email: tokenDoc.email });
        }

        callback(null, true, tokenDoc.originUrl);
      } else {
        callback(null, false, null);
      }
    } else {
      callback(null, false, null);
    }
  } catch (error) {
    callback(error, false, null);
  }
};

MongoStore.prototype.storeOrUpdate = async function (token, uid, msToLive, originUrl, callback) {
  if (!token || !uid || !msToLive || !callback) {
    throw new Error('TokenStore:storeOrUpdate called with invalid parameters');
  }

  const saltRounds = 10;

  try {
    const hashedToken = await bcrypt.hash(token, saltRounds);
    const newRecord = { hashedToken, uid, ttl: new Date(Date.now() + msToLive), originUrl };

    await PasswordlessToken.updateOne(
      { uid },
      { $set: newRecord },
      { upsert: true, runValidators: true },
    );
    callback();
  } catch (error) {
    callback(error);
  }
};

MongoStore.prototype.invalidateUser = async function (uid, callback) {
  if (!uid || !callback) {
    throw new Error('TokenStore:invalidateUser called with invalid parameters');
  }

  try {
    await PasswordlessToken.deleteOne({ uid });
    callback();
  } catch (error) {
    callback(error);
  }
};

MongoStore.prototype.clear = async function (callback) {
  if (!callback) {
    throw new Error('TokenStore:clear called with invalid parameters');
  }

  try {
    await PasswordlessToken.deleteMany({});
    callback();
  } catch (error) {
    callback(error);
  }
};

MongoStore.prototype.length = function (callback) {
  PasswordlessToken.countDocuments(callback);
};

MongoStore.prototype.storeOrUpdateByEmail = async function addEmail(email: string) {
  if (!email) {
    throw new Error('TokenStore:addEmail called with invalid parameters');
  }

  const obj = await PasswordlessToken.findOne({ email }).select('uid').setOptions({ lean: true });

  if (obj) {
    return obj.uid;
  }

  const uid = new mongoose.Types.ObjectId().toHexString();
  await PasswordlessToken.updateOne({ uid }, { email }, { upsert: true });

  return uid;
};

export default MongoStore;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\server\server.ts -----

// eslint-disable-next-line @typescript-eslint/no-var-requires
const MongoStore = require('connect-mongo');

import * as cors from 'cors';
import * as express from 'express';
import * as session from 'express-session';
import * as httpModule from 'http';
import * as mongoose from 'mongoose';

import api from './api';
import { setupGoogle } from './google-auth';
import { setupPasswordless } from './passwordless-auth';
import { setupSockets } from './sockets';
import { stripeWebhookAndCheckoutCallback } from './stripe';

import logger from './logger';

import * as compression from 'compression';
import helmet from 'helmet';

// eslint-disable-next-line
require('dotenv').config();

const dev = process.env.NODE_ENV !== 'production';
const port = process.env.PORT || 8000;
const MONGO_URL = dev ? process.env.MONGO_URL_TEST : process.env.MONGO_URL;

// check connection
(async () => {
  try {
    mongoose.set('strictQuery', false);
    await mongoose.connect(MONGO_URL);
    logger.info('connected to db');

    // async tasks, for ex, inserting email templates to db
    // logger.info('finished async tasks');
  } catch (err) {
    console.log('error: ' + err);
  }
})();

const server = express();

server.use(
  cors({
    origin: dev ? process.env.URL_APP : process.env.PRODUCTION_URL_APP,
    methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',
    credentials: true,
  }),
);

server.use(helmet());
server.use(compression());

stripeWebhookAndCheckoutCallback({ server });

server.use(express.json());

const sessionOptions = {
  name: process.env.SESSION_NAME,
  secret: process.env.SESSION_SECRET,
  store: MongoStore.create({
    mongoUrl: MONGO_URL,
    ttl: 14 * 24 * 60 * 60, // save session 14 days
  }),
  resave: false,
  saveUninitialized: false,
  cookie: {
    httpOnly: true,
    maxAge: 14 * 24 * 60 * 60 * 1000, // expires in 14 days
    domain: dev ? 'localhost' : process.env.COOKIE_DOMAIN,
  } as any,
};

if (!dev) {
  server.set('trust proxy', 1); // sets req.hostname, req.ip
  sessionOptions.cookie.secure = true; // sets cookie over HTTPS only
}

const sessionMiddleware = session(sessionOptions);
server.use(sessionMiddleware);

setupGoogle({ server });
setupPasswordless({ server });

api(server);

const httpServer = httpModule.createServer(server);
setupSockets({
  httpServer,
  origin: dev ? process.env.URL_APP : process.env.PRODUCTION_URL_APP,
  sessionMiddleware,
});

server.get('*', (_, res) => {
  res.sendStatus(403);
});

httpServer.listen(port, () => {
  logger.debug('debug right before info');
  logger.info(`> Ready on ${dev ? process.env.URL_API : process.env.PRODUCTION_URL_API}`);
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\server\sockets.ts -----

import { Response } from 'express';
import { Server } from 'socket.io';

import { DiscussionDocument } from './models/Discussion';
import { PostDocument } from './models/Post';

let io: Server = null;
// const dev = process.env.NODE_ENV !== 'production';

function setupSockets({ httpServer, origin, sessionMiddleware }) {
  if (io === null) {
    io = new Server(httpServer, {
      cors: {
        origin,
        methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',
        credentials: true,
      },
      cookie: {
        name: 'io',
        httpOnly: true,
        maxAge: 14 * 24 * 60 * 60 * 1000, // expires in 14 days
        domain: 'localhost',
        secure: false,
      },
      serveClient: false,
      transports: ['polling', 'websocket'],
    });

    const wrap = (middleware) => (socket, next) => middleware(socket.request, {} as Response, next);

    io.use(wrap(sessionMiddleware));

    io.on('connection', (socket: any) => {
      if (
        !socket.request.session ||
        ((!socket.request.session.passport || !socket.request.session.passport.user) &&
          !socket.request.session.passwordless)
      ) {
        socket.disconnect(true);
        return;
      }

      socket.on('joinTeamRoom', (teamId) => {
        console.log(`    joinTeamRoom ${teamId}`);
        socket.join(`teamRoom-${teamId}`);
      });

      socket.on('leaveTeamRoom', (teamId) => {
        console.log(`** leaveTeamRoom ${teamId}`);
        socket.leave(`teamRoom-${teamId}`);
      });

      socket.on('joinDiscussionRoom', (discussionId) => {
        console.log(`    joinDiscussionRoom ${discussionId}`);
        socket.join(`discussionRoom-${discussionId}`);
      });

      socket.on('leaveDiscussionRoom', (discussionId) => {
        console.log(`** leaveDiscussionRoom ${discussionId}`);
        socket.leave(`discussionRoom-${discussionId}`);
      });

      socket.on('disconnect', (reason) => {
        console.log(`disconnected`, `reason: ` + reason);
      });
    });
  }
}

function getSocket(socketId?: string) {
  if (!io) {
    return null;
  }

  if (socketId && io.sockets.sockets.get(socketId)) {
    return io.sockets.sockets.get(socketId).broadcast;
  } else {
    return io;
  }
}

function discussionAdded({
  socketId,
  discussion,
}: {
  socketId?: string;
  discussion: DiscussionDocument;
}) {
  const roomName = `teamRoom-${discussion.teamId}`;

  const socket = getSocket(socketId);
  if (socket) {
    socket.to(roomName).emit('discussionEvent', { actionType: 'added', discussion });
  }
}

function discussionEdited({
  socketId,
  discussion,
}: {
  socketId?: string;
  discussion: DiscussionDocument;
}) {
  const roomName = `teamRoom-${discussion.teamId}`;
  const socket = getSocket(socketId);

  if (socket) {
    socket.to(roomName).emit('discussionEvent', {
      actionType: 'edited',
      discussion,
    });
  }
}

function discussionDeleted({
  socketId,
  teamId,
  id,
}: {
  socketId?: string;
  teamId: string;
  id: string;
}) {
  const roomName = `teamRoom-${teamId}`;
  const socket = getSocket(socketId);

  if (socket) {
    socket.to(roomName).emit('discussionEvent', { actionType: 'deleted', id });
  }
}

function postAdded({ socketId, post }: { socketId?: string; post: PostDocument }) {
  const roomName = `discussionRoom-${post.discussionId}`;

  const socket = getSocket(socketId);
  if (socket) {
    socket.to(roomName).emit('postEvent', { actionType: 'added', post });
  }
}

function postEdited({ socketId, post }: { socketId?: string; post: PostDocument }) {
  const roomName = `discussionRoom-${post.discussionId}`;

  const socket = getSocket(socketId);
  if (socket) {
    socket.to(roomName).emit('postEvent', { actionType: 'edited', post });
  }
}

function postDeleted({
  socketId,
  id,
  discussionId,
}: {
  socketId?: string;
  id: string;
  discussionId: string;
}) {
  const roomName = `discussionRoom-${discussionId}`;

  const socket = getSocket(socketId);
  if (socket) {
    socket.to(roomName).emit('postEvent', { actionType: 'deleted', id });
  }
}

export {
  setupSockets,
  postAdded,
  postEdited,
  postDeleted,
  discussionAdded,
  discussionEdited,
  discussionDeleted,
};

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\server\stripe.ts -----

import * as dotenv from "dotenv";
import * as express from "express";
import Stripe from "stripe";

import Team from "./models/Team";
import User from "./models/User";

import logger from "./logger";

dotenv.config();

const dev = process.env.NODE_ENV !== "production";

const stripeInstance = new Stripe(dev ? process.env.STRIPE_TEST_SECRETKEY : process.env.STRIPE_LIVE_SECRETKEY, {
  apiVersion: "2025-02-24.acacia",
});

function createSession({
  userId,
  teamId,
  teamSlug,
  customerId,
  subscriptionId,
  userEmail,
  mode,
}: {
  userId: string;
  teamId: string;
  teamSlug: string;
  customerId: string;
  subscriptionId: string;
  userEmail: string;
  mode: Stripe.Checkout.SessionCreateParams.Mode;
}) {
  const params: Stripe.Checkout.SessionCreateParams = {
    customer_email: customerId ? undefined : userEmail,
    customer: customerId,
    payment_method_types: ["card"],
    mode,
    success_url: `${
      dev ? process.env.URL_API : process.env.PRODUCTION_URL_API
    }/stripe/checkout-completed/{CHECKOUT_SESSION_ID}`,
    cancel_url: `${
      dev ? process.env.URL_APP : process.env.PRODUCTION_URL_APP
    }/teams/${teamSlug}/billing?redirectMessage=Checkout%20canceled`,
    metadata: { userId, teamId },
  };

  console.log(process.env.STRIPE_TEST_SECRETKEY, process.env.STRIPE_TEST_PRICEID);

  if (mode === "subscription") {
    params.line_items = [
      {
        price: dev ? process.env.STRIPE_TEST_PRICEID : process.env.STRIPE_LIVE_PRICEID,
        quantity: 1,
      },
    ];
  } else if (mode === "setup") {
    if (!customerId || !subscriptionId) {
      throw new Error("customerId and subscriptionId required");
    }

    params.setup_intent_data = {
      metadata: { customer_id: customerId, subscription_id: subscriptionId },
    };
  }

  return stripeInstance.checkout.sessions.create(params);
}

function retrieveSession({ sessionId }: { sessionId: string }) {
  return stripeInstance.checkout.sessions.retrieve(sessionId, {
    expand: [
      "setup_intent",
      "setup_intent.payment_method",
      "customer",
      "subscription",
      "subscription.default_payment_method",
    ],
  });
}

function updateCustomer(customerId, params: Stripe.CustomerUpdateParams) {
  logger.debug("updating customer", customerId);
  return stripeInstance.customers.update(customerId, params);
}

function updateSubscription(subscriptionId: string, params: Stripe.SubscriptionUpdateParams) {
  logger.debug("updating subscription", subscriptionId);
  return stripeInstance.subscriptions.update(subscriptionId, params);
}

function cancelSubscription({ subscriptionId }: { subscriptionId: string }) {
  logger.debug("cancel subscription", subscriptionId);
  return stripeInstance.subscriptions.cancel(subscriptionId);
}

function getListOfInvoices({ customerId }: { customerId: string }) {
  logger.debug("getting list of invoices for customer", customerId);
  return stripeInstance.invoices.list({ customer: customerId, limit: 100 });
}

function stripeWebhookAndCheckoutCallback({ server }: { server: express.Application }) {
  server.post(
    "/api/v1/public/stripe-invoice-payment-failed",
    express.raw({ type: "application/json" }),
    async (req, res, next) => {
      try {
        const event = stripeInstance.webhooks.constructEvent(
          req.body,
          req.headers["stripe-signature"],
          dev ? process.env.STRIPE_TEST_ENDPOINTSECRET : process.env.STRIPE_LIVE_ENDPOINTSECRET
        );

        logger.debug(`${event.id}, ${event.type}`);

        // invoice.payment_failed
        // data.object is an invoice
        // Occurs whenever an invoice payment attempt fails, due either to a declined payment or to the lack of a stored payment method.

        if (event.type === "invoice.payment_failed") {
          const { subscription } = event.data.object;
          logger.debug(JSON.stringify(subscription));

          await Team.cancelSubscriptionAfterFailedPayment({
            subscriptionId: JSON.stringify(subscription),
          });
        }

        res.sendStatus(200);
      } catch (err) {
        console.error(`Webhook error: ${err.message}`);
        next(err);
      }
    }
  );

  server.get("/stripe/checkout-completed/:sessionId", async (req, res) => {
    const { sessionId } = req.params;

    const session = await retrieveSession({ sessionId });
    if (!session || !session.metadata || !session.metadata.userId || !session.metadata.teamId) {
      throw new Error("Wrong session.");
    }

    const user = await User.findById(
      session.metadata.userId,
      "_id stripeCustomer email displayName isSubscriptionActive stripeSubscription"
    ).setOptions({ lean: true });

    const team = await Team.findById(
      session.metadata.teamId,
      "isSubscriptionActive stripeSubscription teamLeaderId slug"
    ).setOptions({ lean: true });

    if (!user) {
      throw new Error("User not found.");
    }

    if (!team) {
      throw new Error("Team not found.");
    }

    if (team.teamLeaderId !== user._id.toString()) {
      throw new Error("Permission denied");
    }

    try {
      if (session.mode === "setup" && session.setup_intent) {
        const si: Stripe.SetupIntent = session.setup_intent as Stripe.SetupIntent;
        const pm: Stripe.PaymentMethod = si.payment_method as Stripe.PaymentMethod;

        if (user.stripeCustomer) {
          await updateCustomer(user.stripeCustomer.id, {
            invoice_settings: { default_payment_method: pm.id },
          });
        }

        if (team.stripeSubscription) {
          await updateSubscription(team.stripeSubscription.id, { default_payment_method: pm.id });
        }

        await User.changeStripeCard({ session, user });
      } else if (session.mode === "subscription") {
        await User.saveStripeCustomerAndCard({ session, user });
        await Team.subscribeTeam({ session, team });
        await User.getListOfInvoicesForCustomer({ userId: user._id.toString() });
      } else {
        throw new Error("Wrong session.");
      }

      res.redirect(`${dev ? process.env.URL_APP : process.env.PRODUCTION_URL_APP}/teams/${team.slug}/billing`);
    } catch (err) {
      console.error(err);

      res.redirect(
        `${dev ? process.env.URL_APP : process.env.PRODUCTION_URL_APP}/teams/${
          team.slug
        }/billing?redirectMessage=${err.message || err.toString()}`
      );
    }
  });
}

export { createSession, cancelSubscription, getListOfInvoices, stripeWebhookAndCheckoutCallback };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\test\server\utils\slugify.test.ts -----

import * as mongoose from 'mongoose';
import User from '../../../server/models/User';
import { generateSlug } from '../../../server/utils/slugify';

// eslint-disable-next-line
require('dotenv').config();

describe('slugify', () => {
  beforeAll(async () => {
    await mongoose.connect(process.env.MONGO_URL_TEST);

    const mockUsers = [
      {
        slug: 'john',
        email: 'john@example.com',
        createdAt: new Date(),
        displayName: 'abc',
        avatarUrl: 'def',
      },
      {
        slug: 'john-johnson',
        email: 'john-johnson@example.com',
        createdAt: new Date(),
        displayName: 'abc',
        avatarUrl: 'def',
      },
      {
        slug: 'john-johnson-1',
        email: 'john-johnson-1@example.com',
        createdAt: new Date(),
        displayName: 'abc',
        avatarUrl: 'def',
      },
    ];

    await User.insertMany(mockUsers);
  });

  test('not duplicated', async () => {
    expect.assertions(1);

    await expect(generateSlug(User, 'John J Johnson@#$')).resolves.toEqual('john-j-johnson');
  });

  test('one time duplicated', async () => {
    expect.assertions(1);

    await expect(generateSlug(User, ' John@#$')).resolves.toEqual('john-1');
  });

  test('multiple duplicated', async () => {
    expect.assertions(1);

    await expect(generateSlug(User, 'John & Johnson@#$')).resolves.toEqual('john-johnson-2');
  });

  afterAll(async () => {
    await User.deleteMany({ slug: { $in: ['john', 'john-johnson', 'john-johnson-1'] } });
    await mongoose.disconnect();
  });
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\test\server\utils\sum.test.ts -----

import { sum } from '../../../server/utils/sum';

console.log(sum(1, 2));

describe.skip('testing sum function', () => {
  test('adds 1 + 2 to equal 3', () => {
    expect(sum(1, 2)).toBe(3);
  });
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\.eslintrc.js -----

module.exports = {
  parser: "@typescript-eslint/parser",
  extends: ["plugin:@typescript-eslint/recommended", "prettier"],
  env: {
    "es6": true,
    "node": true,
  },
  plugins: ["prettier"],
  rules: {
    'prettier/prettier': [
      'error',
      {
        singleQuote: true,
        trailingComma: 'all',
        arrowParens: 'always',
        printWidth: 100,
        semi: true,
      },
    ],
    '@typescript-eslint/no-unused-vars': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/no-explicit-any': 'off',
    'prefer-arrow-callback': 'error',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
 },
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\nodemon.json -----

{
  "watch": ["server"],
  "exec": "ts-node --project tsconfig.json",
  "ext": "ts"
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\package.json -----

{
  "name": "api-same-as-10-end-api",
  "version": "1.0.0",
  "license": "MIT",
  "engines": {
    "node": ">=18.17.0",
    "yarn": ">=1.22.19"
  },
  "scripts": {
    "dev": "nodemon server/server.ts",
    "lint": "eslint . --ext .ts,.tsx",
    "test": "jest",
    "postinstall": "rm -rf production-server/",
    "build": "tsc --project tsconfig.json",
    "start": "node production-server/server.js"
  },
  "jest": {
    "preset": "ts-jest",
    "testPathIgnorePatterns": [
      "production-server"
    ],
    "testEnvironment": "node"
  },
  "dependencies": {
    "aws-sdk": "^2.1692.0",
    "bcryptjs": "^3.0.2",
    "compression": "^1.8.0",
    "connect-mongo": "^5.1.0",
    "cors": "^2.8.5",
    "dotenv": "^16.4.7",
    "express": "^4.21.2",
    "express-session": "^1.18.1",
    "he": "^1.2.0",
    "helmet": "8.1.0",
    "highlight.js": "^11.11.1",
    "lodash": "^4.17.21",
    "marked": "^15.0.7",
    "mongoose": "^8.12.1",
    "node-fetch": "2",
    "passport": "^0.7.0",
    "passport-google-oauth": "^2.0.0",
    "passwordless": "^1.1.3",
    "passwordless-tokenstore": "^0.0.10",
    "socket.io": "^4.8.1",
    "stripe": "^17.7.0",
    "typescript": "^5.8.2",
    "winston": "^3.17.0"
  },
  "devDependencies": {
    "@types/connect-mongo": "^3.1.6",
    "@types/dotenv": "^8.2.3",
    "@types/express": "^5.0.1",
    "@types/express-session": "^1.18.1",
    "@types/jest": "^29.5.14",
    "@types/lodash": "^4.17.16",
    "@types/mongoose": "^5.11.97",
    "@types/node": "^22.13.11",
    "@types/node-fetch": "^2.6.12",
    "@types/passport": "^1.0.17",
    "@types/socket.io": "^3.0.2",
    "@typescript-eslint/eslint-plugin": "^8.27.0",
    "@typescript-eslint/parser": "^8.27.0",
    "eslint": "^9.22.0",
    "eslint-config-prettier": "^10.1.1",
    "eslint-plugin-prettier": "^5.2.3",
    "jest": "^29.7.0",
    "nodemon": "^3.1.9",
    "prettier": "^3.5.3",
    "ts-jest": "^29.2.6",
    "ts-node": "^10.9.2"
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\api\tsconfig.json -----

{
  "compileOnSave": false,
  "compilerOptions": {
    "jsx": "preserve",
    "allowJs": true,
    "alwaysStrict": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "removeComments": false,
    "preserveConstEnums": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "sourceMap": true,
    "skipLibCheck": true,
    "baseUrl": ".",
    "experimentalDecorators": true,
    "typeRoots": ["./node_modules/@types"],
    "target": "es2020",
    "lib": ["es2020"],
    "module": "commonjs",
    "outDir": "production-server/",
    "downlevelIteration": true,
  },
  "include": ["./server/**/*.ts"]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\components\common\Confirmer.tsx -----

import Button from '@mui/material/Button';
import Dialog from '@mui/material/Dialog';
import DialogActions from '@mui/material/DialogActions';
import DialogContent from '@mui/material/DialogContent';
import DialogContentText from '@mui/material/DialogContentText';
import DialogTitle from '@mui/material/DialogTitle';
import React from 'react';

export let openConfirmDialogExternal;

type State = {
  open: boolean;
  title: string;
  message: string;
  onAnswer: (answer) => void;
};

class Confirmer extends React.Component<any, State> {
  constructor(props) {
    super(props);

    this.state = {
      open: false,
      title: 'Are you sure?',
      message: '',
      onAnswer: null,
    };

    openConfirmDialogExternal = this.openConfirmDialog;
  }

  public render() {
    return (
      <Dialog
        open={this.state.open}
        onClose={this.handleClose}
        aria-labelledby="alert-dialog-title"
        aria-describedby="alert-dialog-description"
      >
        <DialogTitle id="alert-dialog-title">{this.state.title}</DialogTitle>
        <DialogContent>
          <DialogContentText id="alert-dialog-description">{this.state.message}</DialogContentText>
        </DialogContent>
        <DialogActions style={{ padding: '10px' }}>
          <Button onClick={this.handleClose} variant="contained" color="primary" autoFocus>
            Cancel
          </Button>
          <Button onClick={this.handleYes} variant="contained" color="secondary">
            OK
          </Button>
        </DialogActions>
      </Dialog>
    );
  }

  public handleClose = () => {
    this.setState({ open: false });
    this.state.onAnswer(false);
  };

  public handleYes = () => {
    this.setState({ open: false });
    this.state.onAnswer(true);
  };

  public openConfirmDialog = ({ title, message, onAnswer }) => {
    this.setState({ open: true, title, message, onAnswer });
  };
}

export default Confirmer;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\components\common\LoginButton.tsx -----

import Button from '@mui/material/Button';
import TextField from '@mui/material/TextField';
import React from 'react';

import { emailLoginLinkApiMethod } from '../../lib/api/public';
import notify from '../../lib/notify';
import { makeQueryString } from '../../lib/api/makeQueryString';

const dev = process.env.NODE_ENV !== 'production';

type Props = { invitationToken?: string };
type State = { email: string };

class LoginButton extends React.PureComponent<Props, State> {
  constructor(props) {
    super(props);

    this.state = { email: '' };
  }

  public render() {
    const { invitationToken } = this.props;

    let url = `${
      dev ? process.env.NEXT_PUBLIC_URL_API : process.env.NEXT_PUBLIC_PRODUCTION_URL_API
    }/auth/google`;
    const qs = makeQueryString({ invitationToken });

    if (qs) {
      url += `?${qs}`;
    }

    // console.log(url);

    return (
      <React.Fragment>
        <Button variant="contained" color="secondary" href={url}>
          <img
            src="https://storage.googleapis.com/async-await-all/G.svg"
            alt="Log in with Google"
          />
          &nbsp;&nbsp;&nbsp; Log in with Google
        </Button>
        <p />
        <br />
        <hr style={{ width: '60px' }} /> <h4>OR</h4> <hr style={{ width: '60px' }} />
        <p />
        <br />
        <div>
          <form autoComplete="off" onSubmit={this.onSubmit}>
            <TextField
              required
              type="email"
              label="Email address"
              value={this.state.email}
              onChange={(event) => {
                this.setState({ email: event.target.value });
              }}
              style={{ width: '300px' }}
            />
            <p />
            <Button variant="contained" color="primary" type="submit">
              Log in with email
            </Button>
          </form>
          <p />
          <br />
        </div>
      </React.Fragment>
    );
  }

  private onSubmit = async (event) => {
    event.preventDefault();
    const { email } = this.state;
    const { invitationToken } = this.props;

    if (!email) {
      notify('Email is required');
    }

    try {
      await emailLoginLinkApiMethod({ email, invitationToken });
      this.setState({ email: '' });
      notify('SaaS boilerplate emailed you a login link.');
    } catch (error) {
      notify(error);
    }
  };
}

export default LoginButton;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\components\common\MemberChooser.tsx -----

import React from 'react';

import Autocomplete from '@mui/material/Autocomplete';
import TextField from '@mui/material/TextField';

import { User } from '../../lib/store/user';

type Props = {
  onChange: (item) => void;
  selectedMemberIds?: string[];
  members: User[];
  label?: string;
  helperText?: string;
};

type State = {
  selectedItems: { label: string; id: string }[];
};

class MemberChooser extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    const suggestions = this.props.members.map((user) => ({
      label: user.displayName || user.email,
      id: user._id,
    }));

    const selectedItems = suggestions.filter(
      (s) => this.props.selectedMemberIds.indexOf(s.id) !== -1,
    );

    this.state = {
      selectedItems: selectedItems || [],
    };
  }

  public render() {
    const suggestions = this.props.members.map((user) => ({
      label: user.displayName || user.email,
      id: user._id,
    }));

    return (
      <Autocomplete
        multiple
        id="tags-standard"
        options={suggestions}
        getOptionLabel={(option) => option.label}
        isOptionEqualToValue={(option, value) => option.id === value.id}
        value={this.state.selectedItems}
        renderInput={(params) => (
          <TextField
            {...params}
            variant="standard"
            label="Find team member by name"
            placeholder="Select participants"
          />
        )}
        onChange={this.handleChange}
        filterSelectedOptions={true}
        noOptionsText="No team members to select from"
      />
    );
  }

  public handleChange = (event, value) => {
    event.preventDefault();

    const selectedItems = value;

    this.setState({ selectedItems });

    this.props.onChange(selectedItems.map((i) => i.id));
  };
}

export default MemberChooser;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\components\common\MenuWithLinks.tsx -----

import Menu from '@mui/material/Menu';
import MenuItem from '@mui/material/MenuItem';
import Router, { NextRouter, withRouter } from 'next/router';
import React from 'react';

type Props = {
  options: {
    href: string;
    as: string;
    highlighterSlug: string;
    text: string;
    externalServer: boolean;
    separator: boolean;
  }[];
  router: NextRouter;
  children: any;
};

type State = {
  anchorEl: Element | ((element: Element) => Element);
};

class MenuWithLinks extends React.PureComponent<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      anchorEl: null,
    };
  }

  public render() {
    const { options, children, router } = this.props;
    const { anchorEl } = this.state;

    return (
      <div style={{ textAlign: 'center' }}>
        <div
          aria-controls={anchorEl ? 'simple-menu' : null}
          aria-haspopup="true"
          onClick={this.handleClick}
          onKeyPress={this.handleClick}
        >
          {children}
        </div>
        <Menu
          id="simple-menu"
          anchorEl={anchorEl}
          open={Boolean(anchorEl)}
          onClose={this.handleClose}
          keepMounted
        >
          {options.map((option, i) =>
            option.separator ? (
              <hr style={{ width: '95%', margin: '10px auto' }} key={`separated-${i}`} />
            ) : option.externalServer ? (
              <MenuItem
                onClick={(event) => {
                  event.preventDefault();
                  window.location.href = option.href;
                  this.handleClose();
                }}
                key={option.href || option.text}
              >
                {option.text}
              </MenuItem>
            ) : (
              <MenuItem
                key={option.href}
                style={{
                  fontWeight: router.asPath.includes(option.highlighterSlug) ? 600 : 300,
                  fontSize: '14px',
                }}
                onClick={() => Router.push(option.href, option.as)}
              >
                {option.text}
              </MenuItem>
            ),
          )}
        </Menu>
      </div>
    );
  }

  public handleClick = (event) => {
    this.setState({ anchorEl: event.currentTarget });
  };

  public handleClose = () => {
    this.setState({ anchorEl: null });
  };
}

export default withRouter(MenuWithLinks);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\components\common\MenuWithMenuItems.tsx -----

import Menu from '@mui/material/Menu';
import MenuItem from '@mui/material/MenuItem';
import MoreVertIcon from '@mui/icons-material/MoreVert';
import React from 'react';

type Props = {
  menuOptions: any;
  itemOptions: any[];
};

type State = {
  menuElem: Element | ((element: Element) => Element);
};

class MenuWithMenuItems extends React.PureComponent<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      menuElem: null,
    };
  }

  public render() {
    const { menuOptions, itemOptions } = this.props;
    const { menuElem } = this.state;

    return (
      <div style={{ verticalAlign: 'middle' }}>
        <MoreVertIcon
          aria-controls={menuElem ? menuOptions.id : null}
          data-id={menuOptions.dataId}
          aria-haspopup="true"
          style={{ fontSize: '14px', opacity: 0.7, cursor: 'pointer' }}
          onClick={(e) => this.handleClick(e)}
        />

        <Menu
          id={menuOptions.id}
          anchorEl={menuElem}
          open={Boolean(menuElem)}
          onClose={this.handleClose}
        >
          {itemOptions.map((option, i) => (
            <MenuItem
              key={option.dataId + i}
              data-id={option.dataId}
              data-more-id={option.dataMoreId}
              onClick={(e) => {
                this.setState({ menuElem: null });
                option.onClick(e);
              }}
            >
              {option.text}
            </MenuItem>
          ))}
        </Menu>
      </div>
    );
  }

  public handleClick = (event) => {
    event.preventDefault();
    this.setState({ menuElem: event.currentTarget });
  };

  public handleClose = () => {
    this.setState({ menuElem: null });
  };
}

export default MenuWithMenuItems;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\components\common\Notifier.tsx -----

import Snackbar from '@mui/material/Snackbar';
import React from 'react';

export let openSnackbarExternal;

type State = {
  open: boolean;
  message: string;
};

class Notifier extends React.PureComponent<any, State> {
  constructor(props) {
    super(props);
    openSnackbarExternal = this.openSnackbar;

    this.state = {
      open: false,
      message: '',
    };
  }

  public render() {
    const message = (
      <span id="snackbar-message-id" dangerouslySetInnerHTML={{ __html: this.state.message }} />
    );

    return (
      <Snackbar
        anchorOrigin={{ vertical: 'top', horizontal: 'right' }}
        message={message}
        autoHideDuration={5000}
        onClose={this.handleSnackbarClose}
        open={this.state.open}
        ContentProps={{
          'aria-describedby': 'snackbar-message-id',
        }}
      />
    );
  }

  public handleSnackbarClose = () => {
    this.setState({
      open: false,
      message: '',
    });
  };

  public openSnackbar = ({ message }) => {
    this.setState({ open: true, message });
  };
}

export default Notifier;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\components\discussions\CreateDiscussionForm.tsx -----

import Button from '@mui/material/Button';
import Dialog from '@mui/material/Dialog';
import DialogContent from '@mui/material/DialogContent';
import DialogTitle from '@mui/material/DialogTitle';
import FormControl from '@mui/material/FormControl';
import FormHelperText from '@mui/material/FormHelperText';
import Select from '@mui/material/Select';
import MenuItem from '@mui/material/MenuItem';
import TextField from '@mui/material/TextField';
import { observer } from 'mobx-react';
import Head from 'next/head';
import Router from 'next/router';
import NProgress from 'nprogress';
import React from 'react';

import notify from '../../lib/notify';
import { Store } from '../../lib/store';
import MemberChooser from '../common/MemberChooser';
import PostEditor from '../posts/PostEditor';

type Props = {
  isMobile: boolean;
  store: Store;
  open: boolean;
  onClose: () => void;
};

type State = {
  name: string;
  memberIds: string[];
  disabled: boolean;
  content: string;
  notificationType: string;
};

class CreateDiscussionForm extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      name: '',
      memberIds: [],
      disabled: false,
      content: '',
      notificationType: 'default',
    };
  }
  public render() {
    const { open, isMobile, store } = this.props;
    const { currentTeam, currentUser } = store;

    const membersMinusCreator = Array.from(currentTeam.members.values()).filter(
      (user) => user._id !== currentUser._id,
    );

    return (
      <React.Fragment>
        {open ? (
          <Head>
            <title>New Discussion</title>
            <meta name="description" content="Create new discussion" />
          </Head>
        ) : null}
        <Dialog
          onClose={this.handleClose}
          aria-labelledby="simple-dialog-title"
          open={open}
          fullScreen={true}
        >
          <DialogTitle id="simple-dialog-title">Create new Discussion</DialogTitle>
          <DialogContent>
            <br />
            <form style={{ width: '100%', height: '60%' }} onSubmit={this.onSubmit}>
              <p />
              <br />
              <TextField
                autoFocus
                label="Type name of Discussion"
                helperText="Give a short and informative name to new Discussion"
                value={this.state.name}
                onChange={(event) => {
                  this.setState({ name: event.target.value });
                }}
              />
              <br />
              <p />
              <MemberChooser
                helperText="These members will see all posts and be notified about unread posts in this discussion."
                onChange={this.handleMembersChange}
                members={membersMinusCreator}
                selectedMemberIds={this.state.memberIds}
              />
              <p />
              <br />
              <FormControl>
                <Select
                  value={this.state.notificationType}
                  onChange={(event) => {
                    event.stopPropagation();
                    this.setState({ notificationType: event.target.value });
                  }}
                  required
                >
                  <MenuItem value="default">Default: without email notification.</MenuItem>
                  <MenuItem value="email">Email: with email notification.</MenuItem>
                </Select>
                <FormHelperText>
                  Choose how to notify members about new Posts inside Discussion.
                </FormHelperText>
              </FormControl>
              <p />
              <br />
              <div>
                <Button
                  type="submit"
                  variant="contained"
                  color="primary"
                  disabled={this.state.disabled}
                >
                  Create Discussion
                </Button>
                {isMobile ? <p /> : null}
                <Button
                  variant="outlined"
                  onClick={this.handleClose}
                  disabled={this.state.disabled}
                  style={{ marginLeft: isMobile ? '0px' : '20px' }}
                >
                  Cancel
                </Button>{' '}
              </div>
              <p />
              <PostEditor
                content={this.state.content}
                onChanged={this.onContentChanged}
                members={Array.from(store.currentTeam.members.values())}
                store={store}
                parentComponent="CDF"
              />
              <p />
              <div>
                <Button
                  type="submit"
                  variant="contained"
                  color="primary"
                  disabled={this.state.disabled}
                >
                  Create Discussion
                </Button>
                {isMobile ? <p /> : null}
                <Button
                  variant="outlined"
                  onClick={this.handleClose}
                  disabled={this.state.disabled}
                  style={{ marginLeft: isMobile ? '0px' : '20px' }}
                >
                  Cancel
                </Button>{' '}
                <p />
                <br />
                <br />
              </div>
            </form>
          </DialogContent>
        </Dialog>
      </React.Fragment>
    );
  }

  public handleMembersChange = (memberIds) => {
    this.setState({ memberIds });
  };

  public handleClose = () => {
    this.setState({
      name: '',
      memberIds: [],
      disabled: false,
      content: '',
      notificationType: 'default',
    });
    this.props.onClose();
  };

  private onContentChanged = (content: string) => {
    console.log('onContentChanged', content);
    this.setState({ content });
  };

  private onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();

    const { store } = this.props;
    const { currentTeam } = store;

    if (!currentTeam) {
      notify('Team have not selected');
      return;
    }

    const { name, memberIds, content, notificationType } = this.state;

    if (!name) {
      notify('Name is required');
      return;
    }

    if (!content) {
      notify('Content is required');
      return;
    }

    // if (!memberIds || memberIds.length < 1) {
    //   notify('Please assign at least one person to this Discussion.');
    //   return;
    // }

    if (!notificationType) {
      notify('Please select notification type.');
      return;
    }

    this.setState({ disabled: true });
    NProgress.start();

    try {
      const discussion = await currentTeam.addDiscussion({
        name,
        memberIds,
        notificationType,
      });

      const post = await discussion.addPost(content);

      const dev = process.env.NODE_ENV !== 'production';

      if (discussion.notificationType === 'email') {
        const userIdsForLambda = discussion.memberIds.filter((m) => m !== discussion.createdUserId);

        await discussion.sendDataToLambda({
          discussionName: discussion.name,
          discussionLink: `${
            dev ? process.env.NEXT_PUBLIC_URL_APP : process.env.NEXT_PUBLIC_PRODUCTION_URL_APP
          }/teams/${discussion.team.slug}/discussions/${discussion.slug}`,
          postContent: post.content,
          authorName: post.user.displayName,
          userIds: userIdsForLambda,
        });
      }

      this.setState({ name: '', memberIds: [], content: '', notificationType: 'default' });

      notify('You successfully added new Discussion.');

      Router.push(
        `/discussion?teamSlug=${currentTeam.slug}&discussionSlug=${discussion.slug}`,
        `/teams/${currentTeam.slug}/discussions/${discussion.slug}`,
      );
    } catch (error) {
      console.log(error);
      notify(error);
    } finally {
      this.setState({ disabled: false });
      NProgress.done();
      this.props.onClose();
    }
  };
}

export default observer(CreateDiscussionForm);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\components\discussions\DiscussionActionMenu.tsx -----

import { observer } from 'mobx-react';
import NProgress from 'nprogress';
import React from 'react';

import confirm from '../../lib/confirm';
import notify from '../../lib/notify';
import { Store } from '../../lib/store';
import { Discussion } from '../../lib/store/discussion';

import MenuWithMenuItems from '../common/MenuWithMenuItems';
import EditDiscussionForm from './EditDiscussionForm';

const dev = process.env.NODE_ENV !== 'production';

const getMenuOptions = (discussion) => ({
  dataId: discussion._id,
  id: `discussion-menu-${discussion._id}`,
});

const getMenuItemOptionsForCreator = (discussion, component) => [
  {
    text: 'Copy URL',
    dataId: discussion._id,
    onClick: component.handleCopyUrl,
  },
  {
    text: 'Edit',
    dataId: discussion._id,
    onClick: component.editDiscussion,
  },
  {
    text: 'Delete',
    dataId: discussion._id,
    onClick: component.deleteDiscussion,
  },
];

const getMenuItemOptions = (discussion, component) => [
  {
    text: 'Copy URL',
    dataId: discussion._id,
    onClick: component.handleCopyUrl,
  },
];

type Props = {
  discussion: Discussion;
  store: Store;
  isMobile: boolean;
};

type State = {
  discussionFormOpen: boolean;
  selectedDiscussion: Discussion;
};

class DiscussionActionMenu extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      discussionFormOpen: false,
      selectedDiscussion: null,
    };
  }

  public render() {
    const { discussion, store } = this.props;
    const { currentUser } = store;

    const isCreator = currentUser._id === discussion.createdUserId ? true : false;

    return (
      <React.Fragment>
        <MenuWithMenuItems
          menuOptions={getMenuOptions(discussion)}
          itemOptions={
            isCreator
              ? getMenuItemOptionsForCreator(discussion, this)
              : getMenuItemOptions(discussion, this)
          }
        />

        {this.state.discussionFormOpen ? (
          <EditDiscussionForm
            open={true}
            onClose={this.handleDiscussionFormClose}
            discussion={discussion}
            isMobile={this.props.isMobile}
            store={store}
          />
        ) : null}
      </React.Fragment>
    );
  }

  public handleCopyUrl = async (event) => {
    const { store } = this.props;
    const { currentTeam } = store;

    const id = event.currentTarget.dataset.id;
    if (!id) {
      return;
    }

    const selectedDiscussion = currentTeam.discussions.find((d) => d._id === id);

    const discussionUrl = `${
      dev ? process.env.NEXT_PUBLIC_URL_APP : process.env.NEXT_PUBLIC_PRODUCTION_URL_APP
    }/teams/${currentTeam.slug}/discussions/${selectedDiscussion.slug}`;

    try {
      if (window.navigator) {
        await window.navigator.clipboard.writeText(discussionUrl);
        notify('You successfully copied URL.');
      }
    } catch (err) {
      notify(err);
    } finally {
      this.setState({ discussionFormOpen: false, selectedDiscussion: null });
    }
  };

  public editDiscussion = (event) => {
    const { currentTeam } = this.props.store;
    if (!currentTeam) {
      notify('You have not selected Team.');
      return;
    }

    const id = event.currentTarget.dataset.id;
    if (!id) {
      return;
    }

    const selectedDiscussion = currentTeam.discussions.find((d) => d._id === id);

    this.setState({ discussionFormOpen: true, selectedDiscussion });
  };

  public deleteDiscussion = async (event) => {
    const { currentTeam } = this.props.store;
    if (!currentTeam) {
      notify('You have not selected Team.');
      return;
    }

    const id = event.currentTarget.dataset.id;

    confirm({
      title: 'Are you sure?',
      message: '',
      onAnswer: async (answer) => {
        if (!answer) {
          return;
        }

        NProgress.start();

        try {
          await currentTeam.deleteDiscussion(id);

          notify('You successfully deleted Discussion.');
        } catch (error) {
          console.error(error);
          notify(error);
        } finally {
          NProgress.done();
        }
      },
    });
  };

  public handleDiscussionFormClose = () => {
    this.setState({ discussionFormOpen: false, selectedDiscussion: null });
  };
}

export default observer(DiscussionActionMenu);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\components\discussions\DiscussionList.tsx -----

import Tooltip from '@mui/material/Tooltip';
import AddCircleOutlineIcon from '@mui/icons-material/AddCircleOutline';
import { observer } from 'mobx-react';
import React from 'react';

import { Store } from '../../lib/store';
import { Team } from '../../lib/store/team';

import CreateDiscussionForm from './CreateDiscussionForm';
import DiscussionListItem from './DiscussionListItem';

import notify from '../../lib/notify';

type Props = { store: Store; team: Team; isMobile: boolean };

type State = { discussionFormOpen: boolean };

class DiscussionList extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      discussionFormOpen: false,
    };
  }

  public componentDidMount() {
    this.props.team.loadDiscussions().catch((err) => notify(err));
  }

  public componentDidUpdate(prevProps: Props) {
    if (this.props.team._id !== prevProps.team._id) {
      this.props.team.loadDiscussions().catch((err) => notify(err));
    }
  }

  public render() {
    const { store, team } = this.props;

    const isThemeDark = store && store.currentUser && store.currentUser.darkTheme === true;

    return (
      <div>
        Discussions
        <Tooltip title="Add Discussion" placement="right" disableFocusListener disableTouchListener>
          <a onClick={this.addDiscussion} style={{ float: 'right', padding: '0px 10px' }}>
            <AddCircleOutlineIcon
              color="action"
              style={{ fontSize: 14, opacity: 0.7, color: isThemeDark ? '#fff' : '#000' }}
            />{' '}
          </a>
        </Tooltip>
        <p />
        <ul style={{ listStyle: 'none', padding: '0px' }}>
          {team &&
            team.orderedDiscussions.map((d) => {
              return (
                <DiscussionListItem
                  key={d._id}
                  discussion={d}
                  team={team}
                  isMobile={this.props.isMobile}
                  store={this.props.store}
                />
              );
            })}
        </ul>
        <CreateDiscussionForm
          isMobile={this.props.isMobile}
          store={this.props.store}
          open={this.state.discussionFormOpen}
          onClose={this.handleDiscussionFormClose}
        />
      </div>
    );
  }

  public addDiscussion = (event) => {
    event.preventDefault();
    this.setState({ discussionFormOpen: true });
  };

  public handleDiscussionFormClose = () => {
    this.setState({ discussionFormOpen: false });
  };
}

export default observer(DiscussionList);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\components\discussions\DiscussionListItem.tsx -----

import Paper from '@mui/material/Paper';
import { observer } from 'mobx-react';
import Link from 'next/link';
import React from 'react';

import { Store } from '../../lib/store';
import { Discussion } from '../../lib/store/discussion';
import { Team } from '../../lib/store/team';

import DiscussionActionMenu from './DiscussionActionMenu';

type Props = {
  store: Store;
  discussion: Discussion;
  team: Team;
  isMobile: boolean;
};

class DiscussionListItem extends React.Component<Props> {
  public render() {
    const { store, discussion, team, isMobile } = this.props;
    const trimmingLength = 16;

    const selectedDiscussion =
      store.currentUrl === `/teams/${team.slug}/discussions/${discussion.slug}`;

    console.log(store.currentUrl);

    const isThemeDark = store && store.currentUser && store.currentUser.darkTheme === true;

    const selectedItemBorder = isThemeDark
      ? '1px rgba(255, 255, 255, 0.75) solid'
      : '1px rgba(0, 0, 0, 0.75) solid';

    return (
      <Paper
        key={discussion._id}
        style={{
          margin: '10px 10px 5px 0px',
          padding: '8px',
          border: selectedDiscussion ? selectedItemBorder : 'none',
        }}
        elevation={selectedDiscussion ? 24 : 1}
      >
        <li key={discussion._id} style={{ whiteSpace: 'nowrap', paddingRight: '10px' }}>
          <Link
            scroll={false}
            href={`/discussion?teamSlug=${team.slug}&discussionSlug=${discussion.slug}`}
            as={`/teams/${team.slug}/discussions/${discussion.slug}`}
            style={{ fontWeight: 300, color: isThemeDark ? '#fff' : '#000' }}
            key={discussion._id}
          >
            {discussion.name.length > trimmingLength
              ? `${discussion.name.substring(0, trimmingLength)}...`
              : discussion.name}
          </Link>
          <div
            style={{
              float: 'right',
              marginRight: '-12px',
            }}
          >
            <DiscussionActionMenu discussion={discussion} isMobile={isMobile} store={store} />
          </div>
        </li>
      </Paper>
    );
  }
}

export default observer(DiscussionListItem);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\components\discussions\EditDiscussionForm.tsx -----

import Button from '@mui/material/Button';
import Dialog from '@mui/material/Dialog';
import DialogActions from '@mui/material/DialogActions';
import DialogContent from '@mui/material/DialogContent';
import DialogContentText from '@mui/material/DialogContentText';
import DialogTitle from '@mui/material/DialogTitle';
import FormControl from '@mui/material/FormControl';
import FormHelperText from '@mui/material/FormHelperText';
import Select from '@mui/material/Select';
import MenuItem from '@mui/material/MenuItem';
import TextField from '@mui/material/TextField';
import { observer } from 'mobx-react';
import NProgress from 'nprogress';
import React from 'react';

import notify from '../../lib/notify';
import { Store } from '../../lib/store';
import { Discussion } from '../../lib/store/discussion';
import MemberChooser from '../common/MemberChooser';

type Props = {
  store: Store;
  onClose: () => void;
  open: boolean;
  discussion: Discussion;
  isMobile: boolean;
};

type State = {
  name: string;
  memberIds: string[];
  disabled: boolean;
  discussionId: string;
  notificationType: string;
};

class EditDiscussionForm extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      name: '',
      memberIds: [],
      disabled: false,
      discussionId: '',
      notificationType: 'default',
    };
  }

  public static getDerivedStateFromProps(props: Props, state: State) {
    const { discussion } = props;

    if (state.discussionId === discussion._id) {
      return null;
    }

    return {
      name: (discussion && discussion.name) || '',
      memberIds: (discussion && discussion.memberIds) || [],
      discussionId: discussion._id,
      notificationType: discussion.notificationType || 'default',
    };
  }

  public render() {
    const { open, store } = this.props;
    const { currentTeam, currentUser } = store;

    const membersMinusCreator = Array.from(currentTeam.members.values()).filter(
      (user) => user._id !== currentUser._id,
    );

    // console.log(currentTeam.members);

    return (
      <Dialog onClose={this.handleClose} aria-labelledby="simple-dialog-title" open={open}>
        <DialogTitle id="simple-dialog-title">Edit Discussion</DialogTitle>
        <DialogContent>
          <DialogContentText>Edit discussion</DialogContentText>
          <br />
          <form onSubmit={this.onSubmit}>
            <TextField
              label="Type name of Discussion"
              helperText="Give a short and informative name to Discussion"
              value={this.state.name}
              onChange={(event) => {
                this.setState({ name: event.target.value });
              }}
            />
            <br />
            <p />
            <MemberChooser
              helperText="These members will see all posts and be notified about unread posts in this discussion."
              onChange={this.handleMembersChange}
              members={membersMinusCreator}
              selectedMemberIds={this.state.memberIds}
            />
            <p />
            <br />
            <FormControl>
              <Select
                value={this.state.notificationType}
                onChange={(event) => {
                  event.stopPropagation();
                  this.setState({ notificationType: event.target.value });
                }}
                required
              >
                <MenuItem value="default">Default: without email notification.</MenuItem>
                <MenuItem value="email">Email: with email notification.</MenuItem>
              </Select>
              <FormHelperText>
                Choose how to notify members about new Posts inside Discussion.
              </FormHelperText>
            </FormControl>
            <p />
            <br />
            <DialogActions>
              <Button
                color="primary"
                variant="outlined"
                onClick={this.handleClose}
                disabled={this.state.disabled}
              >
                Cancel
              </Button>
              <Button
                type="submit"
                variant="contained"
                color="primary"
                disabled={this.state.disabled}
              >
                Update Discussion
              </Button>
            </DialogActions>
          </form>
        </DialogContent>
      </Dialog>
    );
  }

  public handleMembersChange = (memberIds) => {
    this.setState({ memberIds });
  };

  public handleClose = () => {
    this.setState({ name: '', memberIds: [], disabled: false, notificationType: 'default' });
    this.props.onClose();
  };

  private onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();

    const { discussion, store } = this.props;
    const { currentTeam } = store;
    const { notificationType } = this.state;

    if (!currentTeam) {
      notify('Team have not selected');
      return;
    }

    const { name, memberIds } = this.state;

    if (!name) {
      notify('Please name this Discussion.');
      return;
    }

    if (memberIds && !memberIds.includes(discussion.store.currentUser._id)) {
      memberIds.push(discussion.store.currentUser._id);
    }

    // if (!memberIds || memberIds.length < 1) {
    //   notify('Please assign at least one person to this Discussion.');
    //   return;
    // }

    if (!notificationType) {
      notify('Please select notification type.');
      return;
    }

    NProgress.start();
    try {
      await discussion.editDiscussion({ name, memberIds, notificationType });

      this.setState({ name: '', memberIds: [], disabled: false, notificationType: 'default' });
      notify('You successfully edited Discussion.');
    } catch (error) {
      console.log(error);
      notify(error);
    } finally {
      this.setState({ disabled: false });
      NProgress.done();

      this.props.onClose();
    }
  };
}

export default observer(EditDiscussionForm);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\components\layout\index.tsx -----

import Avatar from '@mui/material/Avatar';
import Button from '@mui/material/Button';
import Grid from '@mui/material/Grid';
import ArrowDropDownIcon from '@mui/icons-material/ArrowDropDown';
import LensIcon from '@mui/icons-material/Lens';

import Link from 'next/link';
import React from 'react';

import MenuWithLinks from '../common/MenuWithLinks';
import Confirmer from '../common/Confirmer';
import Notifier from '../common/Notifier';

import { Store } from '../../lib/store';
import DiscussionList from '../discussions/DiscussionList';

const dev = process.env.NODE_ENV !== 'production';

const styleGrid = {
  width: '100%',
  height: '100vh',
  maxWidth: '100%',
  padding: '0px 10px',
  display: 'flex',
  overflow: 'hidden',
};

const styleGridIsMobile = {
  width: '100%',
  height: '100vh',
  maxWidth: '100%',
  padding: '0px 0px 0px 10px',
  display: 'flex',
  overflow: 'hidden',
};

function LayoutWrapper({
  children,
  isMobile,
  firstGridItem,
  store,
}: {
  children: React.ReactNode;
  isMobile: boolean;
  firstGridItem: boolean;
  store: Store;
}) {
  const isThemeDark = store.currentUser ? store.currentUser.darkTheme : true;

  return (
    <React.Fragment>
      <Grid
        container
        direction="row"
        justifyContent="flex-start"
        alignItems="stretch"
        style={isMobile ? styleGridIsMobile : styleGrid}
      >
        {firstGridItem ? (
          <Grid
            item
            sm={2}
            xs={12}
            style={{
              borderRight: '1px #707070 solid',
              justifyContent: 'center',
              overflow: 'hidden',
            }}
          >
            <div style={{ display: 'flex', justifyContent: 'space-between' }}>
              <svg
                xmlns="http://www.w3.org/2000/svg"
                width="124"
                height="40"
                viewBox="0 0 124 40"
                style={{
                  marginTop: '20px',
                  display: 'inline-flex',
                  height: '40px',
                }}
              >
                <g id="async-logo">
                  <g id="async-logo-40">
                    <circle id="Ellipse 2" cx="20" cy="20" r="20" fill="black" />
                    <path
                      id="path-async-logo"
                      d="M7.07825 -0.0960007V16H4.51825V13.088C4.04892 14.0907 3.33425 14.8693 2.37425 15.424C1.43558 15.9573 0.336917 16.224 -0.92175 16.224C-2.35108 16.224 -3.60975 15.8827 -4.69775 15.2C-5.76442 14.5173 -6.59642 13.5573 -7.19375 12.32C-7.76975 11.0613 -8.05775 9.6 -8.05775 7.936C-8.05775 6.272 -7.75908 4.81067 -7.16175 3.552C-6.56442 2.272 -5.73242 1.28 -4.66575 0.576C-3.57775 -0.128 -2.32975 -0.48 -0.92175 -0.48C0.336917 -0.48 1.43558 -0.202666 2.37425 0.352C3.31292 0.906667 4.02758 1.68533 4.51825 2.688V-0.0960007H7.07825ZM-0.40975 14.08C1.16892 14.08 2.38492 13.5467 3.23825 12.48C4.09158 11.392 4.51825 9.856 4.51825 7.872C4.51825 5.888 4.09158 4.36267 3.23825 3.296C2.38492 2.22933 1.16892 1.696 -0.40975 1.696C-1.98842 1.696 -3.22575 2.25067 -4.12175 3.36C-4.99642 4.448 -5.43375 5.97333 -5.43375 7.936C-5.43375 9.89867 -4.99642 11.4133 -4.12175 12.48C-3.24708 13.5467 -2.00975 14.08 -0.40975 14.08Z"
                      transform="translate(19.5938 12)"
                      fill="white"
                    />
                  </g>
                  <path
                    id="path-async-text"
                    d="M22.6251 11.928V24H20.7051V21.816C20.3531 22.568 19.8171 23.152 19.0971 23.568C18.3931 23.968 17.5691 24.168 16.6251 24.168C15.5531 24.168 14.6091 23.912 13.7931 23.4C12.9931 22.888 12.3691 22.168 11.9211 21.24C11.4891 20.296 11.2731 19.2 11.2731 17.952C11.2731 16.704 11.4971 15.608 11.9451 14.664C12.3931 13.704 13.0171 12.96 13.8171 12.432C14.6331 11.904 15.5691 11.64 16.6251 11.64C17.5691 11.64 18.3931 11.848 19.0971 12.264C19.8011 12.68 20.3371 13.264 20.7051 14.016V11.928H22.6251ZM17.0091 22.56C18.1931 22.56 19.1051 22.16 19.7451 21.36C20.3851 20.544 20.7051 19.392 20.7051 17.904C20.7051 16.416 20.3851 15.272 19.7451 14.472C19.1051 13.672 18.1931 13.272 17.0091 13.272C15.8251 13.272 14.8971 13.688 14.2251 14.52C13.5691 15.336 13.2411 16.48 13.2411 17.952C13.2411 19.424 13.5691 20.56 14.2251 21.36C14.8811 22.16 15.8091 22.56 17.0091 22.56ZM30.4637 24.168C28.4317 24.168 26.8237 23.648 25.6397 22.608L26.2877 21.168C26.9437 21.68 27.6077 22.048 28.2797 22.272C28.9517 22.496 29.7037 22.608 30.5357 22.608C31.4477 22.608 32.1357 22.456 32.5997 22.152C33.0797 21.832 33.3197 21.376 33.3197 20.784C33.3197 20.304 33.1597 19.92 32.8397 19.632C32.5197 19.344 31.9917 19.12 31.2557 18.96L29.2157 18.48C28.2077 18.256 27.4237 17.856 26.8637 17.28C26.3197 16.704 26.0477 16.016 26.0477 15.216C26.0477 14.16 26.4717 13.304 27.3197 12.648C28.1677 11.976 29.2877 11.64 30.6797 11.64C31.5277 11.64 32.3277 11.776 33.0797 12.048C33.8317 12.32 34.4637 12.712 34.9757 13.224L34.3277 14.64C33.1917 13.696 31.9757 13.224 30.6797 13.224C29.8157 13.224 29.1437 13.392 28.6637 13.728C28.1997 14.048 27.9677 14.504 27.9677 15.096C27.9677 15.592 28.1117 15.984 28.3997 16.272C28.7037 16.56 29.1837 16.784 29.8397 16.944L31.8797 17.448C32.9997 17.704 33.8317 18.104 34.3757 18.648C34.9197 19.176 35.1917 19.872 35.1917 20.736C35.1917 21.776 34.7677 22.608 33.9197 23.232C33.0717 23.856 31.9197 24.168 30.4637 24.168ZM48.687 11.928L43.047 25.104C42.455 26.48 41.711 27.488 40.815 28.128C39.919 28.768 38.815 29.208 37.503 29.448L37.095 27.936C38.231 27.68 39.087 27.336 39.663 26.904C40.255 26.488 40.743 25.84 41.127 24.96L41.607 23.88L36.495 11.928H38.535L42.615 21.888L46.743 11.928H48.687ZM56.853 11.64C59.749 11.64 61.197 13.232 61.197 16.416V24H59.253V16.512C59.253 15.392 59.029 14.576 58.581 14.064C58.133 13.536 57.429 13.272 56.469 13.272C55.349 13.272 54.453 13.616 53.781 14.304C53.109 14.992 52.773 15.92 52.773 17.088V24H50.829V15.312C50.829 14.064 50.765 12.936 50.637 11.928H52.485L52.677 14.088C53.045 13.304 53.597 12.704 54.333 12.288C55.069 11.856 55.909 11.64 56.853 11.64ZM69.9321 24.168C68.7641 24.168 67.7401 23.912 66.8601 23.4C65.9961 22.888 65.3241 22.168 64.8441 21.24C64.3801 20.296 64.1481 19.2 64.1481 17.952C64.1481 16.704 64.3881 15.608 64.8681 14.664C65.3481 13.704 66.0281 12.96 66.9081 12.432C67.8041 11.904 68.8441 11.64 70.0281 11.64C70.8441 11.64 71.6281 11.784 72.3801 12.072C73.1481 12.344 73.7801 12.728 74.2761 13.224L73.6281 14.664C73.0201 14.184 72.4281 13.832 71.8521 13.608C71.2921 13.384 70.7161 13.272 70.1241 13.272C68.8921 13.272 67.9241 13.688 67.2201 14.52C66.5161 15.336 66.1641 16.48 66.1641 17.952C66.1641 19.408 66.5081 20.544 67.1961 21.36C67.9001 22.16 68.8761 22.56 70.1241 22.56C70.7161 22.56 71.2921 22.448 71.8521 22.224C72.4281 22 73.0201 21.648 73.6281 21.168L74.2761 22.608C73.7641 23.088 73.1161 23.472 72.3321 23.76C71.5641 24.032 70.7641 24.168 69.9321 24.168Z"
                    transform="translate(39 4)"
                    fill={isThemeDark ? 'white' : 'black'}
                  />
                </g>
              </svg>
              <MenuWithLinks
                options={[
                  {
                    text: 'Your Settings',
                    href: `/your-settings?teamSlug=${store.currentTeam.slug}`,
                    as: `/teams/${store.currentTeam.slug}/your-settings`,
                    highlighterSlug: '/your-settings',
                  },
                  {
                    text: 'Team Settings',
                    href: `/team-settings?teamSlug=${store.currentTeam.slug}`,
                    as: `/teams/${store.currentTeam.slug}/team-settings`,
                    highlighterSlug: '/team-settings',
                  },
                  {
                    text: 'Billing',
                    href: `/billing?teamSlug=${store.currentTeam.slug}`,
                    as: `/teams/${store.currentTeam.slug}/billing`,
                    highlighterSlug: '/billing',
                  },
                  {
                    separator: true,
                  },
                  {
                    text: 'Log out',
                    href: `${
                      dev
                        ? process.env.NEXT_PUBLIC_URL_API
                        : process.env.NEXT_PUBLIC_PRODUCTION_URL_API
                    }/logout`,
                    as: `${
                      dev
                        ? process.env.NEXT_PUBLIC_URL_API
                        : process.env.NEXT_PUBLIC_PRODUCTION_URL_API
                    }/logout`,
                    externalServer: true,
                  },
                ]}
              >
                <Avatar
                  src={store.currentUser.avatarUrl}
                  alt="Add username here later in the book"
                  style={{
                    margin: '20px auto',
                    cursor: 'pointer',
                    display: 'inline-flex',
                    width: '40px',
                    height: '40px',
                  }}
                />

                <ArrowDropDownIcon color="action" style={{ verticalAlign: 'super' }} />
              </MenuWithLinks>
            </div>
            <hr />
            <p />
            <p />
            <DiscussionList store={store} team={store.currentTeam} isMobile={isMobile} />
          </Grid>
        ) : null}

        {children}
      </Grid>
      <Notifier />
      <Confirmer />
    </React.Fragment>
  );
}

type Props = {
  children: React.ReactNode;
  isMobile?: boolean;
  firstGridItem?: boolean;
  store?: Store;
  teamRequired?: boolean;
};

class Layout extends React.Component<Props> {
  public render() {
    const { children, isMobile, firstGridItem, store, teamRequired } = this.props;

    const { currentUser, currentTeam } = store;

    // console.log(this.props.store.currentUser.darkTheme);

    // const isThemeDark = false;

    // console.log(isMobile);

    // console.log(store, currentUser, currentTeam);

    if (!currentUser) {
      return (
        <LayoutWrapper firstGridItem={firstGridItem} isMobile={isMobile} store={store}>
          <Grid item sm={12} xs={12}>
            {children}
          </Grid>
        </LayoutWrapper>
      );
    }

    if (!currentTeam) {
      if (teamRequired) {
        return (
          <LayoutWrapper firstGridItem={firstGridItem} isMobile={isMobile} store={store}>
            <Grid
              item
              sm={10}
              xs={12}
              style={{ padding: '0px 35px', overflow: 'auto', height: 'auto' }}
            >
              <div style={{ padding: '20px' }}>
                Select existing team or create a new team.
                <p />
                <Link href="/create-team" as="/create-team">
                  <Button variant="contained" color="primary">
                    Create new team
                  </Button>
                </Link>
              </div>
            </Grid>
          </LayoutWrapper>
        );
      } else {
        // console.log('team not required');
        return (
          <LayoutWrapper firstGridItem={firstGridItem} isMobile={isMobile} store={store}>
            <Grid
              item
              sm={10}
              xs={12}
              style={{ padding: '0px 35px', overflow: 'auto', height: 'auto' }}
            >
              {children}
            </Grid>
          </LayoutWrapper>
        );
      }
    }

    return (
      <LayoutWrapper firstGridItem={firstGridItem} isMobile={isMobile} store={store}>
        <Grid
          item
          sm={firstGridItem ? 10 : 12}
          xs={12}
          style={{ padding: '0px 35px', overflowY: 'auto', height: 'inherit' }}
        >
          <div>
            {isMobile || store.currentUrl.includes('create-team') ? null : (
              <React.Fragment>
                <LensIcon
                  style={{
                    margin: '15px 0px 10px 25px',
                    opacity: 0.8,
                    fontSize: '18px',
                    cursor: 'pointer',
                  }}
                  onClick={async () => {
                    await store.currentUser.toggleTheme(!store.currentUser.darkTheme);
                  }}
                />
                <h4
                  style={{
                    margin: '15px 0px 10px 30px',
                    fontWeight: 300,
                  }}
                >
                  Current team: <b>{store.currentTeam.name}</b>
                </h4>
              </React.Fragment>
            )}
            <div style={{ clear: 'both' }} />
          </div>
          {children}
        </Grid>
      </LayoutWrapper>
    );
  }
}

export default Layout;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\components\posts\PostContent.tsx -----

import React from 'react';

type Props = { html: string };

class PostContent extends React.Component<Props> {
  public render() {
    const { html } = this.props;

    return (
      <div
        style={{
          fontSize: '15px',
          lineHeight: '2em',
          fontFamily: 'Roboto, sans-serif',
          wordBreak: 'break-all',
        }}
        dangerouslySetInnerHTML={{ __html: html }}
      />
    );
  }
}

export default PostContent;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\components\posts\PostDetail.tsx -----

import Avatar from '@mui/material/Avatar';
import Paper from '@mui/material/Paper';
import Tooltip from '@mui/material/Tooltip';
import { observer } from 'mobx-react';
import moment from 'moment';
import React from 'react';

import confirm from '../../lib/confirm';
import notify from '../../lib/notify';
import { Store } from '../../lib/store';
import { Post } from '../../lib/store/post';
import { User } from '../../lib/store/user';

import MenuWithMenuItems from '../common/MenuWithMenuItems';

import PostContent from './PostContent';

const stylePaper = {
  margin: '10px 0px',
  padding: '20px',
};

const styleLineSeparator = {
  verticalAlign: 'text-bottom',
  fontWeight: 300,
  fontSize: '16px',
  margin: '0px 5px',
  opacity: 0.75,
};

const getMenuOptions = (post) => ({
  dataId: post._id,
  id: `post-menu-${post._id}`,
});

const getMenuItemOptions = (post: Post, currentUser: User, component) => {
  const items = [];

  if (post.createdUserId !== currentUser._id) {
    items.push({
      text: 'Show Markdown',
      dataId: post._id,
      onClick: component.showMarkdown,
    });
  }

  if (post.createdUserId === currentUser._id) {
    const isFirstPost = post.discussion.posts.indexOf(post) === 0;

    items.push({
      text: 'Edit',
      dataId: post._id,
      onClick: component.editPost,
    });

    if (!isFirstPost) {
      items.push({
        text: 'Delete',
        dataId: post._id,
        onClick: component.deletePost,
      });
    }
  }

  return items;
};

type Props = {
  post: Post;
  store: Store;
  isMobile: boolean;
  onEditClick: (post) => void;
  onShowMarkdownClick: (post) => void;
};

class PostDetail extends React.Component<Props> {
  public render() {
    const { post, isMobile } = this.props;

    return <Paper style={stylePaper}>{this.renderPostDetail(post, isMobile)}</Paper>;
  }

  public renderPostDetail(post: Post, isMobile) {
    const createdDate = moment(post.createdAt).local().format('MMM Do YYYY');
    const lastUpdatedDate = moment(post.lastUpdatedAt).fromNow();

    return (
      <React.Fragment>
        <div
          style={{
            float: 'left',
            margin: '-12px 10px 0px -15px',
            zIndex: 1000,
          }}
        >
          {this.renderMenu()}
        </div>
        <div id={`post-${post._id}`}>
          {post.user && (
            <Tooltip
              title={post.user.displayName}
              placement="top"
              disableFocusListener
              disableTouchListener
            >
              <Avatar
                src={post.user.avatarUrl}
                alt={post.user.displayName}
                style={{
                  width: '40px',
                  height: '40px',
                  margin: '0px 10px 0px 5px',
                  cursor: 'pointer',
                  float: 'left',
                }}
              />
            </Tooltip>
          )}
          <div
            style={{
              margin: isMobile ? '0px' : '0px 20px 0px 70px',
              fontWeight: 300,
              lineHeight: '1em',
            }}
          >
            <span style={{ fontSize: '12px', fontWeight: 400 }}>
              {`By: ${post.user && post.user.displayName}` || 'User'}
              <span style={styleLineSeparator}>|</span>
              {`Created: ${post.createdAt && createdDate}` || ''}

              {post.isEdited ? (
                <React.Fragment>
                  <span style={styleLineSeparator}>|</span>
                  Last edited: {lastUpdatedDate}
                </React.Fragment>
              ) : null}
            </span>

            <PostContent html={post.htmlContent} />
          </div>
        </div>
      </React.Fragment>
    );
  }

  public renderMenu() {
    const { post, store } = this.props;
    const { currentUser } = store;

    if (!post.user || !currentUser) {
      return null;
    }

    return (
      <MenuWithMenuItems
        menuOptions={getMenuOptions(post)}
        itemOptions={getMenuItemOptions(post, store.currentUser, this)}
      />
    );
  }

  public showMarkdown = () => {
    const { post, onShowMarkdownClick } = this.props;
    if (onShowMarkdownClick) {
      onShowMarkdownClick(post);
    }
  };

  public editPost = () => {
    const { post, onEditClick } = this.props;
    if (onEditClick) {
      onEditClick(post);
    }
    console.log(`PostDetail: ${post._id}`);
  };

  public deletePost = () => {
    confirm({
      title: 'Are you sure?',
      message: '',
      onAnswer: async (answer) => {
        if (answer) {
          const { post } = this.props;
          await post.discussion.deletePost(post);
          notify('You successfully deleted Post.');
        }
      },
    });
  };
}

export default observer(PostDetail);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\components\posts\PostEditor.tsx -----

import Avatar from '@mui/material/Avatar';
import Button from '@mui/material/Button';
import InsertPhotoIcon from '@mui/icons-material/InsertPhoto';
import he from 'he';
import { marked } from 'marked';
import { observer } from 'mobx-react';
import NProgress from 'nprogress';
import React from 'react';
import { Mention, MentionsInput } from 'react-mentions';

import {
  getSignedRequestForUploadApiMethod,
  uploadFileUsingSignedPutRequestApiMethod,
} from '../../lib/api/team-member';
import notify from '../../lib/notify';
import { resizeImage } from '../../lib/resizeImage';
import { Store } from '../../lib/store';
import { User } from '../../lib/store/user';

import PostContent from './PostContent';

function getImageDimension(file): Promise<{ width: number; height: number }> {
  const reader = new FileReader();
  const img = new Image();

  return new Promise((resolve) => {
    reader.readAsDataURL(file);

    reader.onload = (e) => {
      img.onload = () => {
        resolve({ width: img.width, height: img.height });
      };

      img.src = e.target.result.toString();
    };
  });
}

type Props = {
  store: Store;
  onChanged: (content) => void;
  content: string;
  members: User[];
  textareaHeight?: string;
  placeholder?: string;
  parentComponent: string;
};

type State = { htmlContent: string };

class PostEditor extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      htmlContent: '',
    };
  }

  public render() {
    const { htmlContent } = this.state;
    const { content, members, store, parentComponent } = this.props;
    const { currentUser } = store;

    const membersMinusCurrentUser = members.filter((member) => member._id !== currentUser._id);

    const isThemeDark = store && store.currentUser && store.currentUser.darkTheme === true;
    const textareaBackgroundColor = isThemeDark ? '#0d1117' : '#fff';

    return (
      <div style={{ marginTop: '20px' }}>
        <div style={{ display: 'inline-flex' }}>
          <Button
            onClick={this.showMarkdownContent}
            variant="text"
            style={{ fontWeight: htmlContent ? 300 : 600, color: '#58a6ff' }}
          >
            Markdown
          </Button>{' '}
          <Button
            onClick={this.showHtmlContent}
            variant="text"
            style={{ fontWeight: htmlContent ? 600 : 300, color: '#58a6ff' }}
          >
            HTML
          </Button>
        </div>

        <div style={{ display: 'inline', float: 'left' }}>
          <label htmlFor={'upload-file-post-editor-' + parentComponent}>
            <Button component="span" style={{ color: '#58a6ff' }}>
              <InsertPhotoIcon style={{ fontSize: '22px' }} />
            </Button>
          </label>
          <input
            accept="image/*"
            name={'upload-file-post-editor-' + parentComponent}
            id={'upload-file-post-editor-' + parentComponent}
            type="file"
            style={{ display: 'none' }}
            onChange={async (event) => {
              const file = event.target.files[0];
              await this.uploadFile(file);
              event.target.value = '';
            }}
          />
        </div>
        <br />
        <div
          style={{
            padding: '10px 15px',
            border: isThemeDark
              ? '1px solid rgba(255, 255, 255, 0.5)'
              : '1px solid rgba(0, 0, 0, 0.5)',
          }}
        >
          {htmlContent ? (
            <PostContent html={htmlContent} />
          ) : (
            <MentionsInput
              style={{
                input: {
                  border: 'none',
                  outline: 'none',
                  color: isThemeDark ? '#fff' : '#000',
                  fontFamily: 'Roboto, sans-serif',
                  lineHeight: '1.5em',
                  backgroundColor: content ? textareaBackgroundColor : 'transparent',
                },

                '&multiLine': {
                  control: {
                    fontFamily: 'Roboto, sans-serif',
                    minHeight: 100,
                  },
                },
                suggestions: {
                  list: {
                    backgroundColor: '#222',
                    color: '#fff',
                  },

                  item: {
                    padding: '5px 15px',
                    borderBottom: '1px solid rgba(0,0,0,0.15)',

                    '&focused': {
                      backgroundColor: 'rgba(255, 255, 255, 0.1)',
                    },
                  },
                },
              }}
              autoFocus
              value={content}
              placeholder={this.props.placeholder ? this.props.placeholder : 'Compose new post'}
              onChange={(event) => {
                this.props.onChanged(event.target.value);
              }}
            >
              <Mention
                trigger="@"
                data={membersMinusCurrentUser.map((u) => ({
                  id: u.avatarUrl,
                  display: u.displayName,
                  // you: u._id === currentUser._id ? true : false,
                }))}
                markup={'[`@#__display__`](__id__)'}
                displayTransform={(_, display) => {
                  return `@${display}`;
                }}
                renderSuggestion={(suggestion) => (
                  <React.Fragment>
                    <Avatar
                      role="presentation"
                      src={suggestion.id}
                      alt={suggestion.display}
                      style={{
                        width: '24px',
                        height: '24px',
                        marginRight: '10px',
                        display: 'inline-flex',
                        verticalAlign: 'middle',
                      }}
                    />
                    <span style={{ marginRight: '5px' }}>{suggestion.display}</span>
                  </React.Fragment>
                )}
              />
            </MentionsInput>
          )}
        </div>
      </div>
    );
  }

  public showMarkdownContent = () => {
    this.setState({ htmlContent: '' });
  };

  public showHtmlContent = async () => {
    const { content } = this.props;

    function markdownToHtml(postContent) {
      const renderer = new marked.Renderer();

      renderer.link = (href, title, text) => {
        const t = title ? ` title="${title}"` : '';

        if (text.startsWith('<code>@#')) {
          return `${text.replace('<code>@#', '<code>@')} `;
        }

        return `
          <a target="_blank" href="${href}" rel="noopener noreferrer"${t}>
            ${text}
          </a>
        `;
      };

      marked.setOptions({
        renderer,
        breaks: true,
      });

      return marked(he.decode(postContent));
    }

    const htmlContent = content ? markdownToHtml(content) : '<span>Nothing to preview.</span>';
    this.setState({ htmlContent });
  };

  private uploadFile = async (file: File) => {
    if (!file) {
      notify('No file selected.');
      return;
    }

    if (!file.type || (!file.type.startsWith('image/') && file.type !== 'application/pdf')) {
      notify('Wrong file.');
      return;
    }

    const { store } = this.props;
    const { currentTeam } = store;

    NProgress.start();

    const bucket = process.env.NEXT_PUBLIC_BUCKET_FOR_POSTS;
    const prefix = `${currentTeam.slug}`;
    const fileName = file.name;
    const fileType = file.type;

    try {
      const responseFromApiServerForUpload = await getSignedRequestForUploadApiMethod({
        fileName,
        fileType,
        prefix,
        bucket,
      });

      let fileHtmlOrMarkdown;
      let fileUrl;

      if (file.type.startsWith('image/')) {
        const { width } = await getImageDimension(file);
        const resizedFile = await resizeImage(file, 1024, 1024);

        await uploadFileUsingSignedPutRequestApiMethod(
          resizedFile,
          responseFromApiServerForUpload.signedRequest,
        );

        fileUrl = responseFromApiServerForUpload.url;

        // console.log(fileUrl);

        const finalWidth = width > 768 ? '100%' : `${width}px`;

        fileHtmlOrMarkdown = `
          <div>
            <img style="max-width: ${finalWidth}; width:100%" src="${fileUrl}" alt="Async" class="s3-image" />
          </div>`;
      } else {
        await uploadFileUsingSignedPutRequestApiMethod(
          file,
          responseFromApiServerForUpload.signedRequest,
        );

        fileUrl = responseFromApiServerForUpload.url;
        fileHtmlOrMarkdown = `[${file.name}](${fileUrl})`;
      }

      const content = `${this.props.content}\n${fileHtmlOrMarkdown.replace(/\s+/g, ' ')}`;

      this.props.onChanged(content);

      notify('You successfully uploaded file.');
    } catch (error) {
      console.log(error);
      notify(error);
    } finally {
      NProgress.done();
    }
  };
}

export default observer(PostEditor);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\components\posts\PostForm.tsx -----

import Button from '@mui/material/Button';
import he from 'he';
import { marked } from 'marked';
import { observer } from 'mobx-react';
import NProgress from 'nprogress';
import React from 'react';

import notify from '../../lib/notify';
import { Store } from '../../lib/store';
import { Discussion } from '../../lib/store/discussion';
import { Post } from '../../lib/store/post';
import { User } from '../../lib/store/user';

import PostEditor from './PostEditor';

const dev = process.env.NODE_ENV !== 'production';

type Props = {
  store: Store;
  isMobile: boolean;
  members: User[];
  post: Post;
  discussion: Discussion;
  showMarkdownToNonCreator?: boolean;
  onFinished?: () => void;
};

type State = {
  postId: string;
  content: string;
  disabled: boolean;
};

class PostForm extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      postId: null,
      content: '',
      disabled: false,
    };
  }

  public static getDerivedStateFromProps(props: Props, state: State) {
    const { post } = props;

    if (!post && !state.postId) {
      return null;
    }

    if (post && post._id === state.postId) {
      return null;
    }

    return {
      postId: (post && post._id) || null,
      content: (post && post.content) || '',
    };
  }

  public render() {
    const { store, members, post, isMobile, showMarkdownToNonCreator } = this.props;
    const isEditingPost = !!post;

    let title = 'Add Post';
    if (showMarkdownToNonCreator) {
      title = 'Showing Markdown';
    } else if (isEditingPost) {
      title = 'Edit Post';
    }

    return (
      <div style={{ height: '100%', margin: '0px 20px' }}>
        <p />
        <br />
        <h3>{title}</h3>
        <form style={{ width: '100%', height: '100%' }} onSubmit={this.onSubmit} autoComplete="off">
          <p />
          <br />
          <div>
            {showMarkdownToNonCreator ? null : (
              <React.Fragment>
                <Button
                  type="submit"
                  variant="contained"
                  color="primary"
                  disabled={this.state.disabled}
                >
                  {isEditingPost ? 'Save changes' : 'Publish Post'}
                </Button>
                {isMobile ? <p /> : null}
              </React.Fragment>
            )}
            {isEditingPost ? (
              <Button
                variant="outlined"
                onClick={this.closeForm}
                disabled={this.state.disabled}
                style={{ marginLeft: '10px' }}
              >
                {showMarkdownToNonCreator ? 'Go back' : 'Cancel'}
              </Button>
            ) : null}
          </div>
          <p />
          <br />
          <PostEditor
            content={this.state.content}
            onChanged={this.onContentChanged}
            members={members}
            store={store}
            textareaHeight="100%"
            parentComponent="PF"
          />
          <p />
          <div style={{ margin: '20px 0px' }}>
            {isEditingPost ? (
              <Button
                variant="outlined"
                onClick={this.closeForm}
                disabled={this.state.disabled}
                style={{ marginLeft: '10px' }}
              >
                {showMarkdownToNonCreator ? 'Go back' : 'Cancel'}
              </Button>
            ) : null}
          </div>
          <p />
          <br />
        </form>
      </div>
    );
  }

  private onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();

    const { content } = this.state;
    const htmlContent = marked(he.decode(content));
    const { post, onFinished, store, discussion } = this.props;
    const isEditingPost = !!post;

    if (!content) {
      notify('Add content to your Post');
      return;
    }

    if (isEditingPost) {
      this.setState({ disabled: true });
      NProgress.start();
      try {
        await post.editPost({ content, htmlContent });
        notify('You successfully edited Post');
      } catch (error) {
        console.log(error);
        notify(error);
      } finally {
        this.setState({ disabled: false });
        NProgress.done();
      }

      if (onFinished) {
        onFinished();
      }

      return;
    }

    const { currentTeam } = store;
    if (!currentTeam) {
      notify('Team is not selected or does not exist.');
      return;
    }

    NProgress.start();
    this.setState({ disabled: true });

    try {
      const post = await discussion.addPost(content);

      if (discussion.notificationType === 'email') {
        const userIdsForLambda = discussion.memberIds.filter((m) => m !== store.currentUser._id);

        await discussion.sendDataToLambda({
          discussionName: discussion.name,
          discussionLink: `${
            dev ? process.env.NEXT_PUBLIC_URL_APP : process.env.NEXT_PUBLIC_PRODUCTION_URL_APP
          }/teams/${discussion.team.slug}/discussions/${discussion.slug}`,
          postContent: post.content,
          authorName: post.user.displayName,
          userIds: userIdsForLambda,
        });
      }

      this.setState({ content: '' });

      notify('You successfully published new Post.');
    } catch (error) {
      console.log(error);
      notify(error);
    } finally {
      this.setState({ disabled: false });
      NProgress.done();
    }

    if (onFinished) {
      onFinished();
    }
  };

  private onContentChanged = (content: string) => {
    this.setState({ content });
  };

  private closeForm = () => {
    this.setState({ postId: null, content: '' });

    const { onFinished } = this.props;
    if (onFinished) {
      onFinished();
    }
  };
}

export default observer(PostForm);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\components\teams\InviteMember.tsx -----

import Button from '@mui/material/Button';
import Dialog from '@mui/material/Dialog';
import DialogContent from '@mui/material/DialogContent';
import DialogTitle from '@mui/material/DialogTitle';
import TextField from '@mui/material/TextField';
import { inject, observer } from 'mobx-react';
import NProgress from 'nprogress';
import React from 'react';

import notify from '../../lib/notify';
import { Store } from '../../lib/store';

type Props = {
  store: Store;
  onClose: () => void;
  open: boolean;
};

type State = {
  email: string;
  disabled: boolean;
};

class InviteMember extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      email: '',
      disabled: false,
    };
  }

  public render() {
    const { open } = this.props;

    return (
      <Dialog onClose={this.handleClose} aria-labelledby="invite-member-dialog-title" open={open}>
        <DialogTitle id="invite-member-dialog-title">Invite member</DialogTitle>
        <DialogContent>
          <form onSubmit={this.onSubmit} style={{ padding: '20px' }}>
            <TextField
              autoComplete="off"
              value={this.state.email}
              placeholder="Email"
              onChange={(event) => {
                this.setState({ email: event.target.value });
              }}
            />
            <p />
            <br />
            <Button variant="outlined" onClick={this.handleClose} disabled={this.state.disabled}>
              Cancel
            </Button>{' '}
            <Button
              type="submit"
              variant="contained"
              color="primary"
              disabled={this.state.disabled}
            >
              Invite
            </Button>
          </form>
        </DialogContent>
      </Dialog>
    );
  }

  private handleClose = () => {
    this.setState({ email: '', disabled: false });
    this.props.onClose();
  };

  private onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();

    const { store } = this.props;

    if (!store.currentTeam) {
      notify('Team have not selected');
      return;
    }

    const { email } = this.state;

    if (!email) {
      notify('Email is required');
      return;
    }

    NProgress.start();
    try {
      this.setState({ disabled: true });
      await store.currentTeam.inviteMember(email);

      this.setState({ email: '' });
      notify('You successfully sent invitation.');
      NProgress.done();
    } catch (error) {
      console.log(error);
      notify(error);
    } finally {
      this.props.onClose();
      this.setState({ disabled: false });
      NProgress.done();
    }
  };
}

export default inject('store')(observer(InviteMember));

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\lib\api\makeQueryString.ts -----

function makeQueryString(params) {
  const query = Object.keys(params)
    .filter((k) => !!params[k])
    .map((k) => `${encodeURIComponent(k)}=${encodeURIComponent(params[k])}`)
    .join('&');

  return query;
}

export { makeQueryString };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\lib\api\public.ts -----

import sendRequestAndGetResponse from './sendRequestAndGetResponse';

const BASE_PATH = '/api/v1/public';

export const getUserApiMethod = (request) =>
  sendRequestAndGetResponse(`${BASE_PATH}/get-user`, {
    request,
    method: 'GET',
  });

export const getUserBySlugApiMethod = (slug) =>
  sendRequestAndGetResponse(`${BASE_PATH}/get-user-by-slug`, {
    body: JSON.stringify({ slug }),
  });

export const emailLoginLinkApiMethod = ({
  email,
  invitationToken,
}: {
  email: string;
  invitationToken?: string;
}) =>
  sendRequestAndGetResponse('/auth/email-login-link', {
    qs: { invitationToken },
    body: JSON.stringify({ user: email }),
  });

export const getTeamByTokenApiMethod = (token: string, request) =>
  sendRequestAndGetResponse(`${BASE_PATH}/invitations/get-team-by-token`, {
    request,
    method: 'GET',
    qs: { token },
  });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\lib\api\sendRequestAndGetResponse.ts -----

import 'isomorphic-unfetch';

import { makeQueryString } from './makeQueryString';

const dev = process.env.NODE_ENV !== 'production';

export default async function sendRequestAndGetResponse(path, opts: any = {}) {
  const headers = Object.assign(
    {},
    opts.headers || {},
    opts.externalServer
      ? {}
      : {
          'Content-type': 'application/json; charset=UTF-8',
        },
  );

  const { request } = opts;

  if (request && request.headers && request.headers.cookie) {
    headers.cookie = request.headers.cookie;
  }

  // const qs = opts.qs || '';

  const qs = (opts.qs && `?${makeQueryString(opts.qs)}`) || '';

  // console.log(`before: ${process.env.NEXT_PUBLIC_URL_API}${path}${qs}`);

  const response = await fetch(
    opts.externalServer
      ? `${path}${qs}`
      : `${
          dev ? process.env.NEXT_PUBLIC_URL_API : process.env.NEXT_PUBLIC_PRODUCTION_URL_API
        }${path}${qs}`,
    Object.assign({ method: 'POST', credentials: 'include' }, opts, { headers }),
  );

  // console.log(`after: ${process.env.NEXT_PUBLIC_URL_API}${path}${qs}`);

  // console.log(response.status);
  // console.log(response.statusText);

  const text = await response.text();

  if (response.status >= 400) {
    console.error(text);
    throw new Error(response.status.toString());
  }

  try {
    const data = JSON.parse(text);

    return data;
  } catch (err) {
    if (err instanceof SyntaxError) {
      return text;
    }

    throw err;
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\lib\api\team-leader.ts -----

import sendRequestAndGetResponse from './sendRequestAndGetResponse';

const BASE_PATH = '/api/v1/team-leader';

export const addTeamApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams/add`, {
    body: JSON.stringify(data),
  });

export const updateTeamApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams/update`, {
    body: JSON.stringify(data),
  });

export const getTeamInvitationsApiMethod = (teamId: string) =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams/get-invitations-for-team`, {
    method: 'GET',
    qs: { teamId },
  });

export const inviteMemberApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams/invite-member`, {
    body: JSON.stringify(data),
  });

export const removeMemberApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams/remove-member`, {
    body: JSON.stringify(data),
  });

export const fetchCheckoutSessionApiMethod = ({ mode, teamId }: { mode: string; teamId: string }) =>
  sendRequestAndGetResponse(`${BASE_PATH}/stripe/fetch-checkout-session`, {
    body: JSON.stringify({ mode, teamId }),
  });

export const cancelSubscriptionApiMethod = ({ teamId }: { teamId: string }) =>
  sendRequestAndGetResponse(`${BASE_PATH}/cancel-subscription`, {
    body: JSON.stringify({ teamId }),
  });

export const getListOfInvoicesApiMethod = () =>
  sendRequestAndGetResponse(`${BASE_PATH}/get-list-of-invoices-for-customer`, {
    method: 'GET',
  });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\lib\api\team-member.ts -----

import sendRequestAndGetResponse from './sendRequestAndGetResponse';

const BASE_PATH = '/api/v1/team-member';

export const getSignedRequestForUploadApiMethod = ({ fileName, fileType, prefix, bucket }) =>
  sendRequestAndGetResponse(`${BASE_PATH}/aws/get-signed-request-for-upload-to-s3`, {
    body: JSON.stringify({ fileName, fileType, prefix, bucket }),
  });

export const uploadFileUsingSignedPutRequestApiMethod = (file, signedRequest, headers = {}) =>
  sendRequestAndGetResponse(signedRequest, {
    externalServer: true,
    method: 'PUT',
    body: file,
    headers,
  });

export const updateProfileApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/user/update-profile`, {
    body: JSON.stringify(data),
  });

export const toggleThemeApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/user/toggle-theme`, {
    body: JSON.stringify(data),
  });

export const getInitialDataApiMethod = (options: any = {}) =>
  sendRequestAndGetResponse(
    `${BASE_PATH}/get-initial-data`,
    Object.assign(
      {
        body: JSON.stringify(options.data || {}),
      },
      options,
    ),
  );

// export const getTeamListApiMethod = () =>
//   sendRequestAndGetResponse(`${BASE_PATH}/teams`, {
//     method: 'GET',
//   });

export const getTeamMembersApiMethod = (teamId: string) =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams/get-members`, {
    method: 'GET',
    qs: { teamId },
  });

// Discussion and Post

export const getDiscussionListApiMethod = (params): Promise<{ discussions: any[] }> =>
  sendRequestAndGetResponse(`${BASE_PATH}/discussions/list`, {
    method: 'GET',
    qs: params,
  });

export const addDiscussionApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/discussions/add`, {
    body: JSON.stringify(data),
  });

export const editDiscussionApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/discussions/edit`, {
    body: JSON.stringify(data),
  });

export const deleteDiscussionApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/discussions/delete`, {
    body: JSON.stringify(data),
  });

export const getPostListApiMethod = (discussionId: string) =>
  sendRequestAndGetResponse(`${BASE_PATH}/posts/list`, {
    method: 'GET',
    qs: { discussionId },
  });

export const addPostApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/posts/add`, {
    body: JSON.stringify(data),
  });

export const editPostApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/posts/edit`, {
    body: JSON.stringify(data),
  });

export const deletePostApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/posts/delete`, {
    body: JSON.stringify(data),
  });

export const sendDataToLambdaApiMethod = (data) =>
  sendRequestAndGetResponse(`${process.env.NEXT_PUBLIC_API_GATEWAY_ENDPOINT}/`, {
    externalServer: true,
    body: JSON.stringify(data),
  });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\lib\store\discussion.ts -----

import { action, IObservableArray, observable, runInAction, computed, makeObservable } from 'mobx';

import {
  addPostApiMethod,
  deletePostApiMethod,
  editDiscussionApiMethod,
  getPostListApiMethod,
  sendDataToLambdaApiMethod,
} from '../api/team-member';
import { Store } from './index';
import { Team } from './team';
import { Post } from './post';

class Discussion {
  public _id: string;
  public createdUserId: string;
  public store: Store;
  public team: Team;

  public name: string;
  public slug: string;
  public memberIds: IObservableArray<string> = observable([]);
  public posts: IObservableArray<Post> = observable([]);
  public isLoadingPosts = false;

  public notificationType: string;

  constructor(params) {
    makeObservable(this, {
      name: observable,
      slug: observable,
      memberIds: observable,
      posts: observable,
      isLoadingPosts: observable,

      editDiscussion: action,
      changeLocalCache: action,

      setInitialPosts: action,
      loadPosts: action,
      addPost: action,
      addPostToLocalCache: action,
      deletePost: action,

      addDiscussionToLocalCache: action,
      editDiscussionFromLocalCache: action,
      deleteDiscussionFromLocalCache: action,
      editPostFromLocalCache: action,
      deletePostFromLocalCache: action,

      members: computed,
    });

    this._id = params._id;
    this.createdUserId = params.createdUserId;
    this.store = params.store;
    this.team = params.team;

    this.name = params.name;
    this.slug = params.slug;
    this.memberIds.replace(params.memberIds || []);

    this.notificationType = params.notificationType;

    if (params.initialPosts) {
      this.setInitialPosts(params.initialPosts);
      console.log(params.initialPosts[0]);
    } else {
      this.loadPosts();
    }
  }

  public async editDiscussion(data) {
    try {
      await editDiscussionApiMethod({
        id: this._id,
        ...data,
        socketId: (this.store.socket && this.store.socket.id) || null,
      });

      runInAction(() => {
        this.changeLocalCache(data);
      });
    } catch (error) {
      console.error(error);
      throw error;
    }
  }

  public changeLocalCache(data) {
    this.name = data.name;
    this.memberIds.replace(data.memberIds || []);
  }

  get members() {
    return this.memberIds.map((id) => this.team.members.get(id)).filter((u) => !!u);
  }

  public setInitialPosts(posts) {
    const postObjs = posts.map((p) => new Post({ discussion: this, store: this.store, ...p }));
    this.posts.replace(postObjs);
  }

  public async loadPosts() {
    if (this.store.isServer || this.isLoadingPosts) {
      return;
    }

    this.isLoadingPosts = true;

    try {
      const { posts = [] } = await getPostListApiMethod(this._id);

      runInAction(() => {
        const postObjs = posts.map((t) => new Post({ discussion: this, store: this.store, ...t }));
        this.posts.replace(postObjs);
      });
    } finally {
      runInAction(() => {
        this.isLoadingPosts = false;
      });
    }
  }

  public async addPost(content: string): Promise<Post> {
    const { post } = await addPostApiMethod({
      discussionId: this._id,
      content,
      socketId: (this.store.socket && this.store.socket.id) || null,
    });

    return new Promise<Post>((resolve) => {
      runInAction(() => {
        const obj = this.addPostToLocalCache(post);
        resolve(obj);
      });
    });
  }

  public addPostToLocalCache(data) {
    const postObj = new Post({ discussion: this, store: this.store, ...data });

    this.posts.push(postObj);

    return postObj;
  }

  public async deletePost(post: Post) {
    await deletePostApiMethod({
      id: post._id,
      discussionId: this._id,
      socketId: (this.store.socket && this.store.socket.id) || null,
    });

    runInAction(() => {
      this.posts.remove(post);
    });
  }

  public joinSocketRooms() {
    if (this.store.socket) {
      console.log('joining socket discussion room', this.name);
      this.store.socket.emit('joinTeamRoom', this.team._id);
      this.store.socket.emit('joinDiscussionRoom', this._id);
    }
  }

  public leaveSocketRooms() {
    if (this.store.socket) {
      console.log('leaving socket discussion room', this.name);
      this.store.socket.emit('leaveTeamRoom', this.team._id);
      this.store.socket.emit('leaveDiscussionRoom', this._id);
    }
  }

  public handleDiscussionRealtimeEvent = (data) => {
    console.log('discussion realtime event', data);
    const { actionType } = data;

    if (actionType === 'added') {
      this.addDiscussionToLocalCache(data.discussion);
    } else if (actionType === 'edited') {
      this.editDiscussionFromLocalCache(data.discussion);
    } else if (actionType === 'deleted') {
      this.deleteDiscussionFromLocalCache(data.id);
    }
  };

  public addDiscussionToLocalCache(data): Discussion {
    const obj = new Discussion({ team: this.team, store: this.store, ...data });

    if (obj.memberIds.includes(this.store.currentUser._id)) {
      this.team.discussions.push(obj);
    }

    return obj;
  }

  public editDiscussionFromLocalCache(data) {
    const discussion = this.team.discussions.find((item) => item._id === data._id);
    if (discussion) {
      if (data.memberIds && data.memberIds.includes(this.store.currentUser._id)) {
        discussion.changeLocalCache(data);
      } else {
        this.deleteDiscussionFromLocalCache(data._id);
      }
    } else if (data.memberIds && data.memberIds.includes(this.store.currentUser._id)) {
      this.addDiscussionToLocalCache(data);
    }
  }

  public deleteDiscussionFromLocalCache(discussionId: string) {
    const discussion = this.team.discussions.find((item) => item._id === discussionId);
    this.team.discussions.remove(discussion);
  }

  public handlePostRealtimeEvent(data) {
    const { actionType } = data;

    if (actionType === 'added') {
      this.addPostToLocalCache(data.post);
    } else if (actionType === 'edited') {
      this.editPostFromLocalCache(data.post);
    } else if (actionType === 'deleted') {
      this.deletePostFromLocalCache(data.id);
    }
  }

  public editPostFromLocalCache(data) {
    const post = this.posts.find((t) => t._id === data._id);
    if (post) {
      post.changeLocalCache(data);
    }
  }

  public deletePostFromLocalCache(postId) {
    const post = this.posts.find((t) => t._id === postId);
    this.posts.remove(post);
  }

  public async sendDataToLambda({
    discussionName,
    discussionLink,
    postContent,
    authorName,
    userIds,
  }) {
    console.log(discussionName, discussionLink, authorName, postContent, userIds);
    try {
      await sendDataToLambdaApiMethod({
        discussionName,
        discussionLink,
        postContent,
        authorName,
        userIds,
      });
    } catch (error) {
      console.error(error);
      throw error;
    }
  }
}

export { Discussion };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\lib\store\index.ts -----

import { action, configure, IObservableArray, observable, makeObservable } from 'mobx';
import { enableStaticRendering } from 'mobx-react';
import { io, Socket } from 'socket.io-client';

import { addTeamApiMethod, getTeamInvitationsApiMethod } from '../api/team-leader';
import { getTeamMembersApiMethod } from '../api/team-member';

import { User } from './user';
import { Team } from './team';

const dev = process.env.NODE_ENV !== 'production';

enableStaticRendering(typeof window === 'undefined');

configure({ enforceActions: 'observed' });

class Store {
  public isServer: boolean;

  public currentUser?: User = null;
  public currentUrl = '';

  public currentTeam?: Team = null;

  public teams: IObservableArray<Team> = observable([]);

  public socket: Socket;

  constructor({
    initialState = {},
    isServer,
    socket = null,
  }: {
    initialState?: any;
    isServer: boolean;
    socket?: Socket;
  }) {
    makeObservable(this, {
      currentUser: observable,
      currentUrl: observable,
      currentTeam: observable,

      changeCurrentUrl: action,
      setCurrentUser: action,
      setCurrentTeam: action,
    });

    this.isServer = !!isServer;

    // console.log('initialState.user', initialState.user);

    this.setCurrentUser(initialState.user);

    this.currentUrl = initialState.currentUrl || '';

    // console.log(initialState);

    this.setCurrentTeam(initialState.team);

    if (initialState.teams && initialState.teams.length > 0) {
      this.setInitialTeamsStoreMethod(initialState.teams);
    }

    this.socket = socket;

    if (socket) {
      socket.on('disconnect', () => {
        console.log('socket: ## disconnected');
      });

      socket.on('reconnect', (attemptNumber) => {
        console.log('socket: $$ reconnected', attemptNumber);
      });
    }
  }

  public changeCurrentUrl(url: string) {
    this.currentUrl = url;
  }

  public async setCurrentUser(user) {
    if (user) {
      this.currentUser = new User({ store: this, ...user });
    } else {
      this.currentUser = null;
    }
  }

  public async addTeam({ name, avatarUrl }: { name: string; avatarUrl: string }): Promise<Team> {
    const data = await addTeamApiMethod({ name, avatarUrl });
    const team = new Team({ store: this, ...data });

    return team;
  }

  public async setCurrentTeam(team) {
    if (this.currentTeam) {
      if (this.currentTeam.slug === team.slug) {
        return;
      }
    }

    if (team) {
      this.currentTeam = new Team({ ...team, store: this });

      const users =
        team.initialMembers || (await getTeamMembersApiMethod(this.currentTeam._id)).users;

      const invitations =
        team.initialInvitations ||
        (await getTeamInvitationsApiMethod(this.currentTeam._id)).invitations;

      this.currentTeam.setInitialMembersAndInvitations(users, invitations);
    } else {
      this.currentTeam = null;
    }
  }

  private setInitialTeamsStoreMethod(teams: any[]) {
    // console.log(initialTeams);

    const teamObjs = teams.map((t) => new Team({ store: this, ...t }));

    this.teams.replace(teamObjs);
  }
}

let store: Store = null;

function initializeStore(initialState = {}) {
  const isServer = typeof window === 'undefined';

  const socket = isServer
    ? null
    : io(dev ? process.env.NEXT_PUBLIC_URL_API : process.env.NEXT_PUBLIC_PRODUCTION_URL_API, {
        reconnection: true,
        autoConnect: true,
        transports: ['polling', 'websocket'],
        withCredentials: true,
      });

  const _store =
    store !== null && store !== undefined ? store : new Store({ initialState, isServer, socket });

  // For SSG and SSR always create a new store
  if (typeof window === 'undefined') {
    return _store;
  }
  // Create the store once in the client
  if (!store) {
    store = _store;
  }

  // console.log(_store);

  return _store;
}

function getStore() {
  return store;
}

export { Store, initializeStore, getStore };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\lib\store\invitation.ts -----

class Invitation {
  public _id: string;
  public teamId: string;
  public email: string;
  public createdAt: Date;

  constructor(params) {
    Object.assign(this, params);
  }
}

export { Invitation };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\lib\store\post.ts -----

import { action, computed, observable, runInAction, makeObservable } from 'mobx';

import { editPostApiMethod } from '../api/team-member';

import { Store } from './index';
import { User } from './user';
import { Discussion } from './discussion';

export class Post {
  public _id: string;
  public createdUserId: string;
  public createdAt: Date;
  public discussionId: string;

  public discussion: Discussion;
  public store: Store;

  public content: string;
  public htmlContent: string;

  public isEdited: boolean;
  public lastUpdatedAt: Date;

  constructor(params) {
    makeObservable(this, {
      content: observable,
      htmlContent: observable,
      isEdited: observable,
      lastUpdatedAt: observable,

      editPost: action,
      changeLocalCache: action,

      user: computed,
    });

    this._id = params._id;
    this.createdUserId = params.createdUserId;
    this.createdAt = params.createdAt;
    this.discussionId = params.discussionId;

    this.content = params.content;
    this.htmlContent = params.htmlContent;

    this.discussion = params.discussion;
    this.store = params.store;

    this.isEdited = params.isEdited;
    this.lastUpdatedAt = params.lastUpdatedAt;
  }

  public async editPost(data) {
    try {
      await editPostApiMethod({
        id: this._id,
        content: data.content,
        socketId: (this.store.socket && this.store.socket.id) || null,
      });

      runInAction(() => {
        this.changeLocalCache(data);
      });
    } catch (error) {
      console.error(error);
      throw error;
    }
  }

  public changeLocalCache(data) {
    this.content = data.content;
    this.htmlContent = data.htmlContent;
    this.isEdited = true;
    this.lastUpdatedAt = data.lastUpdatedAt;
  }

  get user(): User {
    return this.discussion.team.members.get(this.createdUserId) || null;
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\lib\store\team.ts -----

import { action, computed, IObservableArray, observable, runInAction, makeObservable } from 'mobx';
import Router from 'next/router';
import {
  cancelSubscriptionApiMethod,
  inviteMemberApiMethod,
  removeMemberApiMethod,
  updateTeamApiMethod,
} from '../api/team-leader';
import {
  addDiscussionApiMethod,
  deleteDiscussionApiMethod,
  getDiscussionListApiMethod,
} from '../api/team-member';
import { Store } from './index';
import { User } from './user';
import { Invitation } from './invitation';
import { Discussion } from './discussion';

class Team {
  public store: Store;

  public _id: string;
  public teamLeaderId: string;

  public name: string;
  public slug: string;
  public avatarUrl: string;
  public memberIds: IObservableArray<string> = observable([]);
  public members: Map<string, User> = new Map();
  public invitations: Map<string, Invitation> = new Map();

  public currentDiscussion?: Discussion;
  public currentDiscussionSlug?: string;
  public discussions: IObservableArray<Discussion> = observable([]);
  public isLoadingDiscussions = false;

  public stripeSubscription: {
    id: string;
    object: string;
    application_fee_percent: number;
    billing: string;
    cancel_at_period_end: boolean;
    billing_cycle_anchor: number;
    canceled_at: number;
    created: number;
  };
  public isSubscriptionActive: boolean;
  public isPaymentFailed: boolean;

  constructor(params) {
    makeObservable(this, {
      name: observable,
      slug: observable,
      avatarUrl: observable,
      memberIds: observable,
      members: observable,
      invitations: observable,
      currentDiscussion: observable,
      currentDiscussionSlug: observable,
      isLoadingDiscussions: observable,
      discussions: observable,

      setInitialMembersAndInvitations: action,
      updateTheme: action,
      inviteMember: action,
      removeMember: action,
      setInitialDiscussions: action,
      loadDiscussions: action,
      addDiscussion: action,
      addDiscussionToLocalCache: action,
      deleteDiscussion: action,
      deleteDiscussionFromLocalCache: action,
      getDiscussionBySlug: action,

      orderedDiscussions: computed,
    });

    this._id = params._id;
    this.teamLeaderId = params.teamLeaderId;
    this.slug = params.slug;
    this.name = params.name;
    this.avatarUrl = params.avatarUrl;
    this.memberIds.replace(params.memberIds || []);
    this.currentDiscussionSlug = params.currentDiscussionSlug || null;

    this.stripeSubscription = params.stripeSubscription;
    this.isSubscriptionActive = params.isSubscriptionActive;
    this.isPaymentFailed = params.isPaymentFailed;

    this.store = params.store;

    if (params.initialDiscussions) {
      this.setInitialDiscussions(params.initialDiscussions);
    } else {
      this.loadDiscussions();
    }
  }

  public setInitialMembersAndInvitations(users, invitations) {
    this.members.clear();
    this.invitations.clear();

    for (const user of users) {
      if (this.store.currentUser && this.store.currentUser._id === user._id) {
        this.members.set(user._id, this.store.currentUser);
      } else {
        this.members.set(user._id, new User(user));
      }
    }

    for (const invitation of invitations || []) {
      this.invitations.set(invitation._id, new Invitation(invitation));
    }

    // console.log(this.members);
  }

  public async updateTheme({ name, avatarUrl }: { name: string; avatarUrl: string }) {
    try {
      const { slug } = await updateTeamApiMethod({
        teamId: this._id,
        name,
        avatarUrl,
      });

      runInAction(() => {
        this.name = name;
        this.avatarUrl = avatarUrl;
        this.slug = slug;
      });
    } catch (error) {
      console.error(error);
      throw error;
    }
  }

  public async inviteMember(email: string) {
    try {
      const { newInvitation } = await inviteMemberApiMethod({ teamId: this._id, email });

      runInAction(() => {
        this.invitations.set(newInvitation._id, new Invitation(newInvitation));
      });
    } catch (error) {
      console.error(error);
      throw error;
    }
  }

  public async removeMember(userId: string) {
    try {
      await removeMemberApiMethod({ teamId: this._id, userId });

      runInAction(() => {
        this.members.delete(userId);
        this.memberIds.remove(userId);
      });
    } catch (error) {
      console.error(error);
      throw error;
    }
  }

  public setCurrentDiscussion({ slug }: { slug: string }) {
    this.currentDiscussionSlug = slug;
    for (const discussion of this.discussions) {
      if (discussion && discussion.slug === slug) {
        this.currentDiscussion = discussion;
        break;
      }
    }
  }

  public setInitialDiscussions(discussions) {
    const discussionObjs = discussions.map(
      (d) => new Discussion({ team: this, store: this.store, ...d }),
    );

    this.discussions.replace(discussionObjs);

    if (!this.currentDiscussionSlug && this.discussions.length > 0) {
      this.currentDiscussionSlug = this.orderedDiscussions[0].slug;
    }

    if (this.currentDiscussionSlug) {
      this.setCurrentDiscussion({ slug: this.currentDiscussionSlug });
    }
  }

  public async loadDiscussions() {
    if (this.store.isServer || this.isLoadingDiscussions) {
      return;
    }

    this.isLoadingDiscussions = true;

    try {
      const { discussions = [] } = await getDiscussionListApiMethod({
        teamId: this._id,
      });
      const newList: Discussion[] = [];

      runInAction(() => {
        discussions.forEach((d) => {
          const disObj = this.discussions.find((obj) => obj._id === d._id);
          if (disObj) {
            disObj.changeLocalCache(d);
            newList.push(disObj);
          } else {
            newList.push(new Discussion({ team: this, store: this.store, ...d }));
          }
        });

        this.discussions.replace(newList);
      });
    } finally {
      runInAction(() => {
        this.isLoadingDiscussions = false;
      });
    }
  }

  public changeLocalCache(data) {
    this.name = data.name;
    this.memberIds.replace(data.memberIds || []);
  }

  public async addDiscussion(data): Promise<Discussion> {
    const { discussion } = await addDiscussionApiMethod({
      teamId: this._id,
      socketId: (this.store.socket && this.store.socket.id) || null,
      ...data,
    });

    return new Promise<Discussion>((resolve) => {
      runInAction(() => {
        const obj = this.addDiscussionToLocalCache(discussion);
        resolve(obj);
      });
    });
  }

  public addDiscussionToLocalCache(data): Discussion {
    const obj = new Discussion({ team: this, store: this.store, ...data });

    if (obj.memberIds.includes(this.store.currentUser._id)) {
      this.discussions.push(obj);
    }

    return obj;
  }

  public async deleteDiscussion(id: string) {
    await deleteDiscussionApiMethod({
      id,
      socketId: (this.store.socket && this.store.socket.id) || null,
    });

    runInAction(() => {
      this.deleteDiscussionFromLocalCache(id);

      const discussion = this.discussions.find((d) => d._id === id);

      if (this.currentDiscussion === discussion) {
        this.currentDiscussion = null;
        this.currentDiscussionSlug = null;

        if (this.discussions.length > 0) {
          const d = this.discussions[0];

          Router.push(
            `/discussion?teamSlug=${this.slug}&discussionSlug=${d.slug}`,
            `/teams/${this.slug}/discussions/${d.slug}`,
          );
        } else {
          Router.push(`/discussion?teamSlug=${this.slug}`, `/teams/${this.slug}/discussions`);
        }
      }
    });
  }

  public deleteDiscussionFromLocalCache(discussionId: string) {
    const discussion = this.discussions.find((item) => item._id === discussionId);
    this.discussions.remove(discussion);
  }

  public getDiscussionBySlug(slug: string): Discussion {
    return this.discussions.find((d) => d.slug === slug);
  }

  public async cancelSubscription({ teamId }: { teamId: string }) {
    try {
      const { isSubscriptionActive } = await cancelSubscriptionApiMethod({ teamId });

      runInAction(() => {
        this.isSubscriptionActive = isSubscriptionActive;
      });
    } catch (error) {
      console.error(error);
      throw error;
    }
  }

  public async checkIfTeamLeaderMustBeCustomer() {
    let ifTeamLeaderMustBeCustomerOnClient: boolean;

    if (this && this.memberIds.length < 2) {
      ifTeamLeaderMustBeCustomerOnClient = false;
    } else if (this && this.memberIds.length >= 2 && this.isSubscriptionActive) {
      ifTeamLeaderMustBeCustomerOnClient = false;
    } else if (this && this.memberIds.length >= 2 && !this.isSubscriptionActive) {
      ifTeamLeaderMustBeCustomerOnClient = true;
    }

    return ifTeamLeaderMustBeCustomerOnClient;
  }

  get orderedDiscussions() {
    return this.discussions.slice().sort();
  }
}

export { Team };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\lib\store\user.ts -----

import { action, observable, runInAction, makeObservable } from 'mobx';

import * as NProgress from 'nprogress';

import { getListOfInvoicesApiMethod } from '../api/team-leader';
import { toggleThemeApiMethod, updateProfileApiMethod } from '../api/team-member';
import { Store } from './index';

class User {
  public store: Store;

  public _id: string;
  public slug: string;
  public email: string | null;
  public displayName: string | null;
  public avatarUrl: string | null;
  public isSignedupViaGoogle: boolean;

  public darkTheme = false;
  public defaultTeamSlug: string;

  public stripeCard: {
    brand: string;
    funding: string;
    last4: string;
    exp_month: number;
    exp_year: number;
  };
  public hasCardInformation: boolean;
  public stripeListOfInvoices: {
    object: string;
    data: [
      {
        amount_paid: number;
        teamName: string;
        created: number;
        hosted_invoice_url: string;
      },
    ];
    has_more: boolean;
  };

  constructor(params) {
    makeObservable(this, {
      slug: observable,
      email: observable,
      displayName: observable,
      avatarUrl: observable,
      // darkTheme: observable,
      defaultTeamSlug: observable,
      stripeCard: observable,
      stripeListOfInvoices: observable,

      updateProfile: action,
      toggleTheme: action,
      getListOfInvoices: action,
    });

    this.store = params.store;
    this._id = params._id;
    this.slug = params.slug;
    this.email = params.email;
    this.displayName = params.displayName;
    this.avatarUrl = params.avatarUrl;
    this.isSignedupViaGoogle = !!params.isSignedupViaGoogle;
    this.darkTheme = !!params.darkTheme;
    this.defaultTeamSlug = params.defaultTeamSlug;

    this.stripeCard = params.stripeCard;
    this.hasCardInformation = params.hasCardInformation;
    this.stripeListOfInvoices = params.stripeListOfInvoices;
  }

  public async updateProfile({ name, avatarUrl }: { name: string; avatarUrl: string }) {
    const { updatedUser } = await updateProfileApiMethod({
      name,
      avatarUrl,
    });

    runInAction(() => {
      this.displayName = updatedUser.displayName;
      this.avatarUrl = updatedUser.avatarUrl;
      this.slug = updatedUser.slug;
    });
  }

  public async toggleTheme(darkTheme: boolean) {
    await toggleThemeApiMethod({ darkTheme });
    runInAction(() => {
      this.darkTheme = darkTheme;
    });
    NProgress.start();
    NProgress.set(0.5);
    window.location.reload();
  }

  public async getListOfInvoices() {
    try {
      const { stripeListOfInvoices } = await getListOfInvoicesApiMethod();
      runInAction(() => {
        this.stripeListOfInvoices = stripeListOfInvoices;
      });
    } catch (error) {
      console.error(error);
      throw error;
    }
  }
}

export { User };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\lib\confirm.ts -----

import { openConfirmDialogExternal } from '../components/common/Confirmer';

export default function confirm({
  title,
  message,
  onAnswer,
}: {
  title: string;
  message: string;
  onAnswer: (answer) => void;
}) {
  openConfirmDialogExternal({ title, message, onAnswer });
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\lib\gtag.ts -----

const { NEXT_PUBLIC_GA_MEASUREMENT_ID } = process.env;

// https://developers.google.com/analytics/devguides/collection/gtagjs/pages
export const pageview = (url) => {
  (window as any).gtag('config', NEXT_PUBLIC_GA_MEASUREMENT_ID, {
    page_location: url,
  });
};

// https://developers.google.com/analytics/devguides/collection/gtagjs/events
export const event = ({ action, category, label }) => {
  (window as any).gtag('event', action, {
    event_category: category,
    event_label: label,
  });
};

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\lib\isMobile.ts -----

const mobileRE =
  /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i;

export function isMobile(opts) {
  if (!opts) {
    opts = {};
  }

  let ua = opts.ua;

  if (!ua && typeof navigator !== 'undefined') {
    ua = navigator.userAgent;
  }

  if (!ua && opts.req && opts.req.headers && typeof opts.req.headers['user-agent'] === 'string') {
    ua = opts.req.headers['user-agent'];
    // console.log(ua);
  }

  if (typeof ua !== 'string') {
    return false;
  }

  return mobileRE.test(ua);
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\lib\notify.ts -----

import { openSnackbarExternal } from '../components/common/Notifier';

export default function notify(obj) {
  openSnackbarExternal({ message: obj.message || obj.toString() });
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\lib\resizeImage.ts -----

function resizeImage(file: File, MAX_WIDTH, MAX_HEIGHT) {
  const image = document.createElement('img');

  const resize = (resolve) => () => {
    let isResizeNeeded = false;
    let width = image.width;
    let height = image.height;

    if (width > height) {
      if (width > MAX_WIDTH) {
        isResizeNeeded = true;
        height *= MAX_WIDTH / width;
        width = MAX_WIDTH;
      }
    } else {
      if (height > MAX_HEIGHT) {
        isResizeNeeded = true;
        width *= MAX_HEIGHT / height;
        height = MAX_HEIGHT;
      }
    }

    if (isResizeNeeded) {
      const canvas = document.createElement('canvas');

      canvas.width = width;
      canvas.height = height;

      console.log(width, height);

      const ctx = canvas.getContext('2d');
      ctx.drawImage(image, 0, 0, width, height);

      canvas.toBlob((blob) => {
        resolve(blob);
      }, file.type);
    } else {
      resolve(file);
    }
  };

  return new Promise((resolve) => {
    const reader = new FileReader();

    console.log(`before ${image.src}`);

    reader.readAsDataURL(file);

    reader.onload = (e) => {
      image.src = e.target.result.toString();

      image.onload = resize(resolve);

      console.log(`after ${image.src}`);
    };
  });
}

export { resizeImage };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\lib\sharedStyles.ts -----

const styleBigAvatar = {
  width: '80px',
  height: '80px',
  margin: '0px auto 15px',
};

const styleRaisedButton = {
  margin: '15px',
};

const styleToolbar = {
  background: '#FFF',
  height: '64px',
  paddingRight: '20px',
};

const styleTextField = {
  color: '#222',
  fontWeight: '300',
};

const styleForm = {
  margin: '7% auto',
  width: '360px',
};

export { styleBigAvatar, styleRaisedButton, styleToolbar, styleTextField, styleForm };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\lib\theme.ts -----

import { createTheme } from '@mui/material/styles';

const themeDark = createTheme({
  palette: {
    primary: { main: '#238636' },
    secondary: { main: '#b62324' },
    mode: 'dark',
    background: { default: '#0d1117' },
    text: {
      primary: '#c9d1d9',
    },
  },
  typography: {
    fontFamily: ['IBM Plex Mono', 'monospace'].join(','),
    button: {
      textTransform: 'none',
    },
  },
});

const themeLight = createTheme({
  palette: {
    primary: { main: '#238636' },
    secondary: { main: '#b62324' },
    mode: 'light',
    background: { default: '#fff' },
    text: {
      primary: '#222',
    },
  },
  typography: {
    fontFamily: ['IBM Plex Mono', 'monospace'].join(','),
    button: {
      textTransform: 'none',
    },
  },
});

export { themeDark, themeLight };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\lib\withAuth.tsx -----

import { observer } from 'mobx-react';
import Router from 'next/router';
import React from 'react';

import * as NProgress from 'nprogress';

import * as gtag from './gtag';

import { Store, getStore } from './store';

Router.events.on('routeChangeStart', () => {
  NProgress.start();
});

Router.events.on('routeChangeComplete', (url) => {
  const store = getStore();
  if (store) {
    store.changeCurrentUrl(url);
  }

  if (window) {
    gtag.pageview(url);
    gtag.event({
      action: 'view_item',
      category: 'engagement',
      label: store.currentUser ? store.currentUser.email : 'no_email',
    });
  }

  NProgress.done();
});

Router.events.on('routeChangeError', () => NProgress.done());

export default function withAuth(Component, { loginRequired = true, logoutRequired = false } = {}) {
  class WithAuth extends React.Component<{ store: Store }> {
    public static async getInitialProps(ctx) {
      console.log('WithAuth.getInitialProps');

      const { req } = ctx;

      let pageComponentProps = {};

      if (Component.getInitialProps) {
        pageComponentProps = await Component.getInitialProps(ctx);
      }

      return {
        ...pageComponentProps,
        isServer: !!req,
      };
    }

    public componentDidMount() {
      console.log('WithAuth.componentDidMount');

      const { store } = this.props;
      const user = store.currentUser;

      if (loginRequired && !logoutRequired && !user) {
        Router.push('/login');
        return;
      }

      let redirectUrl = '/login';
      let asUrl = '/login';
      if (user) {
        if (!user.defaultTeamSlug) {
          redirectUrl = '/create-team';
          asUrl = '/create-team';
        } else {
          redirectUrl = `/your-settings?teamSlug=${user.defaultTeamSlug}`;
          asUrl = `/teams/${user.defaultTeamSlug}/your-settings`;
        }
      }

      if (logoutRequired && user) {
        Router.push(redirectUrl, asUrl);
      }
    }

    public render() {
      const { store } = this.props;
      const user = store.currentUser;

      if (loginRequired && !logoutRequired && !user) {
        return null;
      }

      if (logoutRequired && user) {
        return null;
      }

      return <Component {...this.props} />;
    }
  }

  return observer(WithAuth);
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\pages\billing.tsx -----

import { observer } from 'mobx-react';
import moment from 'moment';
import Head from 'next/head';
import * as React from 'react';
import { loadStripe } from '@stripe/stripe-js';
import Button from '@mui/material/Button';
import DoneIcon from '@mui/icons-material/Done';
import NProgress from 'nprogress';

import Layout from '../components/layout';
import notify from '../lib/notify';
import { Store } from '../lib/store';
import withAuth from '../lib/withAuth';
import { fetchCheckoutSessionApiMethod } from '../lib/api/team-leader';

const dev = process.env.NODE_ENV !== 'production';

const stripePromise = loadStripe(
  dev
    ? process.env.NEXT_PUBLIC_STRIPE_TEST_PUBLISHABLEKEY
    : process.env.NEXT_PUBLIC_STRIPE_LIVE_PUBLISHABLEKEY,
);

type Props = {
  store: Store;
  isMobile: boolean;
  teamSlug: string;
  redirectMessage?: string;
};

type State = { disabled: boolean; showInvoices: boolean };

class Billing extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = { disabled: false, showInvoices: false };
  }

  public render() {
    const { store, isMobile } = this.props;
    const { currentTeam, currentUser } = store;
    const isTeamLeader = currentTeam && currentUser && currentUser._id === currentTeam.teamLeaderId;

    if (!currentTeam || currentTeam.slug !== this.props.teamSlug) {
      return (
        <Layout {...this.props}>
          <div style={{ padding: isMobile ? '0px' : '0px 30px' }}>
            <p>You did not select any team.</p>
            <p>
              To access this page, please select existing team or create new team if you have no
              teams.
            </p>
          </div>
        </Layout>
      );
    }

    if (!isTeamLeader) {
      return (
        <Layout {...this.props}>
          <div style={{ padding: isMobile ? '0px' : '0px 30px' }}>
            <p>Only the Team Leader can access this page.</p>
            <p>Create your own team to become a Team Leader.</p>
          </div>
        </Layout>
      );
    }

    return (
      <Layout {...this.props}>
        <Head>
          <title>Your Billing</title>
        </Head>
        <div style={{ padding: isMobile ? '0px' : '0px 30px' }}>
          <h3>Your Billing</h3>
          <p />
          <h4 style={{ marginTop: '40px' }}>Paid plan</h4>
          {this.renderSubscriptionButton()}
          <p />
          <br />
          <h4>Card information</h4>
          {this.renderCardInfo()}
          <p />
          <br />
          <h4>Payment history</h4>
          <Button
            variant="outlined"
            color="primary"
            onClick={this.showListOfInvoicesOnClick}
            disabled={this.state.disabled}
          >
            Show payment history
          </Button>
          <p />
          {this.renderInvoices()}
          <p />
          <br />
        </div>
      </Layout>
    );
  }

  public async componentDidMount() {
    if (this.props.redirectMessage) {
      notify(this.props.redirectMessage);
    }
  }

  private renderSubscriptionButton() {
    const { currentTeam } = this.props.store;

    let subscriptionDate;
    let billingDay;
    if (currentTeam && currentTeam.stripeSubscription) {
      subscriptionDate = moment(currentTeam.stripeSubscription.billing_cycle_anchor * 1000).format(
        'MMM Do YYYY',
      );
      billingDay = moment(currentTeam.stripeSubscription.billing_cycle_anchor * 1000).format('Do');
    }

    if (currentTeam && !currentTeam.isSubscriptionActive && currentTeam.isPaymentFailed) {
      return (
        <>
          <p>You are not a paying customer.</p>
          <Button
            variant="contained"
            color="primary"
            onClick={() => this.handleCheckoutClick('subscription')}
            disabled={this.state.disabled}
          >
            Buy subscription
          </Button>
          <p />
          <p>
            Team was automatically unsubscribed due to failed payment. You will be prompt to update
            card information if you choose to re-subscribe Team.
          </p>
        </>
      );
    } else if (currentTeam && !currentTeam.isSubscriptionActive && !currentTeam.isPaymentFailed) {
      return (
        <React.Fragment>
          <p>You are not a paying customer.</p>
          <p>
            Buy subscription using your current card, see below section for current card
            information.
          </p>
          <Button
            variant="contained"
            color="primary"
            onClick={() => this.handleCheckoutClick('subscription')}
            disabled={this.state.disabled}
          >
            Buy subscription
          </Button>
        </React.Fragment>
      );
    } else {
      return (
        <React.Fragment>
          <span>
            {' '}
            <DoneIcon color="action" style={{ verticalAlign: 'text-bottom' }} /> Subscription is
            active.
            <p>
              You subscribed <b>{currentTeam.name}</b> on <b>{subscriptionDate}</b>.
            </p>
            <p>
              You will be billed $50 on <b>{billingDay} day</b> of each month unless you cancel
              subscription or subscription is cancelled automatically due to failed payment.
            </p>
          </span>
          <p />
          <Button
            variant="outlined"
            color="primary"
            onClick={this.cancelSubscriptionOnClick}
            disabled={this.state.disabled}
          >
            Unsubscribe Team
          </Button>
          <br />
        </React.Fragment>
      );
    }
  }

  private handleCheckoutClick = async (mode: 'subscription' | 'setup') => {
    try {
      const { currentTeam } = this.props.store;

      NProgress.start();
      this.setState({ disabled: true });

      const { sessionId } = await fetchCheckoutSessionApiMethod({ mode, teamId: currentTeam._id });

      // console.log(process.env.NEXT_PUBLIC_STRIPE_TEST_PUBLISHABLEKEY, sessionId);

      // When the customer clicks on the button, redirect them to Checkout.
      const stripe = await stripePromise;
      const { error } = await stripe.redirectToCheckout({ sessionId });

      if (error) {
        notify(error);
        console.error(error);
      }
    } catch (err) {
      notify(err);
      console.error(err);
    } finally {
      this.setState({ disabled: false });
      NProgress.done();
    }
  };

  private cancelSubscriptionOnClick = async () => {
    const { currentTeam } = this.props.store;

    NProgress.start();
    this.setState({ disabled: true });

    try {
      await currentTeam.cancelSubscription({ teamId: currentTeam._id });
      notify('Success!');
    } catch (err) {
      notify(err);
    } finally {
      this.setState({ disabled: false });
      NProgress.done();
    }
  };

  private renderCardInfo() {
    const { currentUser } = this.props.store;

    if (currentUser && currentUser.hasCardInformation) {
      return (
        <span>
          {' '}
          <DoneIcon color="action" style={{ verticalAlign: 'text-bottom' }} /> Your default payment
          method:
          <li>
            {currentUser.stripeCard.brand}, {currentUser.stripeCard.funding} card
          </li>
          <li>Last 4 digits: *{currentUser.stripeCard.last4}</li>
          <li>
            Expiration: {currentUser.stripeCard.exp_month}/{currentUser.stripeCard.exp_year}
          </li>
          <p />
          <Button
            variant="outlined"
            color="primary"
            onClick={() => this.handleCheckoutClick('setup')}
            disabled={this.state.disabled}
          >
            Update card
          </Button>
        </span>
      );
    } else {
      return 'You have not added a card.';
    }
  }

  private renderInvoices() {
    const { currentUser } = this.props.store;
    const { showInvoices } = this.state;

    if (!showInvoices) {
      return null;
    }

    if (currentUser && currentUser.stripeCard) {
      return (
        <React.Fragment>
          {currentUser.stripeListOfInvoices.data.map((invoice, i) => (
            <React.Fragment key={i}>
              <p>Your history of payments:</p>
              <li>
                ${invoice.amount_paid / 100} was paid on{' '}
                {moment(invoice.created * 1000).format('MMM Do YYYY')} for Team '{invoice.teamName}'
                -{' '}
                <a href={invoice.hosted_invoice_url} target="_blank" rel="noopener noreferrer">
                  See invoice
                </a>
              </li>
            </React.Fragment>
          ))}
        </React.Fragment>
      );
    } else {
      return 'You have no history of payments.';
    }
  }

  private showListOfInvoicesOnClick = async () => {
    const { currentUser } = this.props.store;
    NProgress.start();
    this.setState({ disabled: true });
    try {
      await currentUser.getListOfInvoices();
      this.setState({ showInvoices: true });
    } catch (err) {
      notify(err);
    } finally {
      this.setState({ disabled: false });
      NProgress.done();
    }
  };
}

export default withAuth(observer(Billing));

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\pages\create-team.tsx -----

import { inject, observer } from 'mobx-react';
import * as React from 'react';

import Avatar from '@mui/material/Avatar';
import Button from '@mui/material/Button';
import Grid from '@mui/material/Grid';
import TextField from '@mui/material/TextField';
import Head from 'next/head';
import Router from 'next/router';

import {
  getSignedRequestForUploadApiMethod,
  uploadFileUsingSignedPutRequestApiMethod,
} from '../lib/api/team-member';
import notify from '../lib/notify';
import { resizeImage } from '../lib/resizeImage';
import { Store } from '../lib/store';
import withAuth from '../lib/withAuth';

import Layout from '../components/layout';

const styleGrid = {
  height: '100%',
};

type Props = { store: Store; isMobile: boolean; teamRequired: boolean };

type State = { newName: string; newAvatarUrl: string; disabled: boolean };

class CreateTeam extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      newName: '',
      newAvatarUrl: 'https://storage.googleapis.com/async-await/default-user.png?v=1',
      disabled: false,
    };
  }

  public render() {
    const { newAvatarUrl } = this.state;

    console.log(this.props.store);

    return (
      <Layout {...this.props}>
        <Head>
          <title>Create Team</title>
          <meta name="description" content="Create a new Team at SaaS Boilerplate" />
        </Head>
        <div style={{ padding: '0px', fontSize: '14px', height: '100%' }}>
          <Grid container style={styleGrid}>
            <Grid
              item
              sm={12}
              xs={12}
              style={{ padding: this.props.isMobile ? '0px' : '0px 30px' }}
            >
              <h3>Create team</h3>
              <p />
              <form onSubmit={this.onSubmit}>
                <h4>Team name</h4>
                <TextField
                  value={this.state.newName}
                  label="Type your team's name."
                  helperText="Team name as seen by your team members."
                  onChange={(event) => {
                    this.setState({ newName: event.target.value });
                  }}
                />
                <p />
                <h4 style={{ marginTop: '40px' }}>Team logo (optional)</h4>
                <Avatar
                  src={newAvatarUrl}
                  style={{
                    display: 'inline-flex',
                    verticalAlign: 'middle',
                    marginRight: 20,
                    width: 60,
                    height: 60,
                  }}
                />
                <label htmlFor="upload-file">
                  <Button variant="outlined" color="primary" component="span">
                    Select team logo
                  </Button>
                </label>
                <input
                  accept="image/*"
                  name="upload-file"
                  id="upload-file"
                  type="file"
                  style={{ display: 'none' }}
                  onChange={this.previewTeamLogo}
                />
                <p />
                <br />
                <br />
                <Button
                  variant="contained"
                  color="primary"
                  type="submit"
                  disabled={this.state.disabled}
                >
                  Create new team
                </Button>
              </form>
            </Grid>
          </Grid>
          <br />
        </div>
      </Layout>
    );
  }

  private onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();

    const { newName } = this.state;

    const { store } = this.props;

    if (!newName) {
      notify('Team name is required.');
      return;
    }

    const file = (document.getElementById('upload-file') as HTMLFormElement).files[0];

    try {
      this.setState({ disabled: true });

      const defaultAvatarUrl = 'https://storage.googleapis.com/async-await/default-user.png?v=1';
      const team = await store.addTeam({
        name: newName,
        avatarUrl: defaultAvatarUrl,
      });

      console.log(`Returned to client: ${team._id}, ${team.name}, ${team.slug}`);

      if (file == null) {
        Router.push(`/teams/${team.slug}/team-settings`);
        notify('You successfully created Team.<p />Redirecting...');
        return;
      }

      const fileName = file.name;
      const fileType = file.type;
      const bucket = process.env.NEXT_PUBLIC_BUCKET_FOR_TEAM_LOGOS;
      const prefix = team.slug;

      const responseFromApiServerForUpload = await getSignedRequestForUploadApiMethod({
        fileName,
        fileType,
        prefix,
        bucket,
      });

      const resizedFile = await resizeImage(file, 128, 128);

      await uploadFileUsingSignedPutRequestApiMethod(
        resizedFile,
        responseFromApiServerForUpload.signedRequest,
        {
          'Cache-Control': 'max-age=2592000',
        },
      );

      const uploadedAvatarUrl = responseFromApiServerForUpload.url;

      await team.updateTheme({ name: team.name, avatarUrl: uploadedAvatarUrl });

      this.setState({
        newName: '',
        newAvatarUrl: 'https://storage.googleapis.com/async-await/default-user.png?v=1',
      });

      (document.getElementById('upload-file') as HTMLFormElement).value = '';

      Router.push(`/teams/${team.slug}/team-settings`);

      notify('You successfully created Team. Redirecting ...');
    } catch (error) {
      console.log(error);
      notify(error);
    } finally {
      this.setState({ disabled: false });
    }
  };

  private previewTeamLogo = () => {
    const file = (document.getElementById('upload-file') as HTMLFormElement).files[0];
    if (!file) {
      return;
    }

    const reader = new FileReader();

    reader.readAsDataURL(file);

    reader.onload = (e) => {
      this.setState({ newAvatarUrl: e.target.result as string });
    };
  };
}

export default withAuth(inject('store')(observer(CreateTeam)));

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\pages\discussion-f.tsx -----

import Avatar from '@mui/material/Avatar';
import Tooltip from '@mui/material/Tooltip';
import Head from 'next/head';
import Router from 'next/router';
import * as React from 'react';
import { useState, useEffect, useRef } from 'react';

import { observer } from 'mobx-react';

import Layout from '../components/layout';
import PostDetail from '../components/posts/PostDetail';
import PostForm from '../components/posts/PostForm';
import notify from '../lib/notify';
import { Store } from '../lib/store';
import { Discussion } from '../lib/store/discussion';
import withAuth from '../lib/withAuth';
import { Post } from 'lib/store/post';

type Props = {
  store: Store;
  teamSlug: string;
  discussionSlug: string;
  isServer: boolean;
  isMobile: boolean;
  firstGridItem: boolean;
  teamRequired: boolean;
};

function DiscussionPageCompFunctional({
  store,
  teamSlug,
  discussionSlug,
  isServer,
  isMobile,
  firstGridItem,
  teamRequired,
}: Props) {
  const [selectedPost, setSelectedPost] = useState<Post>(null);
  const [showMarkdownClicked, setShowMarkdownClicked] = useState<boolean>(false);

  function usePrevious(value) {
    const ref = useRef();
    useEffect(() => {
      ref.current = value;
    });
    return ref.current;
  }

  const prevDiscussionSlug = usePrevious(discussionSlug);

  const mounted = useRef();

  useEffect(() => {
    if (!mounted.current) {
      // console.log('useEffect 1 for DiscussionPageCompFunctional');

      if (store.currentTeam && (!isServer || !discussionSlug)) {
        store.currentTeam.loadDiscussions().catch((err) => notify(err));
      }

      const discussion = getDiscussion(discussionSlug);

      if (discussion) {
        discussion.joinSocketRooms();
      }

      console.log(store.socket);

      store.socket.on('discussionEvent', handleDiscussionEvent);
      store.socket.on('postEvent', handlePostEvent);
      store.socket.on('reconnect', handleSocketReconnect);

      (mounted as any).current = true;
    } else {
      // console.log('useEffect 2 for DiscussionPageCompFunctional');

      if (prevDiscussionSlug) {
        const prevDiscussion = getDiscussion(prevDiscussionSlug);
        if (prevDiscussion) {
          prevDiscussion.leaveSocketRooms();
        }
      }

      const discussion = getDiscussion(discussionSlug);

      if (!isServer && discussion) {
        discussion.loadPosts().catch((err) => notify(err));
      }

      if (discussion) {
        discussion.joinSocketRooms();
      }
    }

    return () => {
      const discussion = getDiscussion(discussionSlug);

      if (discussion) {
        discussion.leaveSocketRooms();
      }

      store.socket.off('discussionEvent', handleDiscussionEvent);
      store.socket.off('postEvent', handlePostEvent);
      store.socket.off('reconnect', handleSocketReconnect);
    };
  }, [discussionSlug]);

  const { currentTeam } = store;

  const getDiscussion = (slug: string): Discussion => {
    if (!currentTeam) {
      return;
    }

    if (!slug && currentTeam.discussions.length > 0) {
      Router.replace(
        `/discussion-f?teamSlug=${teamSlug}&discussionSlug=${currentTeam.orderedDiscussions[0].slug}`,
        `/teams/${teamSlug}/discussions-f/${currentTeam.orderedDiscussions[0].slug}`,
      );
      return;
    }

    if (slug && currentTeam) {
      return currentTeam.getDiscussionBySlug(slug);
    }

    return null;
  };

  const renderPosts = () => {
    const discussion = getDiscussion(discussionSlug);

    if (!discussion.isLoadingPosts && discussion.posts.length === 0) {
      return <p>Empty Discussion.</p>;
    }

    let loading = 'loading Posts ...';
    if (discussion.posts.length > 0) {
      loading = 'checking for newer Posts ...';
    }

    return (
      <React.Fragment>
        {discussion
          ? discussion.posts.map((p) =>
              selectedPost && selectedPost._id === p._id ? (
                <PostForm
                  store={store}
                  isMobile={isMobile}
                  key={p._id}
                  post={p}
                  showMarkdownToNonCreator={showMarkdownClicked}
                  discussion={discussion}
                  members={discussion.members}
                  onFinished={() => {
                    setSelectedPost(null);
                    setShowMarkdownClicked(false);
                  }}
                />
              ) : (
                <PostDetail
                  key={p._id}
                  post={p}
                  onEditClick={onEditClickCallback}
                  onShowMarkdownClick={onSnowMarkdownClickCallback}
                  isMobile={isMobile}
                  store={store}
                />
              ),
            )
          : null}

        {discussion && discussion.isLoadingPosts && !isServer ? <p>{loading}</p> : null}
      </React.Fragment>
    );
  };

  const onEditClickCallback = (post) => {
    setSelectedPost(post);
    setShowMarkdownClicked(false);
  };

  const onSnowMarkdownClickCallback = (post) => {
    setSelectedPost(post);
    setShowMarkdownClicked(true);
  };

  const handleDiscussionEvent = (data) => {
    console.log('discussion realtime event', data);

    const discussion = getDiscussion(discussionSlug);
    if (discussion) {
      discussion.handleDiscussionRealtimeEvent(data);
    }
  };

  const handlePostEvent = (data) => {
    console.log('post realtime event', data);

    const discussion = getDiscussion(discussionSlug);
    if (discussion) {
      discussion.handlePostRealtimeEvent(data);
    }
  };

  const handleSocketReconnect = () => {
    console.log('pages/discussion.tsx: socket re-connected');

    const discussion = getDiscussion(discussionSlug);
    if (discussion) {
      discussion.loadPosts().catch((err) => notify(err));
      discussion.joinSocketRooms();
    }
  };

  if (!currentTeam || currentTeam.slug !== teamSlug) {
    return (
      <Layout
        store={store}
        isMobile={isMobile}
        firstGridItem={firstGridItem}
        teamRequired={teamRequired}
      >
        <Head>
          <title>No Team is found.</title>
        </Head>
        <div style={{ padding: isMobile ? '0px' : '0px 30px' }}>No Team is found.</div>
      </Layout>
    );
  }

  const discussion = getDiscussion(discussionSlug);

  if (!discussion) {
    if (currentTeam.isLoadingDiscussions) {
      return (
        <Layout
          store={store}
          isMobile={isMobile}
          firstGridItem={firstGridItem}
          teamRequired={teamRequired}
        >
          <Head>
            <title>Loading...</title>
          </Head>
          <div style={{ padding: isMobile ? '0px' : '0px 30px' }}>
            <p>Loading Discussions...</p>
          </div>
        </Layout>
      );
    } else {
      return (
        <Layout
          store={store}
          isMobile={isMobile}
          firstGridItem={firstGridItem}
          teamRequired={teamRequired}
        >
          <Head>
            <title>No Discussion is found.</title>
          </Head>
          <div style={{ padding: isMobile ? '0px' : '0px 30px' }}>
            <p>No Discussion is found.</p>
          </div>
        </Layout>
      );
    }
  }

  const title = discussion ? `${discussion.name}  Discussion` : 'Discussions';

  return (
    <Layout
      store={store}
      isMobile={isMobile}
      firstGridItem={firstGridItem}
      teamRequired={teamRequired}
    >
      <Head>
        <title>{title}</title>
      </Head>
      <div style={{ padding: isMobile ? '0px' : '0px 30px', height: '100vh' }}>
        <h4>
          <span style={{ fontWeight: 300 }}>Discussion : </span>
          {(discussion && discussion.name) || 'No Discussion is found.'}
        </h4>{' '}
        Visible to :{' '}
        {discussion
          ? discussion.members.map((m) => (
              <Tooltip
                title={m.displayName}
                placement="right"
                disableFocusListener
                disableTouchListener
                key={m._id}
              >
                <Avatar
                  role="presentation"
                  src={m.avatarUrl}
                  alt={m.avatarUrl}
                  key={m._id}
                  style={{
                    margin: '0px 5px',
                    display: 'inline-flex',
                    width: '30px',
                    height: '30px',
                    verticalAlign: 'middle',
                  }}
                />
              </Tooltip>
            ))
          : null}
        <p />
        {renderPosts()}
        {discussion && !discussion.isLoadingPosts ? (
          <React.Fragment>
            {selectedPost ? null : (
              <PostForm
                post={null}
                discussion={discussion}
                members={discussion.members}
                isMobile={isMobile}
                store={store}
              />
            )}
          </React.Fragment>
        ) : null}
        <p />
        <br />
      </div>
    </Layout>
  );
}

export default withAuth(observer(DiscussionPageCompFunctional));

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\pages\discussion.tsx -----

import Avatar from '@mui/material/Avatar';
import Tooltip from '@mui/material/Tooltip';
import Head from 'next/head';
import Router from 'next/router';
import * as React from 'react';

import { observer } from 'mobx-react';

import Layout from '../components/layout';
import PostDetail from '../components/posts/PostDetail';
import PostForm from '../components/posts/PostForm';
import notify from '../lib/notify';
import { Store } from '../lib/store';
import { Discussion } from '../lib/store/discussion';
import withAuth from '../lib/withAuth';
import { Post } from 'lib/store/post';

type Props = {
  store: Store;
  teamSlug: string;
  discussionSlug: string;
  isServer: boolean;
  isMobile: boolean;
  teamRequired: boolean;
};

type State = {
  selectedPost: Post;
  showMarkdownClicked: boolean;
};

class DiscussionPageComp extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      selectedPost: null,
      showMarkdownClicked: false,
    };
  }

  public render() {
    const { store, isMobile, discussionSlug } = this.props;
    const { currentTeam } = store;
    const { selectedPost } = this.state;

    if (!currentTeam || currentTeam.slug !== this.props.teamSlug) {
      return (
        <Layout {...this.props}>
          <Head>
            <title>No Team is found.</title>
          </Head>
          <div style={{ padding: isMobile ? '0px' : '0px 30px' }}>No Team is found.</div>
        </Layout>
      );
    }

    const discussion = this.getDiscussion(discussionSlug);

    if (!discussion) {
      if (currentTeam.isLoadingDiscussions) {
        return (
          <Layout {...this.props}>
            <Head>
              <title>Loading...</title>
            </Head>
            <div style={{ padding: isMobile ? '0px' : '0px 30px' }}>
              <p>Loading Discussions...</p>
            </div>
          </Layout>
        );
      } else {
        return (
          <Layout {...this.props}>
            <Head>
              <title>No Discussion is found.</title>
            </Head>
            <div style={{ padding: isMobile ? '0px' : '0px 30px' }}>
              <p>No Discussion is found.</p>
            </div>
          </Layout>
        );
      }
    }

    const title = discussion ? `${discussion.name}  Discussion` : 'Discussions';

    return (
      <Layout {...this.props}>
        <Head>
          <title>{title}</title>
        </Head>
        <div style={{ padding: isMobile ? '0px' : '0px 30px', height: '100vh' }}>
          <h4>
            <span style={{ fontWeight: 300 }}>Discussion : </span>
            {(discussion && discussion.name) || 'No Discussion is found.'}
          </h4>{' '}
          Visible to :{' '}
          {discussion
            ? discussion.members.map((m) => (
                <Tooltip
                  title={m.displayName}
                  placement="right"
                  disableFocusListener
                  disableTouchListener
                  key={m._id}
                >
                  <Avatar
                    role="presentation"
                    src={m.avatarUrl}
                    alt={m.avatarUrl}
                    key={m._id}
                    style={{
                      margin: '0px 5px',
                      display: 'inline-flex',
                      width: '30px',
                      height: '30px',
                      verticalAlign: 'middle',
                    }}
                  />
                </Tooltip>
              ))
            : null}
          <p />
          {this.renderPosts()}
          {discussion && !discussion.isLoadingPosts ? (
            <React.Fragment>
              {selectedPost ? null : (
                <PostForm
                  post={null}
                  discussion={discussion}
                  members={discussion.members}
                  isMobile={this.props.isMobile}
                  store={store}
                />
              )}
            </React.Fragment>
          ) : null}
          <p />
          <br />
        </div>
      </Layout>
    );
  }

  private getDiscussion(slug: string): Discussion {
    const { store, teamSlug } = this.props;
    const { currentTeam } = store;

    if (!currentTeam) {
      return;
    }

    if (!slug && currentTeam.discussions.length > 0) {
      Router.replace(
        `/discussion?teamSlug=${teamSlug}&discussionSlug=${currentTeam.orderedDiscussions[0].slug}`,
        `/teams/${teamSlug}/discussions/${currentTeam.orderedDiscussions[0].slug}`,
      );
      return;
    }

    if (slug && currentTeam) {
      return currentTeam.getDiscussionBySlug(slug);
    }

    return null;
  }

  private renderPosts() {
    const { isServer, store, isMobile } = this.props;
    const { selectedPost, showMarkdownClicked } = this.state;
    const discussion = this.getDiscussion(this.props.discussionSlug);

    if (!discussion.isLoadingPosts && discussion.posts.length === 0) {
      return <p>Empty Discussion.</p>;
    }

    let loading = 'loading Posts ...';
    if (discussion.posts.length > 0) {
      loading = 'checking for newer Posts ...';
    }

    return (
      <React.Fragment>
        {discussion
          ? discussion.posts.map((p) =>
              selectedPost && selectedPost._id === p._id ? (
                <PostForm
                  store={store}
                  isMobile={isMobile}
                  key={p._id}
                  post={p}
                  showMarkdownToNonCreator={showMarkdownClicked}
                  discussion={discussion}
                  members={discussion.members}
                  onFinished={() => {
                    this.setState({
                      selectedPost: null,
                      showMarkdownClicked: false,
                    });
                  }}
                />
              ) : (
                <PostDetail
                  key={p._id}
                  post={p}
                  onEditClick={this.onEditClickCallback}
                  onShowMarkdownClick={this.onSnowMarkdownClickCallback}
                  isMobile={this.props.isMobile}
                  store={store}
                />
              ),
            )
          : null}

        {discussion && discussion.isLoadingPosts && !isServer ? <p>{loading}</p> : null}
      </React.Fragment>
    );
  }

  private onEditClickCallback = (post) => {
    this.setState({ selectedPost: post, showMarkdownClicked: false });
  };

  private onSnowMarkdownClickCallback = (post) => {
    this.setState({ selectedPost: post, showMarkdownClicked: true });
  };

  public componentDidMount() {
    // console.log('DiscussionPageComp.componentDidMount');

    const { discussionSlug, store, isServer } = this.props;

    if (store.currentTeam && (!isServer || !discussionSlug)) {
      store.currentTeam.loadDiscussions().catch((err) => notify(err));
    }

    const discussion = this.getDiscussion(discussionSlug);

    if (discussion) {
      discussion.joinSocketRooms();
    }

    console.log(store.socket);

    store.socket.on('discussionEvent', this.handleDiscussionEvent);
    store.socket.on('postEvent', this.handlePostEvent);
    store.socket.on('reconnect', this.handleSocketReconnect);
  }

  public componentDidUpdate(prevProps: Props) {
    // console.log('before condition DiscussionPageComp.componentDidUpdate');

    const { discussionSlug, isServer } = this.props;

    if (prevProps.discussionSlug !== discussionSlug) {
      console.log('inside condition DiscussionPageComp.componentDidUpdate');
      if (prevProps.discussionSlug) {
        const prevDiscussion = this.getDiscussion(prevProps.discussionSlug);
        if (prevDiscussion) {
          prevDiscussion.leaveSocketRooms();
        }
      }

      const discussion = this.getDiscussion(discussionSlug);

      if (!isServer && discussion) {
        discussion.loadPosts().catch((err) => notify(err));
      }

      if (discussion) {
        discussion.joinSocketRooms();
      }
    }
  }

  public componentWillUnmount() {
    // console.log('DiscussionPageComp.componentWillUnmount');

    const { discussionSlug, store } = this.props;

    const discussion = this.getDiscussion(discussionSlug);

    if (discussion) {
      discussion.leaveSocketRooms();
    }

    store.socket.off('discussionEvent', this.handleDiscussionEvent);
    store.socket.off('postEvent', this.handlePostEvent);
    store.socket.off('reconnect', this.handleSocketReconnect);
  }

  private handleDiscussionEvent = (data) => {
    console.log('discussion realtime event', data);

    const discussion = this.getDiscussion(this.props.discussionSlug);
    if (discussion) {
      discussion.handleDiscussionRealtimeEvent(data);
    }
  };

  private handlePostEvent = (data) => {
    console.log('post realtime event', data);

    const discussion = this.getDiscussion(this.props.discussionSlug);
    if (discussion) {
      discussion.handlePostRealtimeEvent(data);
    }
  };

  private handleSocketReconnect = () => {
    console.log('pages/discussion.tsx: socket re-connected');

    const discussion = this.getDiscussion(this.props.discussionSlug);
    if (discussion) {
      discussion.loadPosts().catch((err) => notify(err));
      discussion.joinSocketRooms();
    }
  };
}

export default withAuth(observer(DiscussionPageComp));

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\pages\invitation.tsx -----

import Avatar from '@mui/material/Avatar';
import { observer } from 'mobx-react';
import Error from 'next/error';
import Head from 'next/head';
import Router from 'next/router';
// import { NextPageContext } from 'next';
import React from 'react';

import LoginButton from '../components/common/LoginButton';
import Layout from '../components/layout';
import { getTeamByTokenApiMethod } from '../lib/api/public';
import { Team } from '../lib/store/team';
import { Store } from '../lib/store';
import withAuth from '../lib/withAuth';

const dev = process.env.NODE_ENV !== 'production';

class InvitationPageComp extends React.Component<{ store: Store; team: Team; token: string }> {
  public static async getInitialProps(ctx) {
    const { token } = ctx.query;
    if (!token) {
      return {};
    }

    try {
      const { team } = await getTeamByTokenApiMethod(token, ctx.req);

      return { team, token };
    } catch (error) {
      console.log(error);
      return {};
    }
  }

  public render() {
    const { team, token, store } = this.props;

    if (!team) {
      return <Error statusCode={404} />;
    }

    const user = store.currentUser;

    if (user) {
      return null;
    }

    return (
      <Layout {...this.props}>
        <Head>
          <title>Invitation to {team.name}</title>
          <meta name="description" content={`Invitation to join ${team.name}`} />
        </Head>
        <div style={{ textAlign: 'center', margin: '0 20px' }}>
          <br />
          <Avatar
            src={`${
              team.avatarUrl || 'https://storage.googleapis.com/async-await/default-user.png?v=1'
            }`}
            alt="Team logo"
            style={{
              verticalAlign: 'middle',
              display: 'inline-flex',
            }}
          />{' '}
          <h2>{team.name}</h2>
          <p>
            Join <b>{team.name}</b> by logging in or signing up.
          </p>
          <br />
          <LoginButton invitationToken={token} />
        </div>
      </Layout>
    );
  }

  public async componentDidMount() {
    const { store, team, token } = this.props;

    const user = store.currentUser;

    if (user && team) {
      Router.push(
        `${
          dev ? process.env.NEXT_PUBLIC_URL_API : process.env.NEXT_PUBLIC_PRODUCTION_URL_API
        }/logout?invitationToken=${token}`,
        `${
          dev ? process.env.NEXT_PUBLIC_URL_API : process.env.NEXT_PUBLIC_PRODUCTION_URL_API
        }/logout`,
      );
    }
  }
}

// export async function getServerSideProps(context: NextPageContext) {
//   const { token } = context.query;

//   try {
//     const { team } = await getTeamByTokenApiMethod(token as string, context.req);

//     if (team && token) {
//       return { props: { team, token } };
//     } else {
//       return { props: {} };
//     }
//   } catch (error) {
//     console.log(error);
//     return { props: {} };
//   }
// }

// see our explanation for not using getServerSideProps at this time: https://github.com/async-labs/saas/issues/193

export default withAuth(observer(InvitationPageComp), { loginRequired: false });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\pages\login-cached.tsx -----

import Head from 'next/head';
import React from 'react';
import LoginButton from '../components/common/LoginButton';
import Layout from '../components/layout';
import withAuth from '../lib/withAuth';

class Login extends React.Component {
  public render() {
    return (
      <Layout {...this.props}>
        <div style={{ textAlign: 'center', margin: '0 20px' }}>
          <Head>
            <title>Log in or sign up to SaaS boilerplate</title>
            <meta
              name="description"
              content="Login and signup page for SaaS boilerplate demo by Async"
            />
          </Head>
          <br />
          <p style={{ margin: '45px auto', fontSize: '44px', fontWeight: 400 }}>
            Log in or sign up
          </p>
          <p>Youll be logged in for 14 days unless you log out manually.</p>
          <br />

          <LoginButton />
        </div>
      </Layout>
    );
  }
}

export default withAuth(Login, { logoutRequired: true });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\pages\login.tsx -----

import Head from 'next/head';
import React from 'react';
import LoginButton from '../components/common/LoginButton';
import Layout from '../components/layout';
import withAuth from '../lib/withAuth';

class Login extends React.Component {
  public render() {
    return (
      <Layout {...this.props}>
        <div style={{ textAlign: 'center', margin: '0 20px' }}>
          <Head>
            <title>Log in or Sign up to SaaS boilerplate</title>
            <meta
              name="description"
              content="Login and signup page for SaaS boilerplate demo by Async"
            />
          </Head>
          <br />
          <p style={{ margin: '45px auto', fontSize: '44px', fontWeight: 400 }}>
            Log in or Sign up
          </p>
          <p>Youll be logged in for 14 days unless you log out manually.</p>
          <br />
          <LoginButton />
        </div>
      </Layout>
    );
  }
}

export default withAuth(Login, { logoutRequired: true });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\pages\team-settings.tsx -----

import Avatar from '@mui/material/Avatar';
import Button from '@mui/material/Button';
import Hidden from '@mui/material/Hidden';
import TextField from '@mui/material/TextField';
import DeleteOutlineIcon from '@mui/icons-material/DeleteOutline';
import { inject, observer } from 'mobx-react';
import Head from 'next/head';
import NProgress from 'nprogress';
import * as React from 'react';
import Table from '@mui/material/Table';
import TableBody from '@mui/material/TableBody';
import TableCell from '@mui/material/TableCell';
import TableContainer from '@mui/material/TableContainer';
import TableHead from '@mui/material/TableHead';
import TableRow from '@mui/material/TableRow';

import Layout from '../components/layout';
import InviteMember from '../components/teams/InviteMember';
import {
  getSignedRequestForUploadApiMethod,
  uploadFileUsingSignedPutRequestApiMethod,
} from '../lib/api/team-member';
import confirm from '../lib/confirm';
import notify from '../lib/notify';
import { resizeImage } from '../lib/resizeImage';
import { Store } from '../lib/store';
import withAuth from '../lib/withAuth';

type Props = { isMobile: boolean; store: Store; teamSlug: string };

type State = {
  newName: string;
  newAvatarUrl: string;
  disabled: boolean;
  inviteMemberOpen: boolean;
};

class TeamSettings extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      newName: this.props.store.currentTeam.name,
      newAvatarUrl: this.props.store.currentTeam.avatarUrl,
      disabled: false,
      inviteMemberOpen: false,
    };
  }

  public render() {
    const { store, isMobile } = this.props;
    const { currentTeam, currentUser } = store;
    const { newName, newAvatarUrl } = this.state;
    const isTeamLeader = currentTeam && currentUser && currentUser._id === currentTeam.teamLeaderId;

    // console.log(this.props.firstGridItem);

    if (!currentTeam || currentTeam.slug !== this.props.teamSlug) {
      return (
        <Layout {...this.props}>
          <div style={{ padding: isMobile ? '0px' : '0px 30px' }}>
            <p>You did not select any team.</p>
            <p>
              To access this page, please select existing team or create new team if you have no
              teams.
            </p>
          </div>
        </Layout>
      );
    }

    if (!isTeamLeader) {
      return (
        <Layout {...this.props}>
          <div style={{ padding: isMobile ? '0px' : '0px 30px' }}>
            <p>Only the Team Leader can access this page.</p>
            <p>Create your own team to become a Team Leader.</p>
          </div>
        </Layout>
      );
    }

    return (
      <Layout {...this.props}>
        <Head>
          <title>Team Settings</title>
        </Head>
        <div style={{ padding: isMobile ? '0px' : '0px 30px', fontSize: '15px', height: '100%' }}>
          <h3>Team Settings</h3>
          <p />
          <br />
          <form onSubmit={this.onSubmit}>
            <h4>Team name</h4>
            <TextField
              value={newName}
              helperText="Team name as seen by your team members"
              onChange={(event) => {
                this.setState({ newName: event.target.value });
              }}
            />
            <br />
            <br />
            <Button
              variant="contained"
              color="primary"
              type="submit"
              disabled={this.state.disabled}
            >
              Update username
            </Button>
          </form>
          <p />
          <br />
          <h4>Team logo</h4>
          <Avatar
            src={newAvatarUrl}
            style={{
              display: 'inline-flex',
              verticalAlign: 'middle',
              marginRight: 20,
              width: 60,
              height: 60,
            }}
          />
          <label htmlFor="upload-file-team-logo">
            <Button
              variant="contained"
              color="primary"
              component="span"
              disabled={this.state.disabled}
            >
              Update logo
            </Button>
          </label>
          <input
            accept="image/*"
            name="upload-file-team-logo"
            id="upload-file-team-logo"
            type="file"
            style={{ display: 'none' }}
            onChange={this.uploadFile}
          />
          <p />
          <br />
          <br />
          <h4 style={{ marginRight: 20, display: 'inline' }}>
            Team Members ( {Array.from(currentTeam.members.values()).length} / 20 )
          </h4>
          <Button
            onClick={this.openInviteMember}
            variant="contained"
            color="primary"
            style={{ float: 'right', marginTop: '-20px' }}
            disabled={this.state.disabled}
          >
            Invite member
          </Button>
          <p />
          <TableContainer>
            <Table>
              <TableHead>
                <TableRow>
                  <TableCell>Person</TableCell>
                  <TableCell>Role</TableCell>
                  <TableCell>Action</TableCell>
                </TableRow>
              </TableHead>

              <TableBody>
                {currentTeam.memberIds
                  .map((userId) => currentTeam.members.get(userId))
                  .map((m) => (
                    <TableRow key={m._id}>
                      <TableCell style={{ width: '300px' }}>
                        <Hidden mdDown>
                          <Avatar
                            role="presentation"
                            src={m.avatarUrl}
                            alt={(m.displayName || m.email)[0]}
                            key={m._id}
                            style={{
                              margin: '0px 5px',
                              display: 'inline-flex',
                              width: '30px',
                              height: '30px',
                              verticalAlign: 'middle',
                            }}
                          />
                        </Hidden>
                        {m.email}
                      </TableCell>
                      <TableCell>
                        {isTeamLeader && m._id !== currentUser._id ? 'Team Member' : 'Team Leader'}
                      </TableCell>
                      <TableCell>
                        {isTeamLeader && m._id !== currentUser._id ? (
                          <DeleteOutlineIcon
                            color="action"
                            data-id={m._id}
                            onClick={this.removeMember}
                            style={{
                              marginLeft: '20px',
                              fontSize: '16px',
                              opacity: 0.6,
                              cursor: 'pointer',
                              verticalAlign: 'middle',
                            }}
                          />
                        ) : null}
                      </TableCell>
                    </TableRow>
                  ))}
              </TableBody>
            </Table>
          </TableContainer>

          <p />
          <br />

          {Array.from(currentTeam.invitations.values()).length > 0 ? (
            <React.Fragment>
              <h4>Invited users</h4>
              <p />
              <TableContainer>
                <Table>
                  <TableHead>
                    <TableRow>
                      <TableCell>Email</TableCell>
                      <TableCell>Status</TableCell>
                    </TableRow>
                  </TableHead>

                  <TableBody>
                    {Array.from(currentTeam.invitations.values()).map((i) => (
                      <TableRow key={i._id}>
                        <TableCell style={{ width: '300px' }}>{i.email}</TableCell>
                        <TableCell>Sent</TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              </TableContainer>
            </React.Fragment>
          ) : null}
          <p />
          <br />
          <InviteMember
            open={this.state.inviteMemberOpen}
            onClose={this.handleInviteMemberClose}
            store={this.props.store}
          />
          <br />
        </div>
      </Layout>
    );
  }

  private onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    const { newName, newAvatarUrl } = this.state;
    const { currentTeam } = this.props.store;

    if (!newName) {
      notify('Team name is required');
      return;
    }

    NProgress.start();

    try {
      this.setState({ disabled: true });

      await currentTeam.updateTheme({ name: newName, avatarUrl: newAvatarUrl });

      notify('You successfully updated Team name.');
    } catch (error) {
      notify(error);
    } finally {
      this.setState({ disabled: false });
      NProgress.done();
    }
  };

  private uploadFile = async () => {
    const { store } = this.props;
    const { currentTeam } = store;

    const fileElement = document.getElementById('upload-file-team-logo') as HTMLFormElement;
    const file = fileElement.files[0];

    if (file == null) {
      notify('No file selected for upload.');
      return;
    }

    const fileName = file.name;
    const fileType = file.type;

    NProgress.start();
    this.setState({ disabled: true });

    const bucket = process.env.NEXT_PUBLIC_BUCKET_FOR_TEAM_LOGOS;
    const prefix = `${currentTeam.slug}`;

    console.log(bucket);

    try {
      const responseFromApiServerForUpload = await getSignedRequestForUploadApiMethod({
        fileName,
        fileType,
        prefix,
        bucket,
      });

      const resizedFile = await resizeImage(file, 128, 128);

      await uploadFileUsingSignedPutRequestApiMethod(
        resizedFile,
        responseFromApiServerForUpload.signedRequest,
        { 'Cache-Control': 'max-age=2592000' },
      );

      this.setState({
        newAvatarUrl: responseFromApiServerForUpload.url,
      });

      await currentTeam.updateTheme({
        name: this.state.newName,
        avatarUrl: this.state.newAvatarUrl,
      });

      notify('You successfully uploaded new Team logo.');
    } catch (error) {
      notify(error);
    } finally {
      this.setState({ disabled: false });
      NProgress.done();
    }
  };

  private openInviteMember = async () => {
    const { currentTeam } = this.props.store;
    if (!currentTeam) {
      notify('You have not selected a Team.');
      return;
    }

    const ifTeamLeaderMustBeCustomer = await currentTeam.checkIfTeamLeaderMustBeCustomer();

    if (ifTeamLeaderMustBeCustomer) {
      notify(
        'To add a third team member, you have to become a paid customer.' +
          '<p />' +
          ' To become a paid customer,' +
          ' navigate to Billing page.',
      );
      return;
    }

    this.setState({ inviteMemberOpen: true });
  };

  private handleInviteMemberClose = () => {
    this.setState({ inviteMemberOpen: false });
  };

  private removeMember = (event) => {
    const { currentTeam } = this.props.store;
    if (!currentTeam) {
      notify('You have not selected a Team.');
      return;
    }

    const userId = event.currentTarget.dataset.id;
    if (!userId) {
      notify('Select user.');
      return;
    }

    confirm({
      title: 'Are you sure?',
      message: '',
      onAnswer: async (answer) => {
        if (answer) {
          try {
            await currentTeam.removeMember(userId);
          } catch (error) {
            notify(error);
          }
        }
      },
    });
  };
}

export default withAuth(inject('store')(observer(TeamSettings)));

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\pages\your-settings.tsx -----

import Avatar from '@mui/material/Avatar';
import Button from '@mui/material/Button';
import TextField from '@mui/material/TextField';
import DoneIcon from '@mui/icons-material/Done';

import Table from '@mui/material/Table';
import TableBody from '@mui/material/TableBody';
import TableCell from '@mui/material/TableCell';
import TableContainer from '@mui/material/TableContainer';
import TableHead from '@mui/material/TableHead';
import TableRow from '@mui/material/TableRow';

import { inject, observer } from 'mobx-react';
import Head from 'next/head';
import Link from 'next/link';
import NProgress from 'nprogress';

import * as React from 'react';

import Layout from '../components/layout';

import {
  getSignedRequestForUploadApiMethod,
  uploadFileUsingSignedPutRequestApiMethod,
} from '../lib/api/team-member';

import notify from '../lib/notify';
import { resizeImage } from '../lib/resizeImage';
import { Store } from '../lib/store';
import withAuth from '../lib/withAuth';

const dev = process.env.NODE_ENV !== 'production';
const URL_APP = dev ? process.env.NEXT_PUBLIC_URL_APP : process.env.NEXT_PUBLIC_PRODUCTION_URL_APP;

type Props = { isMobile: boolean; store: Store };

type State = { newName: string; newAvatarUrl: string; disabled: boolean };

class YourSettings extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      newName: this.props.store.currentUser.displayName,
      newAvatarUrl: this.props.store.currentUser.avatarUrl,
      disabled: false,
    };
  }

  public render() {
    const { currentUser } = this.props.store;
    const { newName, newAvatarUrl } = this.state;

    return (
      <Layout {...this.props}>
        <Head>
          <title>Your Settings at Async</title>
        </Head>
        <div
          style={{
            padding: this.props.isMobile ? '0px' : '0px 30px',
            height: '100%',
          }}
        >
          <h3>Your Settings</h3>
          <h4 style={{ marginTop: '40px' }}>Your account</h4>
          <div>
            <DoneIcon color="action" style={{ verticalAlign: 'text-bottom' }} />{' '}
            {currentUser.isSignedupViaGoogle
              ? 'You signed up on Async using your Google account.'
              : 'You signed up on Async using your email.'}
            <p />
            <li>
              Your email: <b>{currentUser.email}</b>
            </li>
            <li>
              Your username: <b>{currentUser.displayName}</b>
            </li>
          </div>
          <form onSubmit={this.onSubmit} autoComplete="off">
            <h4>Your username</h4>
            <TextField
              autoComplete="off"
              value={newName}
              helperText="Your username as seen by your team members"
              onChange={(event) => {
                this.setState({ newName: event.target.value });
              }}
            />
            <br />
            <br />
            <Button
              variant="contained"
              color="primary"
              type="submit"
              disabled={this.state.disabled}
            >
              Update username
            </Button>
          </form>

          <br />
          <h4>Your photo</h4>
          <Avatar
            src={newAvatarUrl}
            style={{
              display: 'inline-flex',
              verticalAlign: 'middle',
              marginRight: 20,
              width: 60,
              height: 60,
            }}
          />
          <label htmlFor="upload-file-user-avatar">
            <Button
              variant="outlined"
              color="primary"
              component="span"
              disabled={this.state.disabled}
            >
              Update avatar
            </Button>
          </label>
          <input
            accept="image/*"
            name="upload-file-user-avatar"
            id="upload-file-user-avatar"
            type="file"
            style={{ display: 'none' }}
            onChange={this.uploadFile}
          />
          <p />
          <br />
          <h4 style={{ marginRight: 20, display: 'inline' }}>Your Teams</h4>
          <Link href={`${URL_APP}/create-team`}>
            <Button
              variant="contained"
              color="primary"
              style={{
                fontSize: this.props.isMobile ? '13px' : '14px',
                marginTop: this.props.isMobile ? '10px' : '-20px',
                float: 'right',
              }}
            >
              + Add team
            </Button>
          </Link>
          <TableContainer>
            <Table>
              <TableHead>
                <TableRow>
                  <TableCell>Team name</TableCell>
                  <TableCell>Team slug</TableCell>
                  <TableCell>Action</TableCell>
                </TableRow>
              </TableHead>

              <TableBody>
                {this.props.store.teams.map((t) => (
                  <TableRow key={t._id}>
                    <TableCell style={{ width: '300px' }}>{t.name}</TableCell>
                    <TableCell>{t.slug}</TableCell>
                    <TableCell>
                      <Link href={`${URL_APP}/teams/${t.slug}/discussions`}>
                        <Button
                          variant="contained"
                          color="primary"
                          style={{
                            fontSize: this.props.isMobile ? '13px' : '14px',
                            marginTop: this.props.isMobile ? '10px' : 'inherit',
                          }}
                        >
                          See team
                        </Button>
                      </Link>
                    </TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </TableContainer>
        </div>
      </Layout>
    );
  }

  private onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();

    const { currentUser } = this.props.store;

    const { newName, newAvatarUrl } = this.state;

    console.log(newName);

    if (!newName) {
      notify('Name is required');
      return;
    }

    NProgress.start();
    this.setState({ disabled: true });

    try {
      await currentUser.updateProfile({ name: newName, avatarUrl: newAvatarUrl });

      notify('You successfully updated your profile.');
    } catch (error) {
      notify(error);
    } finally {
      this.setState({ disabled: false });
      NProgress.done();
    }
  };

  private uploadFile = async () => {
    const fileElement = document.getElementById('upload-file-user-avatar') as HTMLFormElement;
    const file = fileElement.files[0];

    const { currentUser } = this.props.store;

    if (file == null) {
      notify('No file selected for upload.');
      return;
    }

    const fileName = file.name;
    const fileType = file.type;

    NProgress.start();
    this.setState({ disabled: true });

    const bucket = process.env.NEXT_PUBLIC_BUCKET_FOR_AVATARS;

    const prefix = `${currentUser.slug}`;

    try {
      const responseFromApiServerForUpload = await getSignedRequestForUploadApiMethod({
        fileName,
        fileType,
        prefix,
        bucket,
      });

      const resizedFile = await resizeImage(file, 128, 128);

      console.log(file);
      console.log(resizedFile);

      await uploadFileUsingSignedPutRequestApiMethod(
        resizedFile,
        responseFromApiServerForUpload.signedRequest,
        { 'Cache-Control': 'max-age=2592000' },
      );

      this.setState({
        newAvatarUrl: responseFromApiServerForUpload.url,
      });

      await currentUser.updateProfile({
        name: this.state.newName,
        avatarUrl: this.state.newAvatarUrl,
      });

      notify('You successfully uploaded new avatar.');
    } catch (error) {
      notify(error);
    } finally {
      fileElement.value = '';
      this.setState({ disabled: false });
      NProgress.done();
    }
  };
}

export default withAuth(inject('store')(observer(YourSettings)));

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\pages\_app.tsx -----

import createCache from '@emotion/cache';
import { CacheProvider } from '@emotion/react';
import CssBaseline from '@mui/material/CssBaseline';
import { ThemeProvider } from '@mui/material/styles';
import { Provider } from 'mobx-react';
import App from 'next/app';
import Head from 'next/head';
import React from 'react';

import { themeDark, themeLight } from '../lib/theme';
import { getUserApiMethod } from '../lib/api/public';
import { getInitialDataApiMethod } from '../lib/api/team-member';
import { isMobile } from '../lib/isMobile';
import { getStore, initializeStore, Store } from '../lib/store';

class MyApp extends App {
  public static async getInitialProps({ Component, ctx }) {
    console.log('MyApp.getInitialProps');

    let firstGridItem = true;
    let teamRequired = false;

    if (
      ctx.pathname.includes('/login') ||
      ctx.pathname.includes('/create-team') ||
      ctx.pathname.includes('/invitation')
    ) {
      firstGridItem = false;
    }

    if (
      ctx.pathname.includes('/your-settings') ||
      ctx.pathname.includes('/team-settings') ||
      ctx.pathname.includes('/discussion') ||
      ctx.pathname.includes('/billing')
    ) {
      teamRequired = true;
    }

    const { teamSlug, discussionSlug, redirectMessage } = ctx.query;

    const pageProps = {
      isMobile: isMobile({ req: ctx.req }),
      firstGridItem,
      teamRequired,
      teamSlug,
      discussionSlug,
      redirectMessage,
    };

    if (Component.getInitialProps) {
      Object.assign(pageProps, await Component.getInitialProps(ctx));
    }

    const appProps = { pageProps };

    console.log('before getStore');

    const store = getStore();
    if (store) {
      return appProps;
    }

    let userObj = null;
    try {
      const { user } = await getUserApiMethod(ctx.req);
      userObj = user;
    } catch (error) {
      console.log(error);
    }

    let initialData;

    if (userObj) {
      try {
        initialData = await getInitialDataApiMethod({
          request: ctx.req,
          data: { teamSlug, discussionSlug },
        });
      } catch (error) {
        console.error(error);
      }
    }

    // console.log(initialData);

    let selectedTeamSlug = '';

    if (teamSlug) {
      selectedTeamSlug = teamSlug;
    } else {
      selectedTeamSlug = userObj && userObj.defaultTeamSlug;
    }

    const team =
      initialData &&
      initialData.teams &&
      initialData.teams.find((t) => t.slug === selectedTeamSlug);

    // console.log(initialData.teams, team);

    return {
      ...appProps,
      initialState: { user: userObj, currentUrl: ctx.asPath, team, teamSlug, ...initialData },
    };
  }

  private store: Store;

  constructor(props) {
    super(props);

    console.log('MyApp.constructor');

    this.store = initializeStore(props.initialState);
  }

  public render() {
    const { Component, pageProps } = this.props;
    const store = this.store;

    const isThemeDark = store.currentUser ? store.currentUser.darkTheme : true;

    const isServer = typeof window === 'undefined';

    return (
      <CacheProvider value={createCache({ key: 'css', prepend: true })}>
        <ThemeProvider theme={isThemeDark ? themeDark : themeLight}>
          <Head>
            <meta name="viewport" content="width=device-width, initial-scale=1.0" />
            <link rel="stylesheet" href={isServer ? '/fonts/server.css' : '/fonts/cdn.css'} />
            <link
              rel="stylesheet"
              href={
                isThemeDark
                  ? 'https://storage.googleapis.com/async-await/nprogress-light-spinner.css'
                  : 'https://storage.googleapis.com/async-await/nprogress-dark-spinner.css'
              }
            />
          </Head>
          <CssBaseline />
          <Provider store={store}>
            <Component {...pageProps} store={store} />
          </Provider>
        </ThemeProvider>
      </CacheProvider>
    );
  }
}

export default MyApp;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\pages\_document.tsx -----

import Document, { Head, Html, Main, NextScript } from 'next/document';
import React from 'react';

import createEmotionServer from '@emotion/server/create-instance';
import createCache from '@emotion/cache';

class MyDocument extends Document {
  public static getInitialProps = async (ctx) => {
    // Render app and page and get the context of the page with collected side effects.
    const originalRenderPage = ctx.renderPage;

    // You can consider sharing the same emotion cache between all the SSR requests to speed up performance.
    // However, be aware that it can have global side effects.
    const cache = createCache({ key: 'css' });
    const { extractCriticalToChunks } = createEmotionServer(cache);

    ctx.renderPage = () =>
      originalRenderPage({
        // eslint-disable-next-line react/display-name
        enhanceApp: (App) => (props) => <App emotionCache={cache} {...props} />,
      });

    const initialProps = await Document.getInitialProps(ctx);
    // This is important. It prevents emotion to render invalid HTML.
    // See https://github.com/mui-org/material-ui/issues/26561#issuecomment-855286153
    const emotionStyles = extractCriticalToChunks(initialProps.html);
    const emotionStyleTags = emotionStyles.styles.map((style) => (
      <style
        data-emotion={`${style.key} ${style.ids.join(' ')}`}
        key={style.key}
        // eslint-disable-next-line react/no-danger
        dangerouslySetInnerHTML={{ __html: style.css }}
      />
    ));

    return {
      ...initialProps,
      // Styles fragment is rendered after the app and page rendering finish.
      styles: [...React.Children.toArray(initialProps.styles), ...emotionStyleTags],
    };
  };

  public render() {
    console.log('MyDocument.render');

    const isThemeDark = this.props.__NEXT_DATA__.props.initialState.user
      ? this.props.__NEXT_DATA__.props.initialState.user.darkTheme
      : true;

    return (
      <Html lang="en">
        <Head>
          <meta charSet="utf-8" />
          <meta name="google" content="notranslate" />
          <meta name="theme-color" content="#303030" />

          <link
            rel="shortcut icon"
            href="https://storage.googleapis.com/async-await/async-favicon32.png"
          />

          <link
            rel="stylesheet"
            href={
              isThemeDark
                ? 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/a11y-dark.min.css'
                : 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/a11y-light.min.css'
            }
          />

          <style>
            {`
              #__next {
                width: 100%;
                height: 100%;
              }
              a {
                font-weight: 400;
                color: #58a6ff;
                text-decoration: none;
                outline: none;
              }
              hr {
                border: 0.5px #707070 solid;
                color: #000;
              }
              blockquote {
                padding: 0 0.5em;
                margin: 20px 1em;
                border-left: 0.25em solid #dfe2e5;
                color: #000;
              }
              pre {
                display: block;
                overflow-x: auto;
                padding: 0.5em;
                background: #d0d0d0;
                border: 1px solid #ddd;
                font-size: 14px;
                color: #000;
              }
              pre code {
                font-size: 13px;
                background: #d0d0d0;
                padding: 0px;
                color: #000;
              }
              code {
                font-size: 13px;
                background: #d0d0d0;
                padding: 3px 5px;
                color: #000;
              }
              mark {
                background-color: #ffff0060;
              }
              summary:focus {
                outline: none;
              }
              table {
                border-collapse: collapse;
                margin: 15px 0px;
              }
              table, th, td {
                border: 1px solid #a1a1a1;
              }
              th, td {
                line-height: 1.5em;
                padding: 10px;
              }
            `}
          </style>
          <script
            async
            src={`https://www.googletagmanager.com/gtag/js?id=${process.env.NEXT_PUBLIC_GA_MEASUREMENT_ID}`}
          />
          <script
            dangerouslySetInnerHTML={{
              __html: `
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', '${process.env.NEXT_PUBLIC_GA_MEASUREMENT_ID}', {
                page_path: window.location.pathname,
              });
            `,
            }}
          />
        </Head>
        <body>
          <Main />
          <NextScript />
        </body>
      </Html>
    );
  }
}

export default MyDocument;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\server\routesWithCache.ts -----

import { LRUCache } from 'lru-cache';

export default function routesWithCache({ server, app }) {
  const ssrCache = new LRUCache({
    max: 100, // 100 items
    ttl: 1000 * 60 * 60, // in ms, 1hr
  });

  function getCacheKey(req) {
    if (req.user) {
      return `${req.url}${req.user.id}`;
    }
    return `${req.url}`;
  }

  async function renderAndCache(req, res, pagePath, queryParams) {
    const key = getCacheKey(req);

    if (ssrCache.has(key)) {
      res.setHeader('x-cache', 'HIT');
      res.send(ssrCache.get(key));
      return;
    }

    try {
      const renderedPage = await app.renderToHTML(req, res, pagePath, queryParams);

      ssrCache.set(key, renderedPage);

      res.send(renderedPage);
    } catch (err) {
      app.renderError(err, req, res, pagePath, queryParams);
    }
  }

  server.get('/login-cached', (req, res) => {
    renderAndCache(req, res, '/login-cached', {});
  });
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\server\server.ts -----

import express from 'express';
import next from 'next';

import setupSitemapAndRobots from './setupSitemapAndRobots';

import routesWithCache from './routesWithCache';

const dev = process.env.NODE_ENV !== 'production';
const port = process.env.PORT || 3000;

const app = next({ dev });
const handle = app.getRequestHandler();

app.prepare().then(() => {
  const server = express();

  // give all Nextjs's request to next server before anything else
  server.get('/_next/*', (req, res) => {
    // console.log('next server, page');
    handle(req, res);
  });

  server.use(express.json());

  if (!dev) {
    server.set('trust proxy', 1); // sets req.hostname, req.ip
  }

  server.get('/', async (req: any, res) => {
    let redirectUrl = 'login';

    if (req.user) {
      if (!req.user.defaultTeamSlug) {
        redirectUrl = 'create-team';
      } else {
        redirectUrl = `team/${req.user.defaultTeamSlug}/discussions`;
      }
    }

    res.redirect(
      `${
        dev ? process.env.NEXT_PUBLIC_URL_APP : process.env.NEXT_PUBLIC_PRODUCTION_URL_APP
      }/${redirectUrl}`,
    );
  });

  // server.get('/api/v1/public/get-user', (_, res) => {
  //   res.json({ user: { email: 'team@builderbook.org' } });
  // });

  server.get('/teams/:teamSlug/your-settings', (req, res) => {
    const { teamSlug } = req.params;
    app.render(req, res, '/your-settings', { teamSlug });
  });

  server.get('/teams/:teamSlug/team-settings', (req, res) => {
    const { teamSlug } = req.params;
    app.render(req, res, '/team-settings', { teamSlug });
  });

  server.get('/teams/:teamSlug/billing', (req, res) => {
    const { teamSlug } = req.params;
    app.render(req, res, '/billing', { teamSlug, ...(req.query || {}) });
  });

  server.get('/teams/:teamSlug/discussions/:discussionSlug', (req, res) => {
    const { teamSlug, discussionSlug } = req.params;
    app.render(req, res, '/discussion', { teamSlug, discussionSlug });
  });

  server.get('/teams/:teamSlug/discussions', (req, res) => {
    const { teamSlug } = req.params;
    app.render(req, res, '/discussion', { teamSlug });
  });

  server.get('/teams/:teamSlug/discussions-f/:discussionSlug', (req, res) => {
    const { teamSlug, discussionSlug } = req.params;
    app.render(req, res, '/discussion-f', { teamSlug, discussionSlug });
  });

  server.get('/teams/:teamSlug/discussions-f', (req, res) => {
    const { teamSlug } = req.params;
    app.render(req, res, '/discussion-f', { teamSlug });
  });

  server.get('/signup', (req, res) => {
    app.render(req, res, '/login');
  });

  server.get('/invitation', (req, res) => {
    app.render(req, res, '/invitation', { token: req.query.token as string });
  });

  setupSitemapAndRobots({ server });

  routesWithCache({ server, app });

  server.get('*', (req, res) => {
    handle(req, res);
  });

  // listen(handle: any, listeningListener?: () => void): http.Server;
  // "@types/express-serve-static-core", "version": "4.17.1"
  server.listen(port, () => {
    console.log(
      `> Ready on ${
        dev ? process.env.NEXT_PUBLIC_URL_APP : process.env.NEXT_PUBLIC_PRODUCTION_URL_APP
      }`,
    );
  });
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\server\setupSitemapAndRobots.ts -----

import { SitemapStream, streamToPromise } from 'sitemap';
import path from 'path';
import zlib from 'zlib';

const dev = process.env.NODE_ENV !== 'production';

export default function setupSitemapAndRobots({ server }) {
  let sitemap;

  server.get('/sitemap.xml', async (_, res) => {
    res.header('Content-Type', 'application/xml');
    res.header('Content-Encoding', 'gzip');

    if (sitemap) {
      res.send(sitemap);
      return;
    }

    try {
      const smStream = new SitemapStream({
        hostname: dev
          ? process.env.NEXT_PUBLIC_URL_APP
          : process.env.NEXT_PUBLIC_PRODUCTION_URL_APP,
      });
      const gzip = zlib.createGzip();

      smStream.write({
        url: '/login',
        changefreq: 'daily',
        priority: 1,
      });

      streamToPromise(smStream.pipe(gzip)).then((sm) => (sitemap = sm));

      smStream.end();

      smStream
        .pipe(gzip)
        .pipe(res)
        .on('error', (err) => {
          throw err;
        });
    } catch (err) {
      console.error(err);
      res.status(500).end();
    }
  });

  server.get('/robots.txt', (_, res) => {
    res.sendFile(path.join(__dirname, '../static', 'robots.txt'));
  });
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\.eslintrc.js -----

module.exports = {
  settings: {
    react: { version: 'detect' },
  },
  parser: '@typescript-eslint/parser',
  extends: ['plugin:react/recommended', 'plugin:@typescript-eslint/recommended', 'prettier'],
  env: {
    es6: true,
    node: true,
  },
  plugins: ['prettier', 'react'],
  rules: {
    'prettier/prettier': [
      'error',
      {
        singleQuote: true,
        trailingComma: 'all',
        arrowParens: 'always',
        printWidth: 100,
        semi: true,
      },
    ],
    '@typescript-eslint/camelcase': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    'react/no-unescaped-entities': 'off',
    'react/jsx-filename-extension': ['error', { extensions: ['.tsx'] }],
    '@typescript-eslint/no-explicit-any': 'off',
    'prefer-arrow-callback': 'error',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
  },
};

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\next-env.d.ts -----

/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/pages/api-reference/config/typescript for more information.

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\next.config.js -----

module.exports = {
  poweredByHeader: false,
  webpack5: true,
  typescript: {
    ignoreBuildErrors: true,
  },
};

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\nodemon.json -----

{
  "watch": ["server"],
  "exec": "ts-node --project tsconfig.server.json",
  "ext": "ts"
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\package.json -----

{
  "name": "app-same-as-10-end-app",
  "version": "1.0.0",
  "license": "MIT",
  "engines": {
    "node": ">=18.17.0",
    "yarn": ">=1.22.19"
  },
  "scripts": {
    "dev": "nodemon server/server.ts",
    "lint": "eslint . --ext .ts,.tsx",
    "postinstall": "rm -rf production-server/",
    "build": "next build && tsc --project tsconfig.server.json && cp server/robots.txt production-server",
    "start": "node production-server/server.js"
  },
  "dependencies": {
    "@emotion/cache": "^11.14.0",
    "@emotion/react": "^11.14.0",
    "@emotion/server": "^11.11.0",
    "@emotion/styled": "^11.14.0",
    "@mui/icons-material": "^6.4.8",
    "@mui/material": "^6.4.8",
    "@mui/system": "^6.4.8",
    "@stripe/stripe-js": "^6.1.0",
    "express": "^4.21.2",
    "he": "^1.2.0",
    "isomorphic-unfetch": "^4.0.1",
    "keycode": "^2.2.0",
    "lru-cache": "^11.0.2",
    "marked": "^15.0.7",
    "mobx": "^6.13.7",
    "mobx-react": "^9.2.0",
    "moment": "^2.30.1",
    "next": "^15.2.3",
    "next-transpile-modules": "^10.0.1",
    "nprogress": "0.2.0",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-mentions": "^4.4.10",
    "sitemap": "^8.0.0",
    "socket.io-client": "^4.8.1",
    "typescript": "^5.8.2"
  },
  "devDependencies": {
    "@babel/core": "^7.26.10",
    "@babel/plugin-proposal-private-methods": "^7.18.6",
    "@babel/plugin-proposal-private-property-in-object": "^7.21.11",
    "@types/express": "^5.0.1",
    "@types/he": "^1.2.3",
    "@types/node": "^22.13.11",
    "@types/react": "^19.0.12",
    "@types/react-dom": "^19.0.4",
    "@typescript-eslint/eslint-plugin": "^8.27.0",
    "@typescript-eslint/parser": "^8.27.0",
    "babel-eslint": "^10.1.0",
    "eslint": "^9.22.0",
    "eslint-config-prettier": "^10.1.1",
    "eslint-plugin-prettier": "^5.2.3",
    "eslint-plugin-react": "^7.37.4",
    "nodemon": "^3.1.9",
    "prettier": "^3.5.3",
    "ts-node": "^10.9.2"
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\tsconfig.json -----

{
  "compileOnSave": false,
  "compilerOptions": {
    "target": "esnext",
    "module": "esnext",
    "jsx": "preserve",
    "allowJs": true,
    "alwaysStrict": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "removeComments": true,
    "preserveConstEnums": true,
    "sourceMap": false,
    "skipLibCheck": true,
    "baseUrl": ".",
    "typeRoots": [
      "./node_modules/@types"
    ],
    "lib": [
      "dom",
      "es2017"
    ],
    "strict": false,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "incremental": true,
    "experimentalDecorators": true ,
    "useDefineForClassFields": true,
  },
  "include": [
    "next-env.d.ts",
    "./**/*.tsx",
    "./**/*.ts"
  ],
  "exclude": [
    "dist",
    "production-server",
    ".next",
    "out",
    "next.config.js",
    "node_modules"
  ]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\app\tsconfig.server.json -----

{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "module": "commonjs",
    "outDir": "production-server/",
    "target": "es2017",
    "isolatedModules": false,
    "noEmit": false
  },
  "exclude": ["./server/types.d.ts"],
  "include": ["./server/**/*.ts"],
  "typeRoots": ["./node_modules/@types", "./server/types.d.ts"]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\lambda\.eslintrc.js -----

module.exports = {
  parser: "@typescript-eslint/parser",
  extends: ["plugin:@typescript-eslint/recommended", "prettier"],
  env: {
    "es6": true,
    "node": true,
  },
  rules: {
    'prettier/prettier': [
      'error',
      {
        singleQuote: true,
        trailingComma: 'all',
        arrowParens: 'always',
        printWidth: 100,
        semi: true,
      },
    ],
    '@typescript-eslint/no-unused-vars': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/no-explicit-any': 'off',
    'prefer-arrow-callback': 'error',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
 },
  plugins: [
    "prettier",
  ]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\lambda\handler.ts -----

import * as mongoose from 'mongoose';

import sendEmail from './api/server/aws-ses';
import getEmailTemplate from './api/server/models/EmailTemplate';
import User from './api/server/models/User';

const dev = process.env.NODE_ENV !== 'production';

export const sendEmailForNewPost = async (event) => {
  console.log('Received event (request representation):', JSON.stringify(event));

  const reqBody = JSON.parse(event.body);

  const { discussionName, discussionLink, postContent, authorName, userIds } = reqBody;

  if (
    discussionName === undefined ||
    discussionLink === undefined ||
    postContent === undefined ||
    authorName === undefined ||
    userIds === undefined
  ) {
    throw new Error('Missing data');
  }

  console.log(discussionName, discussionLink, postContent, authorName, userIds);

  await mongoose.connect(dev ? process.env.MONGO_URL_TEST : process.env.MONGO_URL);

  try {
    const emailTemplate = await getEmailTemplate('newPost', {
      discussionName,
      discussionLink,
      postContent,
      authorName,
    });

    if (!emailTemplate) {
      throw new Error('newPost Email template not found');
    }

    const usersToNotify = await User.find({ _id: { $in: userIds } })
      .select('email')
      .setOptions({ lean: true });

    console.log('usersToNotify', usersToNotify);

    const jobs = usersToNotify
      .filter((user) => !!user.email)
      .map(async (user) => {
        try {
          await sendEmail({
            from: `From async-await.com <${process.env.EMAIL_SUPPORT_FROM_ADDRESS}>`,
            to: [user.email],
            subject: emailTemplate.subject,
            body: emailTemplate.message,
          });
          console.log('email is sent');
        } catch (err) {
          console.error(err.stack);
        }
      });

    await Promise.all(jobs);
  } catch (error) {
    console.error(error.stack);
    return { error: error.message, event };
  } finally {
    await mongoose.disconnect();
  }

  const response = {
    statusCode: 200,
    headers: {
      'Access-Control-Allow-Headers': 'Content-Type',
      'Access-Control-Allow-Origin': dev ? process.env.URL_APP : process.env.PRODUCTION_URL_APP,
      'Access-Control-Allow-Methods': 'OPTIONS,POST,GET',
      'Access-Control-Allow-Credentials': true,
    },
    body: JSON.stringify({
      message: 'Email notification was sent!',
      input: event,
    }),
  };

  return response;
};

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\lambda\package.json -----

{
  "name": "lambda",
  "version": "1.0.0",
  "license": "MIT",
  "scripts": {
    "lint": "eslint . --ext .ts,.tsx"
  },
  "dependencies": {
    "aws-sdk": "^2.1286.0",
    "bcrypt": "^5.1.0",
    "connect-mongo": "^4.6.0",
    "cors": "^2.8.5",
    "dotenv": "^16.0.3",
    "express": "^4.18.2",
    "express-session": "^1.17.3",
    "he": "^1.2.0",
    "highlight.js": "^11.7.0",
    "lodash": "^4.17.21",
    "marked": "^4.2.5",
    "mongoose": "^6.8.2",
    "node-fetch": "^3.3.0",
    "passport": "^0.6.0",
    "passport-google-oauth": "^2.0.0",
    "passwordless": "^1.1.3",
    "passwordless-tokenstore": "^0.0.10",
    "socket.io": "^4.5.4",
    "stripe": "^11.5.0",
    "typescript": "^4.9.4",
    "winston": "^3.8.2"
  },
  "devDependencies": {
    "@types/connect-mongo": "^3.1.3",
    "@types/dotenv": "^8.2.0",
    "@types/express": "^4.17.15",
    "@types/express-session": "^1.17.5",
    "@types/jest": "^29.2.5",
    "@types/lodash": "^4.14.191",
    "@types/mongoose": "^5.11.97",
    "@types/node": "^18.11.18",
    "@types/node-fetch": "^2.6.2",
    "@types/passport": "^1.0.11",
    "@types/socket.io": "^3.0.2",
    "@typescript-eslint/eslint-plugin": "^5.47.1",
    "@typescript-eslint/parser": "^5.47.1",
    "eslint": "^8.31.0",
    "eslint-config-prettier": "^8.5.0",
    "eslint-plugin-prettier": "^4.2.1",
    "jest": "^29.3.1",
    "prettier": "^2.8.1",
    "serverless-dotenv-plugin": "^4.0.2",
    "serverless-plugin-typescript": "^2.1.4",
    "ts-jest": "^29.0.3",
    "ts-node-dev": "^2.0.0"
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end\lambda\tsconfig.json -----

{
  "compileOnSave": false,
  "compilerOptions": {
    "jsx": "preserve",
    "allowJs": true,
    "alwaysStrict": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "removeComments": false,
    "preserveConstEnums": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "sourceMap": true,
    "skipLibCheck": true,
    "baseUrl": ".",
    "experimentalDecorators": true,
    "typeRoots": ["./node_modules/@types"],
    "lib": ["es2015", "es2016"],
    "module": "commonjs",
    "outDir": ".build/",
    "rootDir": "./"
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\server\api\index.ts -----

import * as express from 'express';

import publicExpressRoutes from './public';
import teamMemberExpressRoutes from './team-member';
import teamLeaderApi from './team-leader';

function handleError(err, _, res, __) {
  console.error(err.stack);

  res.json({ error: err.message || err.toString() });
}

export default function api(server: express.Express) {
  server.use('/api/v1/public', publicExpressRoutes, handleError);
  server.use('/api/v1/team-member', teamMemberExpressRoutes, handleError);
  server.use('/api/v1/team-leader', teamLeaderApi, handleError);
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\server\api\public.ts -----

import * as express from 'express';

import User from '../models/User';
import Invitation from '../models/Invitation';

const router = express.Router();

router.get('/get-user', (req, res) => {
  // console.log(req.user);
  res.json({ user: req.user || null });
});

router.post('/get-user-by-slug', async (req, res, next) => {
  console.log('Express route: /get-user-by-slug');

  // req.session.foo = 'bar';

  try {
    const { slug } = req.body;

    const user = await User.getUserBySlug({ slug });

    res.json({ user });
  } catch (err) {
    next(err);
  }
});

router.get('/invitations/get-team-by-token', async (req, res, next) => {
  const token = req.query.token as string;

  try {
    const team = await Invitation.getTeamByToken({ token });

    res.json({ team });
  } catch (err) {
    next(err);
  }
});

export default router;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\server\api\team-leader.ts -----

import * as express from 'express';

import Invitation from '../models/Invitation';
import Team from '../models/Team';
import User from '../models/User';
import { createSession } from '../stripe';

const router = express.Router();

router.use((req, res, next) => {
  console.log('team leader API', req.path);

  if (!req.user) {
    res.status(401).json({ error: 'Unauthorized' });
    return;
  }

  next();
});

router.post('/teams/add', async (req: any, res, next) => {
  try {
    const { name, avatarUrl } = req.body;

    console.log(`Express route: ${name}, ${avatarUrl}`);

    const team = await Team.addTeam({ userId: req.user.id, name, avatarUrl });

    res.json(team);
  } catch (err) {
    next(err);
  }
});

router.post('/teams/update', async (req: any, res, next) => {
  try {
    const { teamId, name, avatarUrl } = req.body;

    // console.log(req.user.id, typeof req.user.id);
    // console.log(req.user._id, typeof req.user._id);

    const team = await Team.updateTeam({
      userId: req.user.id,
      teamId,
      name,
      avatarUrl,
    });

    res.json(team);
  } catch (err) {
    next(err);
  }
});

router.get('/teams/get-invitations-for-team', async (req: any, res, next) => {
  try {
    const invitations = await Invitation.getTeamInvitations({
      userId: req.user.id,
      teamId: req.query.teamId as string,
    });

    res.json({ invitations });
  } catch (err) {
    next(err);
  }
});

router.post('/teams/invite-member', async (req: any, res, next) => {
  try {
    const { teamId, email } = req.body;

    const newInvitation = await Invitation.add({ userId: req.user.id, teamId, email });

    res.json({ newInvitation });
  } catch (err) {
    next(err);
  }
});

router.post('/teams/remove-member', async (req: any, res, next) => {
  try {
    const { teamId, userId } = req.body;

    await Team.removeMember({ teamLeaderId: req.user.id, teamId, userId });

    res.json({ done: 1 });
  } catch (err) {
    next(err);
  }
});

router.post('/stripe/fetch-checkout-session', async (req: any, res, next) => {
  try {
    const { mode, teamId } = req.body;

    const user = await User.findById(req.user.id)
      .select(['stripeCustomer', 'email'])
      .setOptions({ lean: true });

    const team = await Team.findById(teamId)
      .select(['stripeSubscription', 'slug', 'teamLeaderId'])
      .setOptions({ lean: true });

    if (!user || !team || team.teamLeaderId !== req.user.id) {
      throw new Error('Permission denied');
    }

    const session = await createSession({
      mode,
      userId: user._id.toString(),
      userEmail: user.email,
      teamId,
      teamSlug: team.slug,
      customerId: (user.stripeCustomer && user.stripeCustomer.id) || undefined,
      subscriptionId: (team.stripeSubscription && team.stripeSubscription.id) || undefined,
    });

    res.json({ sessionId: session.id });
  } catch (err) {
    next(err);
  }
});

router.post('/cancel-subscription', async (req: any, res, next) => {
  const { teamId } = req.body;

  try {
    const { isSubscriptionActive } = await Team.cancelSubscription({
      teamLeaderId: req.user.id,
      teamId,
    });

    res.json({ isSubscriptionActive });
  } catch (err) {
    next(err);
  }
});

router.get('/get-list-of-invoices-for-customer', async (req: any, res, next) => {
  try {
    const { stripeListOfInvoices } = await User.getListOfInvoicesForCustomer({
      userId: req.user.id,
    });
    res.json({ stripeListOfInvoices });
  } catch (err) {
    next(err);
  }
});

export default router;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\server\api\team-member.ts -----

import * as express from "express";

import { signRequestForUpload } from "../aws-s3";

import User from "../models/User";
import Team from "../models/Team";
import Invitation from "../models/Invitation";
import Discussion from "../models/Discussion";
import Post from "../models/Post";

import { discussionAdded, discussionDeleted, discussionEdited, postAdded, postDeleted, postEdited } from "../sockets";

const router = express.Router();

router.use((req, res, next) => {
  console.log("team member API", req.path);
  if (!req.user) {
    res.status(401).json({ error: "Unauthorized" });
    return;
  }

  next();
});

// Get signed request from AWS S3 server
router.post("/aws/get-signed-request-for-upload-to-s3", async (req, res, next) => {
  try {
    const { fileName, fileType, prefix, bucket } = req.body;

    const returnData = await signRequestForUpload({
      fileName,
      fileType,
      prefix,
      bucket,
    });

    console.log(bucket);

    res.json(returnData);
  } catch (err) {
    next(err);
  }
});

router.post("/user/update-profile", async (req: any, res, next) => {
  try {
    const { name, avatarUrl } = req.body;

    const updatedUser = await User.updateProfile({
      userId: req.user.id,
      name,
      avatarUrl,
    });

    res.json({ updatedUser });
  } catch (err) {
    next(err);
  }
});

router.post("/user/toggle-theme", async (req: any, res, next) => {
  try {
    const { darkTheme } = req.body;

    await User.toggleTheme({ userId: req.user.id, darkTheme });

    res.json({ done: 1 });
  } catch (err) {
    next(err);
  }
});

async function loadDiscussionsData(team, userId, body) {
  const { discussionSlug } = body;

  if (!discussionSlug) {
    return [];
  }

  const { discussions } = await Discussion.getList({
    userId,
    teamId: team._id,
  });

  for (const discussion of discussions) {
    if (discussion.slug === discussionSlug) {
      Object.assign(discussion, {
        initialPosts: await Post.getList({
          userId,
          discussionId: discussion._id.toString(),
        }),
      });

      break;
    }
  }

  return discussions;
}

async function loadTeamData(team, userId, body) {
  const initialMembers = await User.getMembersForTeam({
    userId,
    teamId: team._id,
  });

  let initialInvitations = [];
  if (userId === team.teamLeaderId) {
    initialInvitations = await Invitation.getTeamInvitations({
      userId,
      teamId: team._id,
    });
  }

  console.log(`initialMembers:${initialMembers}`);

  const initialDiscussions = await loadDiscussionsData(team, userId, body);

  const data: any = { initialMembers, initialInvitations, initialDiscussions };

  // console.log(`Express route:${data.initialPosts}`);

  return data;
}

router.post("/get-initial-data", async (req: any, res, next) => {
  try {
    const teams = await Team.getAllTeamsForUser(req.user.id);

    let selectedTeamSlug = req.body.teamSlug;
    if (!selectedTeamSlug && teams && teams.length > 0) {
      selectedTeamSlug = teams[0].slug;
    }

    for (const team of teams) {
      if (team.slug === selectedTeamSlug) {
        Object.assign(team, await loadTeamData(team, req.user.id, req.body));
        break;
      }
    }

    // console.log(teams.length, teams);

    res.json({ teams });
  } catch (err) {
    next(err);
  }
});

// router.get('/teams', async (req, res, next) => {
//   try {
//     const teams = await Team.getAllTeamsForUser(req.user.id);

//     console.log(teams);

//     res.json({ teams });
//   } catch (err) {
//     next(err);
//   }
// });

router.get("/teams/get-members", async (req: any, res, next) => {
  try {
    const users = await User.getMembersForTeam({
      userId: req.user.id,
      teamId: req.query.teamId as string,
    });

    res.json({ users });
  } catch (err) {
    next(err);
  }
});

router.post("/discussions/add", async (req: any, res, next) => {
  try {
    const { name, teamId, memberIds = [], socketId, notificationType } = req.body;

    const discussion = await Discussion.add({
      userId: req.user.id,
      name,
      teamId,
      memberIds,
      notificationType,
    });

    discussionAdded({ socketId, discussion });

    res.json({ discussion });
  } catch (err) {
    next(err);
  }
});

router.post("/discussions/edit", async (req: any, res, next) => {
  try {
    const { name, id, memberIds = [], socketId, notificationType } = req.body;

    const updatedDiscussion = await Discussion.edit({
      userId: req.user.id,
      name,
      id,
      memberIds,
      notificationType,
    });

    discussionEdited({ socketId, discussion: updatedDiscussion });

    res.json({ done: 1 });
  } catch (err) {
    next(err);
  }
});

router.post("/discussions/delete", async (req: any, res, next) => {
  try {
    const { id, socketId } = req.body;

    const { teamId } = await Discussion.delete({ userId: req.user.id, id });

    discussionDeleted({ socketId, teamId, id });

    res.json({ done: 1 });
  } catch (err) {
    next(err);
  }
});

router.get("/discussions/list", async (req: any, res, next) => {
  try {
    const { discussions } = await Discussion.getList({
      userId: req.user.id,
      teamId: req.query.teamId as string,
    });

    res.json({ discussions });
  } catch (err) {
    next(err);
  }
});

router.get("/posts/list", async (req: any, res, next) => {
  try {
    const posts = await Post.getList({
      userId: req.user.id,
      discussionId: req.query.discussionId as string,
    });

    res.json({ posts });
  } catch (err) {
    next(err);
  }
});

router.post("/posts/add", async (req: any, res, next) => {
  try {
    const { content, discussionId, socketId } = req.body;

    const post = await Post.add({ userId: req.user.id, content, discussionId });

    postAdded({ socketId, post });

    res.json({ post });
  } catch (err) {
    next(err);
  }
});

router.post("/posts/edit", async (req: any, res, next) => {
  try {
    const { content, id, socketId } = req.body;

    const updatedPost = await Post.edit({ userId: req.user.id, content, id });

    postEdited({ socketId, post: updatedPost });

    res.json({ done: 1 });
  } catch (err) {
    next(err);
  }
});

router.post("/posts/delete", async (req: any, res, next) => {
  try {
    const { id, discussionId, socketId } = req.body;

    await Post.delete({ userId: req.user.id, id });

    postDeleted({ socketId, id, discussionId });

    res.json({ done: 1 });
  } catch (err) {
    next(err);
  }
});

export default router;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\server\models\Discussion.ts -----

import { uniq } from 'lodash';
import * as mongoose from 'mongoose';

import { generateRandomSlug } from '../utils/slugify';
import Team, { TeamDocument } from './Team';
import Post from './Post';

const mongoSchema = new mongoose.Schema({
  createdUserId: {
    type: String,
    required: true,
  },
  teamId: {
    type: String,
    required: true,
  },
  name: {
    type: String,
    required: true,
  },
  slug: {
    type: String,
    required: true,
  },
  memberIds: [
    {
      type: String,
    },
  ],
  createdAt: {
    type: Date,
    required: true,
    default: Date.now,
  },
  notificationType: {
    type: String,
    enum: ['default', 'email'],
    required: true,
    default: 'default',
  },
});

export interface DiscussionDocument extends mongoose.Document {
  createdUserId: string;
  teamId: string;
  name: string;
  slug: string;
  memberIds: string[];
  createdAt: Date;
  notificationType: string;
}

interface DiscussionModel extends mongoose.Model<DiscussionDocument> {
  getList({
    userId,
    teamId,
  }: {
    userId: string;
    teamId: string;
  }): Promise<{ discussions: DiscussionDocument[] }>;

  add({
    name,
    userId,
    teamId,
    memberIds,
    notificationType,
  }: {
    name: string;
    userId: string;
    teamId: string;
    memberIds: string[];
    notificationType: string;
  }): Promise<DiscussionDocument>;

  edit({
    userId,
    id,
    name,
    memberIds,
    notificationType,
  }: {
    userId: string;
    id: string;
    name: string;
    memberIds: string[];
    notificationType: string;
  }): Promise<DiscussionDocument>;

  delete({ userId, id }: { userId: string; id: string }): Promise<{ teamId: string }>;

  checkPermissionAndGetTeam({
    userId,
    teamId,
    memberIds,
  }: {
    userId: string;
    teamId: string;
    memberIds: string[];
  }): Promise<TeamDocument>;
}

class DiscussionClass extends mongoose.Model {
  public static async getList({ userId, teamId }) {
    await this.checkPermissionAndGetTeam({ userId, teamId });

    const filter: any = { teamId, memberIds: userId };

    const discussions: any[] = await this.find(filter).setOptions({ lean: true });

    return { discussions };
  }

  public static async add({ name, userId, teamId, memberIds = [], notificationType }) {
    if (!name) {
      throw new Error('Bad data');
    }

    await this.checkPermissionAndGetTeam({ userId, teamId, memberIds });

    const slug = await generateRandomSlug(this, { teamId });

    return this.create({
      createdUserId: userId,
      teamId,
      name,
      slug,
      memberIds: uniq([userId, ...memberIds]),
      createdAt: new Date(),
      notificationType,
    });
  }

  public static async edit({ userId, id, name, memberIds = [], notificationType }) {
    if (!id) {
      throw new Error('Bad data');
    }

    const discussion = await this.findById(id)
      .select('teamId createdUserId')
      .setOptions({ lean: true });

    const team = await this.checkPermissionAndGetTeam({
      userId,
      teamId: discussion.teamId,
      memberIds,
    });

    if (discussion.createdUserId !== userId && team.teamLeaderId !== userId) {
      throw new Error('Permission denied. Only author or team leader can edit Discussion.');
    }

    const updatedObj = await this.findOneAndUpdate(
      { _id: id },
      {
        name,
        memberIds: uniq([userId, ...memberIds]),
        notificationType,
      },
      { runValidators: true, new: true },
    );

    return updatedObj;
  }

  public static async delete({ userId, id }) {
    if (!id) {
      throw new Error('Bad data');
    }

    const discussion = await this.findById(id).select('teamId').setOptions({ lean: true });

    await this.checkPermissionAndGetTeam({ userId, teamId: discussion.teamId });

    await Post.deleteMany({ discussionId: id });

    await this.deleteOne({ _id: id });

    return { teamId: discussion.teamId };
  }

  private static async checkPermissionAndGetTeam({ userId, teamId, memberIds = [] }) {
    if (!userId || !teamId) {
      throw new Error('Bad data');
    }

    const team = await Team.findById(teamId)
      .select('memberIds teamLeaderId')
      .setOptions({ lean: true });

    if (!team || team.memberIds.indexOf(userId) === -1) {
      throw new Error('Team not found');
    }

    for (const id of memberIds) {
      if (team.memberIds.indexOf(id) === -1) {
        throw new Error('Permission denied');
      }
    }

    return team;
  }
}

mongoSchema.loadClass(DiscussionClass);

const Discussion = mongoose.model<DiscussionDocument, DiscussionModel>('Discussion', mongoSchema);

export default Discussion;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\server\models\EmailTemplate.ts -----

import * as _ from 'lodash';
import * as mongoose from 'mongoose';

interface EmailTemplateDocument extends mongoose.Document {
  name: string;
  subject: string;
  message: string;
}

const EmailTemplate = mongoose.model<EmailTemplateDocument>(
  'EmailTemplate',
  new mongoose.Schema({
    name: {
      type: String,
      required: true,
      unique: true,
    },
    subject: {
      type: String,
      required: true,
    },
    message: {
      type: String,
      required: true,
    },
  }),
);

export async function insertTemplates() {
  const templates = [
    {
      name: 'welcome',
      subject: 'Welcome to SaaS boilerplate (demo)',
      message: `Welcome <%= userName %>,
        <p>
          Thanks for signing up on our demo!
        </p>
        <p>
          If you are learning how to code and/or build a SaaS web application, check out our two books:
           <a href="https://builderbook.org" target="blank">Builder Book</a>
           and
           <a href="https://builderbook.org/book" target="blank">SaaS Boilerplate</a>.
        </p>
        <p>
          Also check out our other projects built with SaaS boilerplate:
          <a href="https://async-await.com" target="blank"> Async</a>, 
          <a href="https://async-labs.com" target="blank"> Async Labs</a>, and
          <a href="https://workinbiotech.com" target="blank"> Work in biotech</a>.
        </p>
        Kelly & Timur, Team Async Labs
      `,
    },
    {
      name: 'login',
      subject: 'Login link for saas-app.async-await.com',
      message: `
        <p>Log into your account by clicking on this link: <a href="<%= loginURL %>"><%= loginURL %></a>.</p>`,
    },
    {
      name: 'invitation',
      subject: 'You are invited to join a team at saas-app.async-await.com',
      message: `You've been invited to join <b><%= teamName%></b>.
        <br/>Click here to accept the invitation: <%= invitationURL%>
      `,
    },
    {
      name: 'newPost',
      subject: 'New Post was created in Discussion: <%= discussionName %>',
      message: `<p>New Post in Discussion: "<%= discussionName%>" by <%= authorName%></p>
        New Post: "<%= postContent %>"
        <p>---</p>
        <p>View it at <a href="<%= discussionLink %>"><%= discussionLink %></a>.</p>
      `,
    },
  ];

  for (const t of templates) {
    const et = await EmailTemplate.findOne({ name: t.name }).setOptions({ lean: true });
    const message = t.message.replace(/\n/g, '').replace(/[ ]+/g, ' ').trim();

    if (!et) {
      EmailTemplate.create(Object.assign({}, t, { message }));
    } else if (et.subject !== t.subject || et.message !== message) {
      EmailTemplate.updateOne({ _id: et._id }, { $set: { message, subject: t.subject } }).exec();
    }
  }
}

export default async function getEmailTemplate(name: string, params: any) {
  await insertTemplates();

  const et = await EmailTemplate.findOne({ name }).setOptions({ lean: true });

  if (!et) {
    throw new Error('Email Template is not found in database.');
  }

  return {
    message: _.template(et.message)(params),
    subject: _.template(et.subject)(params),
  };
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\server\models\Invitation.ts -----

import * as mongoose from 'mongoose';

import sendEmail from '../aws-ses';
import getEmailTemplate from './EmailTemplate';
import Team from './Team';
import User, { UserDocument } from './User';

const mongoSchema = new mongoose.Schema({
  teamId: {
    type: String,
    required: true,
  },
  email: {
    type: String,
    required: true,
  },
  createdAt: {
    type: Date,
    required: true,
    default: Date.now,
    expires: 60 * 60 * 24, // delete doc after 24 hours
  },
  token: {
    type: String,
    required: true,
    unique: true,
  },
});

mongoSchema.index({ teamId: 1, email: 1 }, { unique: true });

interface InvitationDocument extends mongoose.Document {
  teamId: string;
  email: string;
  createdAt: Date;
  token: string;
}

interface InvitationModel extends mongoose.Model<InvitationDocument> {
  add({
    userId,
    teamId,
    email,
  }: {
    userId: string;
    teamId: string;
    email: string;
  }): InvitationDocument;

  getTeamInvitations({ userId, teamId }: { userId: string; teamId: string });
  getTeamByToken({ token }: { token: string });
  addUserToTeam({ token, user }: { token: string; user: UserDocument });
}

function generateToken() {
  const gen = () =>
    Math.random().toString(36).substring(2, 12) + Math.random().toString(36).substring(2, 12);

  return `${gen()}`;
}

class InvitationClass extends mongoose.Model {
  public static async add({ userId, teamId, email }) {
    if (!teamId || !email) {
      throw new Error('Bad data');
    }

    const team = await Team.findById(teamId).setOptions({ lean: true });
    if (!team || team.teamLeaderId !== userId) {
      throw new Error('Team does not exist or you have no permission');
    }

    const registeredUser = await User.findOne({ email }).setOptions({ lean: true });

    if (registeredUser && team.memberIds.includes(registeredUser._id.toString())) {
      throw new Error('This user is already Team Member.');
    }

    let token;
    const invitation = await this.findOne({ teamId, email })
      .select('token')
      .setOptions({ lean: true });

    if (invitation) {
      token = invitation.token;
    } else {
      token = generateToken();
      while ((await this.countDocuments({ token })) > 0) {
        token = generateToken();
      }

      await this.create({
        teamId,
        email,
        token,
      });
    }

    const dev = process.env.NODE_ENV !== 'production';

    const emailTemplate = await getEmailTemplate('invitation', {
      teamName: team.name,
      invitationURL: `${
        dev ? process.env.URL_APP : process.env.PRODUCTION_URL_APP
      }/invitation?token=${token}`,
    });

    if (!emailTemplate) {
      throw new Error('Invitation email template not found');
    }

    try {
      await sendEmail({
        from: `Kelly from saas-app.async-await.com <${process.env.EMAIL_SUPPORT_FROM_ADDRESS}>`,
        to: [email],
        subject: emailTemplate.subject,
        body: emailTemplate.message,
      });
    } catch (err) {
      console.log('Email sending error:', err);
    }

    return await this.findOne({ teamId, email }).setOptions({ lean: true });
  }

  public static async getTeamInvitations({ userId, teamId }) {
    const team = await Team.findOne({ _id: teamId })
      .select('teamLeaderId')
      .setOptions({ lean: true });

    if (userId !== team.teamLeaderId) {
      throw new Error('You have no permission.');
    }

    return this.find({ teamId }).select('email').setOptions({ lean: true });
  }

  public static async getTeamByToken({ token }) {
    if (!token) {
      throw new Error('Bad data');
    }

    const invitation = await this.findOne({ token }).setOptions({ lean: true });

    if (!invitation) {
      throw new Error('Invitation not found');
    }

    const team = await Team.findById(invitation.teamId)
      .select('name slug avatarUrl memberIds')
      .setOptions({ lean: true });

    if (!team) {
      throw new Error('Team does not exist');
    }

    return team;
  }

  public static async addUserToTeam({ token, user }) {
    if (!token || !user) {
      throw new Error('Bad data');
    }

    const invitation = await this.findOne({ token }).setOptions({ lean: true });

    if (!invitation || invitation.email !== user.email) {
      throw new Error('Invitation not found');
    }

    await this.deleteOne({ token });

    const team = await Team.findById(invitation.teamId)
      .select('memberIds slug teamLeaderId')
      .setOptions({ lean: true });

    if (!team) {
      throw new Error('Team does not exist');
    }

    if (team && !team.memberIds.includes(user._id)) {
      await Team.updateOne({ _id: team._id }, { $addToSet: { memberIds: user._id } });

      if (user._id !== team.teamLeaderId) {
        await User.findByIdAndUpdate(user._id, { $set: { defaultTeamSlug: team.slug } });
      }
    }

    return team.slug;
  }
}

mongoSchema.loadClass(InvitationClass);

const Invitation = mongoose.model<InvitationDocument, InvitationModel>('Invitation', mongoSchema);

export default Invitation;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\server\models\Post.ts -----

import * as mongoose from "mongoose";

import * as he from "he";
import hljs from "highlight.js";
import { marked } from "marked";

import Discussion from "./Discussion";
import Team from "./Team";

const mongoSchema = new mongoose.Schema({
  createdUserId: {
    type: String,
    required: true,
  },
  discussionId: {
    type: String,
    required: true,
  },
  content: {
    type: String,
    required: true,
  },
  htmlContent: {
    type: String,
    required: true,
  },
  isEdited: {
    type: Boolean,
    default: false,
  },
  lastUpdatedAt: Date,
  createdAt: {
    type: Date,
    required: true,
  },
});

function markdownToHtml(content) {
  const renderer = new marked.Renderer();

  renderer.link = ({ href, title, text }) => {
    const t = title ? ` title="${title}"` : "";

    if (text.startsWith("<code>@#")) {
      return `${text.replace("<code>@#", "<code>@")} `;
    }

    return `
      <a target="_blank" href="${href}" rel="noopener noreferrer"${t}>
        ${text}
      </a>
    `;
  };

  renderer.code = ({ text, lang }) => {
    const language = hljs.getLanguage(lang) ? lang : "plaintext";

    return `<pre><code class="hljs language-${lang}">${hljs.highlight(text, { language }).value}</code></pre>`;
  };

  marked.setOptions({
    renderer,
    breaks: true,
  });

  return marked(he.decode(content));
}

export interface PostDocument extends mongoose.Document {
  createdUserId: string;
  discussionId: string;
  content: string;
  isEdited: boolean;
  lastUpdatedAt: Date;
  createdAt: Date;
}

interface PostModel extends mongoose.Model<PostDocument> {
  getList({ userId, discussionId }: { userId: string; discussionId: string }): Promise<PostDocument[]>;

  add({
    content,
    userId,
    discussionId,
  }: {
    content: string;
    userId: string;
    discussionId: string;
  }): Promise<PostDocument>;

  edit({ content, userId, id }: { content: string; userId: string; id: string }): Promise<PostDocument>;

  delete({ userId, id }: { userId: string; id: string }): Promise<void>;

  checkPermissionAndGetTeamAndDiscussion({
    userId,
    discussionId,
    post,
  }: {
    userId: string;
    discussionId: string;
    post: PostDocument;
  }): Promise<{ TeamDocument; DiscussionDocument }>;
}

class PostClass extends mongoose.Model {
  public static async getList({ userId, discussionId }) {
    await this.checkPermissionAndGetTeamAndDiscussion({ userId, discussionId });

    const filter: any = { discussionId };

    const posts: any[] = await this.find(filter).sort({ createdAt: 1 }).setOptions({ lean: true });

    return posts;
  }

  public static async add({ content, userId, discussionId }) {
    if (!content) {
      throw new Error("Bad data");
    }

    await this.checkPermissionAndGetTeamAndDiscussion({ userId, discussionId });

    const htmlContent = markdownToHtml(content);

    const post = await this.create({
      createdUserId: userId,
      discussionId,
      content,
      htmlContent,
      createdAt: new Date(),
    });

    return post;
  }

  public static async edit({ content, userId, id }) {
    if (!content || !id) {
      throw new Error("Bad data");
    }

    const post = await this.findById(id).select("createdUserId discussionId").setOptions({ lean: true });

    await this.checkPermissionAndGetTeamAndDiscussion({
      userId,
      discussionId: post.discussionId,
      post,
    });

    const htmlContent = markdownToHtml(content);

    const updatedObj = await this.findOneAndUpdate(
      { _id: id },
      { content, htmlContent, isEdited: true, lastUpdatedAt: new Date() },
      { runValidators: true, new: true }
    );

    return updatedObj;
  }

  public static async delete({ userId, id }) {
    if (!id) {
      throw new Error("Bad data");
    }

    const post = await this.findById(id).select("createdUserId discussionId content").setOptions({ lean: true });

    await this.checkPermissionAndGetTeamAndDiscussion({
      userId,
      discussionId: post.discussionId,
      post,
    });

    await this.deleteOne({ _id: id });
  }

  private static async checkPermissionAndGetTeamAndDiscussion({ userId, discussionId, post = null }) {
    if (!userId || !discussionId) {
      throw new Error("Bad data");
    }

    if (post && post.createdUserId !== userId) {
      throw new Error("Permission denied");
    }

    const discussion = await Discussion.findById(discussionId)
      .select("teamId memberIds slug")
      .setOptions({ lean: true });

    if (!discussion) {
      throw new Error("Discussion not found");
    }

    if (discussion.memberIds.indexOf(userId) === -1) {
      throw new Error("Permission denied");
    }

    const team = await Team.findById(discussion.teamId).select("memberIds slug").setOptions({ lean: true });

    if (!team || team.memberIds.indexOf(userId) === -1) {
      throw new Error("Team not found");
    }

    return { team, discussion };
  }
}

mongoSchema.loadClass(PostClass);

const Post = mongoose.model<PostDocument, PostModel>("Post", mongoSchema);

export default Post;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\server\models\Team.ts -----

import * as mongoose from 'mongoose';
import Stripe from 'stripe';

import { cancelSubscription } from '../stripe';
import { generateRandomSlug } from '../utils/slugify';
import User from './User';

const mongoSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
  },
  slug: {
    type: String,
    required: true,
    unique: true,
  },
  avatarUrl: String,
  createdAt: {
    type: Date,
    required: true,
  },
  teamLeaderId: {
    type: String,
    required: true,
  },
  memberIds: [
    {
      type: String,
      required: true,
    },
  ],
  defaultTeam: {
    type: Boolean,
    default: false,
  },
  stripeSubscription: {
    id: String,
    object: String,
    application_fee_percent: Number,
    billing: String,
    cancel_at_period_end: Boolean,
    billing_cycle_anchor: Number,
    canceled_at: Number,
    created: Number,
  },
  isSubscriptionActive: {
    type: Boolean,
    default: false,
  },
  isPaymentFailed: {
    type: Boolean,
    default: false,
  },
});

export interface TeamDocument extends mongoose.Document {
  name: string;
  slug: string;
  avatarUrl: string;
  createdAt: Date;

  teamLeaderId: string;
  memberIds: string[];
  defaultTeam: boolean;

  stripeSubscription: {
    id: string;
    object: string;
    application_fee_percent: number;
    billing: string;
    cancel_at_period_end: boolean;
    billing_cycle_anchor: number;
    canceled_at: number;
    created: number;
  };
  isSubscriptionActive: boolean;
  isPaymentFailed: boolean;
}

interface TeamModel extends mongoose.Model<TeamDocument> {
  addTeam({
    name,
    userId,
  }: {
    userId: string;
    name: string;
    avatarUrl: string;
  }): Promise<TeamDocument>;

  updateTeam({
    userId,
    teamId,
    name,
    avatarUrl,
  }: {
    userId: string;
    teamId: string;
    name: string;
    avatarUrl: string;
  }): Promise<TeamDocument>;

  getAllTeamsForUser(userId: string): Promise<TeamDocument[]>;

  removeMember({
    teamId,
    teamLeaderId,
    userId,
  }: {
    teamId: string;
    teamLeaderId: string;
    userId: string;
  }): Promise<void>;

  subscribeTeam({
    session,
    team,
  }: {
    session: Stripe.Checkout.Session;
    team: TeamDocument;
  }): Promise<void>;

  cancelSubscription({
    teamLeaderId,
    teamId,
  }: {
    teamLeaderId: string;
    teamId: string;
  }): Promise<TeamDocument>;

  cancelSubscriptionAfterFailedPayment({
    subscriptionId,
  }: {
    subscriptionId: string;
  }): Promise<TeamDocument>;
}

class TeamClass extends mongoose.Model {
  public static async addTeam({ userId, name, avatarUrl }) {
    console.log(`Static method: ${name}, ${avatarUrl}`);

    if (!userId || !name || !avatarUrl) {
      throw new Error('Bad data');
    }

    const slug = await generateRandomSlug(this);

    let defaultTeam = false;
    if ((await this.countDocuments({ teamLeaderId: userId })) === 0) {
      await User.findByIdAndUpdate(userId, { $set: { defaultTeamSlug: slug } });
      defaultTeam = true;
    }

    const team = await this.create({
      teamLeaderId: userId,
      name,
      slug,
      avatarUrl,
      memberIds: [userId],
      createdAt: new Date(),
      defaultTeam,
    });

    return team;
  }

  public static async updateTeam({ userId, teamId, name, avatarUrl }) {
    const team = await this.findById(teamId, 'name teamLeaderId');

    if (!team) {
      throw new Error('Team not found');
    }

    if (team.teamLeaderId !== userId) {
      throw new Error('Permission denied');
    }

    const modifier = { name: team.name, avatarUrl };

    if (name !== team.name) {
      modifier.name = name;
    }

    await this.updateOne({ _id: teamId }, { $set: modifier }, { runValidators: true });

    return this.findById(teamId, 'name avatarUrl slug defaultTeam').setOptions({ lean: true });
  }

  public static getAllTeamsForUser(userId: string) {
    return this.find({ memberIds: userId }).setOptions({ lean: true });
  }

  public static async removeMember({ teamId, teamLeaderId, userId }) {
    const team = await this.findById(teamId).select('memberIds teamLeaderId');

    if (!team) {
      throw new Error('Team does not exist');
    }

    if (team.teamLeaderId !== teamLeaderId || teamLeaderId === userId) {
      throw new Error('Permission denied');
    }

    await this.findByIdAndUpdate(teamId, { $pull: { memberIds: userId } });
  }

  public static async subscribeTeam({
    session,
    team,
  }: {
    session: Stripe.Checkout.Session;
    team: TeamDocument;
  }) {
    if (!session.subscription) {
      throw new Error('Not subscribed');
    }

    if (!team) {
      throw new Error('User not found.');
    }

    if (team.isSubscriptionActive) {
      throw new Error('Team is already subscribed.');
    }

    const stripeSubscription = session.subscription as Stripe.Subscription;
    if (stripeSubscription.canceled_at) {
      throw new Error('Unsubscribed');
    }

    await this.updateOne({ _id: team._id }, { stripeSubscription, isSubscriptionActive: true });
  }

  public static async cancelSubscription({ teamLeaderId, teamId }) {
    const team = await this.findById(teamId).select(
      'teamLeaderId isSubscriptionActive stripeSubscription',
    );

    if (team.teamLeaderId !== teamLeaderId) {
      throw new Error('You do not have permission to subscribe Team.');
    }

    if (!team.isSubscriptionActive) {
      throw new Error('Team is already unsubscribed.');
    }

    const cancelledSubscriptionObj = await cancelSubscription({
      subscriptionId: team.stripeSubscription.id,
    });

    return this.findByIdAndUpdate(
      teamId,
      {
        stripeSubscription: cancelledSubscriptionObj,
        isSubscriptionActive: false,
      },
      { new: true, runValidators: true },
    )
      .select('isSubscriptionActive stripeSubscription')
      .setOptions({ lean: true });
  }

  public static async cancelSubscriptionAfterFailedPayment({ subscriptionId }) {
    const team: any = await this.find({ 'stripeSubscription.id': subscriptionId })
      .select('teamLeaderId isSubscriptionActive stripeSubscription isPaymentFailed')
      .setOptions({ lean: true });
    if (!team.isSubscriptionActive) {
      throw new Error('Team is already unsubscribed.');
    }
    if (team.isPaymentFailed) {
      throw new Error('Team is already unsubscribed after failed payment.');
    }
    const cancelledSubscriptionObj = await cancelSubscription({
      subscriptionId,
    });
    return this.findByIdAndUpdate(
      team._id,
      {
        stripeSubscription: cancelledSubscriptionObj,
        isSubscriptionActive: false,
        isPaymentFailed: true,
      },
      { new: true, runValidators: true },
    )
      .select('isSubscriptionActive stripeSubscription isPaymentFailed')
      .setOptions({ lean: true });
  }
}

mongoSchema.loadClass(TeamClass);

const Team = mongoose.model<TeamDocument, TeamModel>('Team', mongoSchema);

export default Team;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\server\models\User.ts -----

import * as _ from 'lodash';
import * as mongoose from 'mongoose';
import Stripe from 'stripe';

import sendEmail from '../aws-ses';
import { addToMailchimp } from '../mailchimp';
import { generateSlug } from '../utils/slugify';
import getEmailTemplate from './EmailTemplate';
import Team, { TeamDocument } from './Team';

import { getListOfInvoices } from '../stripe';

const mongoSchema = new mongoose.Schema({
  slug: {
    type: String,
    required: true,
    unique: true,
  },
  createdAt: {
    type: Date,
    required: true,
  },
  email: {
    type: String,
    required: true,
    unique: true,
  },
  displayName: String,
  avatarUrl: String,
  googleId: {
    type: String,
    unique: true,
    sparse: true,
  },
  googleToken: {
    accessToken: String,
    refreshToken: String,
  },
  isSignedupViaGoogle: {
    type: Boolean,
    required: true,
    default: false,
  },
  darkTheme: Boolean,
  defaultTeamSlug: {
    type: String,
    default: '',
  },
  stripeCustomer: {
    id: String,
    object: String,
    created: Number,
    currency: String,
    default_source: String,
    description: String,
  },
  stripeCard: {
    id: String,
    object: String,
    brand: String,
    funding: String,
    country: String,
    last4: String,
    exp_month: Number,
    exp_year: Number,
  },
  hasCardInformation: {
    type: Boolean,
    default: false,
  },
  stripeListOfInvoices: {
    object: String,
    has_more: Boolean,
    data: [
      {
        id: String,
        object: String,
        amount_paid: Number,
        created: Number,
        customer: String,
        subscription: String,
        hosted_invoice_url: String,
        billing: String,
        paid: Boolean,
        number: String,
        teamId: String,
        teamName: String,
      },
    ],
  },
});

export interface UserDocument extends mongoose.Document {
  slug: string;
  createdAt: Date;
  email: string;
  displayName: string;
  avatarUrl: string;
  googleId: string;
  googleToken: { accessToken: string; refreshToken: string };
  isSignedupViaGoogle: boolean;
  darkTheme: boolean;
  defaultTeamSlug: string;
  stripeCustomer: {
    id: string;
    default_source: string;
    created: number;
    object: string;
    description: string;
  };
  stripeCard: {
    id: string;
    object: string;
    brand: string;
    country: string;
    last4: string;
    exp_month: number;
    exp_year: number;
    funding: string;
  };
  hasCardInformation: boolean;
  stripeListOfInvoices: {
    object: string;
    has_more: boolean;
    data: [
      {
        id: string;
        object: string;
        amount_paid: number;
        date: number;
        customer: string;
        subscription: string;
        hosted_invoice_url: string;
        billing: string;
        paid: boolean;
        number: string;
        teamId: string;
        teamName: string;
      },
    ];
  };
}

interface UserModel extends mongoose.Model<UserDocument> {
  getUserBySlug({ slug }: { slug: string }): Promise<UserDocument>;

  updateProfile({
    userId,
    name,
    avatarUrl,
  }: {
    userId: string;
    name: string;
    avatarUrl: string;
  }): Promise<UserDocument[]>;

  publicFields(): string[];

  signInOrSignUpViaGoogle({
    googleId,
    email,
    displayName,
    avatarUrl,
    googleToken,
  }: {
    googleId: string;
    email: string;
    displayName: string;
    avatarUrl: string;
    googleToken: { accessToken?: string; refreshToken?: string };
  }): Promise<UserDocument>;

  signInOrSignUpByPasswordless({
    uid,
    email,
  }: {
    uid: string;
    email: string;
  }): Promise<UserDocument>;

  toggleTheme({ userId, darkTheme }: { userId: string; darkTheme: boolean }): Promise<void>;

  getMembersForTeam({
    userId,
    teamId,
  }: {
    userId: string;
    teamId: string;
  }): Promise<UserDocument[]>;

  checkPermissionAndGetTeam({
    userId,
    teamId,
  }: {
    userId: string;
    teamId: string;
  }): Promise<TeamDocument>;

  saveStripeCustomerAndCard({
    user,
    session,
  }: {
    session: Stripe.Checkout.Session;
    user: UserDocument;
  }): Promise<void>;

  changeStripeCard({
    session,
    user,
  }: {
    session: Stripe.Checkout.Session;
    user: UserDocument;
  }): Promise<void>;

  getListOfInvoicesForCustomer({ userId }: { userId: string }): Promise<UserDocument>;
}

class UserClass extends mongoose.Model {
  public static async getUserBySlug({ slug }) {
    console.log('Static method: getUserBySlug');

    return this.findOne({ slug }, 'email displayName avatarUrl');
  }

  public static async updateProfile({ userId, name, avatarUrl }) {
    console.log('Static method: updateProfile');

    const user = await this.findById(userId, 'slug displayName');

    const modifier = { displayName: user.displayName, avatarUrl, slug: user.slug };

    console.log(user.slug);

    if (name !== user.displayName) {
      modifier.displayName = name;
      modifier.slug = await generateSlug(this, name);
    }

    return this.findByIdAndUpdate(userId, { $set: modifier }, { new: true, runValidators: true })
      .select('displayName avatarUrl slug')
      .setOptions({ lean: true });
  }

  public static publicFields(): string[] {
    return [
      '_id',
      'id',
      'displayName',
      'email',
      'avatarUrl',
      'slug',
      'isSignedupViaGoogle',
      'darkTheme',
      'defaultTeamSlug',
      'stripeCard',
      'hasCardInformation',
      'stripeListOfInvoices',
    ];
  }

  public static async signInOrSignUpViaGoogle({
    googleId,
    email,
    displayName,
    avatarUrl,
    googleToken,
  }) {
    const user = await this.findOne({ email })
      .select([...this.publicFields(), 'googleId'].join(' '))
      .setOptions({ lean: true });

    if (user) {
      if (_.isEmpty(googleToken) && user.googleId) {
        return user;
      }

      const modifier = { googleId };
      if (googleToken.accessToken) {
        modifier['googleToken.accessToken'] = googleToken.accessToken;
      }

      if (googleToken.refreshToken) {
        modifier['googleToken.refreshToken'] = googleToken.refreshToken;
      }

      await this.updateOne({ email }, { $set: modifier });

      return user;
    }

    const slug = await generateSlug(this, displayName);

    const newUser = await this.create({
      createdAt: new Date(),
      googleId,
      email,
      googleToken,
      displayName,
      avatarUrl,
      slug,
      isSignedupViaGoogle: true,
      defaultTeamSlug: '',
      darkTheme: false,
    });

    const emailTemplate = await getEmailTemplate('welcome', { userName: displayName });

    if (!emailTemplate) {
      throw new Error('Welcome email template not found');
    }

    try {
      await sendEmail({
        from: `Kelly from saas-app.async-await.com <${process.env.EMAIL_SUPPORT_FROM_ADDRESS}>`,
        to: [email],
        subject: emailTemplate.subject,
        body: emailTemplate.message,
      });
    } catch (err) {
      console.error('Email sending error:', err);
    }

    try {
      await addToMailchimp({ email, listName: 'signups' });
    } catch (error) {
      console.error('Mailchimp error:', error);
    }

    return _.pick(newUser, this.publicFields());
  }

  public static async signInOrSignUpByPasswordless({ uid, email }) {
    const user = await this.findOne({ email })
      .select(this.publicFields().join(' '))
      .setOptions({ lean: true });

    if (user) {
      throw Error('User already exists');
    }

    const slug = await generateSlug(this, email);

    const newUser = await this.create({
      _id: uid,
      createdAt: new Date(),
      email,
      slug,
      defaultTeamSlug: '',
    });

    const emailTemplate = await getEmailTemplate('welcome', { userName: email });

    if (!emailTemplate) {
      throw new Error('Email template "welcome" not found in database.');
    }

    try {
      await sendEmail({
        from: `Kelly from saas-app.async-await.com <${process.env.EMAIL_SUPPORT_FROM_ADDRESS}>`,
        to: [email],
        subject: emailTemplate.subject,
        body: emailTemplate.message,
      });
    } catch (err) {
      console.error('Email sending error:', err);
    }

    try {
      await addToMailchimp({ email, listName: 'signups' });
    } catch (error) {
      console.error('Mailchimp error:', error);
    }

    return _.pick(newUser, this.publicFields());
  }

  // try private instead of public, run `yarn build`
  public static toggleTheme({ userId, darkTheme }) {
    return this.updateOne({ _id: userId }, { darkTheme: !!darkTheme });
  }

  public static async getMembersForTeam({ userId, teamId }) {
    const team = await this.checkPermissionAndGetTeam({ userId, teamId });

    return this.find({ _id: { $in: team.memberIds } })
      .select(this.publicFields().join(' '))
      .setOptions({ lean: true });
  }

  public static async saveStripeCustomerAndCard({
    user,
    session,
  }: {
    session: Stripe.Checkout.Session;
    user: UserDocument;
  }) {
    if (!user) {
      throw new Error('User not found.');
    }

    const stripeSubscription = session.subscription as Stripe.Subscription;

    const stripeCard =
      (stripeSubscription.default_payment_method &&
        (stripeSubscription.default_payment_method as Stripe.PaymentMethod).card) ||
      undefined;

    const hasCardInformation = !!stripeCard;

    await this.updateOne(
      { _id: user._id },
      {
        stripeCustomer: session.customer,
        stripeCard,
        hasCardInformation,
      },
    );
  }

  public static async changeStripeCard({
    session,
    user,
  }: {
    session: Stripe.Checkout.Session;
    user: UserDocument;
  }): Promise<void> {
    if (!user) {
      throw new Error('User not found.');
    }

    const si: Stripe.SetupIntent = session.setup_intent as Stripe.SetupIntent;
    const pm: Stripe.PaymentMethod = si.payment_method as Stripe.PaymentMethod;

    if (!pm.card) {
      throw new Error('No card found.');
    }
    await this.updateOne({ _id: user._id }, { stripeCard: pm.card, hasCardInformation: true });
  }

  public static async getListOfInvoicesForCustomer({ userId }) {
    const user = await this.findById(userId, 'stripeCustomer');

    if (!user.stripeCustomer.id) {
      throw new Error('You are not a customer and you have no payment history.');
    }

    const newListOfInvoices = await getListOfInvoices({
      customerId: user.stripeCustomer.id,
    });

    if (newListOfInvoices.data === undefined || newListOfInvoices.data.length === 0) {
      throw new Error('You are a customer. But there is no payment history.');
    }

    const modifier = {
      stripeListOfInvoices: newListOfInvoices,
    };

    return this.findByIdAndUpdate(userId, { $set: modifier }, { new: true, runValidators: true })
      .select('stripeListOfInvoices')
      .setOptions({ lean: true });
  }

  private static async checkPermissionAndGetTeam({ userId, teamId }) {
    console.log(userId, teamId);

    if (!userId || !teamId) {
      throw new Error('Bad data');
    }

    const team = await Team.findById(teamId).select('memberIds').setOptions({ lean: true });

    if (!team || team.memberIds.indexOf(userId) === -1) {
      throw new Error('Team not found');
    }

    return team;
  }
}

mongoSchema.loadClass(UserClass);

const User = mongoose.model<UserDocument, UserModel>('User', mongoSchema);

export default User;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\server\utils\slugify.ts -----

import * as _ from 'lodash';

const slugify = (text) => _.kebabCase(text);

async function createUniqueSlug(Model, slug, count, filter) {
  const obj = await Model.findOne({ slug: `${slug}-${count}`, ...filter })
    .select('_id')
    .setOptions({ lean: true });

  if (!obj) {
    return `${slug}-${count}`;
  }

  return createUniqueSlug(Model, slug, count + 1, filter);
}

async function generateSlug(Model, name, filter = {}) {
  const origSlug = slugify(name);

  const obj = await Model.findOne({ slug: origSlug, ...filter })
    .select('_id')
    .setOptions({ lean: true });

  if (!obj) {
    return origSlug;
  }

  return createUniqueSlug(Model, origSlug, 1, filter);
}

async function generateRandomSlug(Model, filter = {}) {
  const randomString12 =
    Math.random().toString(36).substring(2, 8) + Math.random().toString(36).substring(2, 8);

  const obj = await Model.findOne({ slug: randomString12, ...filter })
    .select('_id')
    .setOptions({ lean: true });

  if (!obj) {
    return randomString12;
  }

  return generateRandomSlug(Model, filter);
}

export { generateSlug, generateRandomSlug };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\server\utils\sum.ts -----

function sum(a, b) {
  return a + b;
}

export { sum };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\server\aws-s3.ts -----

import * as url from 'url';
import * as aws from 'aws-sdk';

async function signRequestForUpload({
  fileName,
  fileType,
  prefix,
  bucket,
}: {
  fileName: string;
  fileType: string;
  prefix: string;
  bucket: string;
}) {
  const randomStringForPrefix =
    Math.random().toString(36).substring(2, 12) + Math.random().toString(36).substring(2, 12);

  const key = `${prefix}/${randomStringForPrefix}/${fileName}`;

  const acl = 'public-read';

  const params = {
    Bucket: bucket,
    Key: key,
    Expires: 60,
    ContentType: fileType,
    ACL: acl,
  };

  console.log(key, bucket);

  const s3 = new aws.S3({
    apiVersion: 'latest',
    region: process.env.AWS_REGION,
    accessKeyId: process.env.AWS_ACCESSKEYID,
    secretAccessKey: process.env.AWS_SECRETACCESSKEY,
  });

  return new Promise((resolve, reject) => {
    s3.getSignedUrl('putObject', params, (err, data) => {
      const parsedUrl = url.parse(data);

      const returnData = {
        signedRequest: data,
        url: `${parsedUrl.protocol}//${parsedUrl.hostname}${parsedUrl.pathname}`,
      };

      console.log(returnData);

      if (err) {
        console.error(err);
        reject(err);
      } else {
        resolve(returnData);
      }
    });
  });
}

export { signRequestForUpload };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\server\aws-ses.ts -----

import * as aws from 'aws-sdk';

export default function sendEmail(options) {
  const ses = new aws.SES({
    apiVersion: 'latest',
    region: process.env.AWS_REGION,
    accessKeyId: process.env.AWS_ACCESSKEYID,
    secretAccessKey: process.env.AWS_SECRETACCESSKEY,
  });

  return new Promise((resolve, reject) => {
    ses.sendEmail(
      {
        Source: options.from,
        Destination: {
          CcAddresses: options.cc,
          ToAddresses: options.to,
        },
        Message: {
          Subject: {
            Data: options.subject,
          },
          Body: {
            Html: {
              Data: options.body,
            },
          },
        },
        ReplyToAddresses: options.replyTo,
      },
      (err, info) => {
        if (err) {
          reject(err);
        } else {
          resolve(info);
        }
      },
    );
  });
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\server\google-auth.ts -----

import * as passport from 'passport';
import { OAuth2Strategy as Strategy } from 'passport-google-oauth';

import User, { UserDocument } from './models/User';
import Invitation from './models/Invitation';

const dev = process.env.NODE_ENV !== 'production';

function setupGoogle({ server }) {
  if (!process.env.GOOGLE_CLIENTID) {
    return;
  }

  const verify = async (req, accessToken, refreshToken, profile, done) => {
    let email;
    let avatarUrl;

    if (profile.emails) {
      email = profile.emails[0].value;
    }

    if (profile.photos && profile.photos.length > 0) {
      avatarUrl = profile.photos[0].value.replace('sz=50', 'sz=128');
    }

    try {
      const user = await User.signInOrSignUpViaGoogle({
        googleId: profile.id,
        email,
        googleToken: { accessToken, refreshToken },
        displayName: profile.displayName,
        avatarUrl,
      });

      let teamSlugOfInvitedTeam;
      if (user && req.session.invitationToken) {
        teamSlugOfInvitedTeam = await Invitation.addUserToTeam({
          token: req.session.invitationToken,
          user,
        }).catch((err) => console.error(err));
      }

      user.defaultTeamSlug = teamSlugOfInvitedTeam ? teamSlugOfInvitedTeam : user.defaultTeamSlug;

      done(null, user);
    } catch (err) {
      done(err);
      console.error(err);
    }
  };

  passport.use(
    new Strategy(
      {
        clientID: process.env.GOOGLE_CLIENTID,
        clientSecret: process.env.GOOGLE_CLIENTSECRET,
        callbackURL: `${dev ? process.env.URL_API : process.env.PRODUCTION_URL_API}/oauth2callback`,
        passReqToCallback: true,
      },
      verify,
    ),
  );

  passport.serializeUser((user: UserDocument, done) => {
    done(null, user._id);
  });

  passport.deserializeUser((id, done) => {
    User.findById(id, User.publicFields())
      .then((user) => {
        done(null, user);
      })
      .catch((error) => {
        done(error, null);
      });
  });

  server.use(passport.initialize());
  server.use(passport.session());

  server.get('/auth/google', (req, res, next) => {
    const options = {
      scope: ['profile', 'email'],
      prompt: 'select_account',
    };

    if (req.query && req.query.invitationToken) {
      req.session.invitationToken = req.query.invitationToken;
    } else {
      req.session.invitationToken = null;
    }

    passport.authenticate('google', options)(req, res, next);
  });

  server.get(
    '/oauth2callback',
    passport.authenticate('google', {
      failureRedirect: '/login',
    }),
    async (req, res) => {
      let teamSlugOfInvitedTeam;

      if (req.user && req.session.invitationToken) {
        teamSlugOfInvitedTeam = await Invitation.addUserToTeam({
          token: req.session.invitationToken,
          user: req.user,
        }).catch((err) => console.error(err));

        req.session.invitationToken = null;
      }

      let redirectUrlAfterLogin;
      const defaultTeamSlug = req.user && req.user.defaultTeamSlug;

      if (teamSlugOfInvitedTeam || defaultTeamSlug) {
        redirectUrlAfterLogin = `/your-settings`;
      } else {
        redirectUrlAfterLogin = `/create-team`;
      }

      res.redirect(
        `${dev ? process.env.URL_APP : process.env.PRODUCTION_URL_APP}${redirectUrlAfterLogin}`,
      );
    },
  );
}

export { setupGoogle };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\server\logger.ts -----

import * as winston from 'winston';

const dev = process.env.NODE_ENV !== 'production';

const logger = winston.createLogger({
  format: winston.format.simple(),
  level: dev ? 'debug' : 'info',
  transports: [new winston.transports.Console()],
});

export default logger;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\server\mailchimp.ts -----

import fetch, { Response } from 'node-fetch';

const LIST_IDS = {
  signups: process.env.MAILCHIMP_SAAS_ALL_LIST_ID,
};

function callAPI({
  path,
  method,
  data,
}: {
  path: string;
  method: string;
  data: {
    email_address: string;
    status: string;
  };
}): Promise<Response> {
  const ROOT_URI = `https://${process.env.MAILCHIMP_REGION}.api.mailchimp.com/3.0`;

  return fetch(`${ROOT_URI}${path}`, {
    method,
    headers: {
      Accept: 'application/json',
      Authorization: `Basic ${Buffer.from(`apikey:${process.env.MAILCHIMP_API_KEY}`).toString(
        'base64',
      )}`,
    },
    body: JSON.stringify(data),
  });
}

async function addToMailchimp({ email, listName }: { email: string; listName: string }) {
  const data = {
    email_address: email,
    status: 'subscribed',
  };

  const path = `/lists/${LIST_IDS[listName]}/members/`;

  await callAPI({ path, method: 'POST', data });
}

export { addToMailchimp };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\server\passwordless-auth.ts -----

import * as passwordless from 'passwordless';

import sendEmail from './aws-ses';
import getEmailTemplate from './models/EmailTemplate';
import User from './models/User';
import PasswordlessMongoStore from './passwordless-token-mongostore';
import Invitation from './models/Invitation';

function setupPasswordless({ server }) {
  const mongoStore = new PasswordlessMongoStore();

  const dev = process.env.NODE_ENV !== 'production';

  passwordless.addDelivery(async (tokenToSend, uidToSend, recipient, callback) => {
    try {
      const template = await getEmailTemplate('login', {
        loginURL: `${
          dev ? process.env.URL_API : process.env.PRODUCTION_URL_API
        }/auth/logged_in?token=${tokenToSend}&uid=${encodeURIComponent(uidToSend)}`,
      });

      await sendEmail({
        from: `Kelly from saas-app.async-await.com <${process.env.EMAIL_SUPPORT_FROM_ADDRESS}>`,
        to: [recipient],
        subject: template.subject,
        body: template.message,
      });

      callback();
    } catch (err) {
      console.error('Email sending error:', err);
      callback(err);
    }
  });

  passwordless.init(mongoStore);
  server.use(passwordless.sessionSupport());

  server.use((req, __, next) => {
    if (req.user && typeof req.user === 'string') {
      User.findById(req.user, User.publicFields())
        .then((user) => {
          req.user = user;
          console.log('passwordless middleware');
          next();
        })
        .catch((err) => {
          next(err);
        });
    } else {
      next();
    }
  });

  server.post(
    '/auth/email-login-link',
    passwordless.requestToken(async (email, __, callback) => {
      try {
        const user = await User.findOne({ email }).select('_id').setOptions({ lean: true });

        if (user) {
          callback(null, user._id);
        } else {
          const id = await mongoStore.storeOrUpdateByEmail(email);
          callback(null, id);
        }
      } catch (error) {
        callback(error, null);
      }
    }),
    (req, res) => {
      if (req.query && req.query.invitationToken) {
        req.session.invitationToken = req.query.invitationToken;
      } else {
        req.session.invitationToken = null;
      }

      res.json({ done: 1 });
    },
  );

  server.get(
    '/auth/logged_in',
    passwordless.acceptToken(),
    (req, __, next) => {
      if (req.user && typeof req.user === 'string') {
        User.findById(req.user, User.publicFields())
          .then((user) => {
            req.user = user;
            next();
          })
          .catch((err) => {
            next(err);
          });
      } else {
        next();
      }
    },
    async (req, res) => {
      let teamSlugOfInvitedTeam;

      if (req.user && req.session.invitationToken) {
        teamSlugOfInvitedTeam = await Invitation.addUserToTeam({
          token: req.session.invitationToken,
          user: req.user,
        }).catch((err) => console.error(err));

        req.session.invitationToken = null;
      }

      let redirectUrlAfterLogin;
      const defaultTeamSlug = req.user && req.user.defaultTeamSlug;

      if (teamSlugOfInvitedTeam || defaultTeamSlug) {
        redirectUrlAfterLogin = `/your-settings`;
      } else {
        redirectUrlAfterLogin = `/create-team`;
      }

      res.redirect(
        `${dev ? process.env.URL_APP : process.env.PRODUCTION_URL_APP}${redirectUrlAfterLogin}`,
      );
    },
  );

  server.get('/logout', (req, res, next) => {
    req.logout((err) => {
      if (err) {
        next(err);
      }

      if (req.query && req.query.invitationToken) {
        res.redirect(
          `${dev ? process.env.URL_APP : process.env.PRODUCTION_URL_APP}/invitation?token=${
            req.query.invitationToken
          }`,
        );
      } else {
        res.redirect(`${dev ? process.env.URL_APP : process.env.PRODUCTION_URL_APP}/login`);
      }
    });
  });
}

export { setupPasswordless };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\server\passwordless-token-mongostore.ts -----

import * as bcrypt from 'bcryptjs';
import * as mongoose from 'mongoose';
import * as TokenStore from 'passwordless-tokenstore';
import * as util from 'util';

import User from './models/User';

interface TokenDocument extends mongoose.Document {
  hashedToken: string;
  uid: string;
  ttl: Date;
  originUrl: string;
  email: string;
}

const mongoSchema = new mongoose.Schema({
  hashedToken: {
    type: String,
    required: true,
  },
  uid: {
    type: String,
    required: true,
    unique: true,
  },
  ttl: {
    type: Date,
    required: true,
    expires: 0,
  },
  originUrl: String,
  email: String,
});

const PasswordlessToken = mongoose.model<TokenDocument>(
  'PasswordlessToken',
  mongoSchema,
  'passwordless-token',
);

function MongoStore(options = {}) {
  TokenStore.call(this);

  this._options = options || {};
}

util.inherits(MongoStore, TokenStore);

MongoStore.prototype.authenticate = async function (token, uid, callback) {
  if (!token || !uid || !callback) {
    throw new Error('TokenStore:authenticate called with invalid parameters');
  }

  try {
    const tokenDoc = await PasswordlessToken.findOne({ uid, ttl: { $gt: new Date() } }).setOptions({
      lean: true,
    });

    if (tokenDoc) {
      const isMatch = await bcrypt.compare(token, tokenDoc.hashedToken);
      if (isMatch) {
        if (tokenDoc.email) {
          await User.signInOrSignUpByPasswordless({ uid, email: tokenDoc.email });
        }

        callback(null, true, tokenDoc.originUrl);
      } else {
        callback(null, false, null);
      }
    } else {
      callback(null, false, null);
    }
  } catch (error) {
    callback(error, false, null);
  }
};

MongoStore.prototype.storeOrUpdate = async function (token, uid, msToLive, originUrl, callback) {
  if (!token || !uid || !msToLive || !callback) {
    throw new Error('TokenStore:storeOrUpdate called with invalid parameters');
  }

  const saltRounds = 10;

  try {
    const hashedToken = await bcrypt.hash(token, saltRounds);
    const newRecord = { hashedToken, uid, ttl: new Date(Date.now() + msToLive), originUrl };

    await PasswordlessToken.updateOne(
      { uid },
      { $set: newRecord },
      { upsert: true, runValidators: true },
    );
    callback();
  } catch (error) {
    callback(error);
  }
};

MongoStore.prototype.invalidateUser = async function (uid, callback) {
  if (!uid || !callback) {
    throw new Error('TokenStore:invalidateUser called with invalid parameters');
  }

  try {
    await PasswordlessToken.deleteOne({ uid });
    callback();
  } catch (error) {
    callback(error);
  }
};

MongoStore.prototype.clear = async function (callback) {
  if (!callback) {
    throw new Error('TokenStore:clear called with invalid parameters');
  }

  try {
    await PasswordlessToken.deleteMany({});
    callback();
  } catch (error) {
    callback(error);
  }
};

MongoStore.prototype.length = function (callback) {
  PasswordlessToken.countDocuments(callback);
};

MongoStore.prototype.storeOrUpdateByEmail = async function addEmail(email: string) {
  if (!email) {
    throw new Error('TokenStore:addEmail called with invalid parameters');
  }

  const obj = await PasswordlessToken.findOne({ email }).select('uid').setOptions({ lean: true });

  if (obj) {
    return obj.uid;
  }

  const uid = new mongoose.Types.ObjectId().toHexString();
  await PasswordlessToken.updateOne({ uid }, { email }, { upsert: true });

  return uid;
};

export default MongoStore;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\server\server.ts -----

import * as cors from 'cors';
import * as express from 'express';
import * as session from 'express-session';
import * as httpModule from 'http';
import * as mongoose from 'mongoose';

import mongoSessionStore = require('connect-mongo');

import api from './api';
import { setupGoogle } from './google-auth';
import { setupPasswordless } from './passwordless-auth';
import { setupSockets } from './sockets';
import { stripeWebhookAndCheckoutCallback } from './stripe';

import logger from './logger';

import * as compression from 'compression';
import helmet from 'helmet';

// eslint-disable-next-line
require('dotenv').config();

const dev = process.env.NODE_ENV !== 'production';
const port = process.env.PORT || 8000;
const MONGO_URL = dev ? process.env.MONGO_URL_TEST : process.env.MONGO_URL;

// check connection
(async () => {
  try {
    mongoose.set('strictQuery', false);
    await mongoose.connect(MONGO_URL);
    logger.info('connected to db');

    // async tasks, for ex, inserting email templates to db
    // logger.info('finished async tasks');
  } catch (err) {
    console.log('error: ' + err);
  }
})();

const server = express();

server.use(
  cors({
    origin: dev ? process.env.URL_APP : process.env.PRODUCTION_URL_APP,
    methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',
    credentials: true,
  }),
);

server.use(helmet());
server.use(compression());

stripeWebhookAndCheckoutCallback({ server });

server.use(express.json());

const sessionOptions = {
  name: process.env.SESSION_NAME,
  secret: process.env.SESSION_SECRET,
  store: mongoSessionStore.create({
    mongoUrl: MONGO_URL,
    ttl: 14 * 24 * 60 * 60, // save session 14 days
  }),
  resave: false,
  saveUninitialized: false,
  cookie: {
    httpOnly: true,
    maxAge: 14 * 24 * 60 * 60 * 1000, // expires in 14 days
    domain: dev ? 'localhost' : process.env.COOKIE_DOMAIN,
  } as any,
};

if (!dev) {
  server.set('trust proxy', 1); // sets req.hostname, req.ip
  sessionOptions.cookie.secure = true; // sets cookie over HTTPS only
}

const sessionMiddleware = session(sessionOptions);
server.use(sessionMiddleware);

setupGoogle({ server });
setupPasswordless({ server });

api(server);

const httpServer = httpModule.createServer(server);
setupSockets({
  httpServer,
  origin: dev ? process.env.URL_APP : process.env.PRODUCTION_URL_APP,
  sessionMiddleware,
});

server.get('*', (_, res) => {
  res.sendStatus(403);
});

httpServer.listen(port, () => {
  logger.debug('debug right before info');
  logger.info(`> Ready on ${dev ? process.env.URL_API : process.env.PRODUCTION_URL_API}`);
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\server\sockets.ts -----

import { Response } from 'express';
import * as express from 'express';
import { Server } from 'socket.io';
import * as httpModule from 'http';

import { DiscussionDocument } from './models/Discussion';
import { PostDocument } from './models/Post';

let io: Server = null;

const dev = process.env.NODE_ENV !== 'production';

function setupSockets({
  httpServer,
  origin,
  sessionMiddleware,
}: {
  httpServer: httpModule.Server;
  origin: string | boolean | RegExp | (string | RegExp)[];
  sessionMiddleware: express.RequestHandler;
}) {
  if (io === null) {
    io = new Server(httpServer, {
      cors: {
        origin,
        methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',
        credentials: true,
      },
      cookie: {
        name: 'saas-socket-cookie',
        httpOnly: true,
        maxAge: 14 * 24 * 60 * 60 * 1000, // expires in 14 days
        domain: dev ? 'localhost' : '.async-await.com',
        secure: dev ? false : true,
      },
      serveClient: false,
      transports: ['polling', 'websocket'],
    });

    const wrap = (middleware) => (socket, next) => middleware(socket.request, {} as Response, next);

    io.use(wrap(sessionMiddleware));

    io.on('connection', (socket: any) => {
      if (
        !socket.request.session ||
        ((!socket.request.session.passport || !socket.request.session.passport.user) &&
          !socket.request.session.passwordless)
      ) {
        socket.disconnect(true);
        return;
      }

      socket.on('joinTeamRoom', (teamId) => {
        console.log(`    joinTeamRoom ${teamId}`);
        socket.join(`teamRoom-${teamId}`);
      });

      socket.on('leaveTeamRoom', (teamId) => {
        console.log(`** leaveTeamRoom ${teamId}`);
        socket.leave(`teamRoom-${teamId}`);
      });

      socket.on('joinDiscussionRoom', (discussionId) => {
        console.log(`    joinDiscussionRoom ${discussionId}`);
        socket.join(`discussionRoom-${discussionId}`);
      });

      socket.on('leaveDiscussionRoom', (discussionId) => {
        console.log(`** leaveDiscussionRoom ${discussionId}`);
        socket.leave(`discussionRoom-${discussionId}`);
      });

      socket.on('disconnect', (reason) => {
        console.log(`disconnected`, `reason: ` + reason);
      });
    });
  }
}

function getSocket(socketId?: string) {
  if (!io) {
    return null;
  }

  if (socketId && io.sockets.sockets.get(socketId)) {
    return io.sockets.sockets.get(socketId).broadcast;
  } else {
    return io;
  }
}

function discussionAdded({
  socketId,
  discussion,
}: {
  socketId?: string;
  discussion: DiscussionDocument;
}) {
  const roomName = `teamRoom-${discussion.teamId}`;

  const socket = getSocket(socketId);
  if (socket) {
    socket.to(roomName).emit('discussionEvent', { actionType: 'added', discussion });
  }
}

function discussionEdited({
  socketId,
  discussion,
}: {
  socketId?: string;
  discussion: DiscussionDocument;
}) {
  const roomName = `teamRoom-${discussion.teamId}`;
  const socket = getSocket(socketId);

  if (socket) {
    socket.to(roomName).emit('discussionEvent', {
      actionType: 'edited',
      discussion,
    });
  }
}

function discussionDeleted({
  socketId,
  teamId,
  id,
}: {
  socketId?: string;
  teamId: string;
  id: string;
}) {
  const roomName = `teamRoom-${teamId}`;
  const socket = getSocket(socketId);

  if (socket) {
    socket.to(roomName).emit('discussionEvent', { actionType: 'deleted', id });
  }
}

function postAdded({ socketId, post }: { socketId?: string; post: PostDocument }) {
  const roomName = `discussionRoom-${post.discussionId}`;

  const socket = getSocket(socketId);
  if (socket) {
    socket.to(roomName).emit('postEvent', { actionType: 'added', post });
  }
}

function postEdited({ socketId, post }: { socketId?: string; post: PostDocument }) {
  const roomName = `discussionRoom-${post.discussionId}`;

  const socket = getSocket(socketId);
  if (socket) {
    socket.to(roomName).emit('postEvent', { actionType: 'edited', post });
  }
}

function postDeleted({
  socketId,
  id,
  discussionId,
}: {
  socketId?: string;
  id: string;
  discussionId: string;
}) {
  const roomName = `discussionRoom-${discussionId}`;

  const socket = getSocket(socketId);
  if (socket) {
    socket.to(roomName).emit('postEvent', { actionType: 'deleted', id });
  }
}

export {
  setupSockets,
  postAdded,
  postEdited,
  postDeleted,
  discussionAdded,
  discussionEdited,
  discussionDeleted,
};

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\server\stripe.ts -----

import * as dotenv from "dotenv";
import * as express from "express";
import Stripe from "stripe";

import Team from "./models/Team";
import User from "./models/User";

import logger from "./logger";

dotenv.config();

const dev = process.env.NODE_ENV !== "production";

const stripeInstance = new Stripe(dev ? process.env.STRIPE_TEST_SECRETKEY : process.env.STRIPE_LIVE_SECRETKEY, {
  apiVersion: "2025-02-24.acacia",
});

function createSession({
  userId,
  teamId,
  teamSlug,
  customerId,
  subscriptionId,
  userEmail,
  mode,
}: {
  userId: string;
  teamId: string;
  teamSlug: string;
  customerId: string;
  subscriptionId: string;
  userEmail: string;
  mode: Stripe.Checkout.SessionCreateParams.Mode;
}) {
  const params: Stripe.Checkout.SessionCreateParams = {
    customer_email: customerId ? undefined : userEmail,
    customer: customerId,
    payment_method_types: ["card"],
    mode,
    success_url: `${
      dev ? process.env.URL_API : process.env.PRODUCTION_URL_API
    }/stripe/checkout-completed/{CHECKOUT_SESSION_ID}`,
    cancel_url: `${
      dev ? process.env.URL_APP : process.env.PRODUCTION_URL_APP
    }/teams/${teamSlug}/billing?redirectMessage=Checkout%20canceled`,
    metadata: { userId, teamId },
  };

  console.log(process.env.STRIPE_TEST_SECRETKEY, process.env.STRIPE_TEST_PRICEID);

  if (mode === "subscription") {
    params.line_items = [
      {
        price: dev ? process.env.STRIPE_TEST_PRICEID : process.env.STRIPE_LIVE_PRICEID,
        quantity: 1,
      },
    ];
  } else if (mode === "setup") {
    if (!customerId || !subscriptionId) {
      throw new Error("customerId and subscriptionId required");
    }

    params.setup_intent_data = {
      metadata: { customer_id: customerId, subscription_id: subscriptionId },
    };
  }

  return stripeInstance.checkout.sessions.create(params);
}

function retrieveSession({ sessionId }: { sessionId: string }) {
  return stripeInstance.checkout.sessions.retrieve(sessionId, {
    expand: [
      "setup_intent",
      "setup_intent.payment_method",
      "customer",
      "subscription",
      "subscription.default_payment_method",
    ],
  });
}

function updateCustomer(customerId, params: Stripe.CustomerUpdateParams) {
  logger.debug("updating customer", customerId);
  return stripeInstance.customers.update(customerId, params);
}

function updateSubscription(subscriptionId: string, params: Stripe.SubscriptionUpdateParams) {
  logger.debug("updating subscription", subscriptionId);
  return stripeInstance.subscriptions.update(subscriptionId, params);
}

function cancelSubscription({ subscriptionId }: { subscriptionId: string }) {
  logger.debug("cancel subscription", subscriptionId);
  return stripeInstance.subscriptions.cancel(subscriptionId);
}

function getListOfInvoices({ customerId }: { customerId: string }) {
  logger.debug("getting list of invoices for customer", customerId);
  return stripeInstance.invoices.list({ customer: customerId, limit: 100 });
}

function stripeWebhookAndCheckoutCallback({ server }: { server: express.Application }) {
  server.post(
    "/api/v1/public/stripe-invoice-payment-failed",
    express.raw({ type: "application/json" }),
    async (req, res, next) => {
      try {
        const event = stripeInstance.webhooks.constructEvent(
          req.body,
          req.headers["stripe-signature"],
          dev ? process.env.STRIPE_TEST_ENDPOINTSECRET : process.env.STRIPE_LIVE_ENDPOINTSECRET
        );

        logger.debug(`${event.id}, ${event.type}`);

        // invoice.payment_failed
        // data.object is an invoice
        // Occurs whenever an invoice payment attempt fails, due either to a declined payment or to the lack of a stored payment method.

        if (event.type === "invoice.payment_failed") {
          const { subscription } = event.data.object;
          logger.debug(JSON.stringify(subscription));

          await Team.cancelSubscriptionAfterFailedPayment({
            subscriptionId: JSON.stringify(subscription),
          });
        }

        res.sendStatus(200);
      } catch (err) {
        console.error(`Webhook error: ${err.message}`);
        next(err);
      }
    }
  );

  server.get("/stripe/checkout-completed/:sessionId", async (req, res) => {
    const { sessionId } = req.params;

    const session = await retrieveSession({ sessionId });
    if (!session || !session.metadata || !session.metadata.userId || !session.metadata.teamId) {
      throw new Error("Wrong session.");
    }

    const user = await User.findById(
      session.metadata.userId,
      "_id stripeCustomer email displayName isSubscriptionActive stripeSubscription"
    ).setOptions({ lean: true });

    const team = await Team.findById(
      session.metadata.teamId,
      "isSubscriptionActive stripeSubscription teamLeaderId slug"
    ).setOptions({ lean: true });

    if (!user) {
      throw new Error("User not found.");
    }

    if (!team) {
      throw new Error("Team not found.");
    }

    if (team.teamLeaderId !== user._id.toString()) {
      throw new Error("Permission denied");
    }

    try {
      if (session.mode === "setup" && session.setup_intent) {
        const si: Stripe.SetupIntent = session.setup_intent as Stripe.SetupIntent;
        const pm: Stripe.PaymentMethod = si.payment_method as Stripe.PaymentMethod;

        if (user.stripeCustomer) {
          await updateCustomer(user.stripeCustomer.id, {
            invoice_settings: { default_payment_method: pm.id },
          });
        }

        if (team.stripeSubscription) {
          await updateSubscription(team.stripeSubscription.id, { default_payment_method: pm.id });
        }

        await User.changeStripeCard({ session, user });
      } else if (session.mode === "subscription") {
        await User.saveStripeCustomerAndCard({ session, user });
        await Team.subscribeTeam({ session, team });
        await User.getListOfInvoicesForCustomer({ userId: user._id.toString() });
      } else {
        throw new Error("Wrong session.");
      }

      res.redirect(`${dev ? process.env.URL_APP : process.env.PRODUCTION_URL_APP}/teams/${team.slug}/billing`);
    } catch (err) {
      console.error(err);

      res.redirect(
        `${dev ? process.env.URL_APP : process.env.PRODUCTION_URL_APP}/teams/${
          team.slug
        }/billing?redirectMessage=${err.message || err.toString()}`
      );
    }
  });
}

export { createSession, cancelSubscription, getListOfInvoices, stripeWebhookAndCheckoutCallback };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\test\server\utils\slugify.test.ts -----

import * as mongoose from 'mongoose';
import User from '../../../server/models/User';
import { generateSlug } from '../../../server/utils/slugify';

// eslint-disable-next-line
require('dotenv').config();

describe('slugify', () => {
  beforeAll(async (done) => {
    await mongoose.connect(process.env.MONGO_URL_TEST);

    const mockUsers = [
      {
        slug: 'john',
        email: 'john@example.com',
        createdAt: new Date(),
        displayName: 'abc',
        avatarUrl: 'def',
      },
      {
        slug: 'john-johnson',
        email: 'john-johnson@example.com',
        createdAt: new Date(),
        displayName: 'abc',
        avatarUrl: 'def',
      },
      {
        slug: 'john-johnson-1',
        email: 'john-johnson-1@example.com',
        createdAt: new Date(),
        displayName: 'abc',
        avatarUrl: 'def',
      },
    ];

    await User.insertMany(mockUsers);

    done();
  });

  test('not duplicated', async () => {
    expect.assertions(1);

    await expect(generateSlug(User, 'John J Johnson@#$')).resolves.toEqual('john-j-johnson');
  });

  test('one time duplicated', async () => {
    expect.assertions(1);

    await expect(generateSlug(User, ' John@#$')).resolves.toEqual('john-1');
  });

  test('multiple duplicated', async () => {
    expect.assertions(1);

    await expect(generateSlug(User, 'John & Johnson@#$')).resolves.toEqual('john-johnson-2');
  });

  afterAll(async (done) => {
    await User.deleteMany({ slug: { $in: ['john', 'john-johnson', 'john-johnson-1'] } });
    await mongoose.disconnect();

    done();
  });
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\test\server\utils\sum.test.ts -----

import { sum } from '../../../server/utils/sum';

console.log(sum(1, 2));

describe.skip('testing sum function', () => {
  test('adds 1 + 2 to equal 3', () => {
    expect(sum(1, 2)).toBe(3);
  });
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\.eslintrc.js -----

module.exports = {
  parser: "@typescript-eslint/parser",
  extends: ["plugin:@typescript-eslint/recommended", "prettier"],
  env: {
    "es6": true,
    "node": true,
  },
  plugins: ["prettier"],
  rules: {
    'prettier/prettier': [
      'error',
      {
        singleQuote: true,
        trailingComma: 'all',
        arrowParens: 'always',
        printWidth: 100,
        semi: true,
      },
    ],
    '@typescript-eslint/no-unused-vars': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/no-explicit-any': 'off',
    'prefer-arrow-callback': 'error',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
 },
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\nodemon.json -----

{
  "watch": ["server"],
  "exec": "ts-node --project tsconfig.json",
  "ext": "ts"
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\package.json -----

{
  "name": "api-same-as-10-end-api",
  "version": "1.0.0",
  "license": "MIT",
  "engines": {
    "node": ">=18.17.0",
    "yarn": ">=1.22.19"
  },
  "scripts": {
    "dev": "nodemon server/server.ts",
    "lint": "eslint . --ext .ts,.tsx",
    "test": "jest",
    "postinstall": "rm -rf production-server/",
    "build": "tsc --project tsconfig.json",
    "start": "node production-server/server.js"
  },
  "jest": {
    "preset": "ts-jest",
    "testPathIgnorePatterns": [
      "production-server"
    ],
    "testEnvironment": "node"
  },
  "dependencies": {
    "aws-sdk": "^2.1692.0",
    "bcryptjs": "^3.0.2",
    "compression": "^1.8.0",
    "connect-mongo": "^5.1.0",
    "cors": "^2.8.5",
    "dotenv": "^16.4.7",
    "express": "^4.21.2",
    "express-session": "^1.18.1",
    "he": "^1.2.0",
    "helmet": "8.1.0",
    "highlight.js": "^11.11.1",
    "lodash": "^4.17.21",
    "marked": "^15.0.7",
    "mongoose": "^8.12.1",
    "node-fetch": "2",
    "passport": "^0.7.0",
    "passport-google-oauth": "^2.0.0",
    "passwordless": "^1.1.3",
    "passwordless-tokenstore": "^0.0.10",
    "socket.io": "^4.8.1",
    "stripe": "^17.7.0",
    "typescript": "^5.8.2",
    "winston": "^3.17.0"
  },
  "devDependencies": {
    "@types/connect-mongo": "^3.1.6",
    "@types/dotenv": "^8.2.3",
    "@types/express": "^5.0.1",
    "@types/express-session": "^1.18.1",
    "@types/jest": "^29.5.14",
    "@types/lodash": "^4.17.16",
    "@types/mongoose": "^5.11.97",
    "@types/node": "^22.13.11",
    "@types/node-fetch": "^2.6.12",
    "@types/passport": "^1.0.17",
    "@types/socket.io": "^3.0.2",
    "@typescript-eslint/eslint-plugin": "^8.27.0",
    "@typescript-eslint/parser": "^8.27.0",
    "eslint": "^9.22.0",
    "eslint-config-prettier": "^10.1.1",
    "eslint-plugin-prettier": "^5.2.3",
    "jest": "^29.7.0",
    "nodemon": "^3.1.9",
    "prettier": "^3.5.3",
    "ts-jest": "^29.2.6",
    "ts-node": "^10.9.2"
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\api\tsconfig.json -----

{
  "compileOnSave": false,
  "compilerOptions": {
    "jsx": "preserve",
    "allowJs": true,
    "alwaysStrict": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "removeComments": false,
    "preserveConstEnums": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "sourceMap": true,
    "skipLibCheck": true,
    "baseUrl": ".",
    "experimentalDecorators": true,
    "typeRoots": ["./node_modules/@types"],
    "target": "es2020",
    "lib": ["es2020"],
    "module": "commonjs",
    "outDir": "production-server/",
    "downlevelIteration": true,
  },
  "include": ["./server/**/*.ts"]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\components\common\Confirmer.tsx -----

import Button from '@mui/material/Button';
import Dialog from '@mui/material/Dialog';
import DialogActions from '@mui/material/DialogActions';
import DialogContent from '@mui/material/DialogContent';
import DialogContentText from '@mui/material/DialogContentText';
import DialogTitle from '@mui/material/DialogTitle';
import React from 'react';

export let openConfirmDialogExternal;

type State = {
  open: boolean;
  title: string;
  message: string;
  onAnswer: (answer) => void;
};

class Confirmer extends React.Component<any, State> {
  constructor(props) {
    super(props);

    this.state = {
      open: false,
      title: 'Are you sure?',
      message: '',
      onAnswer: null,
    };

    openConfirmDialogExternal = this.openConfirmDialog;
  }

  public render() {
    return (
      <Dialog
        open={this.state.open}
        onClose={this.handleClose}
        aria-labelledby="alert-dialog-title"
        aria-describedby="alert-dialog-description"
      >
        <DialogTitle id="alert-dialog-title">{this.state.title}</DialogTitle>
        <DialogContent>
          <DialogContentText id="alert-dialog-description">{this.state.message}</DialogContentText>
        </DialogContent>
        <DialogActions style={{ padding: '10px' }}>
          <Button onClick={this.handleClose} variant="contained" color="primary" autoFocus>
            Cancel
          </Button>
          <Button onClick={this.handleYes} variant="contained" color="secondary">
            OK
          </Button>
        </DialogActions>
      </Dialog>
    );
  }

  public handleClose = () => {
    this.setState({ open: false });
    this.state.onAnswer(false);
  };

  public handleYes = () => {
    this.setState({ open: false });
    this.state.onAnswer(true);
  };

  public openConfirmDialog = ({ title, message, onAnswer }) => {
    this.setState({ open: true, title, message, onAnswer });
  };
}

export default Confirmer;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\components\common\LoginButton.tsx -----

import Button from '@mui/material/Button';
import TextField from '@mui/material/TextField';
import React from 'react';

import { emailLoginLinkApiMethod } from '../../lib/api/public';
import notify from '../../lib/notify';
import { makeQueryString } from '../../lib/api/makeQueryString';

const dev = process.env.NODE_ENV !== 'production';

type Props = { invitationToken?: string };
type State = { email: string };

class LoginButton extends React.PureComponent<Props, State> {
  constructor(props) {
    super(props);

    this.state = { email: '' };
  }

  public render() {
    const { invitationToken } = this.props;

    let url = `${
      dev ? process.env.NEXT_PUBLIC_URL_API : process.env.NEXT_PUBLIC_PRODUCTION_URL_API
    }/auth/google`;
    const qs = makeQueryString({ invitationToken });

    if (qs) {
      url += `?${qs}`;
    }

    // console.log(url);

    return (
      <React.Fragment>
        <Button variant="contained" color="secondary" href={url}>
          <img
            src="https://storage.googleapis.com/async-await-all/G.svg"
            alt="Log in with Google"
          />
          &nbsp;&nbsp;&nbsp; Log in with Google
        </Button>
        <p />
        <br />
        <hr style={{ width: '60px' }} /> <h4>OR</h4> <hr style={{ width: '60px' }} />
        <p />
        <br />
        <div>
          <form autoComplete="off" onSubmit={this.onSubmit}>
            <TextField
              required
              type="email"
              label="Email address"
              value={this.state.email}
              onChange={(event) => {
                this.setState({ email: event.target.value });
              }}
              style={{ width: '300px' }}
            />
            <p />
            <Button variant="contained" color="primary" type="submit">
              Log in with email
            </Button>
          </form>
          <p />
          <br />
        </div>
      </React.Fragment>
    );
  }

  private onSubmit = async (event) => {
    event.preventDefault();
    const { email } = this.state;
    const { invitationToken } = this.props;

    if (!email) {
      notify('Email is required');
      return;
    }

    try {
      await emailLoginLinkApiMethod({ email, invitationToken });
      this.setState({ email: '' });
      notify('SaaS boilerplate emailed you a login link.');
    } catch (error) {
      notify(error);
    }
  };
}

export default LoginButton;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\components\common\MemberChooser.tsx -----

import React from 'react';

import Autocomplete from '@mui/material/Autocomplete';
import TextField from '@mui/material/TextField';

import { User } from '../../lib/store/user';

type Props = {
  onChange: (item) => void;
  selectedMemberIds?: string[];
  members: User[];
  label?: string;
  helperText?: string;
};

type State = {
  selectedItems: { label: string; id: string }[];
};

class MemberChooser extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    const suggestions = this.props.members.map((user) => ({
      label: user.displayName || user.email,
      id: user._id,
    }));

    const selectedItems = suggestions.filter(
      (s) => this.props.selectedMemberIds.indexOf(s.id) !== -1,
    );

    this.state = {
      selectedItems: selectedItems || [],
    };
  }

  public render() {
    const suggestions = this.props.members.map((user) => ({
      label: user.displayName || user.email,
      id: user._id,
    }));

    return (
      <Autocomplete
        multiple
        id="tags-standard"
        options={suggestions}
        getOptionLabel={(option) => option.label}
        isOptionEqualToValue={(option, value) => option.id === value.id}
        value={this.state.selectedItems}
        renderInput={(params) => (
          <TextField
            {...params}
            variant="standard"
            label="Find team member by name"
            placeholder="Select participants"
          />
        )}
        onChange={this.handleChange}
        filterSelectedOptions={true}
        noOptionsText="No team members to select from"
      />
    );
  }

  public handleChange = (event, value) => {
    event.preventDefault();

    const selectedItems = value;

    this.setState({ selectedItems });

    this.props.onChange(selectedItems.map((i) => i.id));
  };
}

export default MemberChooser;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\components\common\MenuWithLinks.tsx -----

import Menu from '@mui/material/Menu';
import MenuItem from '@mui/material/MenuItem';
import Router, { NextRouter, withRouter } from 'next/router';
import React from 'react';

type Props = {
  options: {
    href: string;
    as: string;
    highlighterSlug: string;
    text: string;
    externalServer: boolean;
    separator: boolean;
  }[];
  router: NextRouter;
  children: any;
};

type State = {
  anchorEl: Element | ((element: Element) => Element);
};

class MenuWithLinks extends React.PureComponent<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      anchorEl: null,
    };
  }

  public render() {
    const { options, children, router } = this.props;
    const { anchorEl } = this.state;

    return (
      <div style={{ textAlign: 'center' }}>
        <div
          aria-controls={anchorEl ? 'simple-menu' : null}
          aria-haspopup="true"
          onClick={this.handleClick}
          onKeyPress={this.handleClick}
        >
          {children}
        </div>
        <Menu
          id="simple-menu"
          anchorEl={anchorEl}
          open={Boolean(anchorEl)}
          onClose={this.handleClose}
          keepMounted
        >
          {options.map((option, i) =>
            option.separator ? (
              <hr style={{ width: '95%', margin: '10px auto' }} key={`separated-${i}`} />
            ) : option.externalServer ? (
              <MenuItem
                onClick={(event) => {
                  event.preventDefault();
                  window.location.href = option.href;
                  this.handleClose();
                }}
                key={option.href || option.text}
              >
                {option.text}
              </MenuItem>
            ) : (
              <MenuItem
                key={option.href}
                style={{
                  fontWeight: router.asPath.includes(option.highlighterSlug) ? 600 : 300,
                  fontSize: '14px',
                }}
                onClick={() => Router.push(option.href, option.as)}
              >
                {option.text}
              </MenuItem>
            ),
          )}
        </Menu>
      </div>
    );
  }

  public handleClick = (event) => {
    this.setState({ anchorEl: event.currentTarget });
  };

  public handleClose = () => {
    this.setState({ anchorEl: null });
  };
}

export default withRouter(MenuWithLinks);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\components\common\MenuWithMenuItems.tsx -----

import Menu from '@mui/material/Menu';
import MenuItem from '@mui/material/MenuItem';
import MoreVertIcon from '@mui/icons-material/MoreVert';
import React from 'react';

type Props = {
  menuOptions: any;
  itemOptions: any[];
};

type State = {
  menuElem: Element | ((element: Element) => Element);
};

class MenuWithMenuItems extends React.PureComponent<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      menuElem: null,
    };
  }

  public render() {
    const { menuOptions, itemOptions } = this.props;
    const { menuElem } = this.state;

    return (
      <div style={{ verticalAlign: 'middle' }}>
        <MoreVertIcon
          aria-controls={menuElem ? menuOptions.id : null}
          data-id={menuOptions.dataId}
          aria-haspopup="true"
          style={{ fontSize: '14px', opacity: 0.7, cursor: 'pointer' }}
          onClick={(e) => this.handleClick(e)}
        />

        <Menu
          id={menuOptions.id}
          anchorEl={menuElem}
          open={Boolean(menuElem)}
          onClose={this.handleClose}
        >
          {itemOptions.map((option, i) => (
            <MenuItem
              key={option.dataId + i}
              data-id={option.dataId}
              data-more-id={option.dataMoreId}
              onClick={(e) => {
                this.setState({ menuElem: null });
                option.onClick(e);
              }}
            >
              {option.text}
            </MenuItem>
          ))}
        </Menu>
      </div>
    );
  }

  public handleClick = (event) => {
    event.preventDefault();
    this.setState({ menuElem: event.currentTarget });
  };

  public handleClose = () => {
    this.setState({ menuElem: null });
  };
}

export default MenuWithMenuItems;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\components\common\Notifier.tsx -----

import Snackbar from '@mui/material/Snackbar';
import React from 'react';

export let openSnackbarExternal;

type State = {
  open: boolean;
  message: string;
};

class Notifier extends React.PureComponent<any, State> {
  constructor(props) {
    super(props);
    openSnackbarExternal = this.openSnackbar;

    this.state = {
      open: false,
      message: '',
    };
  }

  public render() {
    const message = (
      <span id="snackbar-message-id" dangerouslySetInnerHTML={{ __html: this.state.message }} />
    );

    return (
      <Snackbar
        anchorOrigin={{ vertical: 'top', horizontal: 'right' }}
        message={message}
        autoHideDuration={5000}
        onClose={this.handleSnackbarClose}
        open={this.state.open}
        ContentProps={{
          'aria-describedby': 'snackbar-message-id',
        }}
      />
    );
  }

  public handleSnackbarClose = () => {
    this.setState({
      open: false,
      message: '',
    });
  };

  public openSnackbar = ({ message }) => {
    this.setState({ open: true, message });
  };
}

export default Notifier;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\components\discussions\CreateDiscussionForm.tsx -----

import Button from '@mui/material/Button';
import Dialog from '@mui/material/Dialog';
import DialogContent from '@mui/material/DialogContent';
import DialogTitle from '@mui/material/DialogTitle';
import FormControl from '@mui/material/FormControl';
import FormHelperText from '@mui/material/FormHelperText';
import Select from '@mui/material/Select';
import MenuItem from '@mui/material/MenuItem';
import TextField from '@mui/material/TextField';
import { observer } from 'mobx-react';
import Head from 'next/head';
import Router from 'next/router';
import NProgress from 'nprogress';
import React from 'react';

import notify from '../../lib/notify';
import { Store } from '../../lib/store';
import MemberChooser from '../common/MemberChooser';
import PostEditor from '../posts/PostEditor';

type Props = {
  isMobile: boolean;
  store: Store;
  open: boolean;
  onClose: () => void;
};

type State = {
  name: string;
  memberIds: string[];
  disabled: boolean;
  content: string;
  notificationType: string;
};

class CreateDiscussionForm extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      name: '',
      memberIds: [],
      disabled: false,
      content: '',
      notificationType: 'default',
    };
  }
  public render() {
    const { open, isMobile, store } = this.props;
    const { currentTeam, currentUser } = store;

    const membersMinusCreator = Array.from(currentTeam.members.values()).filter(
      (user) => user._id !== currentUser._id,
    );

    return (
      <React.Fragment>
        {open ? (
          <Head>
            <title>New Discussion</title>
            <meta name="description" content="Create new discussion" />
          </Head>
        ) : null}
        <Dialog
          onClose={this.handleClose}
          aria-labelledby="simple-dialog-title"
          open={open}
          fullScreen={true}
        >
          <DialogTitle id="simple-dialog-title">Create new Discussion</DialogTitle>
          <DialogContent>
            <br />
            <form style={{ width: '100%', height: '60%' }} onSubmit={this.onSubmit}>
              <p />
              <br />
              <TextField
                autoFocus
                label="Type name of Discussion"
                helperText="Give a short and informative name to new Discussion"
                value={this.state.name}
                onChange={(event) => {
                  this.setState({ name: event.target.value });
                }}
              />
              <br />
              <p />
              <MemberChooser
                helperText="These members will see all posts and be notified about unread posts in this discussion."
                onChange={this.handleMembersChange}
                members={membersMinusCreator}
                selectedMemberIds={this.state.memberIds}
              />
              <p />
              <br />
              <FormControl>
                <Select
                  value={this.state.notificationType}
                  onChange={(event) => {
                    event.stopPropagation();
                    this.setState({ notificationType: event.target.value });
                  }}
                  required
                >
                  <MenuItem value="default">Default: without email notification.</MenuItem>
                  <MenuItem value="email">Email: with email notification.</MenuItem>
                </Select>
                <FormHelperText>
                  Choose how to notify members about new Posts inside Discussion.
                </FormHelperText>
              </FormControl>
              <p />
              <br />
              <div>
                <Button
                  type="submit"
                  variant="contained"
                  color="primary"
                  disabled={this.state.disabled}
                >
                  Create Discussion
                </Button>
                {isMobile ? <p /> : null}
                <Button
                  variant="outlined"
                  onClick={this.handleClose}
                  disabled={this.state.disabled}
                  style={{ marginLeft: isMobile ? '0px' : '20px' }}
                >
                  Cancel
                </Button>{' '}
              </div>
              <p />
              <PostEditor
                content={this.state.content}
                onChanged={this.onContentChanged}
                members={Array.from(store.currentTeam.members.values())}
                store={store}
                parentComponent="CDF"
              />
              <p />
              <div>
                <Button
                  type="submit"
                  variant="contained"
                  color="primary"
                  disabled={this.state.disabled}
                >
                  Create Discussion
                </Button>
                {isMobile ? <p /> : null}
                <Button
                  variant="outlined"
                  onClick={this.handleClose}
                  disabled={this.state.disabled}
                  style={{ marginLeft: isMobile ? '0px' : '20px' }}
                >
                  Cancel
                </Button>{' '}
                <p />
                <br />
                <br />
              </div>
            </form>
          </DialogContent>
        </Dialog>
      </React.Fragment>
    );
  }

  public handleMembersChange = (memberIds) => {
    this.setState({ memberIds });
  };

  public handleClose = () => {
    this.setState({
      name: '',
      memberIds: [],
      disabled: false,
      content: '',
      notificationType: 'default',
    });
    this.props.onClose();
  };

  private onContentChanged = (content: string) => {
    console.log('onContentChanged', content);
    this.setState({ content });
  };

  private onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();

    const { store } = this.props;
    const { currentTeam } = store;

    if (!currentTeam) {
      notify('Team have not selected');
      return;
    }

    const { name, memberIds, content, notificationType } = this.state;

    if (!name) {
      notify('Name is required');
      return;
    }

    if (!content) {
      notify('Content is required');
      return;
    }

    // if (!memberIds || memberIds.length < 1) {
    //   notify('Please assign at least one person to this Discussion.');
    //   return;
    // }

    if (!notificationType) {
      notify('Please select notification type.');
      return;
    }

    this.setState({ disabled: true });
    NProgress.start();

    // console.log(notificationType);

    try {
      const discussion = await currentTeam.addDiscussion({
        name,
        memberIds,
        notificationType,
      });

      const post = await discussion.addPost(content);

      const dev = process.env.NODE_ENV !== 'production';

      if (discussion.notificationType === 'email') {
        const userIdsForLambda = discussion.memberIds.filter((m) => m !== discussion.createdUserId);

        await discussion.sendDataToLambda({
          discussionName: discussion.name,
          discussionLink: `${
            dev ? process.env.NEXT_PUBLIC_URL_APP : process.env.NEXT_PUBLIC_PRODUCTION_URL_APP
          }/teams/${discussion.team.slug}/discussions/${discussion.slug}`,
          postContent: post.content,
          authorName: post.user.displayName,
          userIds: userIdsForLambda,
        });
      }

      this.setState({ name: '', memberIds: [], content: '', notificationType: 'default' });

      notify('You successfully added new Discussion.');

      Router.push(
        `/discussion?teamSlug=${currentTeam.slug}&discussionSlug=${discussion.slug}`,
        `/teams/${currentTeam.slug}/discussions/${discussion.slug}`,
      );
    } catch (error) {
      console.log(error);
      notify(error);
    } finally {
      this.setState({ disabled: false });
      NProgress.done();
      this.props.onClose();
    }
  };
}

export default observer(CreateDiscussionForm);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\components\discussions\DiscussionActionMenu.tsx -----

import { observer } from 'mobx-react';
import NProgress from 'nprogress';
import React from 'react';

import confirm from '../../lib/confirm';
import notify from '../../lib/notify';
import { Store } from '../../lib/store';
import { Discussion } from '../../lib/store/discussion';

import MenuWithMenuItems from '../common/MenuWithMenuItems';
import EditDiscussionForm from './EditDiscussionForm';

const dev = process.env.NODE_ENV !== 'production';

const getMenuOptions = (discussion) => ({
  dataId: discussion._id,
  id: `discussion-menu-${discussion._id}`,
});

const getMenuItemOptionsForCreator = (discussion, component) => [
  {
    text: 'Copy URL',
    dataId: discussion._id,
    onClick: component.handleCopyUrl,
  },
  {
    text: 'Edit',
    dataId: discussion._id,
    onClick: component.editDiscussion,
  },
  {
    text: 'Delete',
    dataId: discussion._id,
    onClick: component.deleteDiscussion,
  },
];

const getMenuItemOptions = (discussion, component) => [
  {
    text: 'Copy URL',
    dataId: discussion._id,
    onClick: component.handleCopyUrl,
  },
];

type Props = {
  discussion: Discussion;
  store: Store;
  isMobile: boolean;
};

type State = {
  discussionFormOpen: boolean;
  selectedDiscussion: Discussion;
};

class DiscussionActionMenu extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      discussionFormOpen: false,
      selectedDiscussion: null,
    };
  }

  public render() {
    const { discussion, store } = this.props;
    const { currentUser } = store;

    const isCreator = currentUser._id === discussion.createdUserId ? true : false;

    return (
      <React.Fragment>
        <MenuWithMenuItems
          menuOptions={getMenuOptions(discussion)}
          itemOptions={
            isCreator
              ? getMenuItemOptionsForCreator(discussion, this)
              : getMenuItemOptions(discussion, this)
          }
        />

        {this.state.discussionFormOpen ? (
          <EditDiscussionForm
            open={true}
            onClose={this.handleDiscussionFormClose}
            discussion={discussion}
            isMobile={this.props.isMobile}
            store={store}
          />
        ) : null}
      </React.Fragment>
    );
  }

  public handleCopyUrl = async (event) => {
    const { store } = this.props;
    const { currentTeam } = store;

    const id = event.currentTarget.dataset.id;
    if (!id) {
      return;
    }

    const selectedDiscussion = currentTeam.discussions.find((d) => d._id === id);

    const discussionUrl = `${
      dev ? process.env.NEXT_PUBLIC_URL_APP : process.env.NEXT_PUBLIC_PRODUCTION_URL_APP
    }/teams/${currentTeam.slug}/discussions/${selectedDiscussion.slug}`;

    try {
      if (window.navigator) {
        await window.navigator.clipboard.writeText(discussionUrl);
        notify('You successfully copied URL.');
      }
    } catch (err) {
      notify(err);
    } finally {
      this.setState({ discussionFormOpen: false, selectedDiscussion: null });
    }
  };

  public editDiscussion = (event) => {
    const { currentTeam } = this.props.store;
    if (!currentTeam) {
      notify('You have not selected Team.');
      return;
    }

    const id = event.currentTarget.dataset.id;
    if (!id) {
      return;
    }

    const selectedDiscussion = currentTeam.discussions.find((d) => d._id === id);

    this.setState({ discussionFormOpen: true, selectedDiscussion });
  };

  public deleteDiscussion = async (event) => {
    const { currentTeam } = this.props.store;
    if (!currentTeam) {
      notify('You have not selected Team.');
      return;
    }

    const id = event.currentTarget.dataset.id;

    confirm({
      title: 'Are you sure?',
      message: '',
      onAnswer: async (answer) => {
        if (!answer) {
          return;
        }

        NProgress.start();

        try {
          await currentTeam.deleteDiscussion(id);

          notify('You successfully deleted Discussion.');
        } catch (error) {
          console.error(error);
          notify(error);
        } finally {
          NProgress.done();
        }
      },
    });
  };

  public handleDiscussionFormClose = () => {
    this.setState({ discussionFormOpen: false, selectedDiscussion: null });
  };
}

export default observer(DiscussionActionMenu);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\components\discussions\DiscussionList.tsx -----

import Tooltip from '@mui/material/Tooltip';
import AddCircleOutlineIcon from '@mui/icons-material/AddCircleOutline';
import { observer } from 'mobx-react';
import React from 'react';

import { Store } from '../../lib/store';
import { Team } from '../../lib/store/team';

import CreateDiscussionForm from './CreateDiscussionForm';
import DiscussionListItem from './DiscussionListItem';

import notify from '../../lib/notify';

type Props = { store: Store; team: Team; isMobile: boolean };

type State = { discussionFormOpen: boolean };

class DiscussionList extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      discussionFormOpen: false,
    };
  }

  public componentDidMount() {
    this.props.team.loadDiscussions().catch((err) => notify(err));
  }

  public componentDidUpdate(prevProps: Props) {
    if (this.props.team._id !== prevProps.team._id) {
      this.props.team.loadDiscussions().catch((err) => notify(err));
    }
  }

  public render() {
    const { store, team } = this.props;

    const isThemeDark = store && store.currentUser && store.currentUser.darkTheme === true;

    return (
      <div>
        Discussions
        <Tooltip title="Add Discussion" placement="right" disableFocusListener disableTouchListener>
          <a onClick={this.addDiscussion} style={{ float: 'right', padding: '0px 10px' }}>
            <AddCircleOutlineIcon
              color="action"
              style={{ fontSize: 14, opacity: 0.7, color: isThemeDark ? '#fff' : '#000' }}
            />{' '}
          </a>
        </Tooltip>
        <p />
        <ul style={{ listStyle: 'none', padding: '0px' }}>
          {team &&
            team.orderedDiscussions.map((d) => {
              return (
                <DiscussionListItem
                  key={d._id}
                  discussion={d}
                  team={team}
                  isMobile={this.props.isMobile}
                  store={this.props.store}
                />
              );
            })}
        </ul>
        <CreateDiscussionForm
          isMobile={this.props.isMobile}
          store={this.props.store}
          open={this.state.discussionFormOpen}
          onClose={this.handleDiscussionFormClose}
        />
      </div>
    );
  }

  public addDiscussion = (event) => {
    event.preventDefault();
    this.setState({ discussionFormOpen: true });
  };

  public handleDiscussionFormClose = () => {
    this.setState({ discussionFormOpen: false });
  };
}

export default observer(DiscussionList);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\components\discussions\DiscussionListItem.tsx -----

import Paper from '@mui/material/Paper';
import { observer } from 'mobx-react';
import Link from 'next/link';
import React from 'react';

import { Store } from '../../lib/store';
import { Discussion } from '../../lib/store/discussion';
import { Team } from '../../lib/store/team';

import DiscussionActionMenu from './DiscussionActionMenu';

type Props = {
  store: Store;
  discussion: Discussion;
  team: Team;
  isMobile: boolean;
};

class DiscussionListItem extends React.Component<Props> {
  public render() {
    const { store, discussion, team, isMobile } = this.props;
    const trimmingLength = 16;

    const selectedDiscussion =
      store.currentUrl === `/teams/${team.slug}/discussions/${discussion.slug}`;

    // console.log(store.currentUrl);

    const isThemeDark = store && store.currentUser && store.currentUser.darkTheme === true;

    const selectedItemBorder = isThemeDark
      ? '1px rgba(255, 255, 255, 0.75) solid'
      : '1px rgba(0, 0, 0, 0.75) solid';

    return (
      <Paper
        key={discussion._id}
        style={{
          margin: '10px 10px 5px 0px',
          padding: '8px',
          border: selectedDiscussion ? selectedItemBorder : 'none',
        }}
        elevation={selectedDiscussion ? 24 : 1}
      >
        <li key={discussion._id} style={{ whiteSpace: 'nowrap', paddingRight: '10px' }}>
          <Link
            scroll={false}
            href={`/discussion?teamSlug=${team.slug}&discussionSlug=${discussion.slug}`}
            as={`/teams/${team.slug}/discussions/${discussion.slug}`}
            style={{ fontWeight: 300, color: isThemeDark ? '#fff' : '#000' }}
            key={discussion._id}
          >
            {discussion.name.length > trimmingLength
              ? `${discussion.name.substring(0, trimmingLength)}...`
              : discussion.name}
          </Link>
          <div
            style={{
              float: 'right',
              marginRight: '-12px',
            }}
          >
            <DiscussionActionMenu discussion={discussion} isMobile={isMobile} store={store} />
          </div>
        </li>
      </Paper>
    );
  }
}

export default observer(DiscussionListItem);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\components\discussions\EditDiscussionForm.tsx -----

import Button from '@mui/material/Button';
import Dialog from '@mui/material/Dialog';
import DialogActions from '@mui/material/DialogActions';
import DialogContent from '@mui/material/DialogContent';
import DialogContentText from '@mui/material/DialogContentText';
import DialogTitle from '@mui/material/DialogTitle';
import FormControl from '@mui/material/FormControl';
import FormHelperText from '@mui/material/FormHelperText';
import Select from '@mui/material/Select';
import MenuItem from '@mui/material/MenuItem';
import TextField from '@mui/material/TextField';
import { observer } from 'mobx-react';
import NProgress from 'nprogress';
import React from 'react';

import notify from '../../lib/notify';
import { Store } from '../../lib/store';
import { Discussion } from '../../lib/store/discussion';
import MemberChooser from '../common/MemberChooser';

type Props = {
  store: Store;
  onClose: () => void;
  open: boolean;
  discussion: Discussion;
  isMobile: boolean;
};

type State = {
  name: string;
  memberIds: string[];
  disabled: boolean;
  discussionId: string;
  notificationType: string;
};

class EditDiscussionForm extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      name: '',
      memberIds: [],
      disabled: false,
      discussionId: '',
      notificationType: 'default',
    };
  }

  public static getDerivedStateFromProps(props: Props, state: State) {
    const { discussion } = props;

    if (state.discussionId === discussion._id) {
      return null;
    }

    return {
      name: (discussion && discussion.name) || '',
      memberIds: (discussion && discussion.memberIds) || [],
      discussionId: discussion._id,
      notificationType: discussion.notificationType || 'default',
    };
  }

  public render() {
    const { open, store } = this.props;
    const { currentTeam, currentUser } = store;

    const membersMinusCreator = Array.from(currentTeam.members.values()).filter(
      (user) => user._id !== currentUser._id,
    );

    // console.log(currentTeam.members);

    return (
      <Dialog onClose={this.handleClose} aria-labelledby="simple-dialog-title" open={open}>
        <DialogTitle id="simple-dialog-title">Edit Discussion</DialogTitle>
        <DialogContent>
          <DialogContentText>Edit discussion</DialogContentText>
          <br />
          <form onSubmit={this.onSubmit}>
            <TextField
              label="Type name of Discussion"
              helperText="Give a short and informative name to Discussion"
              value={this.state.name}
              onChange={(event) => {
                this.setState({ name: event.target.value });
              }}
            />
            <br />
            <p />
            <MemberChooser
              helperText="These members will see all posts and be notified about unread posts in this discussion."
              onChange={this.handleMembersChange}
              members={membersMinusCreator}
              selectedMemberIds={this.state.memberIds}
            />
            <p />
            <br />
            <FormControl>
              <Select
                value={this.state.notificationType}
                onChange={(event) => {
                  event.stopPropagation();
                  this.setState({ notificationType: event.target.value });
                }}
                required
              >
                <MenuItem value="default">Default: without email notification.</MenuItem>
                <MenuItem value="email">Email: with email notification.</MenuItem>
              </Select>
              <FormHelperText>
                Choose how to notify members about new Posts inside Discussion.
              </FormHelperText>
            </FormControl>
            <p />
            <br />
            <DialogActions>
              <Button
                color="primary"
                variant="outlined"
                onClick={this.handleClose}
                disabled={this.state.disabled}
              >
                Cancel
              </Button>
              <Button
                type="submit"
                variant="contained"
                color="primary"
                disabled={this.state.disabled}
              >
                Update Discussion
              </Button>
            </DialogActions>
          </form>
        </DialogContent>
      </Dialog>
    );
  }

  public handleMembersChange = (memberIds) => {
    this.setState({ memberIds });
  };

  public handleClose = () => {
    this.setState({ name: '', memberIds: [], disabled: false, notificationType: 'default' });
    this.props.onClose();
  };

  private onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();

    const { discussion, store } = this.props;
    const { currentTeam } = store;
    const { notificationType } = this.state;

    if (!currentTeam) {
      notify('Team have not selected');
      return;
    }

    const { name, memberIds } = this.state;

    if (!name) {
      notify('Please name this Discussion.');
      return;
    }

    if (memberIds && !memberIds.includes(discussion.store.currentUser._id)) {
      memberIds.push(discussion.store.currentUser._id);
    }

    // if (!memberIds || memberIds.length < 1) {
    //   notify('Please assign at least one person to this Discussion.');
    //   return;
    // }

    if (!notificationType) {
      notify('Please select notification type.');
      return;
    }

    NProgress.start();
    try {
      await discussion.editDiscussion({ name, memberIds, notificationType });

      this.setState({ name: '', memberIds: [], disabled: false, notificationType: 'default' });
      notify('You successfully edited Discussion.');
    } catch (error) {
      console.log(error);
      notify(error);
    } finally {
      this.setState({ disabled: false });
      NProgress.done();

      this.props.onClose();
    }
  };
}

export default observer(EditDiscussionForm);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\components\layout\index.tsx -----

import Avatar from '@mui/material/Avatar';
import Button from '@mui/material/Button';
import Grid from '@mui/material/Grid';
import ArrowDropDownIcon from '@mui/icons-material/ArrowDropDown';
import LensIcon from '@mui/icons-material/Lens';

import Link from 'next/link';
import React from 'react';

import MenuWithLinks from '../common/MenuWithLinks';
import Confirmer from '../common/Confirmer';
import Notifier from '../common/Notifier';

import { Store } from '../../lib/store';
import DiscussionList from '../discussions/DiscussionList';

const dev = process.env.NODE_ENV !== 'production';

const styleGrid = {
  width: '100%',
  height: '100vh',
  maxWidth: '100%',
  padding: '0px 10px',
  display: 'flex',
  overflow: 'hidden',
};

const styleGridIsMobile = {
  width: '100%',
  height: '100vh',
  maxWidth: '100%',
  padding: '0px 0px 0px 10px',
  display: 'flex',
  overflow: 'hidden',
};

function LayoutWrapper({
  children,
  isMobile,
  firstGridItem,
  store,
}: {
  children: React.ReactNode;
  isMobile: boolean;
  firstGridItem: boolean;
  store: Store;
}) {
  const isThemeDark = store.currentUser ? store.currentUser.darkTheme : true;

  return (
    <React.Fragment>
      <Grid
        container
        direction="row"
        justifyContent="flex-start"
        alignItems="stretch"
        style={isMobile ? styleGridIsMobile : styleGrid}
      >
        {firstGridItem ? (
          <Grid
            item
            sm={2}
            xs={12}
            style={{
              borderRight: '1px #707070 solid',
              justifyContent: 'center',
              overflow: 'hidden',
            }}
          >
            <div style={{ display: 'flex', justifyContent: 'space-between' }}>
              <svg
                xmlns="http://www.w3.org/2000/svg"
                width="124"
                height="40"
                viewBox="0 0 124 40"
                style={{
                  marginTop: '20px',
                  display: 'inline-flex',
                  height: '40px',
                }}
              >
                <g id="async-logo">
                  <g id="async-logo-40">
                    <circle id="Ellipse 2" cx="20" cy="20" r="20" fill="black" />
                    <path
                      id="path-async-logo"
                      d="M7.07825 -0.0960007V16H4.51825V13.088C4.04892 14.0907 3.33425 14.8693 2.37425 15.424C1.43558 15.9573 0.336917 16.224 -0.92175 16.224C-2.35108 16.224 -3.60975 15.8827 -4.69775 15.2C-5.76442 14.5173 -6.59642 13.5573 -7.19375 12.32C-7.76975 11.0613 -8.05775 9.6 -8.05775 7.936C-8.05775 6.272 -7.75908 4.81067 -7.16175 3.552C-6.56442 2.272 -5.73242 1.28 -4.66575 0.576C-3.57775 -0.128 -2.32975 -0.48 -0.92175 -0.48C0.336917 -0.48 1.43558 -0.202666 2.37425 0.352C3.31292 0.906667 4.02758 1.68533 4.51825 2.688V-0.0960007H7.07825ZM-0.40975 14.08C1.16892 14.08 2.38492 13.5467 3.23825 12.48C4.09158 11.392 4.51825 9.856 4.51825 7.872C4.51825 5.888 4.09158 4.36267 3.23825 3.296C2.38492 2.22933 1.16892 1.696 -0.40975 1.696C-1.98842 1.696 -3.22575 2.25067 -4.12175 3.36C-4.99642 4.448 -5.43375 5.97333 -5.43375 7.936C-5.43375 9.89867 -4.99642 11.4133 -4.12175 12.48C-3.24708 13.5467 -2.00975 14.08 -0.40975 14.08Z"
                      transform="translate(19.5938 12)"
                      fill="white"
                    />
                  </g>
                  <path
                    id="path-async-text"
                    d="M22.6251 11.928V24H20.7051V21.816C20.3531 22.568 19.8171 23.152 19.0971 23.568C18.3931 23.968 17.5691 24.168 16.6251 24.168C15.5531 24.168 14.6091 23.912 13.7931 23.4C12.9931 22.888 12.3691 22.168 11.9211 21.24C11.4891 20.296 11.2731 19.2 11.2731 17.952C11.2731 16.704 11.4971 15.608 11.9451 14.664C12.3931 13.704 13.0171 12.96 13.8171 12.432C14.6331 11.904 15.5691 11.64 16.6251 11.64C17.5691 11.64 18.3931 11.848 19.0971 12.264C19.8011 12.68 20.3371 13.264 20.7051 14.016V11.928H22.6251ZM17.0091 22.56C18.1931 22.56 19.1051 22.16 19.7451 21.36C20.3851 20.544 20.7051 19.392 20.7051 17.904C20.7051 16.416 20.3851 15.272 19.7451 14.472C19.1051 13.672 18.1931 13.272 17.0091 13.272C15.8251 13.272 14.8971 13.688 14.2251 14.52C13.5691 15.336 13.2411 16.48 13.2411 17.952C13.2411 19.424 13.5691 20.56 14.2251 21.36C14.8811 22.16 15.8091 22.56 17.0091 22.56ZM30.4637 24.168C28.4317 24.168 26.8237 23.648 25.6397 22.608L26.2877 21.168C26.9437 21.68 27.6077 22.048 28.2797 22.272C28.9517 22.496 29.7037 22.608 30.5357 22.608C31.4477 22.608 32.1357 22.456 32.5997 22.152C33.0797 21.832 33.3197 21.376 33.3197 20.784C33.3197 20.304 33.1597 19.92 32.8397 19.632C32.5197 19.344 31.9917 19.12 31.2557 18.96L29.2157 18.48C28.2077 18.256 27.4237 17.856 26.8637 17.28C26.3197 16.704 26.0477 16.016 26.0477 15.216C26.0477 14.16 26.4717 13.304 27.3197 12.648C28.1677 11.976 29.2877 11.64 30.6797 11.64C31.5277 11.64 32.3277 11.776 33.0797 12.048C33.8317 12.32 34.4637 12.712 34.9757 13.224L34.3277 14.64C33.1917 13.696 31.9757 13.224 30.6797 13.224C29.8157 13.224 29.1437 13.392 28.6637 13.728C28.1997 14.048 27.9677 14.504 27.9677 15.096C27.9677 15.592 28.1117 15.984 28.3997 16.272C28.7037 16.56 29.1837 16.784 29.8397 16.944L31.8797 17.448C32.9997 17.704 33.8317 18.104 34.3757 18.648C34.9197 19.176 35.1917 19.872 35.1917 20.736C35.1917 21.776 34.7677 22.608 33.9197 23.232C33.0717 23.856 31.9197 24.168 30.4637 24.168ZM48.687 11.928L43.047 25.104C42.455 26.48 41.711 27.488 40.815 28.128C39.919 28.768 38.815 29.208 37.503 29.448L37.095 27.936C38.231 27.68 39.087 27.336 39.663 26.904C40.255 26.488 40.743 25.84 41.127 24.96L41.607 23.88L36.495 11.928H38.535L42.615 21.888L46.743 11.928H48.687ZM56.853 11.64C59.749 11.64 61.197 13.232 61.197 16.416V24H59.253V16.512C59.253 15.392 59.029 14.576 58.581 14.064C58.133 13.536 57.429 13.272 56.469 13.272C55.349 13.272 54.453 13.616 53.781 14.304C53.109 14.992 52.773 15.92 52.773 17.088V24H50.829V15.312C50.829 14.064 50.765 12.936 50.637 11.928H52.485L52.677 14.088C53.045 13.304 53.597 12.704 54.333 12.288C55.069 11.856 55.909 11.64 56.853 11.64ZM69.9321 24.168C68.7641 24.168 67.7401 23.912 66.8601 23.4C65.9961 22.888 65.3241 22.168 64.8441 21.24C64.3801 20.296 64.1481 19.2 64.1481 17.952C64.1481 16.704 64.3881 15.608 64.8681 14.664C65.3481 13.704 66.0281 12.96 66.9081 12.432C67.8041 11.904 68.8441 11.64 70.0281 11.64C70.8441 11.64 71.6281 11.784 72.3801 12.072C73.1481 12.344 73.7801 12.728 74.2761 13.224L73.6281 14.664C73.0201 14.184 72.4281 13.832 71.8521 13.608C71.2921 13.384 70.7161 13.272 70.1241 13.272C68.8921 13.272 67.9241 13.688 67.2201 14.52C66.5161 15.336 66.1641 16.48 66.1641 17.952C66.1641 19.408 66.5081 20.544 67.1961 21.36C67.9001 22.16 68.8761 22.56 70.1241 22.56C70.7161 22.56 71.2921 22.448 71.8521 22.224C72.4281 22 73.0201 21.648 73.6281 21.168L74.2761 22.608C73.7641 23.088 73.1161 23.472 72.3321 23.76C71.5641 24.032 70.7641 24.168 69.9321 24.168Z"
                    transform="translate(39 4)"
                    fill={isThemeDark ? 'white' : 'black'}
                  />
                </g>
              </svg>
              <MenuWithLinks
                options={[
                  {
                    text: 'Your Settings',
                    href: `/your-settings?teamSlug=${store.currentTeam.slug}`,
                    as: `/teams/${store.currentTeam.slug}/your-settings`,
                    highlighterSlug: '/your-settings',
                  },
                  {
                    text: 'Team Settings',
                    href: `/team-settings?teamSlug=${store.currentTeam.slug}`,
                    as: `/teams/${store.currentTeam.slug}/team-settings`,
                    highlighterSlug: '/team-settings',
                  },
                  {
                    text: 'Billing',
                    href: `/billing?teamSlug=${store.currentTeam.slug}`,
                    as: `/teams/${store.currentTeam.slug}/billing`,
                    highlighterSlug: '/billing',
                  },
                  {
                    separator: true,
                  },
                  {
                    text: 'Log out',
                    href: `${
                      dev
                        ? process.env.NEXT_PUBLIC_URL_API
                        : process.env.NEXT_PUBLIC_PRODUCTION_URL_API
                    }/logout`,
                    as: `${
                      dev
                        ? process.env.NEXT_PUBLIC_URL_API
                        : process.env.NEXT_PUBLIC_PRODUCTION_URL_API
                    }/logout`,
                    externalServer: true,
                  },
                ]}
              >
                <Avatar
                  src={store.currentUser.avatarUrl}
                  alt="Add username here later in the book"
                  style={{
                    margin: '20px auto',
                    cursor: 'pointer',
                    display: 'inline-flex',
                    width: '40px',
                    height: '40px',
                  }}
                />

                <ArrowDropDownIcon color="action" style={{ verticalAlign: 'super' }} />
              </MenuWithLinks>
            </div>
            <hr />
            <p />
            <p />
            <DiscussionList store={store} team={store.currentTeam} isMobile={isMobile} />
          </Grid>
        ) : null}

        {children}
      </Grid>
      <Notifier />
      <Confirmer />
    </React.Fragment>
  );
}

type Props = {
  children: React.ReactNode;
  store?: Store;
  isMobile?: boolean;
  firstGridItem?: boolean;
  teamRequired?: boolean;
};

class Layout extends React.Component<Props> {
  public render() {
    const { children, isMobile, firstGridItem, store, teamRequired } = this.props;

    const { currentUser, currentTeam } = store;

    // console.log(this.props.store.currentUser.darkTheme);

    // const isThemeDark = false;

    // console.log(isMobile);

    // console.log(store, currentUser, currentTeam);

    if (!currentUser) {
      return (
        <LayoutWrapper firstGridItem={firstGridItem} isMobile={isMobile} store={store}>
          <Grid item sm={12} xs={12}>
            {children}
          </Grid>
        </LayoutWrapper>
      );
    }

    if (!currentTeam) {
      if (teamRequired) {
        return (
          <LayoutWrapper firstGridItem={firstGridItem} isMobile={isMobile} store={store}>
            <Grid
              item
              sm={10}
              xs={12}
              style={{ padding: '0px 35px', overflow: 'auto', height: 'auto' }}
            >
              <div style={{ padding: '20px' }}>
                Select existing team or create a new team.
                <p />
                <Link href="/create-team" as="/create-team">
                  <Button variant="contained" color="primary">
                    Create new team
                  </Button>
                </Link>
              </div>
            </Grid>
          </LayoutWrapper>
        );
      } else {
        // console.log('team not required');
        return (
          <LayoutWrapper firstGridItem={firstGridItem} isMobile={isMobile} store={store}>
            <Grid
              item
              sm={10}
              xs={12}
              style={{ padding: '0px 35px', overflow: 'auto', height: 'auto' }}
            >
              {children}
            </Grid>
          </LayoutWrapper>
        );
      }
    }

    return (
      <LayoutWrapper firstGridItem={firstGridItem} isMobile={isMobile} store={store}>
        <Grid
          item
          sm={firstGridItem ? 10 : 12}
          xs={12}
          style={{ padding: '0px 35px', overflowY: 'auto', height: 'inherit' }}
        >
          <div>
            {isMobile || store.currentUrl.includes('create-team') ? null : (
              <React.Fragment>
                <LensIcon
                  style={{
                    margin: '15px 0px 10px 25px',
                    opacity: 0.8,
                    fontSize: '18px',
                    cursor: 'pointer',
                  }}
                  onClick={async () => {
                    await store.currentUser.toggleTheme(!store.currentUser.darkTheme);
                  }}
                />
                <span
                  style={{
                    float: 'right',
                    margin: '15px 0px 10px 25px',
                    fontSize: '11px',
                  }}
                >
                  Check up our latest project (share with your biotech friends):{' '}
                  <a
                    style={{
                      fontWeight: 600,
                    }}
                    target="_blank"
                    href="https://workinbiotech.com"
                    rel="noopener noreferrer"
                  >
                    Work in biotech
                  </a>
                </span>
                <h4
                  style={{
                    margin: '15px 0px 10px 30px',
                    fontWeight: 300,
                  }}
                >
                  Current team: <b>{store.currentTeam.name}</b>
                </h4>
              </React.Fragment>
            )}
            <div style={{ clear: 'both' }} />
          </div>
          {children}
        </Grid>
      </LayoutWrapper>
    );
  }
}

export default Layout;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\components\posts\PostContent.tsx -----

import React from 'react';

type Props = { html: string };

class PostContent extends React.Component<Props> {
  public render() {
    const { html } = this.props;

    return (
      <div
        style={{
          fontSize: '15px',
          lineHeight: '2em',
          fontFamily: 'Roboto, sans-serif',
          wordBreak: 'break-all',
        }}
        dangerouslySetInnerHTML={{ __html: html }}
      />
    );
  }
}

export default PostContent;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\components\posts\PostDetail.tsx -----

import Avatar from '@mui/material/Avatar';
import Paper from '@mui/material/Paper';
import Tooltip from '@mui/material/Tooltip';
import { observer } from 'mobx-react';
import moment from 'moment';
import React from 'react';

import confirm from '../../lib/confirm';
import notify from '../../lib/notify';
import { Store } from '../../lib/store';
import { Post } from '../../lib/store/post';
import { User } from '../../lib/store/user';

import MenuWithMenuItems from '../common/MenuWithMenuItems';

import PostContent from './PostContent';

const stylePaper = {
  margin: '10px 0px',
  padding: '20px',
};

const styleLineSeparator = {
  verticalAlign: 'text-bottom',
  fontWeight: 300,
  fontSize: '16px',
  margin: '0px 5px',
  opacity: 0.75,
};

const getMenuOptions = (post) => ({
  dataId: post._id,
  id: `post-menu-${post._id}`,
});

const getMenuItemOptions = (post: Post, currentUser: User, component) => {
  const items = [];

  if (post.createdUserId !== currentUser._id) {
    items.push({
      text: 'Show Markdown',
      dataId: post._id,
      onClick: component.showMarkdown,
    });
  }

  if (post.createdUserId === currentUser._id) {
    const isFirstPost = post.discussion.posts.indexOf(post) === 0;

    items.push({
      text: 'Edit',
      dataId: post._id,
      onClick: component.editPost,
    });

    if (!isFirstPost) {
      items.push({
        text: 'Delete',
        dataId: post._id,
        onClick: component.deletePost,
      });
    }
  }

  return items;
};

type Props = {
  post: Post;
  store: Store;
  isMobile: boolean;
  onEditClick: (post) => void;
  onShowMarkdownClick: (post) => void;
};

class PostDetail extends React.Component<Props> {
  public render() {
    const { post, isMobile } = this.props;

    return <Paper style={stylePaper}>{this.renderPostDetail(post, isMobile)}</Paper>;
  }

  public renderPostDetail(post: Post, isMobile) {
    const createdDate = moment(post.createdAt).local().format('MMM Do YYYY');
    const lastUpdatedDate = moment(post.lastUpdatedAt).fromNow();

    return (
      <React.Fragment>
        <div
          style={{
            float: 'left',
            margin: '-12px 10px 0px -15px',
            zIndex: 1000,
          }}
        >
          {this.renderMenu()}
        </div>
        <div id={`post-${post._id}`}>
          {post.user && (
            <Tooltip
              title={post.user.displayName}
              placement="top"
              disableFocusListener
              disableTouchListener
            >
              <Avatar
                src={post.user.avatarUrl}
                alt={post.user.displayName}
                style={{
                  width: '40px',
                  height: '40px',
                  margin: '0px 10px 0px 5px',
                  cursor: 'pointer',
                  float: 'left',
                }}
              />
            </Tooltip>
          )}
          <div
            style={{
              margin: isMobile ? '0px' : '0px 20px 0px 70px',
              fontWeight: 300,
              lineHeight: '1em',
            }}
          >
            <span style={{ fontSize: '12px', fontWeight: 400 }}>
              {`By: ${post.user && post.user.displayName}` || 'User'}
              <span style={styleLineSeparator}>|</span>
              {`Created: ${post.createdAt && createdDate}` || ''}

              {post.isEdited ? (
                <React.Fragment>
                  <span style={styleLineSeparator}>|</span>
                  Last edited: {lastUpdatedDate}
                </React.Fragment>
              ) : null}
            </span>

            <PostContent html={post.htmlContent} />
          </div>
        </div>
      </React.Fragment>
    );
  }

  public renderMenu() {
    const { post, store } = this.props;
    const { currentUser } = store;

    if (!post.user || !currentUser) {
      return null;
    }

    return (
      <MenuWithMenuItems
        menuOptions={getMenuOptions(post)}
        itemOptions={getMenuItemOptions(post, store.currentUser, this)}
      />
    );
  }

  public showMarkdown = () => {
    const { post, onShowMarkdownClick } = this.props;
    if (onShowMarkdownClick) {
      onShowMarkdownClick(post);
    }
  };

  public editPost = () => {
    const { post, onEditClick } = this.props;
    if (onEditClick) {
      onEditClick(post);
    }
    // console.log(`PostDetail: ${post._id}`);
  };

  public deletePost = () => {
    confirm({
      title: 'Are you sure?',
      message: '',
      onAnswer: async (answer) => {
        if (answer) {
          const { post } = this.props;
          await post.discussion.deletePost(post);
          notify('You successfully deleted Post.');
        }
      },
    });
  };
}

export default observer(PostDetail);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\components\posts\PostEditor.tsx -----

import Avatar from '@mui/material/Avatar';
import Button from '@mui/material/Button';
import InsertPhotoIcon from '@mui/icons-material/InsertPhoto';
import he from 'he';
import { marked } from 'marked';
import { observer } from 'mobx-react';
import NProgress from 'nprogress';
import React from 'react';
import { Mention, MentionsInput } from 'react-mentions';

import {
  getSignedRequestForUploadApiMethod,
  uploadFileUsingSignedPutRequestApiMethod,
} from '../../lib/api/team-member';
import notify from '../../lib/notify';
import { resizeImage } from '../../lib/resizeImage';
import { Store } from '../../lib/store';
import { User } from '../../lib/store/user';

import PostContent from './PostContent';

function getImageDimension(file): Promise<{ width: number; height: number }> {
  const reader = new FileReader();
  const img = new Image();

  return new Promise((resolve) => {
    reader.readAsDataURL(file);

    reader.onload = (e) => {
      img.onload = () => {
        resolve({ width: img.width, height: img.height });
      };

      img.src = e.target.result.toString();
    };
  });
}

type Props = {
  store: Store;
  onChanged: (content) => void;
  content: string;
  members: User[];
  textareaHeight?: string;
  placeholder?: string;
  parentComponent: string;
};

type State = { htmlContent: string };

class PostEditor extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      htmlContent: '',
    };
  }

  public render() {
    const { htmlContent } = this.state;
    const { content, members, store, parentComponent } = this.props;
    const { currentUser } = store;

    const membersMinusCurrentUser = members.filter((member) => member._id !== currentUser._id);

    const isThemeDark = store && store.currentUser && store.currentUser.darkTheme === true;
    const textareaBackgroundColor = isThemeDark ? '#0d1117' : '#fff';

    return (
      <div style={{ marginTop: '20px' }}>
        <div style={{ display: 'inline-flex' }}>
          <Button
            onClick={this.showMarkdownContent}
            variant="text"
            style={{ fontWeight: htmlContent ? 300 : 600, color: '#58a6ff' }}
          >
            Markdown
          </Button>{' '}
          <Button
            onClick={this.showHtmlContent}
            variant="text"
            style={{ fontWeight: htmlContent ? 600 : 300, color: '#58a6ff' }}
          >
            HTML
          </Button>
        </div>

        <div style={{ display: 'inline', float: 'left' }}>
          <label htmlFor={'upload-file-post-editor-' + parentComponent}>
            <Button component="span" style={{ color: '#58a6ff' }}>
              <InsertPhotoIcon style={{ fontSize: '22px' }} />
            </Button>
          </label>
          <input
            accept="image/*"
            name={'upload-file-post-editor-' + parentComponent}
            id={'upload-file-post-editor-' + parentComponent}
            type="file"
            style={{ display: 'none' }}
            onChange={async (event) => {
              const file = event.target.files[0];
              await this.uploadFile(file);
              event.target.value = '';
            }}
          />
        </div>
        <br />
        <div
          style={{
            padding: '10px 15px',
            border: isThemeDark
              ? '1px solid rgba(255, 255, 255, 0.5)'
              : '1px solid rgba(0, 0, 0, 0.5)',
          }}
        >
          {htmlContent ? (
            <PostContent html={htmlContent} />
          ) : (
            <MentionsInput
              style={{
                input: {
                  border: 'none',
                  outline: 'none',
                  color: isThemeDark ? '#fff' : '#000',
                  fontFamily: 'Roboto, sans-serif',
                  lineHeight: '1.5em',
                  backgroundColor: content ? textareaBackgroundColor : 'transparent',
                },

                '&multiLine': {
                  control: {
                    fontFamily: 'Roboto, sans-serif',
                    minHeight: 100,
                  },
                },
                suggestions: {
                  list: {
                    backgroundColor: '#222',
                    color: '#fff',
                  },

                  item: {
                    padding: '5px 15px',
                    borderBottom: '1px solid rgba(0,0,0,0.15)',

                    '&focused': {
                      backgroundColor: 'rgba(255, 255, 255, 0.1)',
                    },
                  },
                },
              }}
              autoFocus
              value={content}
              placeholder={this.props.placeholder ? this.props.placeholder : 'Compose new post'}
              onChange={(event) => {
                this.props.onChanged(event.target.value);
              }}
            >
              <Mention
                trigger="@"
                data={membersMinusCurrentUser.map((u) => ({
                  id: u.avatarUrl,
                  display: u.displayName,
                  // you: u._id === currentUser._id ? true : false,
                }))}
                markup={'[`@#__display__`](__id__)'}
                displayTransform={(_, display) => {
                  return `@${display}`;
                }}
                renderSuggestion={(suggestion) => (
                  <React.Fragment>
                    <Avatar
                      role="presentation"
                      src={suggestion.id}
                      alt={suggestion.display}
                      style={{
                        width: '24px',
                        height: '24px',
                        marginRight: '10px',
                        display: 'inline-flex',
                        verticalAlign: 'middle',
                      }}
                    />
                    <span style={{ marginRight: '5px' }}>{suggestion.display}</span>
                  </React.Fragment>
                )}
              />
            </MentionsInput>
          )}
        </div>
      </div>
    );
  }

  public showMarkdownContent = () => {
    this.setState({ htmlContent: '' });
  };

  public showHtmlContent = async () => {
    const { content } = this.props;

    function markdownToHtml(postContent) {
      const renderer = new marked.Renderer();

      renderer.link = (href, title, text) => {
        const t = title ? ` title="${title}"` : '';

        if (text.startsWith('<code>@#')) {
          return `${text.replace('<code>@#', '<code>@')} `;
        }

        return `
          <a target="_blank" href="${href}" rel="noopener noreferrer"${t}>
            ${text}
          </a>
        `;
      };

      marked.setOptions({
        renderer,
        breaks: true,
      });

      return marked(he.decode(postContent));
    }

    const htmlContent = content ? markdownToHtml(content) : '<span>Nothing to preview.</span>';
    this.setState({ htmlContent });
  };

  private uploadFile = async (file: File) => {
    if (!file) {
      notify('No file selected.');
      return;
    }

    if (!file.type || (!file.type.startsWith('image/') && file.type !== 'application/pdf')) {
      notify('Wrong file.');
      return;
    }

    const { store } = this.props;
    const { currentTeam } = store;

    NProgress.start();

    const bucket = process.env.NEXT_PUBLIC_BUCKET_FOR_POSTS;
    const prefix = `${currentTeam.slug}`;
    const fileName = file.name;
    const fileType = file.type;

    try {
      const responseFromApiServerForUpload = await getSignedRequestForUploadApiMethod({
        fileName,
        fileType,
        prefix,
        bucket,
      });

      let fileHtmlOrMarkdown;
      let fileUrl;

      if (file.type.startsWith('image/')) {
        const { width } = await getImageDimension(file);
        const resizedFile = await resizeImage(file, 1024, 1024);

        await uploadFileUsingSignedPutRequestApiMethod(
          resizedFile,
          responseFromApiServerForUpload.signedRequest,
        );

        fileUrl = responseFromApiServerForUpload.url;

        // console.log(fileUrl);

        const finalWidth = width > 768 ? '100%' : `${width}px`;

        fileHtmlOrMarkdown = `
          <div>
            <img style="max-width: ${finalWidth}; width:100%" src="${fileUrl}" alt="Async" class="s3-image" />
          </div>`;
      } else {
        await uploadFileUsingSignedPutRequestApiMethod(
          file,
          responseFromApiServerForUpload.signedRequest,
        );

        fileUrl = responseFromApiServerForUpload.url;
        fileHtmlOrMarkdown = `[${file.name}](${fileUrl})`;
      }

      const content = `${this.props.content}\n${fileHtmlOrMarkdown.replace(/\s+/g, ' ')}`;

      this.props.onChanged(content);

      notify('You successfully uploaded file.');
    } catch (error) {
      console.log(error);
      notify(error);
    } finally {
      NProgress.done();
    }
  };
}

export default observer(PostEditor);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\components\posts\PostForm.tsx -----

import Button from '@mui/material/Button';
import he from 'he';
import { marked } from 'marked';
import { observer } from 'mobx-react';
import NProgress from 'nprogress';
import React from 'react';

import notify from '../../lib/notify';
import { Store } from '../../lib/store';
import { Discussion } from '../../lib/store/discussion';
import { Post } from '../../lib/store/post';
import { User } from '../../lib/store/user';

import PostEditor from './PostEditor';

const dev = process.env.NODE_ENV !== 'production';

type Props = {
  store: Store;
  isMobile: boolean;
  members: User[];
  post: Post;
  discussion: Discussion;
  showMarkdownToNonCreator?: boolean;
  onFinished?: () => void;
};

type State = {
  postId: string;
  content: string;
  disabled: boolean;
};

class PostForm extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      postId: null,
      content: '',
      disabled: false,
    };
  }

  public static getDerivedStateFromProps(props: Props, state: State) {
    const { post } = props;

    if (!post && !state.postId) {
      return null;
    }

    if (post && post._id === state.postId) {
      return null;
    }

    return {
      postId: (post && post._id) || null,
      content: (post && post.content) || '',
    };
  }

  public render() {
    const { store, members, post, isMobile, showMarkdownToNonCreator } = this.props;
    const isEditingPost = !!post;

    let title = 'Add Post';
    if (showMarkdownToNonCreator) {
      title = 'Showing Markdown';
    } else if (isEditingPost) {
      title = 'Edit Post';
    }

    return (
      <div style={{ height: '100%', margin: '0px 20px' }}>
        <p />
        <br />
        <h3>{title}</h3>
        <form style={{ width: '100%', height: '100%' }} onSubmit={this.onSubmit} autoComplete="off">
          <p />
          <br />
          <div>
            {showMarkdownToNonCreator ? null : (
              <React.Fragment>
                <Button
                  type="submit"
                  variant="contained"
                  color="primary"
                  disabled={this.state.disabled}
                >
                  {isEditingPost ? 'Save changes' : 'Publish Post'}
                </Button>
                {isMobile ? <p /> : null}
              </React.Fragment>
            )}
            {isEditingPost ? (
              <Button
                variant="outlined"
                onClick={this.closeForm}
                disabled={this.state.disabled}
                style={{ marginLeft: '10px' }}
              >
                {showMarkdownToNonCreator ? 'Go back' : 'Cancel'}
              </Button>
            ) : null}
          </div>
          <p />
          <PostEditor
            content={this.state.content}
            onChanged={this.onContentChanged}
            members={members}
            store={store}
            textareaHeight="100%"
            parentComponent="PF"
          />
          <p />
          <div style={{ margin: '20px 0px' }}>
            {isEditingPost ? (
              <Button
                variant="outlined"
                onClick={this.closeForm}
                disabled={this.state.disabled}
                style={{ marginLeft: '10px' }}
              >
                {showMarkdownToNonCreator ? 'Go back' : 'Cancel'}
              </Button>
            ) : null}
          </div>
          <p />
          <br />
        </form>
      </div>
    );
  }

  private onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();

    const { content } = this.state;
    const htmlContent = marked(he.decode(content));
    const { post, onFinished, store, discussion } = this.props;
    const isEditingPost = !!post;

    if (!content) {
      notify('Add content to your Post');
      return;
    }

    if (isEditingPost) {
      this.setState({ disabled: true });
      NProgress.start();
      try {
        await post.editPost({ content, htmlContent });
        notify('You successfully edited Post');
      } catch (error) {
        console.log(error);
        notify(error);
      } finally {
        this.setState({ disabled: false });
        NProgress.done();
      }

      if (onFinished) {
        onFinished();
      }

      return;
    }

    const { currentTeam } = store;
    if (!currentTeam) {
      notify('Team is not selected or does not exist.');
      return;
    }

    NProgress.start();
    this.setState({ disabled: true });

    try {
      const post = await discussion.addPost(content);

      if (discussion.notificationType === 'email') {
        const userIdsForLambda = discussion.memberIds.filter((m) => m !== store.currentUser._id);

        await discussion.sendDataToLambda({
          discussionName: discussion.name,
          discussionLink: `${
            dev ? process.env.NEXT_PUBLIC_URL_APP : process.env.NEXT_PUBLIC_PRODUCTION_URL_APP
          }/teams/${discussion.team.slug}/discussions/${discussion.slug}`,
          postContent: post.content,
          authorName: post.user.displayName,
          userIds: userIdsForLambda,
        });
      }

      this.setState({ content: '' });

      notify('You successfully published new Post.');
    } catch (error) {
      console.log(error);
      notify(error);
    } finally {
      this.setState({ disabled: false });
      NProgress.done();
    }

    if (onFinished) {
      onFinished();
    }
  };

  private onContentChanged = (content: string) => {
    this.setState({ content });
  };

  private closeForm = () => {
    this.setState({ postId: null, content: '' });

    const { onFinished } = this.props;
    if (onFinished) {
      onFinished();
    }
  };
}

export default observer(PostForm);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\components\teams\InviteMember.tsx -----

import Button from '@mui/material/Button';
import Dialog from '@mui/material/Dialog';
import DialogContent from '@mui/material/DialogContent';
import DialogTitle from '@mui/material/DialogTitle';
import TextField from '@mui/material/TextField';
import { inject, observer } from 'mobx-react';
import NProgress from 'nprogress';
import React from 'react';

import notify from '../../lib/notify';
import { Store } from '../../lib/store';

type Props = {
  store: Store;
  onClose: () => void;
  open: boolean;
};

type State = {
  email: string;
  disabled: boolean;
};

class InviteMember extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      email: '',
      disabled: false,
    };
  }

  public render() {
    const { open } = this.props;

    return (
      <Dialog onClose={this.handleClose} aria-labelledby="invite-member-dialog-title" open={open}>
        <DialogTitle id="invite-member-dialog-title">Invite member</DialogTitle>
        <DialogContent>
          <form onSubmit={this.onSubmit} style={{ padding: '20px' }}>
            <TextField
              autoComplete="off"
              value={this.state.email}
              placeholder="Email"
              onChange={(event) => {
                this.setState({ email: event.target.value });
              }}
            />
            <p />
            <br />
            <Button variant="outlined" onClick={this.handleClose} disabled={this.state.disabled}>
              Cancel
            </Button>{' '}
            <Button type="submit" variant="contained" color="primary">
              Invite
            </Button>
          </form>
        </DialogContent>
      </Dialog>
    );
  }

  private handleClose = () => {
    this.setState({ email: '', disabled: false });
    this.props.onClose();
  };

  private onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();

    const { store } = this.props;

    if (!store.currentTeam) {
      notify('Team have not selected');
      return;
    }

    const { email } = this.state;

    if (!email) {
      notify('Email is required');
      return;
    }

    NProgress.start();
    try {
      this.setState({ disabled: true });
      await store.currentTeam.inviteMember(email);

      this.setState({ email: '' });
      notify('You successfully sent invitation.');
      NProgress.done();
    } catch (error) {
      console.log(error);
      notify(error);
    } finally {
      this.props.onClose();
      this.setState({ disabled: false });
      NProgress.done();
    }
  };
}

export default inject('store')(observer(InviteMember));

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\lib\api\makeQueryString.ts -----

function makeQueryString(params) {
  const query = Object.keys(params)
    .filter((k) => !!params[k])
    .map((k) => `${encodeURIComponent(k)}=${encodeURIComponent(params[k])}`)
    .join('&');

  return query;
}

export { makeQueryString };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\lib\api\public.ts -----

import sendRequestAndGetResponse from './sendRequestAndGetResponse';

const BASE_PATH = '/api/v1/public';

export const getUserApiMethod = (request) =>
  sendRequestAndGetResponse(`${BASE_PATH}/get-user`, {
    request,
    method: 'GET',
  });

export const getUserBySlugApiMethod = (slug) =>
  sendRequestAndGetResponse(`${BASE_PATH}/get-user-by-slug`, {
    body: JSON.stringify({ slug }),
  });

export const emailLoginLinkApiMethod = ({
  email,
  invitationToken,
}: {
  email: string;
  invitationToken?: string;
}) =>
  sendRequestAndGetResponse('/auth/email-login-link', {
    qs: { invitationToken },
    body: JSON.stringify({ user: email }),
  });

export const getTeamByTokenApiMethod = (token: string, request) =>
  sendRequestAndGetResponse(`${BASE_PATH}/invitations/get-team-by-token`, {
    request,
    method: 'GET',
    qs: { token },
  });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\lib\api\sendRequestAndGetResponse.ts -----

import 'isomorphic-unfetch';

import { makeQueryString } from './makeQueryString';

const dev = process.env.NODE_ENV !== 'production';

export default async function sendRequestAndGetResponse(path, opts: any = {}) {
  const headers = Object.assign(
    {},
    opts.headers || {},
    opts.externalServer
      ? {}
      : {
          'Content-type': 'application/json; charset=UTF-8',
        },
  );

  const { request } = opts;

  if (request && request.headers && request.headers.cookie) {
    headers.cookie = request.headers.cookie;
  }

  // const qs = opts.qs || '';

  const qs = (opts.qs && `?${makeQueryString(opts.qs)}`) || '';

  // console.log(`before: ${process.env.NEXT_PUBLIC_URL_API}${path}${qs}`);

  const response = await fetch(
    opts.externalServer
      ? `${path}${qs}`
      : `${
          dev ? process.env.NEXT_PUBLIC_URL_API : process.env.NEXT_PUBLIC_PRODUCTION_URL_API
        }${path}${qs}`,
    Object.assign({ method: 'POST', credentials: 'include' }, opts, { headers }),
  );

  // console.log(`after: ${process.env.NEXT_PUBLIC_URL_API}${path}${qs}`);

  // console.log(response.status);
  // console.log(response.statusText);

  const text = await response.text();

  if (response.status >= 400) {
    console.error(text);
    throw new Error(response.status.toString());
  }

  try {
    const data = JSON.parse(text);

    return data;
  } catch (err) {
    if (err instanceof SyntaxError) {
      return text;
    }

    throw err;
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\lib\api\team-leader.ts -----

import sendRequestAndGetResponse from './sendRequestAndGetResponse';

const BASE_PATH = '/api/v1/team-leader';

export const addTeamApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams/add`, {
    body: JSON.stringify(data),
  });

export const updateTeamApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams/update`, {
    body: JSON.stringify(data),
  });

export const getTeamInvitationsApiMethod = (teamId: string) =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams/get-invitations-for-team`, {
    method: 'GET',
    qs: { teamId },
  });

export const inviteMemberApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams/invite-member`, {
    body: JSON.stringify(data),
  });

export const removeMemberApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams/remove-member`, {
    body: JSON.stringify(data),
  });

export const fetchCheckoutSessionApiMethod = ({ mode, teamId }: { mode: string; teamId: string }) =>
  sendRequestAndGetResponse(`${BASE_PATH}/stripe/fetch-checkout-session`, {
    body: JSON.stringify({ mode, teamId }),
  });

export const cancelSubscriptionApiMethod = ({ teamId }: { teamId: string }) =>
  sendRequestAndGetResponse(`${BASE_PATH}/cancel-subscription`, {
    body: JSON.stringify({ teamId }),
  });

export const getListOfInvoicesApiMethod = () =>
  sendRequestAndGetResponse(`${BASE_PATH}/get-list-of-invoices-for-customer`, {
    method: 'GET',
  });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\lib\api\team-member.ts -----

import sendRequestAndGetResponse from './sendRequestAndGetResponse';

const BASE_PATH = '/api/v1/team-member';

export const getSignedRequestForUploadApiMethod = ({ fileName, fileType, prefix, bucket }) =>
  sendRequestAndGetResponse(`${BASE_PATH}/aws/get-signed-request-for-upload-to-s3`, {
    body: JSON.stringify({ fileName, fileType, prefix, bucket }),
  });

export const uploadFileUsingSignedPutRequestApiMethod = (file, signedRequest, headers = {}) =>
  sendRequestAndGetResponse(signedRequest, {
    externalServer: true,
    method: 'PUT',
    body: file,
    headers,
  });

export const updateProfileApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/user/update-profile`, {
    body: JSON.stringify(data),
  });

export const toggleThemeApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/user/toggle-theme`, {
    body: JSON.stringify(data),
  });

export const getInitialDataApiMethod = (options: any = {}) =>
  sendRequestAndGetResponse(
    `${BASE_PATH}/get-initial-data`,
    Object.assign(
      {
        body: JSON.stringify(options.data || {}),
      },
      options,
    ),
  );

// export const getTeamListApiMethod = () =>
//   sendRequestAndGetResponse(`${BASE_PATH}/teams`, {
//     method: 'GET',
//   });

export const getTeamMembersApiMethod = (teamId: string) =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams/get-members`, {
    method: 'GET',
    qs: { teamId },
  });

// Discussion and Post

export const getDiscussionListApiMethod = (params): Promise<{ discussions: any[] }> =>
  sendRequestAndGetResponse(`${BASE_PATH}/discussions/list`, {
    method: 'GET',
    qs: params,
  });

export const addDiscussionApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/discussions/add`, {
    body: JSON.stringify(data),
  });

export const editDiscussionApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/discussions/edit`, {
    body: JSON.stringify(data),
  });

export const deleteDiscussionApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/discussions/delete`, {
    body: JSON.stringify(data),
  });

export const getPostListApiMethod = (discussionId: string) =>
  sendRequestAndGetResponse(`${BASE_PATH}/posts/list`, {
    method: 'GET',
    qs: { discussionId },
  });

export const addPostApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/posts/add`, {
    body: JSON.stringify(data),
  });

export const editPostApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/posts/edit`, {
    body: JSON.stringify(data),
  });

export const deletePostApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/posts/delete`, {
    body: JSON.stringify(data),
  });

export const sendDataToLambdaApiMethod = (data) =>
  sendRequestAndGetResponse(`${process.env.NEXT_PUBLIC_API_GATEWAY_ENDPOINT}/`, {
    externalServer: true,
    body: JSON.stringify(data),
  });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\lib\store\discussion.ts -----

import { action, IObservableArray, observable, runInAction, computed, makeObservable } from 'mobx';

import {
  addPostApiMethod,
  deletePostApiMethod,
  editDiscussionApiMethod,
  getPostListApiMethod,
  sendDataToLambdaApiMethod,
} from '../api/team-member';
import { Store } from './index';
import { Team } from './team';
import { Post } from './post';

class Discussion {
  public _id: string;
  public createdUserId: string;
  public store: Store;
  public team: Team;

  public name: string;
  public slug: string;
  public memberIds: IObservableArray<string> = observable([]);
  public posts: IObservableArray<Post> = observable([]);
  public isLoadingPosts = false;

  public notificationType: string;

  constructor(params) {
    makeObservable(this, {
      name: observable,
      slug: observable,
      memberIds: observable,
      posts: observable,
      isLoadingPosts: observable,

      editDiscussion: action,
      changeLocalCache: action,

      setInitialPosts: action,
      loadPosts: action,
      addPost: action,
      addPostToLocalCache: action,
      deletePost: action,

      addDiscussionToLocalCache: action,
      editDiscussionFromLocalCache: action,
      deleteDiscussionFromLocalCache: action,
      editPostFromLocalCache: action,
      deletePostFromLocalCache: action,

      members: computed,
    });

    this._id = params._id;
    this.createdUserId = params.createdUserId;
    this.store = params.store;
    this.team = params.team;

    this.name = params.name;
    this.slug = params.slug;
    this.memberIds.replace(params.memberIds || []);

    this.notificationType = params.notificationType;

    if (params.initialPosts) {
      this.setInitialPosts(params.initialPosts);
      // console.log(params.initialPosts[0]);
    } else {
      this.loadPosts();
    }
  }

  public async editDiscussion(data) {
    try {
      await editDiscussionApiMethod({
        id: this._id,
        ...data,
        socketId: (this.store.socket && this.store.socket.id) || null,
      });

      runInAction(() => {
        this.changeLocalCache(data);
      });
    } catch (error) {
      console.error(error);
      throw error;
    }
  }

  public changeLocalCache(data) {
    this.name = data.name;
    this.memberIds.replace(data.memberIds || []);
  }

  get members() {
    return this.memberIds.map((id) => this.team.members.get(id)).filter((u) => !!u);
  }

  public setInitialPosts(posts) {
    const postObjs = posts.map((p) => new Post({ discussion: this, store: this.store, ...p }));
    this.posts.replace(postObjs);
  }

  public async loadPosts() {
    if (this.store.isServer || this.isLoadingPosts) {
      return;
    }

    this.isLoadingPosts = true;

    try {
      const { posts = [] } = await getPostListApiMethod(this._id);

      runInAction(() => {
        const postObjs = posts.map((t) => new Post({ discussion: this, store: this.store, ...t }));
        this.posts.replace(postObjs);
      });
    } finally {
      runInAction(() => {
        this.isLoadingPosts = false;
      });
    }
  }

  public async addPost(content: string): Promise<Post> {
    const { post } = await addPostApiMethod({
      discussionId: this._id,
      content,
      socketId: (this.store.socket && this.store.socket.id) || null,
    });

    return new Promise<Post>((resolve) => {
      runInAction(() => {
        const obj = this.addPostToLocalCache(post);
        resolve(obj);
      });
    });
  }

  public addPostToLocalCache(data) {
    const postObj = new Post({ discussion: this, store: this.store, ...data });

    this.posts.push(postObj);

    return postObj;
  }

  public async deletePost(post: Post) {
    await deletePostApiMethod({
      id: post._id,
      discussionId: this._id,
      socketId: (this.store.socket && this.store.socket.id) || null,
    });

    runInAction(() => {
      this.posts.remove(post);
    });
  }

  public joinSocketRooms() {
    if (this.store.socket) {
      console.log('joining socket discussion room', this.name);
      this.store.socket.emit('joinTeamRoom', this.team._id);
      this.store.socket.emit('joinDiscussionRoom', this._id);
    }
  }

  public leaveSocketRooms() {
    if (this.store.socket) {
      console.log('leaving socket discussion room', this.name);
      this.store.socket.emit('leaveTeamRoom', this.team._id);
      this.store.socket.emit('leaveDiscussionRoom', this._id);
    }
  }

  public handleDiscussionRealtimeEvent = (data) => {
    console.log('discussion realtime event', data);
    const { actionType } = data;

    if (actionType === 'added') {
      this.addDiscussionToLocalCache(data.discussion);
    } else if (actionType === 'edited') {
      this.editDiscussionFromLocalCache(data.discussion);
    } else if (actionType === 'deleted') {
      this.deleteDiscussionFromLocalCache(data.id);
    }
  };

  public addDiscussionToLocalCache(data): Discussion {
    const obj = new Discussion({ team: this.team, store: this.store, ...data });

    if (obj.memberIds.includes(this.store.currentUser._id)) {
      this.team.discussions.push(obj);
    }

    return obj;
  }

  public editDiscussionFromLocalCache(data) {
    const discussion = this.team.discussions.find((item) => item._id === data._id);
    if (discussion) {
      if (data.memberIds && data.memberIds.includes(this.store.currentUser._id)) {
        discussion.changeLocalCache(data);
      } else {
        this.deleteDiscussionFromLocalCache(data._id);
      }
    } else if (data.memberIds && data.memberIds.includes(this.store.currentUser._id)) {
      this.addDiscussionToLocalCache(data);
    }
  }

  public deleteDiscussionFromLocalCache(discussionId: string) {
    const discussion = this.team.discussions.find((item) => item._id === discussionId);
    this.team.discussions.remove(discussion);
  }

  public handlePostRealtimeEvent(data) {
    const { actionType } = data;

    if (actionType === 'added') {
      this.addPostToLocalCache(data.post);
    } else if (actionType === 'edited') {
      this.editPostFromLocalCache(data.post);
    } else if (actionType === 'deleted') {
      this.deletePostFromLocalCache(data.id);
    }
  }

  public editPostFromLocalCache(data) {
    const post = this.posts.find((t) => t._id === data._id);
    if (post) {
      post.changeLocalCache(data);
    }
  }

  public deletePostFromLocalCache(postId) {
    const post = this.posts.find((t) => t._id === postId);
    this.posts.remove(post);
  }

  public async sendDataToLambda({
    discussionName,
    discussionLink,
    postContent,
    authorName,
    userIds,
  }) {
    console.log(discussionName, discussionLink, authorName, postContent, userIds);
    try {
      await sendDataToLambdaApiMethod({
        discussionName,
        discussionLink,
        postContent,
        authorName,
        userIds,
      });
    } catch (error) {
      console.error(error);
      throw error;
    }
  }
}

export { Discussion };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\lib\store\index.ts -----

import { action, configure, IObservableArray, observable, makeObservable } from 'mobx';
import { enableStaticRendering } from 'mobx-react';
import { io, Socket } from 'socket.io-client';

import { addTeamApiMethod, getTeamInvitationsApiMethod } from '../api/team-leader';
import { getTeamMembersApiMethod } from '../api/team-member';

import { User } from './user';
import { Team } from './team';

const dev = process.env.NODE_ENV !== 'production';

enableStaticRendering(typeof window === 'undefined');

configure({ enforceActions: 'observed' });

class Store {
  public isServer: boolean;

  public currentUser?: User = null;
  public currentUrl = '';

  public currentTeam?: Team = null;

  public teams: IObservableArray<Team> = observable([]);

  public socket: Socket;

  constructor({
    initialState = {},
    isServer,
    socket = null,
  }: {
    initialState?: any;
    isServer: boolean;
    socket?: Socket;
  }) {
    makeObservable(this, {
      currentUser: observable,
      currentUrl: observable,
      currentTeam: observable,

      changeCurrentUrl: action,
      setCurrentUser: action,
      setCurrentTeam: action,
    });

    this.isServer = !!isServer;

    // console.log('initialState.user', initialState.user);

    this.setCurrentUser(initialState.user);

    this.currentUrl = initialState.currentUrl || '';

    // console.log(initialState);

    this.setCurrentTeam(initialState.team);

    if (initialState.teams && initialState.teams.length > 0) {
      this.setInitialTeamsStoreMethod(initialState.teams);
    }

    this.socket = socket;

    if (socket) {
      socket.on('disconnect', () => {
        console.log('socket: ## disconnected');
      });

      socket.on('reconnect', (attemptNumber) => {
        console.log('socket: $$ reconnected', attemptNumber);
      });
    }
  }

  public changeCurrentUrl(url: string) {
    this.currentUrl = url;
  }

  public async setCurrentUser(user) {
    if (user) {
      this.currentUser = new User({ store: this, ...user });
    } else {
      this.currentUser = null;
    }
  }

  public async addTeam({ name, avatarUrl }: { name: string; avatarUrl: string }): Promise<Team> {
    const data = await addTeamApiMethod({ name, avatarUrl });
    const team = new Team({ store: this, ...data });

    return team;
  }

  public async setCurrentTeam(team) {
    if (this.currentTeam) {
      if (this.currentTeam.slug === team.slug) {
        return;
      }
    }

    if (team) {
      this.currentTeam = new Team({ ...team, store: this });

      const users =
        team.initialMembers || (await getTeamMembersApiMethod(this.currentTeam._id)).users;

      const invitations =
        team.initialInvitations ||
        (await getTeamInvitationsApiMethod(this.currentTeam._id)).invitations;

      this.currentTeam.setInitialMembersAndInvitations(users, invitations);
    } else {
      this.currentTeam = null;
    }
  }

  private setInitialTeamsStoreMethod(teams: any[]) {
    // console.log(initialTeams);

    const teamObjs = teams.map((t) => new Team({ store: this, ...t }));

    this.teams.replace(teamObjs);
  }
}

let store: Store = null;

function initializeStore(initialState = {}) {
  const isServer = typeof window === 'undefined';

  const socket = isServer
    ? null
    : io(dev ? process.env.NEXT_PUBLIC_URL_API : process.env.NEXT_PUBLIC_PRODUCTION_URL_API, {
        reconnection: true,
        autoConnect: true,
        transports: ['polling', 'websocket'],
        withCredentials: true,
      });

  const _store =
    store !== null && store !== undefined ? store : new Store({ initialState, isServer, socket });

  // For SSG and SSR always create a new store
  if (typeof window === 'undefined') {
    return _store;
  }
  // Create the store once in the client
  if (!store) {
    store = _store;
  }

  // console.log(_store);

  return _store;
}

function getStore() {
  return store;
}

export { Store, initializeStore, getStore };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\lib\store\invitation.ts -----

class Invitation {
  public _id: string;
  public teamId: string;
  public email: string;
  public createdAt: Date;

  constructor(params) {
    Object.assign(this, params);
  }
}

export { Invitation };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\lib\store\post.ts -----

import { action, computed, observable, runInAction, makeObservable } from 'mobx';

import { editPostApiMethod } from '../api/team-member';

import { Store } from './index';
import { User } from './user';
import { Discussion } from './discussion';

export class Post {
  public _id: string;
  public createdUserId: string;
  public createdAt: Date;
  public discussionId: string;

  public discussion: Discussion;
  public store: Store;

  public content: string;
  public htmlContent: string;

  public isEdited: boolean;
  public lastUpdatedAt: Date;

  constructor(params) {
    makeObservable(this, {
      content: observable,
      htmlContent: observable,
      isEdited: observable,
      lastUpdatedAt: observable,

      editPost: action,
      changeLocalCache: action,

      user: computed,
    });

    this._id = params._id;
    this.createdUserId = params.createdUserId;
    this.createdAt = params.createdAt;
    this.discussionId = params.discussionId;

    this.content = params.content;
    this.htmlContent = params.htmlContent;

    this.discussion = params.discussion;
    this.store = params.store;

    this.isEdited = params.isEdited;
    this.lastUpdatedAt = params.lastUpdatedAt;
  }

  public async editPost(data) {
    try {
      await editPostApiMethod({
        id: this._id,
        content: data.content,
        socketId: (this.store.socket && this.store.socket.id) || null,
      });

      runInAction(() => {
        this.changeLocalCache(data);
      });
    } catch (error) {
      console.error(error);
      throw error;
    }
  }

  public changeLocalCache(data) {
    this.content = data.content;
    this.htmlContent = data.htmlContent;
    this.isEdited = true;
    this.lastUpdatedAt = data.lastUpdatedAt;
  }

  get user(): User {
    return this.discussion.team.members.get(this.createdUserId) || null;
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\lib\store\team.ts -----

import { action, computed, IObservableArray, observable, runInAction, makeObservable } from 'mobx';
import Router from 'next/router';
import {
  cancelSubscriptionApiMethod,
  inviteMemberApiMethod,
  removeMemberApiMethod,
  updateTeamApiMethod,
} from '../api/team-leader';
import {
  addDiscussionApiMethod,
  deleteDiscussionApiMethod,
  getDiscussionListApiMethod,
} from '../api/team-member';
import { Store } from './index';
import { User } from './user';
import { Invitation } from './invitation';
import { Discussion } from './discussion';

class Team {
  public store: Store;

  public _id: string;
  public teamLeaderId: string;

  public name: string;
  public slug: string;
  public avatarUrl: string;
  public memberIds: IObservableArray<string> = observable([]);
  public members: Map<string, User> = new Map();
  public invitations: Map<string, Invitation> = new Map();

  public currentDiscussion?: Discussion;
  public currentDiscussionSlug?: string;
  public discussions: IObservableArray<Discussion> = observable([]);
  public isLoadingDiscussions = false;

  public stripeSubscription: {
    id: string;
    object: string;
    application_fee_percent: number;
    billing: string;
    cancel_at_period_end: boolean;
    billing_cycle_anchor: number;
    canceled_at: number;
    created: number;
  };
  public isSubscriptionActive: boolean;
  public isPaymentFailed: boolean;

  constructor(params) {
    makeObservable(this, {
      name: observable,
      slug: observable,
      avatarUrl: observable,
      memberIds: observable,
      members: observable,
      invitations: observable,
      currentDiscussion: observable,
      currentDiscussionSlug: observable,
      isLoadingDiscussions: observable,
      discussions: observable,

      setInitialMembersAndInvitations: action,
      updateTheme: action,
      inviteMember: action,
      removeMember: action,
      setInitialDiscussions: action,
      loadDiscussions: action,
      addDiscussion: action,
      addDiscussionToLocalCache: action,
      deleteDiscussion: action,
      deleteDiscussionFromLocalCache: action,
      getDiscussionBySlug: action,

      orderedDiscussions: computed,
    });

    this._id = params._id;
    this.teamLeaderId = params.teamLeaderId;
    this.slug = params.slug;
    this.name = params.name;
    this.avatarUrl = params.avatarUrl;
    this.memberIds.replace(params.memberIds || []);
    this.currentDiscussionSlug = params.currentDiscussionSlug || null;

    this.stripeSubscription = params.stripeSubscription;
    this.isSubscriptionActive = params.isSubscriptionActive;
    this.isPaymentFailed = params.isPaymentFailed;

    this.store = params.store;

    if (params.initialDiscussions) {
      this.setInitialDiscussions(params.initialDiscussions);
    } else {
      this.loadDiscussions();
    }
  }

  public setInitialMembersAndInvitations(users, invitations) {
    this.members.clear();
    this.invitations.clear();

    for (const user of users) {
      if (this.store.currentUser && this.store.currentUser._id === user._id) {
        this.members.set(user._id, this.store.currentUser);
      } else {
        this.members.set(user._id, new User(user));
      }
    }

    for (const invitation of invitations || []) {
      this.invitations.set(invitation._id, new Invitation(invitation));
    }

    // console.log(this.members);
  }

  public async updateTheme({ name, avatarUrl }: { name: string; avatarUrl: string }) {
    try {
      const { slug } = await updateTeamApiMethod({
        teamId: this._id,
        name,
        avatarUrl,
      });

      runInAction(() => {
        this.name = name;
        this.avatarUrl = avatarUrl;
        this.slug = slug;
      });
    } catch (error) {
      console.error(error);
      throw error;
    }
  }

  public async inviteMember(email: string) {
    try {
      const { newInvitation } = await inviteMemberApiMethod({ teamId: this._id, email });

      runInAction(() => {
        this.invitations.set(newInvitation._id, new Invitation(newInvitation));
      });
    } catch (error) {
      console.error(error);
      throw error;
    }
  }

  public async removeMember(userId: string) {
    try {
      await removeMemberApiMethod({ teamId: this._id, userId });

      runInAction(() => {
        this.members.delete(userId);
        this.memberIds.remove(userId);
      });
    } catch (error) {
      console.error(error);
      throw error;
    }
  }

  public setCurrentDiscussion({ slug }: { slug: string }) {
    this.currentDiscussionSlug = slug;
    for (const discussion of this.discussions) {
      if (discussion && discussion.slug === slug) {
        this.currentDiscussion = discussion;
        break;
      }
    }
  }

  public setInitialDiscussions(discussions) {
    const discussionObjs = discussions.map(
      (d) => new Discussion({ team: this, store: this.store, ...d }),
    );

    this.discussions.replace(discussionObjs);

    if (!this.currentDiscussionSlug && this.discussions.length > 0) {
      this.currentDiscussionSlug = this.orderedDiscussions[0].slug;
    }

    if (this.currentDiscussionSlug) {
      this.setCurrentDiscussion({ slug: this.currentDiscussionSlug });
    }
  }

  public async loadDiscussions() {
    if (this.store.isServer || this.isLoadingDiscussions) {
      return;
    }

    this.isLoadingDiscussions = true;

    try {
      const { discussions = [] } = await getDiscussionListApiMethod({
        teamId: this._id,
      });
      const newList: Discussion[] = [];

      runInAction(() => {
        discussions.forEach((d) => {
          const disObj = this.discussions.find((obj) => obj._id === d._id);
          if (disObj) {
            disObj.changeLocalCache(d);
            newList.push(disObj);
          } else {
            newList.push(new Discussion({ team: this, store: this.store, ...d }));
          }
        });

        this.discussions.replace(newList);
      });
    } finally {
      runInAction(() => {
        this.isLoadingDiscussions = false;
      });
    }
  }

  public changeLocalCache(data) {
    this.name = data.name;
    this.memberIds.replace(data.memberIds || []);
  }

  public async addDiscussion(data): Promise<Discussion> {
    const { discussion } = await addDiscussionApiMethod({
      teamId: this._id,
      socketId: (this.store.socket && this.store.socket.id) || null,
      ...data,
    });

    return new Promise<Discussion>((resolve) => {
      runInAction(() => {
        const obj = this.addDiscussionToLocalCache(discussion);
        resolve(obj);
      });
    });
  }

  public addDiscussionToLocalCache(data): Discussion {
    const obj = new Discussion({ team: this, store: this.store, ...data });

    if (obj.memberIds.includes(this.store.currentUser._id)) {
      this.discussions.push(obj);
    }

    return obj;
  }

  public async deleteDiscussion(id: string) {
    await deleteDiscussionApiMethod({
      id,
      socketId: (this.store.socket && this.store.socket.id) || null,
    });

    runInAction(() => {
      this.deleteDiscussionFromLocalCache(id);

      const discussion = this.discussions.find((d) => d._id === id);

      if (this.currentDiscussion === discussion) {
        this.currentDiscussion = null;
        this.currentDiscussionSlug = null;

        if (this.discussions.length > 0) {
          const d = this.discussions[0];

          Router.push(
            `/discussion?teamSlug=${this.slug}&discussionSlug=${d.slug}`,
            `/teams/${this.slug}/discussions/${d.slug}`,
          );
        } else {
          Router.push(`/discussion?teamSlug=${this.slug}`, `/teams/${this.slug}/discussions`);
        }
      }
    });
  }

  public deleteDiscussionFromLocalCache(discussionId: string) {
    const discussion = this.discussions.find((item) => item._id === discussionId);
    this.discussions.remove(discussion);
  }

  public getDiscussionBySlug(slug: string): Discussion {
    return this.discussions.find((d) => d.slug === slug);
  }

  public async cancelSubscription({ teamId }: { teamId: string }) {
    try {
      const { isSubscriptionActive } = await cancelSubscriptionApiMethod({ teamId });

      runInAction(() => {
        this.isSubscriptionActive = isSubscriptionActive;
      });
    } catch (error) {
      console.error(error);
      throw error;
    }
  }

  public async checkIfTeamLeaderMustBeCustomer() {
    let ifTeamLeaderMustBeCustomerOnClient: boolean;

    if (this && this.memberIds.length < 2) {
      ifTeamLeaderMustBeCustomerOnClient = false;
    } else if (this && this.memberIds.length >= 2 && this.isSubscriptionActive) {
      ifTeamLeaderMustBeCustomerOnClient = false;
    } else if (this && this.memberIds.length >= 2 && !this.isSubscriptionActive) {
      ifTeamLeaderMustBeCustomerOnClient = true;
    }

    return ifTeamLeaderMustBeCustomerOnClient;
  }

  get orderedDiscussions() {
    return this.discussions.slice().sort();
  }
}

export { Team };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\lib\store\user.ts -----

import { action, observable, runInAction, makeObservable } from 'mobx';

import * as NProgress from 'nprogress';

import { getListOfInvoicesApiMethod } from '../api/team-leader';
import { toggleThemeApiMethod, updateProfileApiMethod } from '../api/team-member';
import { Store } from './index';

class User {
  public store: Store;

  public _id: string;
  public slug: string;
  public email: string | null;
  public displayName: string | null;
  public avatarUrl: string | null;
  public isSignedupViaGoogle: boolean;

  public darkTheme = false;
  public defaultTeamSlug: string;

  public stripeCard: {
    brand: string;
    funding: string;
    last4: string;
    exp_month: number;
    exp_year: number;
  };
  public hasCardInformation: boolean;
  public stripeListOfInvoices: {
    object: string;
    data: [
      {
        amount_paid: number;
        teamName: string;
        created: number;
        hosted_invoice_url: string;
      },
    ];
    has_more: boolean;
  };

  constructor(params) {
    makeObservable(this, {
      slug: observable,
      email: observable,
      displayName: observable,
      avatarUrl: observable,
      // darkTheme: observable,
      defaultTeamSlug: observable,
      stripeCard: observable,
      stripeListOfInvoices: observable,

      updateProfile: action,
      toggleTheme: action,
      getListOfInvoices: action,
    });

    this.store = params.store;
    this._id = params._id;
    this.slug = params.slug;
    this.email = params.email;
    this.displayName = params.displayName;
    this.avatarUrl = params.avatarUrl;
    this.isSignedupViaGoogle = !!params.isSignedupViaGoogle;
    this.darkTheme = !!params.darkTheme;
    this.defaultTeamSlug = params.defaultTeamSlug;

    this.stripeCard = params.stripeCard;
    this.hasCardInformation = params.hasCardInformation;
    this.stripeListOfInvoices = params.stripeListOfInvoices;
  }

  public async updateProfile({ name, avatarUrl }: { name: string; avatarUrl: string }) {
    const { updatedUser } = await updateProfileApiMethod({
      name,
      avatarUrl,
    });

    runInAction(() => {
      this.displayName = updatedUser.displayName;
      this.avatarUrl = updatedUser.avatarUrl;
      this.slug = updatedUser.slug;
    });
  }

  public async toggleTheme(darkTheme: boolean) {
    await toggleThemeApiMethod({ darkTheme });
    runInAction(() => {
      this.darkTheme = darkTheme;
    });
    NProgress.start();
    NProgress.set(0.5);
    window.location.reload();
  }

  public async getListOfInvoices() {
    try {
      const { stripeListOfInvoices } = await getListOfInvoicesApiMethod();
      runInAction(() => {
        this.stripeListOfInvoices = stripeListOfInvoices;
      });
    } catch (error) {
      console.error(error);
      throw error;
    }
  }
}

export { User };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\lib\confirm.ts -----

import { openConfirmDialogExternal } from '../components/common/Confirmer';

export default function confirm({
  title,
  message,
  onAnswer,
}: {
  title: string;
  message: string;
  onAnswer: (answer) => void;
}) {
  openConfirmDialogExternal({ title, message, onAnswer });
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\lib\gtag.ts -----

const { NEXT_PUBLIC_GA_MEASUREMENT_ID } = process.env;

// https://developers.google.com/analytics/devguides/collection/gtagjs/pages
export const pageview = (url) => {
  (window as any).gtag('config', NEXT_PUBLIC_GA_MEASUREMENT_ID, {
    page_location: url,
  });
};

// https://developers.google.com/analytics/devguides/collection/gtagjs/events
export const event = ({ action, category, label }) => {
  (window as any).gtag('event', action, {
    event_category: category,
    event_label: label,
  });
};

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\lib\isMobile.ts -----

const mobileRE =
  /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i;

export function isMobile(opts) {
  if (!opts) {
    opts = {};
  }

  let ua = opts.ua;

  if (!ua && typeof navigator !== 'undefined') {
    ua = navigator.userAgent;
  }

  if (!ua && opts.req && opts.req.headers && typeof opts.req.headers['user-agent'] === 'string') {
    ua = opts.req.headers['user-agent'];
    // console.log(ua);
  }

  if (typeof ua !== 'string') {
    return false;
  }

  return mobileRE.test(ua);
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\lib\notify.ts -----

import { openSnackbarExternal } from '../components/common/Notifier';

export default function notify(obj) {
  openSnackbarExternal({ message: obj.message || obj.toString() });
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\lib\resizeImage.ts -----

function resizeImage(file: File, MAX_WIDTH, MAX_HEIGHT) {
  const image = document.createElement('img');

  const resize = (resolve) => () => {
    let isResizeNeeded = false;
    let width = image.width;
    let height = image.height;

    if (width > height) {
      if (width > MAX_WIDTH) {
        isResizeNeeded = true;
        height *= MAX_WIDTH / width;
        width = MAX_WIDTH;
      }
    } else {
      if (height > MAX_HEIGHT) {
        isResizeNeeded = true;
        width *= MAX_HEIGHT / height;
        height = MAX_HEIGHT;
      }
    }

    if (isResizeNeeded) {
      const canvas = document.createElement('canvas');

      canvas.width = width;
      canvas.height = height;

      console.log(width, height);

      const ctx = canvas.getContext('2d');
      ctx.drawImage(image, 0, 0, width, height);

      canvas.toBlob((blob) => {
        resolve(blob);
      }, file.type);
    } else {
      resolve(file);
    }
  };

  return new Promise((resolve) => {
    const reader = new FileReader();

    console.log(`before ${image.src}`);

    reader.readAsDataURL(file);

    reader.onload = (e) => {
      image.src = e.target.result.toString();

      image.onload = resize(resolve);

      console.log(`after ${image.src}`);
    };
  });
}

export { resizeImage };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\lib\sharedStyles.ts -----

const styleBigAvatar = {
  width: '80px',
  height: '80px',
  margin: '0px auto 15px',
};

const styleRaisedButton = {
  margin: '15px',
};

const styleToolbar = {
  background: '#FFF',
  height: '64px',
  paddingRight: '20px',
};

const styleTextField = {
  color: '#222',
  fontWeight: '300',
};

const styleForm = {
  margin: '7% auto',
  width: '360px',
};

export { styleBigAvatar, styleRaisedButton, styleToolbar, styleTextField, styleForm };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\lib\theme.ts -----

import { createTheme } from '@mui/material/styles';

const themeDark = createTheme({
  palette: {
    primary: { main: '#238636' },
    secondary: { main: '#b62324' },
    mode: 'dark',
    background: { default: '#0d1117' },
    text: {
      primary: '#c9d1d9',
    },
  },
  typography: {
    fontFamily: ['IBM Plex Mono', 'monospace'].join(','),
    button: {
      textTransform: 'none',
    },
  },
});

const themeLight = createTheme({
  palette: {
    primary: { main: '#238636' },
    secondary: { main: '#b62324' },
    mode: 'light',
    background: { default: '#fff' },
    text: {
      primary: '#222',
    },
  },
  typography: {
    fontFamily: ['IBM Plex Mono', 'monospace'].join(','),
    button: {
      textTransform: 'none',
    },
  },
});

export { themeDark, themeLight };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\lib\withAuth.tsx -----

import { observer } from 'mobx-react';
import Router from 'next/router';
import React from 'react';

import * as NProgress from 'nprogress';

import * as gtag from './gtag';

import { Store, getStore } from './store';

Router.events.on('routeChangeStart', () => {
  NProgress.start();
});

Router.events.on('routeChangeComplete', (url) => {
  const store = getStore();
  if (store) {
    store.changeCurrentUrl(url);
  }

  if (window) {
    gtag.pageview(url);
    gtag.event({
      action: 'view_item',
      category: 'engagement',
      label: store.currentUser ? store.currentUser.email : 'no_email',
    });
  }

  NProgress.done();
});

Router.events.on('routeChangeError', () => NProgress.done());

export default function withAuth(Component, { loginRequired = true, logoutRequired = false } = {}) {
  class WithAuth extends React.Component<{ store: Store }> {
    public static async getInitialProps(ctx) {
      // console.log('WithAuth.getInitialProps');

      const { req } = ctx;

      let pageComponentProps = {};

      if (Component.getInitialProps) {
        pageComponentProps = await Component.getInitialProps(ctx);
      }

      return {
        ...pageComponentProps,
        isServer: !!req,
      };
    }

    public componentDidMount() {
      // console.log('WithAuth.componentDidMount');

      const { store } = this.props;
      const user = store.currentUser;

      if (loginRequired && !logoutRequired && !user) {
        Router.push('/login');
        return;
      }

      let redirectUrl = '/login';
      let asUrl = '/login';
      if (user) {
        if (!user.defaultTeamSlug) {
          redirectUrl = '/create-team';
          asUrl = '/create-team';
        } else {
          redirectUrl = `/your-settings?teamSlug=${user.defaultTeamSlug}`;
          asUrl = `/teams/${user.defaultTeamSlug}/your-settings`;
        }
      }

      if (logoutRequired && user) {
        Router.push(redirectUrl, asUrl);
      }
    }

    public render() {
      const { store } = this.props;
      const user = store.currentUser;

      if (loginRequired && !logoutRequired && !user) {
        return null;
      }

      if (logoutRequired && user) {
        return null;
      }

      return <Component {...this.props} />;
    }
  }

  return observer(WithAuth);
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\pages\billing.tsx -----

import { observer } from 'mobx-react';
import moment from 'moment';
import Head from 'next/head';

import * as React from 'react';
import { useState, useEffect } from 'react';

import { loadStripe } from '@stripe/stripe-js';
import Button from '@mui/material/Button';
import DoneIcon from '@mui/icons-material/Done';
import NProgress from 'nprogress';

import Layout from '../components/layout';
import notify from '../lib/notify';
import { Store } from '../lib/store';
import withAuth from '../lib/withAuth';
import { fetchCheckoutSessionApiMethod } from '../lib/api/team-leader';

const dev = process.env.NODE_ENV !== 'production';

const stripePromise = loadStripe(
  dev
    ? process.env.NEXT_PUBLIC_STRIPE_TEST_PUBLISHABLEKEY
    : process.env.NEXT_PUBLIC_STRIPE_LIVE_PUBLISHABLEKEY,
);

type Props = {
  store: Store;
  isMobile: boolean;
  firstGridItem: boolean;
  teamRequired: boolean;
  teamSlug: string;
  redirectMessage?: string;
};

function Billing({
  store,
  isMobile,
  firstGridItem,
  teamRequired,
  teamSlug,
  redirectMessage,
}: Props) {
  const [disabled, setDisabled] = useState<boolean>(false);
  const [showInvoices, setShowInvoices] = useState<boolean>(false);

  useEffect(() => {
    if (redirectMessage) {
      notify(redirectMessage);
    }
  }, []);

  const handleCheckoutClick = async (mode: 'subscription' | 'setup') => {
    try {
      const { currentTeam } = store;

      NProgress.start();
      setDisabled(true);

      const { sessionId } = await fetchCheckoutSessionApiMethod({ mode, teamId: currentTeam._id });

      // console.log(process.env.NEXT_PUBLIC_STRIPE_TEST_PUBLISHABLEKEY, sessionId);

      // When the customer clicks on the button, redirect them to Checkout.
      const stripe = await stripePromise;
      const { error } = await stripe.redirectToCheckout({ sessionId });

      if (error) {
        notify(error);
        console.error(error);
      }
    } catch (err) {
      notify(err);
      console.error(err);
    } finally {
      setDisabled(false);
      NProgress.done();
    }
  };

  const cancelSubscriptionOnClick = async () => {
    const { currentTeam } = store;

    NProgress.start();
    setDisabled(true);

    try {
      await currentTeam.cancelSubscription({ teamId: currentTeam._id });
      notify('Success!');
    } catch (err) {
      notify(err);
    } finally {
      setDisabled(false);
      NProgress.done();
    }
  };

  const renderCardInfo = () => {
    const { currentUser } = store;

    if (currentUser && currentUser.hasCardInformation) {
      return (
        <span>
          {' '}
          <DoneIcon color="action" style={{ verticalAlign: 'text-bottom' }} /> Your default payment
          method:
          <li>
            {currentUser.stripeCard.brand}, {currentUser.stripeCard.funding} card
          </li>
          <li>Last 4 digits: *{currentUser.stripeCard.last4}</li>
          <li>
            Expiration: {currentUser.stripeCard.exp_month}/{currentUser.stripeCard.exp_year}
          </li>
          <p />
          <Button
            variant="outlined"
            color="primary"
            onClick={() => handleCheckoutClick('setup')}
            disabled={disabled}
          >
            Update card
          </Button>
        </span>
      );
    } else {
      return 'You have not added a card.';
    }
  };

  const renderInvoices = () => {
    const { currentUser } = store;

    if (!showInvoices) {
      return null;
    }

    if (currentUser && currentUser.stripeCard) {
      return (
        <React.Fragment>
          {currentUser.stripeListOfInvoices.data.map((invoice, i) => (
            <React.Fragment key={i}>
              <p>Your history of payments:</p>
              <li>
                ${invoice.amount_paid / 100} was paid on{' '}
                {moment(invoice.created * 1000).format('MMM Do YYYY')} for Team '{invoice.teamName}'
                -{' '}
                <a href={invoice.hosted_invoice_url} target="_blank" rel="noopener noreferrer">
                  See invoice
                </a>
              </li>
            </React.Fragment>
          ))}
        </React.Fragment>
      );
    } else {
      return 'You have no history of payments.';
    }
  };

  const showListOfInvoicesOnClick = async () => {
    const { currentUser } = store;

    NProgress.start();
    setDisabled(true);

    try {
      await currentUser.getListOfInvoices();
      setShowInvoices(true);
    } catch (err) {
      notify(err);
    } finally {
      setDisabled(false);
      NProgress.done();
    }
  };

  const renderSubscriptionButton = () => {
    const { currentTeam } = store;

    let subscriptionDate;
    let billingDay;
    if (currentTeam && currentTeam.stripeSubscription) {
      subscriptionDate = moment(currentTeam.stripeSubscription.billing_cycle_anchor * 1000).format(
        'MMM Do YYYY',
      );
      billingDay = moment(currentTeam.stripeSubscription.billing_cycle_anchor * 1000).format('Do');
    }

    if (currentTeam && !currentTeam.isSubscriptionActive && currentTeam.isPaymentFailed) {
      return (
        <>
          <p>You are not a paying customer.</p>
          <Button
            variant="contained"
            color="primary"
            onClick={() => handleCheckoutClick('subscription')}
            disabled={disabled}
          >
            Buy subscription
          </Button>
          <p />
          <p>
            Team was automatically unsubscribed due to failed payment. You will be prompt to update
            card information if you choose to re-subscribe Team.
          </p>
        </>
      );
    } else if (currentTeam && !currentTeam.isSubscriptionActive && !currentTeam.isPaymentFailed) {
      return (
        <React.Fragment>
          <p>You are not a paying customer.</p>
          <p>
            Buy subscription using your current card, see below section for current card
            information.
          </p>
          <Button
            variant="contained"
            color="primary"
            onClick={() => handleCheckoutClick('subscription')}
            disabled={disabled}
          >
            Buy subscription
          </Button>
        </React.Fragment>
      );
    } else {
      return (
        <React.Fragment>
          <span>
            {' '}
            <DoneIcon color="action" style={{ verticalAlign: 'text-bottom' }} /> Subscription is
            active.
            <p>
              You subscribed <b>{currentTeam.name}</b> on <b>{subscriptionDate}</b>.
            </p>
            <p>
              You will be billed $50 on <b>{billingDay} day</b> of each month unless you cancel
              subscription or subscription is cancelled automatically due to failed payment.
            </p>
          </span>
          <p />
          <Button
            variant="outlined"
            color="primary"
            onClick={cancelSubscriptionOnClick}
            disabled={disabled}
          >
            Unsubscribe Team
          </Button>
          <br />
        </React.Fragment>
      );
    }
  };

  const { currentTeam, currentUser } = store;
  const isTeamLeader = currentTeam && currentUser && currentUser._id === currentTeam.teamLeaderId;

  if (!currentTeam || currentTeam.slug !== teamSlug) {
    return (
      <Layout
        store={store}
        isMobile={isMobile}
        teamRequired={teamRequired}
        firstGridItem={firstGridItem}
      >
        <div style={{ padding: isMobile ? '0px' : '0px 30px' }}>
          <p>You did not select any team.</p>
          <p>
            To access this page, please select existing team or create new team if you have no
            teams.
          </p>
        </div>
      </Layout>
    );
  }

  if (!isTeamLeader) {
    return (
      <Layout
        store={store}
        isMobile={isMobile}
        teamRequired={teamRequired}
        firstGridItem={firstGridItem}
      >
        <div style={{ padding: isMobile ? '0px' : '0px 30px' }}>
          <p>Only the Team Leader can access this page.</p>
          <p>Create your own team to become a Team Leader.</p>
        </div>
      </Layout>
    );
  }

  return (
    <Layout
      store={store}
      isMobile={isMobile}
      teamRequired={teamRequired}
      firstGridItem={firstGridItem}
    >
      <Head>
        <title>Your Billing</title>
      </Head>
      <div style={{ padding: isMobile ? '0px' : '0px 30px' }}>
        <h3>Your Billing</h3>
        <p />
        <h4 style={{ marginTop: '40px' }}>Paid plan</h4>
        {renderSubscriptionButton()}
        <p />
        <br />
        <h4>Card information</h4>
        {renderCardInfo()}
        <p />
        <br />
        <h4>Payment history</h4>
        <Button
          variant="outlined"
          color="primary"
          onClick={showListOfInvoicesOnClick}
          disabled={disabled}
        >
          Show payment history
        </Button>
        <p />
        {renderInvoices()}
        <p />
        <br />
      </div>
    </Layout>
  );
}

export default withAuth(observer(Billing));

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\pages\create-team.tsx -----

import { inject, observer } from 'mobx-react';
import * as React from 'react';
import { useState } from 'react';

import Avatar from '@mui/material/Avatar';
import Button from '@mui/material/Button';
import Grid from '@mui/material/Grid';
import TextField from '@mui/material/TextField';

import Head from 'next/head';
import { useRouter } from 'next/router';

import {
  getSignedRequestForUploadApiMethod,
  uploadFileUsingSignedPutRequestApiMethod,
} from '../lib/api/team-member';
import notify from '../lib/notify';
import { resizeImage } from '../lib/resizeImage';
import { Store } from '../lib/store';
import withAuth from '../lib/withAuth';

import Layout from '../components/layout';

const styleGrid = {
  height: '100%',
};

type Props = { store: Store; isMobile: boolean; firstGridItem: boolean; teamRequired: boolean };

function CreateTeam({ store, isMobile, firstGridItem, teamRequired }: Props) {
  const [newName, setNewName] = useState<string>('');
  const [newAvatarUrl, setNewAvatarUrl] = useState<string>(
    'https://storage.googleapis.com/async-await/default-user.png?v=1',
  );
  const [disabled, setDisabled] = useState<boolean>(false);

  const router = useRouter();

  const onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();

    if (!newName) {
      notify('Team name is required.');
      return;
    }

    const file = (document.getElementById('upload-file') as HTMLFormElement).files[0];

    try {
      setDisabled(true);

      const defaultAvatarUrl = 'https://storage.googleapis.com/async-await/default-user.png?v=1';

      const team = await store.addTeam({
        name: newName,
        avatarUrl: defaultAvatarUrl,
      });

      console.log(`Returned to client: ${team._id}, ${team.name}, ${team.slug}`);

      if (file == null) {
        notify('You successfully created Team.<p />Redirecting...');
        router.push(`/teams/${team.slug}/team-settings`);
        return;
      }

      const fileName = file.name;
      const fileType = file.type;
      const bucket = process.env.NEXT_PUBLIC_BUCKET_FOR_TEAM_LOGOS;
      const prefix = team.slug;

      const responseFromApiServerForUpload = await getSignedRequestForUploadApiMethod({
        fileName,
        fileType,
        prefix,
        bucket,
      });

      const resizedFile = await resizeImage(file, 128, 128);

      await uploadFileUsingSignedPutRequestApiMethod(
        resizedFile,
        responseFromApiServerForUpload.signedRequest,
        {
          'Cache-Control': 'max-age=2592000',
        },
      );

      const uploadedAvatarUrl = responseFromApiServerForUpload.url;

      await team.updateTheme({ name: team.name, avatarUrl: uploadedAvatarUrl });

      setNewName('');
      setNewAvatarUrl('https://storage.googleapis.com/async-await/default-user.png?v=1');

      (document.getElementById('upload-file') as HTMLFormElement).value = '';

      notify('You successfully created Team. Redirecting ...');

      router.push(`/teams/${team.slug}/team-settings`);
    } catch (error) {
      console.log(error);
      notify(error);
    } finally {
      setDisabled(false);
    }
  };

  const previewTeamLogo = () => {
    const file = (document.getElementById('upload-file') as HTMLFormElement).files[0];
    if (!file) {
      return;
    }

    const reader = new FileReader();

    reader.readAsDataURL(file);

    reader.onload = (e) => {
      setNewAvatarUrl(e.target.result as string);
    };
  };

  return (
    <Layout
      store={store}
      isMobile={isMobile}
      teamRequired={teamRequired}
      firstGridItem={firstGridItem}
    >
      <Head>
        <title>Create Team</title>
        <meta name="description" content="Create a new Team at SaaS Boilerplate" />
      </Head>
      <div style={{ padding: '0px', fontSize: '14px', height: '100%' }}>
        <Grid container style={styleGrid}>
          <Grid item sm={12} xs={12} style={{ padding: isMobile ? '0px' : '0px 30px' }}>
            <h3>Create team</h3>
            <p />
            <form onSubmit={onSubmit}>
              <h4>Team name</h4>
              <TextField
                value={newName}
                label="Type your team's name."
                helperText="Team name as seen by your team members."
                onChange={(event) => {
                  setNewName(event.target.value);
                }}
              />
              <p />
              <h4 style={{ marginTop: '40px' }}>Team logo (optional)</h4>
              <Avatar
                src={newAvatarUrl}
                style={{
                  display: 'inline-flex',
                  verticalAlign: 'middle',
                  marginRight: 20,
                  width: 60,
                  height: 60,
                }}
              />
              <label htmlFor="upload-file">
                <Button variant="outlined" color="primary" component="span">
                  Select team logo
                </Button>
              </label>
              <input
                accept="image/*"
                name="upload-file"
                id="upload-file"
                type="file"
                style={{ display: 'none' }}
                onChange={previewTeamLogo}
              />
              <p />
              <br />
              <br />
              <Button variant="contained" color="primary" type="submit" disabled={disabled}>
                Create new team
              </Button>
            </form>
          </Grid>
        </Grid>
        <br />
      </div>
    </Layout>
  );
}

export default withAuth(inject('store')(observer(CreateTeam)));

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\pages\discussion.tsx -----

import Avatar from '@mui/material/Avatar';
import Tooltip from '@mui/material/Tooltip';
import Head from 'next/head';
import Router from 'next/router';
import * as React from 'react';
import { useState, useEffect, useRef } from 'react';

import { observer } from 'mobx-react';

import Layout from '../components/layout';
import PostDetail from '../components/posts/PostDetail';
import PostForm from '../components/posts/PostForm';
import notify from '../lib/notify';
import { Store } from '../lib/store';
import { Discussion } from '../lib/store/discussion';
import withAuth from '../lib/withAuth';
import { Post } from 'lib/store/post';

type Props = {
  store: Store;
  teamSlug: string;
  discussionSlug: string;
  isServer: boolean;
  isMobile: boolean;
  firstGridItem: boolean;
  teamRequired: boolean;
};

function DiscussionPageCompFunctional({
  store,
  teamSlug,
  discussionSlug,
  isServer,
  isMobile,
  firstGridItem,
  teamRequired,
}: Props) {
  const [selectedPost, setSelectedPost] = useState<Post>(null);
  const [showMarkdownClicked, setShowMarkdownClicked] = useState<boolean>(false);

  function usePrevious(value) {
    const ref = useRef();
    useEffect(() => {
      ref.current = value;
    });
    return ref.current;
  }

  const prevDiscussionSlug = usePrevious(discussionSlug);

  const mounted = useRef();

  useEffect(() => {
    if (!mounted.current) {
      console.log('useEffect 1 for DiscussionPageCompFunctional');

      if (store.currentTeam && (!isServer || !discussionSlug)) {
        store.currentTeam.loadDiscussions().catch((err) => notify(err));
      }

      const discussion = getDiscussion(discussionSlug);

      if (discussion) {
        discussion.joinSocketRooms();
      }

      // console.log(store.socket);

      store.socket.on('discussionEvent', handleDiscussionEvent);
      store.socket.on('postEvent', handlePostEvent);
      store.socket.on('reconnect', handleSocketReconnect);

      (mounted as any).current = true;
    } else {
      console.log('useEffect 2 for DiscussionPageCompFunctional');

      if (prevDiscussionSlug) {
        const prevDiscussion = getDiscussion(prevDiscussionSlug);
        if (prevDiscussion) {
          prevDiscussion.leaveSocketRooms();
        }
      }

      const discussion = getDiscussion(discussionSlug);

      if (!isServer && discussion) {
        discussion.loadPosts().catch((err) => notify(err));
      }

      if (discussion) {
        discussion.joinSocketRooms();
      }
    }

    return () => {
      const discussion = getDiscussion(discussionSlug);

      if (discussion) {
        discussion.leaveSocketRooms();
      }

      store.socket.off('discussionEvent', handleDiscussionEvent);
      store.socket.off('postEvent', handlePostEvent);
      store.socket.off('reconnect', handleSocketReconnect);
    };
  }, [discussionSlug]);

  const { currentTeam } = store;

  const getDiscussion = (slug: string): Discussion => {
    if (!currentTeam) {
      return;
    }

    if (!slug && currentTeam.discussions.length > 0) {
      Router.replace(
        `/discussion?teamSlug=${teamSlug}&discussionSlug=${currentTeam.orderedDiscussions[0].slug}`,
        `/teams/${teamSlug}/discussions/${currentTeam.orderedDiscussions[0].slug}`,
      );
      return;
    }

    if (slug && currentTeam) {
      return currentTeam.getDiscussionBySlug(slug);
    }

    return null;
  };

  const renderPosts = () => {
    const discussion = getDiscussion(discussionSlug);

    if (!discussion.isLoadingPosts && discussion.posts.length === 0) {
      return <p>Empty Discussion.</p>;
    }

    let loading = 'loading Posts ...';
    if (discussion.posts.length > 0) {
      loading = 'checking for newer Posts ...';
    }

    return (
      <React.Fragment>
        {discussion
          ? discussion.posts.map((p) =>
              selectedPost && selectedPost._id === p._id ? (
                <PostForm
                  store={store}
                  isMobile={isMobile}
                  key={p._id}
                  post={p}
                  showMarkdownToNonCreator={showMarkdownClicked}
                  discussion={discussion}
                  members={discussion.members}
                  onFinished={() => {
                    setSelectedPost(null);
                    setShowMarkdownClicked(false);
                  }}
                />
              ) : (
                <PostDetail
                  key={p._id}
                  post={p}
                  onEditClick={onEditClickCallback}
                  onShowMarkdownClick={onSnowMarkdownClickCallback}
                  isMobile={isMobile}
                  store={store}
                />
              ),
            )
          : null}

        {discussion && discussion.isLoadingPosts && !isServer ? <p>{loading}</p> : null}
      </React.Fragment>
    );
  };

  const onEditClickCallback = (post) => {
    setSelectedPost(post);
    setShowMarkdownClicked(false);
  };

  const onSnowMarkdownClickCallback = (post) => {
    setSelectedPost(post);
    setShowMarkdownClicked(true);
  };

  const handleDiscussionEvent = (data) => {
    // console.log('discussion realtime event', data);

    const discussion = getDiscussion(discussionSlug);
    if (discussion) {
      discussion.handleDiscussionRealtimeEvent(data);
    }
  };

  const handlePostEvent = (data) => {
    // console.log('post realtime event', data);

    const discussion = getDiscussion(discussionSlug);
    if (discussion) {
      discussion.handlePostRealtimeEvent(data);
    }
  };

  const handleSocketReconnect = () => {
    console.log('pages/discussion.tsx: socket re-connected');

    const discussion = getDiscussion(discussionSlug);
    if (discussion) {
      discussion.loadPosts().catch((err) => notify(err));
      discussion.joinSocketRooms();
    }
  };

  if (!currentTeam || currentTeam.slug !== teamSlug) {
    return (
      <Layout
        store={store}
        isMobile={isMobile}
        firstGridItem={firstGridItem}
        teamRequired={teamRequired}
      >
        <Head>
          <title>No Team is found.</title>
        </Head>
        <div style={{ padding: isMobile ? '0px' : '0px 30px' }}>No Team is found.</div>
      </Layout>
    );
  }

  const discussion = getDiscussion(discussionSlug);

  if (!discussion) {
    if (currentTeam.isLoadingDiscussions) {
      return (
        <Layout
          store={store}
          isMobile={isMobile}
          firstGridItem={firstGridItem}
          teamRequired={teamRequired}
        >
          <Head>
            <title>Loading...</title>
          </Head>
          <div style={{ padding: isMobile ? '0px' : '0px 30px' }}>
            <p>Loading Discussions...</p>
          </div>
        </Layout>
      );
    } else {
      return (
        <Layout
          store={store}
          isMobile={isMobile}
          firstGridItem={firstGridItem}
          teamRequired={teamRequired}
        >
          <Head>
            <title>No Discussion is found.</title>
          </Head>
          <div style={{ padding: isMobile ? '0px' : '0px 30px' }}>
            <p>No Discussion is found.</p>
          </div>
        </Layout>
      );
    }
  }

  const title = discussion ? `${discussion.name}  Discussion` : 'Discussions';

  return (
    <Layout
      store={store}
      isMobile={isMobile}
      firstGridItem={firstGridItem}
      teamRequired={teamRequired}
    >
      <Head>
        <title>{title}</title>
      </Head>
      <div style={{ padding: isMobile ? '0px' : '0px 30px', height: '100vh' }}>
        <h4>
          <span style={{ fontWeight: 300 }}>Discussion : </span>
          {(discussion && discussion.name) || 'No Discussion is found.'}
        </h4>{' '}
        Visible to :{' '}
        {discussion
          ? discussion.members.map((m) => (
              <Tooltip
                title={m.displayName}
                placement="right"
                disableFocusListener
                disableTouchListener
                key={m._id}
              >
                <Avatar
                  role="presentation"
                  src={m.avatarUrl}
                  alt={m.avatarUrl}
                  key={m._id}
                  style={{
                    margin: '0px 5px',
                    display: 'inline-flex',
                    width: '30px',
                    height: '30px',
                    verticalAlign: 'middle',
                  }}
                />
              </Tooltip>
            ))
          : null}
        <p />
        {renderPosts()}
        {discussion && !discussion.isLoadingPosts ? (
          <React.Fragment>
            {selectedPost ? null : (
              <PostForm
                post={null}
                discussion={discussion}
                members={discussion.members}
                isMobile={isMobile}
                store={store}
              />
            )}
          </React.Fragment>
        ) : null}
        <p />
        <br />
      </div>
    </Layout>
  );
}

export default withAuth(observer(DiscussionPageCompFunctional));

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\pages\invitation.tsx -----

import Avatar from '@mui/material/Avatar';
import { observer } from 'mobx-react';
import Error from 'next/error';
import Head from 'next/head';
import Router from 'next/router';
import { NextPageContext } from 'next';

import React from 'react';
import { useEffect } from 'react';

import LoginButton from '../components/common/LoginButton';
import Layout from '../components/layout';
import { getTeamByTokenApiMethod } from '../lib/api/public';
import { Team } from '../lib/store/team';
import { Store } from '../lib/store';
import withAuth from '../lib/withAuth';

const dev = process.env.NODE_ENV !== 'production';

type Props = {
  store: Store;
  isMobile: boolean;
  firstGridItem: boolean;
  teamRequired: boolean;
  team: Team;
  token: string;
};

function InvitationPageComp({ store, isMobile, firstGridItem, teamRequired, team, token }: Props) {
  useEffect(() => {
    const user = store.currentUser;

    if (user && team) {
      Router.push(
        `${
          dev ? process.env.NEXT_PUBLIC_URL_API : process.env.NEXT_PUBLIC_PRODUCTION_URL_API
        }/logout?invitationToken=${token}`,
        `${
          dev ? process.env.NEXT_PUBLIC_URL_API : process.env.NEXT_PUBLIC_PRODUCTION_URL_API
        }/logout`,
      );
    }
  }, []);

  if (!team) {
    return <Error statusCode={404} />;
  }

  const user = store.currentUser;

  if (user) {
    return null;
  }

  return (
    <Layout
      store={store}
      isMobile={isMobile}
      teamRequired={teamRequired}
      firstGridItem={firstGridItem}
    >
      <Head>
        <title>Invitation to {team.name}</title>
        <meta name="description" content={`Invitation to join ${team.name}`} />
      </Head>
      <div style={{ textAlign: 'center', margin: '0 20px' }}>
        <br />
        <Avatar
          src={`${
            team.avatarUrl || 'https://storage.googleapis.com/async-await/default-user.png?v=1'
          }`}
          alt="Team logo"
          style={{
            verticalAlign: 'middle',
            display: 'inline-flex',
          }}
        />{' '}
        <h2>{team.name}</h2>
        <p>
          Join <b>{team.name}</b> by logging in or signing up.
        </p>
        <br />
        <LoginButton invitationToken={token} />
      </div>
    </Layout>
  );
}

InvitationPageComp.getInitialProps = async (ctx: NextPageContext) => {
  const { token } = ctx.query;

  if (!token) {
    return {};
  }

  try {
    const { team } = await getTeamByTokenApiMethod(token as string, ctx.req);

    return { team, token };
  } catch (error) {
    console.log(error);
    return {};
  }
};

// export async function getServerSideProps(context: NextPageContext) {
//   const { token } = context.query;

//   try {
//     const { team } = await getTeamByTokenApiMethod(token as string, context.req);

//     if (team && token) {
//       return { props: { team, token } };
//     } else {
//       return { props: {} };
//     }
//   } catch (error) {
//     console.log(error);
//     return { props: {} };
//   }
// }

// see our explanation for not using getServerSideProps at this time: https://github.com/async-labs/saas/issues/193

export default withAuth(observer(InvitationPageComp), { loginRequired: false });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\pages\login-cached.tsx -----

import Head from 'next/head';
import React from 'react';
import LoginButton from '../components/common/LoginButton';
import Layout from '../components/layout';
import withAuth from '../lib/withAuth';
import { Store } from '../lib/store';

type Props = {
  store: Store;
  isMobile: boolean;
  firstGridItem: boolean;
};

function Login({ store, isMobile, firstGridItem }: Props) {
  return (
    <Layout store={store} isMobile={isMobile} firstGridItem={firstGridItem}>
      <div style={{ textAlign: 'center', margin: '0 20px' }}>
        <Head>
          <title>Log in or Sign up to SaaS boilerplate</title>
          <meta
            name="description"
            content="Login and signup page for SaaS boilerplate demo by Async"
          />
        </Head>
        <br />
        <p style={{ margin: '45px auto', fontSize: '44px', fontWeight: 400 }}>Log in or Sign up</p>
        <p>Youll be logged in for 14 days unless you log out manually.</p>
        <br />
        <LoginButton />
      </div>
    </Layout>
  );
}

export default withAuth(Login, { logoutRequired: true });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\pages\login.tsx -----

import Head from 'next/head';
import React from 'react';
import LoginButton from '../components/common/LoginButton';
import Layout from '../components/layout';
import withAuth from '../lib/withAuth';
import { Store } from '../lib/store';

type Props = {
  store: Store;
  isMobile: boolean;
  firstGridItem: boolean;
};

function Login({ store, isMobile, firstGridItem }: Props) {
  return (
    <Layout store={store} isMobile={isMobile} firstGridItem={firstGridItem}>
      <div style={{ textAlign: 'center', margin: '0 20px' }}>
        <Head>
          <title>Log in or Sign up to SaaS boilerplate</title>
          <meta
            name="description"
            content="Login and signup page for SaaS boilerplate demo by Async"
          />
        </Head>
        <br />
        <p style={{ margin: '45px auto', fontSize: '44px', fontWeight: 400 }}>Log in or Sign up</p>
        <p>Youll be logged in for 14 days unless you log out manually.</p>
        <br />
        <LoginButton />
      </div>
    </Layout>
  );
}

export default withAuth(Login, { logoutRequired: true });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\pages\team-settings.tsx -----

import Avatar from '@mui/material/Avatar';
import Button from '@mui/material/Button';
import Hidden from '@mui/material/Hidden';
import TextField from '@mui/material/TextField';
import DeleteOutlineIcon from '@mui/icons-material/DeleteOutline';
import { inject, observer } from 'mobx-react';
import Head from 'next/head';
import NProgress from 'nprogress';

import * as React from 'react';
import { useState } from 'react';

import Table from '@mui/material/Table';
import TableBody from '@mui/material/TableBody';
import TableCell from '@mui/material/TableCell';
import TableContainer from '@mui/material/TableContainer';
import TableHead from '@mui/material/TableHead';
import TableRow from '@mui/material/TableRow';

import Layout from '../components/layout';
import InviteMember from '../components/teams/InviteMember';
import {
  getSignedRequestForUploadApiMethod,
  uploadFileUsingSignedPutRequestApiMethod,
} from '../lib/api/team-member';
import confirm from '../lib/confirm';
import notify from '../lib/notify';
import { resizeImage } from '../lib/resizeImage';
import { Store } from '../lib/store';
import withAuth from '../lib/withAuth';

type Props = {
  store: Store;
  isMobile: boolean;
  firstGridItem: boolean;
  teamRequired: boolean;
  teamSlug: string;
};

function TeamSettings({ store, isMobile, firstGridItem, teamRequired, teamSlug }: Props) {
  const [newName, setNewName] = useState<string>(store.currentTeam.name);
  const [newAvatarUrl, setNewAvatarUrl] = useState<string>(store.currentTeam.avatarUrl);
  const [disabled, setDisabled] = useState<boolean>(false);
  const [inviteMemberOpen, setInviteMemberOpen] = useState<boolean>(false);

  const onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    const { currentTeam } = store;

    if (!newName) {
      notify('Team name is required');
      return;
    }

    NProgress.start();
    setDisabled(true);

    try {
      await currentTeam.updateTheme({ name: newName, avatarUrl: newAvatarUrl });

      notify('You successfully updated Team name.');
    } catch (error) {
      notify(error);
    } finally {
      setDisabled(false);
      NProgress.done();
    }
  };

  const uploadFile = async () => {
    const { currentTeam } = store;

    const fileElement = document.getElementById('upload-file-team-logo') as HTMLFormElement;
    const file = fileElement.files[0];

    if (file == null) {
      notify('No file selected for upload.');
      return;
    }

    const fileName = file.name;
    const fileType = file.type;

    NProgress.start();
    setDisabled(true);

    const bucket = process.env.NEXT_PUBLIC_BUCKET_FOR_TEAM_LOGOS;
    const prefix = `${currentTeam.slug}`;

    console.log(bucket);

    try {
      const responseFromApiServerForUpload = await getSignedRequestForUploadApiMethod({
        fileName,
        fileType,
        prefix,
        bucket,
      });

      const resizedFile = await resizeImage(file, 128, 128);

      await uploadFileUsingSignedPutRequestApiMethod(
        resizedFile,
        responseFromApiServerForUpload.signedRequest,
        { 'Cache-Control': 'max-age=2592000' },
      );

      setNewAvatarUrl(responseFromApiServerForUpload.url);

      await currentTeam.updateTheme({
        name: newName,
        avatarUrl: newAvatarUrl,
      });

      notify('You successfully uploaded new Team logo.');
    } catch (error) {
      notify(error);
    } finally {
      setDisabled(false);
      NProgress.done();
    }
  };

  const openInviteMember = async () => {
    const { currentTeam } = store;
    if (!currentTeam) {
      notify('You have not selected a Team.');
      return;
    }

    const ifTeamLeaderMustBeCustomer = await currentTeam.checkIfTeamLeaderMustBeCustomer();

    if (ifTeamLeaderMustBeCustomer) {
      notify(
        'To add a third team member, you have to become a paid customer.' +
          '<p />' +
          ' To become a paid customer,' +
          ' navigate to Billing page.',
      );
      return;
    }

    setInviteMemberOpen(true);
  };

  const handleInviteMemberClose = () => {
    setInviteMemberOpen(false);
  };

  const removeMember = (event) => {
    const { currentTeam } = store;

    if (!currentTeam) {
      notify('You have not selected a Team.');
      return;
    }

    const userId = event.currentTarget.dataset.id;
    if (!userId) {
      notify('Select user.');
      return;
    }

    confirm({
      title: 'Are you sure?',
      message: '',
      onAnswer: async (answer) => {
        if (answer) {
          try {
            await currentTeam.removeMember(userId);
          } catch (error) {
            notify(error);
          }
        }
      },
    });
  };

  const { currentTeam, currentUser } = store;
  const isTeamLeader = currentTeam && currentUser && currentUser._id === currentTeam.teamLeaderId;

  if (!currentTeam || currentTeam.slug !== teamSlug) {
    return (
      <Layout
        store={store}
        isMobile={isMobile}
        teamRequired={teamRequired}
        firstGridItem={firstGridItem}
      >
        <div style={{ padding: isMobile ? '0px' : '0px 30px' }}>
          <p>You did not select any team.</p>
          <p>
            To access this page, please select existing team or create new team if you have no
            teams.
          </p>
        </div>
      </Layout>
    );
  }

  if (!isTeamLeader) {
    return (
      <Layout
        store={store}
        isMobile={isMobile}
        teamRequired={teamRequired}
        firstGridItem={firstGridItem}
      >
        <div style={{ padding: isMobile ? '0px' : '0px 30px' }}>
          <p>Only the Team Leader can access this page.</p>
          <p>Create your own team to become a Team Leader.</p>
        </div>
      </Layout>
    );
  }

  return (
    <Layout
      store={store}
      isMobile={isMobile}
      teamRequired={teamRequired}
      firstGridItem={firstGridItem}
    >
      <Head>
        <title>Team Settings</title>
      </Head>
      <div style={{ padding: isMobile ? '0px' : '0px 30px', fontSize: '15px', height: '100%' }}>
        <h3>Team Settings</h3>
        <p />
        <br />
        <form onSubmit={onSubmit}>
          <h4>Team name</h4>
          <TextField
            value={newName}
            helperText="Team name as seen by your team members"
            onChange={(event) => {
              setNewName(event.target.value);
            }}
          />
          <br />
          <br />
          <Button variant="contained" color="primary" type="submit" disabled={disabled}>
            Update username
          </Button>
        </form>
        <p />
        <br />
        <h4>Team logo</h4>
        <Avatar
          src={newAvatarUrl}
          style={{
            display: 'inline-flex',
            verticalAlign: 'middle',
            marginRight: 20,
            width: 60,
            height: 60,
          }}
        />
        <label htmlFor="upload-file-team-logo">
          <Button variant="contained" color="primary" component="span" disabled={disabled}>
            Update logo
          </Button>
        </label>
        <input
          accept="image/*"
          name="upload-file-team-logo"
          id="upload-file-team-logo"
          type="file"
          style={{ display: 'none' }}
          onChange={uploadFile}
        />
        <p />
        <br />
        <br />
        <h4 style={{ marginRight: 20, display: 'inline' }}>
          Team Members ( {Array.from(currentTeam.members.values()).length} / 20 )
        </h4>
        <Button
          onClick={openInviteMember}
          variant="contained"
          color="primary"
          style={{ float: 'right', marginTop: '-20px' }}
          disabled={disabled}
        >
          Invite member
        </Button>
        <p />
        <TableContainer>
          <Table>
            <TableHead>
              <TableRow>
                <TableCell>Person</TableCell>
                <TableCell>Role</TableCell>
                <TableCell>Action</TableCell>
              </TableRow>
            </TableHead>

            <TableBody>
              {currentTeam.memberIds
                .map((userId) => currentTeam.members.get(userId))
                .map((m) => (
                  <TableRow key={m._id}>
                    <TableCell style={{ width: '300px' }}>
                      <Hidden mdDown>
                        <Avatar
                          role="presentation"
                          src={m.avatarUrl}
                          alt={(m.displayName || m.email)[0]}
                          key={m._id}
                          style={{
                            margin: '0px 5px',
                            display: 'inline-flex',
                            width: '30px',
                            height: '30px',
                            verticalAlign: 'middle',
                          }}
                        />
                      </Hidden>
                      {m.email}
                    </TableCell>
                    <TableCell>
                      {isTeamLeader && m._id !== currentUser._id ? 'Team Member' : 'Team Leader'}
                    </TableCell>
                    <TableCell>
                      {isTeamLeader && m._id !== currentUser._id ? (
                        <DeleteOutlineIcon
                          color="action"
                          data-id={m._id}
                          onClick={removeMember}
                          style={{
                            marginLeft: '20px',
                            fontSize: '16px',
                            opacity: 0.6,
                            cursor: 'pointer',
                            verticalAlign: 'middle',
                          }}
                        />
                      ) : null}
                    </TableCell>
                  </TableRow>
                ))}
            </TableBody>
          </Table>
        </TableContainer>

        <p />
        <br />

        {Array.from(currentTeam.invitations.values()).length > 0 ? (
          <React.Fragment>
            <h4>Invited users</h4>
            <p />
            <TableContainer>
              <Table>
                <TableHead>
                  <TableRow>
                    <TableCell>Email</TableCell>
                    <TableCell>Status</TableCell>
                  </TableRow>
                </TableHead>

                <TableBody>
                  {Array.from(currentTeam.invitations.values()).map((i) => (
                    <TableRow key={i._id}>
                      <TableCell style={{ width: '300px' }}>{i.email}</TableCell>
                      <TableCell>Sent</TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            </TableContainer>
          </React.Fragment>
        ) : null}
        <p />
        <br />
        <InviteMember open={inviteMemberOpen} onClose={handleInviteMemberClose} store={store} />
        <br />
      </div>
    </Layout>
  );
}

export default withAuth(inject('store')(observer(TeamSettings)));

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\pages\your-settings.tsx -----

import Avatar from '@mui/material/Avatar';
import Button from '@mui/material/Button';
import TextField from '@mui/material/TextField';
import DoneIcon from '@mui/icons-material/Done';

import Table from '@mui/material/Table';
import TableBody from '@mui/material/TableBody';
import TableCell from '@mui/material/TableCell';
import TableContainer from '@mui/material/TableContainer';
import TableHead from '@mui/material/TableHead';
import TableRow from '@mui/material/TableRow';

import { inject, observer } from 'mobx-react';
import Head from 'next/head';
import Link from 'next/link';
import NProgress from 'nprogress';

import * as React from 'react';
import { useState } from 'react';

import Layout from '../components/layout';

import {
  getSignedRequestForUploadApiMethod,
  uploadFileUsingSignedPutRequestApiMethod,
} from '../lib/api/team-member';

import notify from '../lib/notify';
import { resizeImage } from '../lib/resizeImage';
import { Store } from '../lib/store';
import withAuth from '../lib/withAuth';

const dev = process.env.NODE_ENV !== 'production';
const URL_APP = dev ? process.env.NEXT_PUBLIC_URL_APP : process.env.NEXT_PUBLIC_PRODUCTION_URL_APP;

type Props = {
  store: Store;
  isMobile: boolean;
  firstGridItem: boolean;
  teamRequired: boolean;
};

function YourSettings({ store, isMobile, firstGridItem, teamRequired }: Props) {
  const [newName, setNewName] = useState<string>(store.currentUser.displayName);
  const [newAvatarUrl, setNewAvatarUrl] = useState<string>(store.currentUser.avatarUrl);
  const [disabled, setDisabled] = useState<boolean>(false);

  const onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();

    const { currentUser } = store;

    if (!newName) {
      notify('Name is required');
      return;
    }

    NProgress.start();
    setDisabled(true);

    try {
      await currentUser.updateProfile({ name: newName, avatarUrl: newAvatarUrl });

      notify('You successfully updated your profile.');
    } catch (error) {
      notify(error);
    } finally {
      setDisabled(false);
      NProgress.done();
    }
  };

  const uploadFile = async () => {
    const fileElement = document.getElementById('upload-file-user-avatar') as HTMLFormElement;
    const file = fileElement.files[0];

    const { currentUser } = store;

    if (file == null) {
      notify('No file selected for upload.');
      return;
    }

    const fileName = file.name;
    const fileType = file.type;

    NProgress.start();
    setDisabled(true);

    const bucket = process.env.NEXT_PUBLIC_BUCKET_FOR_AVATARS;

    const prefix = `${currentUser.slug}`;

    try {
      const responseFromApiServerForUpload = await getSignedRequestForUploadApiMethod({
        fileName,
        fileType,
        prefix,
        bucket,
      });

      const resizedFile = await resizeImage(file, 128, 128);

      // console.log(file);
      // console.log(resizedFile);

      await uploadFileUsingSignedPutRequestApiMethod(
        resizedFile,
        responseFromApiServerForUpload.signedRequest,
        { 'Cache-Control': 'max-age=2592000' },
      );

      setNewAvatarUrl(responseFromApiServerForUpload.url);

      await currentUser.updateProfile({
        name: newName,
        avatarUrl: newAvatarUrl,
      });

      notify('You successfully uploaded new avatar.');
    } catch (error) {
      notify(error);
    } finally {
      fileElement.value = '';
      setDisabled(false);
      NProgress.done();
    }
  };

  const { currentUser } = store;

  return (
    <Layout
      store={store}
      isMobile={isMobile}
      teamRequired={teamRequired}
      firstGridItem={firstGridItem}
    >
      <Head>
        <title>Your Settings at Async</title>
      </Head>
      <div
        style={{
          padding: isMobile ? '0px' : '0px 30px',
          height: '100%',
        }}
      >
        <h3>Your Settings</h3>
        <h4 style={{ marginTop: '40px' }}>Your account</h4>
        <div>
          <DoneIcon color="action" style={{ verticalAlign: 'text-bottom' }} />{' '}
          {currentUser.isSignedupViaGoogle
            ? 'You signed up on Async using your Google account.'
            : 'You signed up on Async using your email.'}
          <p />
          <li>
            Your email: <b>{currentUser.email}</b>
          </li>
          <li>
            Your username: <b>{currentUser.displayName}</b>
          </li>
        </div>
        <form onSubmit={onSubmit} autoComplete="off">
          <h4>Your username</h4>
          <TextField
            autoComplete="off"
            value={newName}
            helperText="Your username as seen by your team members"
            onChange={(event) => {
              setNewName(event.target.value);
            }}
          />
          <br />
          <br />
          <Button variant="contained" color="primary" type="submit" disabled={disabled}>
            Update username
          </Button>
        </form>

        <br />
        <h4>Your photo</h4>
        <Avatar
          src={newAvatarUrl}
          style={{
            display: 'inline-flex',
            verticalAlign: 'middle',
            marginRight: 20,
            width: 60,
            height: 60,
          }}
        />
        <label htmlFor="upload-file-user-avatar">
          <Button variant="outlined" color="primary" component="span" disabled={disabled}>
            Update avatar
          </Button>
        </label>
        <input
          accept="image/*"
          name="upload-file-user-avatar"
          id="upload-file-user-avatar"
          type="file"
          style={{ display: 'none' }}
          onChange={uploadFile}
        />
        <p />
        <br />
        <h4 style={{ marginRight: 20, display: 'inline' }}>Your Teams</h4>
        <Link href={`${URL_APP}/create-team`}>
          <Button
            variant="contained"
            color="primary"
            style={{
              fontSize: isMobile ? '13px' : '14px',
              marginTop: isMobile ? '10px' : '-20px',
              float: 'right',
            }}
          >
            + Add team
          </Button>
        </Link>
        <TableContainer>
          <Table>
            <TableHead>
              <TableRow>
                <TableCell>Team name</TableCell>
                <TableCell>Team slug</TableCell>
                <TableCell>Action</TableCell>
              </TableRow>
            </TableHead>

            <TableBody>
              {store.teams.map((t) => (
                <TableRow key={t._id}>
                  <TableCell style={{ width: '300px' }}>{t.name}</TableCell>
                  <TableCell>{t.slug}</TableCell>
                  <TableCell>
                    <Link href={`${URL_APP}/teams/${t.slug}/discussions`}>
                      <Button
                        variant="contained"
                        color="primary"
                        style={{
                          fontSize: isMobile ? '13px' : '14px',
                          marginTop: isMobile ? '10px' : 'inherit',
                        }}
                      >
                        See team
                      </Button>
                    </Link>
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </TableContainer>
      </div>
    </Layout>
  );
}

export default withAuth(inject('store')(observer(YourSettings)));

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\pages\_app.tsx -----

import createCache from '@emotion/cache';
import { CacheProvider } from '@emotion/react';
import CssBaseline from '@mui/material/CssBaseline';
import { ThemeProvider } from '@mui/material/styles';
import { Provider } from 'mobx-react';
import Head from 'next/head';
import React from 'react';

import { themeDark, themeLight } from '../lib/theme';
import { getUserApiMethod } from '../lib/api/public';
import { getInitialDataApiMethod } from '../lib/api/team-member';
import { isMobile } from '../lib/isMobile';
import { getStore, initializeStore, Store } from '../lib/store';

// import type { AppProps } from 'next/app';
import { NextPage, NextPageContext } from 'next';

// add types
type Props = {
  Component: NextPage;
  pageProps: any;
  initialState: any;
};

function MyApp({ Component, pageProps, initialState }: Props) {
  // console.log('initialState', initialState);

  const store: Store = initializeStore(initialState);

  // console.log('store.currentUser.email', store.currentUser);

  const isThemeDark = store.currentUser ? store.currentUser.darkTheme : true;

  const isServer = typeof window === 'undefined';

  return (
    <CacheProvider value={createCache({ key: 'css', prepend: true })}>
      <ThemeProvider theme={isThemeDark ? themeDark : themeLight}>
        <Head>
          <meta name="viewport" content="width=device-width, initial-scale=1.0" />
          <link rel="stylesheet" href={isServer ? '/fonts/server.css' : '/fonts/cdn.css'} />
          <link
            rel="stylesheet"
            href={
              isThemeDark
                ? 'https://storage.googleapis.com/async-await/nprogress-light-spinner.css'
                : 'https://storage.googleapis.com/async-await/nprogress-dark-spinner.css'
            }
          />
        </Head>
        <CssBaseline />
        <Provider store={store}>
          <Component {...pageProps} store={store} />
        </Provider>
      </ThemeProvider>
    </CacheProvider>
  );
}

MyApp.getInitialProps = async ({
  Component,
  ctx,
}: {
  Component: NextPage;
  ctx: NextPageContext;
}) => {
  // console.log('MyApp.getInitialProps');

  let firstGridItem = true;
  let teamRequired = false;

  if (
    ctx.pathname.includes('/login') ||
    ctx.pathname.includes('/create-team') ||
    ctx.pathname.includes('/invitation')
  ) {
    firstGridItem = false;
  }

  if (
    ctx.pathname.includes('/your-settings') ||
    ctx.pathname.includes('/team-settings') ||
    ctx.pathname.includes('/discussion') ||
    ctx.pathname.includes('/billing')
  ) {
    teamRequired = true;
  }

  const { teamSlug, discussionSlug, redirectMessage } = ctx.query;

  const pageProps = {
    isMobile: isMobile({ req: ctx.req }),
    firstGridItem,
    teamRequired,
    teamSlug,
    discussionSlug,
    redirectMessage,
  };

  if (Component.getInitialProps) {
    Object.assign(pageProps, await Component.getInitialProps(ctx));
  }

  const appProps = { pageProps };

  // console.log('before getStore');

  const store = getStore();
  if (store) {
    return appProps;
  }

  let userObj = null;
  try {
    const { user } = await getUserApiMethod(ctx.req);
    userObj = user;
  } catch (error) {
    console.log(error);
  }

  let initialData;

  if (userObj) {
    try {
      initialData = await getInitialDataApiMethod({
        request: ctx.req,
        data: { teamSlug, discussionSlug },
      });
    } catch (error) {
      console.error(error);
    }
  }

  // console.log(initialData);

  let selectedTeamSlug = '';

  if (teamSlug) {
    selectedTeamSlug = teamSlug as string;
  } else {
    selectedTeamSlug = userObj && userObj.defaultTeamSlug;
  }

  const team =
    initialData && initialData.teams && initialData.teams.find((t) => t.slug === selectedTeamSlug);

  // console.log('userObj', userObj);

  return {
    ...appProps,
    initialState: { user: userObj, currentUrl: ctx.asPath, team, teamSlug, ...initialData },
  };
};

export default MyApp;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\pages\_document.tsx -----

import Document, { DocumentContext, Head, Html, Main, NextScript } from 'next/document';

import React from 'react';

import createEmotionServer from '@emotion/server/create-instance';
import createCache from '@emotion/cache';

function MyDocument({ __NEXT_DATA__ }: { __NEXT_DATA__: any }) {
  const isThemeDark = __NEXT_DATA__.props.initialState.user
    ? __NEXT_DATA__.props.initialState.user.darkTheme
    : true;

  return (
    <Html lang="en">
      <Head>
        <meta charSet="utf-8" />
        <meta name="google" content="notranslate" />
        <meta name="theme-color" content="#303030" />

        <link
          rel="shortcut icon"
          href="https://storage.googleapis.com/async-await/async-favicon32.png"
        />

        <link
          rel="stylesheet"
          href={
            isThemeDark
              ? 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/a11y-dark.min.css'
              : 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/a11y-light.min.css'
          }
        />

        <style>
          {`
          #__next {
            width: 100%;
            height: 100%;
          }
          a {
            font-weight: 400;
            color: #58a6ff;
            text-decoration: none;
            outline: none;
          }
          hr {
            border: 0.5px #707070 solid;
            color: #000;
          }
          blockquote {
            padding: 0 0.5em;
            margin: 20px 1em;
            border-left: 0.25em solid #dfe2e5;
            color: #000;
          }
          pre {
            display: block;
            overflow-x: auto;
            padding: 0.5em;
            background: #d0d0d0;
            border: 1px solid #ddd;
            font-size: 14px;
            color: #000;
          }
          pre code {
            font-size: 13px;
            background: #d0d0d0;
            padding: 0px;
            color: #000;
          }
          code {
            font-size: 13px;
            background: #d0d0d0;
            padding: 3px 5px;
            color: #000;
          }
          mark {
            background-color: #ffff0060;
          }
          summary:focus {
            outline: none;
          }
          table {
            border-collapse: collapse;
            margin: 15px 0px;
          }
          table, th, td {
            border: 1px solid #a1a1a1;
          }
          th, td {
            line-height: 1.5em;
            padding: 10px;
          }
        `}
        </style>
        <script
          async
          src={`https://www.googletagmanager.com/gtag/js?id=${process.env.NEXT_PUBLIC_GA_MEASUREMENT_ID}`}
        />
        <script
          dangerouslySetInnerHTML={{
            __html: `
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', '${process.env.NEXT_PUBLIC_GA_MEASUREMENT_ID}', {
            page_path: window.location.pathname,
          });
        `,
          }}
        />
      </Head>
      <body>
        <Main />
        <NextScript />
      </body>
    </Html>
  );
}

MyDocument.getInitialProps = async (ctx: DocumentContext) => {
  // Render app and page and get the context of the page with collected side effects.
  const originalRenderPage = ctx.renderPage;

  // You can consider sharing the same emotion cache between all the SSR requests to speed up performance.
  // However, be aware that it can have global side effects.
  const cache = createCache({ key: 'css' });
  const { extractCriticalToChunks } = createEmotionServer(cache);

  ctx.renderPage = () =>
    originalRenderPage({
      // eslint-disable-next-line react/display-name
      enhanceApp: (App: any) => (props) => <App emotionCache={cache} {...props} />,
    });

  const initialProps = await Document.getInitialProps(ctx);
  // This is important. It prevents emotion to render invalid HTML.
  // See https://github.com/mui-org/material-ui/issues/26561#issuecomment-855286153
  const emotionStyles = extractCriticalToChunks(initialProps.html);
  const emotionStyleTags = emotionStyles.styles.map((style) => (
    <style
      data-emotion={`${style.key} ${style.ids.join(' ')}`}
      key={style.key}
      // eslint-disable-next-line react/no-danger
      dangerouslySetInnerHTML={{ __html: style.css }}
    />
  ));

  return {
    ...initialProps,
    // Styles fragment is rendered after the app and page rendering finish.
    styles: [...React.Children.toArray(initialProps.styles), ...emotionStyleTags],
  };
};

export default MyDocument;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\server\routesWithCache.ts -----

import { LRUCache } from 'lru-cache';

export default function routesWithCache({ server, app }) {
  const ssrCache = new LRUCache({
    max: 100, // 100 items
    ttl: 1000 * 60 * 60, // in ms, 1hr
  });

  function getCacheKey(req) {
    if (req.user) {
      return `${req.url}${req.user.id}`;
    }
    return `${req.url}`;
  }

  async function renderAndCache(req, res, pagePath, queryParams) {
    const key = getCacheKey(req);

    if (ssrCache.has(key)) {
      res.setHeader('x-cache', 'HIT');
      res.send(ssrCache.get(key));
      return;
    }

    try {
      const renderedPage = await app.renderToHTML(req, res, pagePath, queryParams);

      ssrCache.set(key, renderedPage);

      res.send(renderedPage);
    } catch (err) {
      app.renderError(err, req, res, pagePath, queryParams);
    }
  }

  server.get('/login-cached', (req, res) => {
    renderAndCache(req, res, '/login-cached', {});
  });
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\server\server.ts -----

import express from 'express';
import next from 'next';

import setupSitemapAndRobots from './setupSitemapAndRobots';

import routesWithCache from './routesWithCache';

const dev = process.env.NODE_ENV !== 'production';
const port = process.env.PORT || 3000;

const app = next({ dev });
const handle = app.getRequestHandler();

app.prepare().then(() => {
  const server = express();

  // give all Nextjs's request to next server before anything else
  server.get('/_next/*', (req, res) => {
    // console.log('next server, page');
    handle(req, res);
  });

  server.use(express.json());

  if (!dev) {
    server.set('trust proxy', 1); // sets req.hostname, req.ip
  }

  server.get('/', async (req: any, res) => {
    let redirectUrl = 'login';

    if (req.user) {
      if (!req.user.defaultTeamSlug) {
        redirectUrl = 'create-team';
      } else {
        redirectUrl = `team/${req.user.defaultTeamSlug}/discussions`;
      }
    }

    res.redirect(
      `${
        dev ? process.env.NEXT_PUBLIC_URL_APP : process.env.NEXT_PUBLIC_PRODUCTION_URL_APP
      }/${redirectUrl}`,
    );
  });

  // server.get('/api/v1/public/get-user', (_, res) => {
  //   res.json({ user: { email: 'team@builderbook.org' } });
  // });

  server.get('/teams/:teamSlug/your-settings', (req, res) => {
    const { teamSlug } = req.params;
    app.render(req, res, '/your-settings', { teamSlug });
  });

  server.get('/teams/:teamSlug/team-settings', (req, res) => {
    const { teamSlug } = req.params;
    app.render(req, res, '/team-settings', { teamSlug });
  });

  server.get('/teams/:teamSlug/billing', (req, res) => {
    const { teamSlug } = req.params;
    app.render(req, res, '/billing', { teamSlug, ...(req.query || {}) });
  });

  server.get('/teams/:teamSlug/discussions/:discussionSlug', (req, res) => {
    const { teamSlug, discussionSlug } = req.params;
    app.render(req, res, '/discussion', { teamSlug, discussionSlug });
  });

  server.get('/teams/:teamSlug/discussions', (req, res) => {
    const { teamSlug } = req.params;
    app.render(req, res, '/discussion', { teamSlug });
  });

  server.get('/signup', (req, res) => {
    app.render(req, res, '/login');
  });

  server.get('/invitation', (req, res) => {
    app.render(req, res, '/invitation', { token: req.query.token as string });
  });

  setupSitemapAndRobots({ server });

  routesWithCache({ server, app });

  server.get('*', (req, res) => {
    handle(req, res);
  });

  // listen(handle: any, listeningListener?: () => void): http.Server;
  // "@types/express-serve-static-core", "version": "4.17.1"
  server.listen(port, () => {
    console.log(
      `> Ready on ${
        dev ? process.env.NEXT_PUBLIC_URL_APP : process.env.NEXT_PUBLIC_PRODUCTION_URL_APP
      }`,
    );
  });
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\server\setupSitemapAndRobots.ts -----

import { SitemapStream, streamToPromise } from 'sitemap';
import path from 'path';
import zlib from 'zlib';

const dev = process.env.NODE_ENV !== 'production';

export default function setupSitemapAndRobots({ server }) {
  let sitemap;

  server.get('/sitemap.xml', async (_, res) => {
    res.header('Content-Type', 'application/xml');
    res.header('Content-Encoding', 'gzip');

    if (sitemap) {
      res.send(sitemap);
      return;
    }

    try {
      const smStream = new SitemapStream({
        hostname: dev ? process.env.NEXT_PUBLIC_URL_APP : process.env.NEXT_PUBLIC_PRODUCTION_URL_APP,
      });
      const gzip = zlib.createGzip();

      smStream.write({
        url: '/login',
        changefreq: 'daily',
        priority: 1,
      });

      streamToPromise(smStream.pipe(gzip)).then((sm) => (sitemap = sm));

      smStream.end();

      smStream
        .pipe(gzip)
        .pipe(res)
        .on('error', (err) => {
          throw err;
        });
    } catch (err) {
      console.error(err);
      res.status(500).end();
    }
  });

  server.get('/robots.txt', (_, res) => {
    res.sendFile(path.join(__dirname, '../static', 'robots.txt'));
  });
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\.eslintrc.js -----

module.exports = {
  settings: {
    react: { version: 'detect' },
  },
  parser: '@typescript-eslint/parser',
  extends: ['plugin:react/recommended', 'plugin:@typescript-eslint/recommended', 'prettier'],
  env: {
    es6: true,
    node: true,
  },
  plugins: ['prettier', 'react'],
  rules: {
    'prettier/prettier': [
      'error',
      {
        singleQuote: true,
        trailingComma: 'all',
        arrowParens: 'always',
        printWidth: 100,
        semi: true,
      },
    ],
    '@typescript-eslint/camelcase': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    'react/no-unescaped-entities': 'off',
    'react/jsx-filename-extension': ['error', { extensions: ['.tsx'] }],
    '@typescript-eslint/no-explicit-any': 'off',
    'prefer-arrow-callback': 'error',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
  },
};

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\next-env.d.ts -----

/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/pages/api-reference/config/typescript for more information.

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\next.config.js -----

module.exports = {
  poweredByHeader: false,
  webpack5: true,
  typescript: {
    ignoreBuildErrors: true,
  },
};

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\nodemon.json -----

{
  "watch": ["server"],
  "exec": "ts-node --project tsconfig.server.json",
  "ext": "ts"
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\package.json -----

{
  "name": "app-same-as-10-end-app",
  "version": "1.0.0",
  "license": "MIT",
  "engines": {
    "node": ">=18.17.0",
    "yarn": ">=1.22.19"
  },
  "scripts": {
    "dev": "nodemon server/server.ts",
    "lint": "eslint . --ext .ts,.tsx",
    "postinstall": "rm -rf production-server/",
    "build": "next build && tsc --project tsconfig.server.json && cp server/robots.txt production-server",
    "start": "node production-server/server.js"
  },
  "dependencies": {
    "@emotion/cache": "^11.14.0",
    "@emotion/react": "^11.14.0",
    "@emotion/server": "^11.11.0",
    "@emotion/styled": "^11.14.0",
    "@mui/icons-material": "^6.4.8",
    "@mui/material": "^6.4.8",
    "@mui/system": "^6.4.8",
    "@stripe/stripe-js": "^6.1.0",
    "express": "^4.21.2",
    "he": "^1.2.0",
    "isomorphic-unfetch": "^4.0.1",
    "keycode": "^2.2.0",
    "lru-cache": "^11.0.2",
    "marked": "^15.0.7",
    "mobx": "^6.13.7",
    "mobx-react": "^9.2.0",
    "moment": "^2.30.1",
    "next": "^15.2.3",
    "next-transpile-modules": "^10.0.1",
    "nprogress": "0.2.0",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-mentions": "^4.4.10",
    "sitemap": "^8.0.0",
    "socket.io-client": "^4.8.1",
    "typescript": "^5.8.2"
  },
  "devDependencies": {
    "@babel/core": "^7.26.10",
    "@babel/plugin-proposal-private-methods": "^7.18.6",
    "@babel/plugin-proposal-private-property-in-object": "^7.21.11",
    "@types/express": "^5.0.1",
    "@types/he": "^1.2.3",
    "@types/node": "^22.13.11",
    "@types/react": "^19.0.12",
    "@types/react-dom": "^19.0.4",
    "@typescript-eslint/eslint-plugin": "^8.27.0",
    "@typescript-eslint/parser": "^8.27.0",
    "babel-eslint": "^10.1.0",
    "eslint": "^9.22.0",
    "eslint-config-prettier": "^10.1.1",
    "eslint-plugin-prettier": "^5.2.3",
    "eslint-plugin-react": "^7.37.4",
    "nodemon": "^3.1.9",
    "prettier": "^3.5.3",
    "ts-node": "^10.9.2"
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\tsconfig.json -----

{
  "compileOnSave": false,
  "compilerOptions": {
    "target": "esnext",
    "module": "esnext",
    "jsx": "preserve",
    "allowJs": true,
    "alwaysStrict": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "removeComments": true,
    "preserveConstEnums": true,
    "sourceMap": false,
    "skipLibCheck": true,
    "baseUrl": ".",
    "typeRoots": [
      "./node_modules/@types"
    ],
    "lib": [
      "dom",
      "es2017"
    ],
    "strict": false,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "incremental": true,
    "experimentalDecorators": true ,
    "useDefineForClassFields": true,
  },
  "include": [
    "next-env.d.ts",
    "./**/*.tsx",
    "./**/*.ts"
  ],
  "exclude": [
    "dist",
    "production-server",
    ".next",
    "out",
    "next.config.js",
    "node_modules"
  ]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\app\tsconfig.server.json -----

{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "module": "commonjs",
    "outDir": "production-server/",
    "target": "es2017",
    "isolatedModules": false,
    "noEmit": false
  },
  "exclude": ["./server/types.d.ts"],
  "include": ["./server/**/*.ts"],
  "typeRoots": ["./node_modules/@types", "./server/types.d.ts"]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\lambda\.eslintrc.js -----

module.exports = {
  parser: "@typescript-eslint/parser",
  extends: ["plugin:@typescript-eslint/recommended", "prettier"],
  env: {
    "es6": true,
    "node": true,
  },
  rules: {
    'prettier/prettier': [
      'error',
      {
        singleQuote: true,
        trailingComma: 'all',
        arrowParens: 'always',
        printWidth: 100,
        semi: true,
      },
    ],
    '@typescript-eslint/no-unused-vars': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/no-explicit-any': 'off',
    'prefer-arrow-callback': 'error',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
 },
  plugins: [
    "prettier",
  ]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\lambda\handler.ts -----

import * as mongoose from 'mongoose';

import sendEmail from './api/server/aws-ses';
import getEmailTemplate from './api/server/models/EmailTemplate';
import User from './api/server/models/User';

const dev = process.env.NODE_ENV !== 'production';

export const sendEmailForNewPost = async (event) => {
  console.log('Received event (request representation):', JSON.stringify(event));

  const reqBody = JSON.parse(event.body);

  const { discussionName, discussionLink, postContent, authorName, userIds } = reqBody;

  if (
    discussionName === undefined ||
    discussionLink === undefined ||
    postContent === undefined ||
    authorName === undefined ||
    userIds === undefined
  ) {
    throw new Error('Missing data');
  }

  console.log(discussionName, discussionLink, postContent, authorName, userIds);

  await mongoose.connect(dev ? process.env.MONGO_URL_TEST : process.env.MONGO_URL, {
    useNewUrlParser: true,
    useCreateIndex: true,
    useFindAndModify: false,
    useUnifiedTopology: true,
  });

  try {
    const emailTemplate = await getEmailTemplate('newPost', {
      discussionName,
      discussionLink,
      postContent,
      authorName,
    });

    if (!emailTemplate) {
      throw new Error('newPost Email template not found');
    }

    const usersToNotify = await User.find({ _id: { $in: userIds } })
      .select('email')
      .setOptions({ lean: true });

    console.log('usersToNotify', usersToNotify);

    const jobs = usersToNotify
      .filter((user) => !!user.email)
      .map(async (user) => {
        try {
          await sendEmail({
            from: `From async-await.com <${process.env.EMAIL_SUPPORT_FROM_ADDRESS}>`,
            to: [user.email],
            subject: emailTemplate.subject,
            body: emailTemplate.message,
          });
          console.log('email is sent');
        } catch (err) {
          console.error(err.stack);
        }
      });

    await Promise.all(jobs);
  } catch (error) {
    console.error(error.stack);
    return { error: error.message, event };
  } finally {
    await mongoose.disconnect();
  }

  const response = {
    statusCode: 200,
    headers: {
      'Access-Control-Allow-Headers': 'Content-Type',
      'Access-Control-Allow-Origin': dev ? process.env.URL_APP : process.env.PRODUCTION_URL_APP,
      'Access-Control-Allow-Methods': 'OPTIONS,POST,GET',
      'Access-Control-Allow-Credentials': true,
    },
    body: JSON.stringify({
      message: 'Email notification was sent!',
      input: event,
    }),
  };

  // console.log(dev ? process.env.URL_APP : process.env.PRODUCTION_URL_APP);

  return response;
};

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\lambda\package.json -----

{
  "name": "lambda",
  "version": "1.0.0",
  "license": "MIT",
  "scripts": {
    "lint": "eslint . --ext .ts,.tsx"
  },
  "dependencies": {
    "aws-sdk": "^2.1286.0",
    "bcrypt": "^5.1.0",
    "connect-mongo": "^4.6.0",
    "cors": "^2.8.5",
    "dotenv": "^16.0.3",
    "express": "^4.18.2",
    "express-session": "^1.17.3",
    "he": "^1.2.0",
    "highlight.js": "^11.7.0",
    "lodash": "^4.17.21",
    "marked": "^4.2.5",
    "mongoose": "^6.8.2",
    "node-fetch": "^3.3.0",
    "passport": "^0.6.0",
    "passport-google-oauth": "^2.0.0",
    "passwordless": "^1.1.3",
    "passwordless-tokenstore": "^0.0.10",
    "socket.io": "^4.5.4",
    "stripe": "^11.5.0",
    "typescript": "^4.9.4",
    "winston": "^3.8.2"
  },
  "devDependencies": {
    "@types/connect-mongo": "^3.1.3",
    "@types/dotenv": "^8.2.0",
    "@types/express": "^4.17.15",
    "@types/express-session": "^1.17.5",
    "@types/jest": "^29.2.5",
    "@types/lodash": "^4.14.191",
    "@types/mongoose": "^5.11.97",
    "@types/node": "^18.11.18",
    "@types/node-fetch": "^2.6.2",
    "@types/passport": "^1.0.11",
    "@types/socket.io": "^3.0.2",
    "@typescript-eslint/eslint-plugin": "^5.47.1",
    "@typescript-eslint/parser": "^5.47.1",
    "eslint": "^8.31.0",
    "eslint-config-prettier": "^8.5.0",
    "eslint-plugin-prettier": "^4.2.1",
    "jest": "^29.3.1",
    "prettier": "^2.8.1",
    "serverless-dotenv-plugin": "^4.0.2",
    "serverless-plugin-typescript": "^2.1.4",
    "ts-jest": "^29.0.3",
    "ts-node-dev": "^2.0.0"
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\10-end-functional\lambda\tsconfig.json -----

{
  "compileOnSave": false,
  "compilerOptions": {
    "jsx": "preserve",
    "allowJs": true,
    "alwaysStrict": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "removeComments": false,
    "preserveConstEnums": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "sourceMap": true,
    "skipLibCheck": true,
    "baseUrl": ".",
    "experimentalDecorators": true,
    "typeRoots": ["./node_modules/@types"],
    "lib": ["es2015", "es2016"],
    "module": "commonjs",
    "outDir": ".build/",
    "rootDir": "./"
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-begin\app\pages\index.tsx -----

import React from 'react';
import Head from 'next/head';

const Index = () => (
  <div>
    <Head>
      <title>Index page</title>
      <meta name="description" content="This is a description of the Index page" />
    </Head>
    <div style={{ padding: '0px 30px', fontSize: '15px', height: '100%', color: '#222' }}>
      <p>Content on Index page</p>
    </div>
  </div>
);

export default Index;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-begin\app\pages\_app.tsx -----

import App from 'next/app';
import React from 'react';

class MyApp extends App {
  public render() {
    const { Component, pageProps } = this.props;

    return <Component {...pageProps} />;
  }
}

export default MyApp;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-begin\app\pages\_document.tsx -----

import Document, { Head, Html, Main, NextScript } from 'next/document';
import React from 'react';

class MyDocument extends Document {
  public render() {
    console.log(process.env.NEXT_PUBLIC_URL_APP);
    return (
      <Html lang="en">
        <Head>
          <meta charSet="utf-8" />
          <meta name="google" content="notranslate" />
          <meta name="theme-color" content="#303030" />
        </Head>
        <body>
          <Main />
          <NextScript />
        </body>
      </Html>
    );
  }
}

export default MyDocument;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-begin\app\server\app.ts -----

const a = 'someString';

// some comment

export default a;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-begin\app\.eslintrc.js -----

module.exports = {
  settings: {
    react: { version: 'detect' },
  },
  parser: '@typescript-eslint/parser',
  extends: ['plugin:react/recommended', 'plugin:@typescript-eslint/recommended', 'prettier'],
  env: {
    es6: true,
    node: true,
  },
  plugins: ['prettier', 'react'],
  rules: {
    'prettier/prettier': [
      'error',
      {
        singleQuote: true,
        trailingComma: 'all',
        arrowParens: 'always',
        printWidth: 100,
        semi: true,
      },
    ],
    '@typescript-eslint/camelcase': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    'react/no-unescaped-entities': 'off',
    'react/jsx-filename-extension': ['error', { extensions: ['.tsx'] }],
    'prefer-arrow-callback': 'error',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
  },
};

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-begin\app\next-env.d.ts -----

/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/pages/api-reference/config/typescript for more information.

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-begin\app\next.config.js -----

module.exports = {
  poweredByHeader: false,
  webpack5: true,
  typescript: {
    ignoreBuildErrors: true,
  },
};

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-begin\app\package.json -----

{
  "name": "2-begin-app",
  "version": "1",
  "license": "MIT",
  "scripts": {
    "dev": "next",
    "build": "next build && tsc --project tsconfig.server.json",
    "lint": "eslint . --ext .ts,.tsx"
  },
  "dependencies": {
    "dotenv": "^16.4.7",
    "next": "^15.2.3",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "typescript": "^5.8.2"
  },
  "devDependencies": {
    "@types/node": "^22.13.10",
    "@types/react": "^19.0.12",
    "@types/react-dom": "^19.0.4",
    "@typescript-eslint/eslint-plugin": "^8.27.0",
    "@typescript-eslint/parser": "^8.27.0",
    "eslint": "^9.22.0",
    "eslint-config-prettier": "^10.1.1",
    "eslint-plugin-prettier": "^5.2.3",
    "eslint-plugin-react": "^7.37.4",
    "prettier": "^3.5.3"
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-begin\app\tsconfig.json -----

{
  "compileOnSave": false,
  "compilerOptions": {
    "target": "esnext",
    "module": "esnext",
    "jsx": "preserve",
    "allowJs": true,
    "alwaysStrict": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "removeComments": true,
    "preserveConstEnums": true,
    "sourceMap": false,
    "skipLibCheck": true,
    "baseUrl": ".",
    "typeRoots": [
      "./node_modules/@types"
    ],
    "lib": [
      "dom",
      "es2017"
    ],
    "strict": false,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "incremental": true
  },
  "include": [
    "next-env.d.ts",
    "./**/*.tsx",
    "./**/*.ts"
  ],
  "exclude": [
    "dist",
    "production-server",
    ".next",
    "out",
    "next.config.js",
    "node_modules"
  ]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-begin\app\tsconfig.server.json -----

{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "module": "commonjs",
    "outDir": "production-server/",
    "target": "es2017",
    "isolatedModules": false,
    "noEmit": false
  },
  "exclude": ["./server/types.d.ts"],
  "include": ["./server/**/*.ts"],
  "typeRoots": ["./node_modules/@types", "./server/types.d.ts"]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-end\app\components\common\Confirmer.tsx -----

import Button from "@mui/material/Button";
import Dialog from "@mui/material/Dialog";
import DialogActions from "@mui/material/DialogActions";
import DialogContent from "@mui/material/DialogContent";
import DialogContentText from "@mui/material/DialogContentText";
import DialogTitle from "@mui/material/DialogTitle";
import React from "react";

export let openConfirmDialogExternal;

type State = {
  open: boolean;
  title: string;
  message: string;
  onAnswer: (answer) => void;
};

class Confirmer extends React.Component<any, State> {
  constructor(props) {
    super(props);

    this.state = {
      open: false,
      title: "Are you sure?",
      message: "",
      onAnswer: null,
    };

    openConfirmDialogExternal = this.openConfirmDialog;
  }

  public render() {
    return (
      <Dialog
        open={this.state.open}
        onClose={this.handleClose}
        aria-labelledby="alert-dialog-title"
        aria-describedby="alert-dialog-description"
      >
        <DialogTitle id="alert-dialog-title">{this.state.title}</DialogTitle>
        <DialogContent>
          <DialogContentText id="alert-dialog-description">{this.state.message}</DialogContentText>
        </DialogContent>
        <DialogActions style={{ padding: "10px" }}>
          <Button onClick={this.handleClose} variant="contained" color="primary" autoFocus>
            Cancel
          </Button>
          <Button onClick={this.handleYes} variant="contained" color="secondary">
            OK
          </Button>
        </DialogActions>
      </Dialog>
    );
  }

  public handleClose = () => {
    this.setState({ open: false });
    this.state.onAnswer(false);
  };

  public handleYes = () => {
    this.setState({ open: false });
    this.state.onAnswer(true);
  };

  public openConfirmDialog = ({ title, message, onAnswer }) => {
    this.setState({ open: true, title, message, onAnswer });
  };
}

export default Confirmer;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-end\app\components\common\MenuWithLinks.tsx -----

import Menu from "@mui/material/Menu";
import MenuItem from "@mui/material/MenuItem";
import Link from "next/link";
import { NextRouter, withRouter } from "next/router";
import React from "react";

type Props = {
  options: {
    href: string;
    as: string;
    highlighterSlug: string;
    text: string;
    separator: boolean;
  }[];
  router: NextRouter;
  children: any;
};

type State = {
  anchorEl: Element | ((element: Element) => Element);
};

class MenuWithLinks extends React.PureComponent<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      anchorEl: null,
    };
  }

  public render() {
    const { options, children, router } = this.props;
    const { anchorEl } = this.state;

    return (
      <div style={{ textAlign: "center" }}>
        <div
          aria-controls={anchorEl ? "simple-menu" : null}
          aria-haspopup="true"
          onClick={this.handleClick}
          onKeyPress={this.handleClick}
        >
          {children}
        </div>
        <Menu id="simple-menu" anchorEl={anchorEl} open={Boolean(anchorEl)} onClose={this.handleClose} keepMounted>
          {options.map((option, i) =>
            option.separator ? (
              <hr style={{ width: "85%", margin: "10px auto" }} key={`separated-${i}`} />
            ) : (
              <Link key={option.href} href={option.href} as={option.as} passHref>
                <MenuItem
                  key={option.href}
                  style={{
                    fontWeight: router.asPath.includes(option.highlighterSlug) ? 600 : 300,
                    fontSize: "14px",
                  }}
                >
                  {option.text}
                </MenuItem>
              </Link>
            )
          )}
        </Menu>
      </div>
    );
  }

  public handleClick = (event) => {
    this.setState({ anchorEl: event.currentTarget });
  };

  public handleClose = () => {
    this.setState({ anchorEl: null });
  };
}

export default withRouter(MenuWithLinks);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-end\app\components\common\Notifier.tsx -----

import Snackbar from "@mui/material/Snackbar";
import React from "react";

export let openSnackbarExternal;

type State = {
  open: boolean;
  message: string;
};

class Notifier extends React.PureComponent<any, State> {
  constructor(props) {
    super(props);
    openSnackbarExternal = this.openSnackbar;

    this.state = {
      open: false,
      message: "",
    };
  }

  public render() {
    const message = <span id="snackbar-message-id" dangerouslySetInnerHTML={{ __html: this.state.message }} />;

    return (
      <Snackbar
        anchorOrigin={{ vertical: "top", horizontal: "right" }}
        message={message}
        autoHideDuration={5000}
        onClose={this.handleSnackbarClose}
        open={this.state.open}
        ContentProps={{
          "aria-describedby": "snackbar-message-id",
        }}
      />
    );
  }

  public handleSnackbarClose = () => {
    this.setState({
      open: false,
      message: "",
    });
  };

  public openSnackbar = ({ message }) => {
    this.setState({ open: true, message });
  };
}

export default Notifier;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-end\app\components\layout\index.tsx -----

import Avatar from "@mui/material/Avatar";
import Grid from "@mui/material/Grid";
import React from "react";
import MenuWithLinks from "../common/MenuWithLinks";
import Confirmer from "../common/Confirmer";
import Notifier from "../common/Notifier";

const styleGrid = {
  width: "100%",
  height: "100vh",
  maxWidth: "100%",
  padding: "0px 10px",
  display: "flex",
  overflow: "hidden",
};

const styleGridIsMobile = {
  width: "100%",
  height: "100vh",
  maxWidth: "100%",
  padding: "0px 0px 0px 10px",
  display: "flex",
  overflow: "hidden",
};

type Props = {
  children: React.ReactNode;
  firstGridItem?: boolean;
  isMobile?: boolean;
};

class Layout extends React.Component<Props> {
  public render() {
    const { children, firstGridItem, isMobile } = this.props;

    const isThemeDark = false;

    console.log(isMobile);

    return (
      <Grid
        container
        direction="row"
        justify="flex-start"
        alignItems="stretch"
        style={isMobile ? styleGridIsMobile : styleGrid}
      >
        {firstGridItem ? (
          <Grid
            item
            sm={2}
            xs={12}
            style={{
              borderRight: "1px #707070 solid",
              justifyContent: "center",
              overflow: "hidden",
            }}
          >
            <div style={{ display: "flex", justifyContent: "space-between" }}>
              <svg
                xmlns="http://www.w3.org/2000/svg"
                width="124"
                height="40"
                viewBox="0 0 124 40"
                style={{
                  marginTop: "20px",
                  display: "inline-flex",
                  height: "40px",
                }}
              >
                <g id="async-logo">
                  <g id="async-logo-40">
                    <circle id="Ellipse 2" cx="20" cy="20" r="20" fill="black" />
                    <path
                      id="path-async-logo"
                      d="M7.07825 -0.0960007V16H4.51825V13.088C4.04892 14.0907 3.33425 14.8693 2.37425 15.424C1.43558 15.9573 0.336917 16.224 -0.92175 16.224C-2.35108 16.224 -3.60975 15.8827 -4.69775 15.2C-5.76442 14.5173 -6.59642 13.5573 -7.19375 12.32C-7.76975 11.0613 -8.05775 9.6 -8.05775 7.936C-8.05775 6.272 -7.75908 4.81067 -7.16175 3.552C-6.56442 2.272 -5.73242 1.28 -4.66575 0.576C-3.57775 -0.128 -2.32975 -0.48 -0.92175 -0.48C0.336917 -0.48 1.43558 -0.202666 2.37425 0.352C3.31292 0.906667 4.02758 1.68533 4.51825 2.688V-0.0960007H7.07825ZM-0.40975 14.08C1.16892 14.08 2.38492 13.5467 3.23825 12.48C4.09158 11.392 4.51825 9.856 4.51825 7.872C4.51825 5.888 4.09158 4.36267 3.23825 3.296C2.38492 2.22933 1.16892 1.696 -0.40975 1.696C-1.98842 1.696 -3.22575 2.25067 -4.12175 3.36C-4.99642 4.448 -5.43375 5.97333 -5.43375 7.936C-5.43375 9.89867 -4.99642 11.4133 -4.12175 12.48C-3.24708 13.5467 -2.00975 14.08 -0.40975 14.08Z"
                      transform="translate(19.5938 12)"
                      fill="white"
                    />
                  </g>
                  <path
                    id="path-async-text"
                    d="M22.6251 11.928V24H20.7051V21.816C20.3531 22.568 19.8171 23.152 19.0971 23.568C18.3931 23.968 17.5691 24.168 16.6251 24.168C15.5531 24.168 14.6091 23.912 13.7931 23.4C12.9931 22.888 12.3691 22.168 11.9211 21.24C11.4891 20.296 11.2731 19.2 11.2731 17.952C11.2731 16.704 11.4971 15.608 11.9451 14.664C12.3931 13.704 13.0171 12.96 13.8171 12.432C14.6331 11.904 15.5691 11.64 16.6251 11.64C17.5691 11.64 18.3931 11.848 19.0971 12.264C19.8011 12.68 20.3371 13.264 20.7051 14.016V11.928H22.6251ZM17.0091 22.56C18.1931 22.56 19.1051 22.16 19.7451 21.36C20.3851 20.544 20.7051 19.392 20.7051 17.904C20.7051 16.416 20.3851 15.272 19.7451 14.472C19.1051 13.672 18.1931 13.272 17.0091 13.272C15.8251 13.272 14.8971 13.688 14.2251 14.52C13.5691 15.336 13.2411 16.48 13.2411 17.952C13.2411 19.424 13.5691 20.56 14.2251 21.36C14.8811 22.16 15.8091 22.56 17.0091 22.56ZM30.4637 24.168C28.4317 24.168 26.8237 23.648 25.6397 22.608L26.2877 21.168C26.9437 21.68 27.6077 22.048 28.2797 22.272C28.9517 22.496 29.7037 22.608 30.5357 22.608C31.4477 22.608 32.1357 22.456 32.5997 22.152C33.0797 21.832 33.3197 21.376 33.3197 20.784C33.3197 20.304 33.1597 19.92 32.8397 19.632C32.5197 19.344 31.9917 19.12 31.2557 18.96L29.2157 18.48C28.2077 18.256 27.4237 17.856 26.8637 17.28C26.3197 16.704 26.0477 16.016 26.0477 15.216C26.0477 14.16 26.4717 13.304 27.3197 12.648C28.1677 11.976 29.2877 11.64 30.6797 11.64C31.5277 11.64 32.3277 11.776 33.0797 12.048C33.8317 12.32 34.4637 12.712 34.9757 13.224L34.3277 14.64C33.1917 13.696 31.9757 13.224 30.6797 13.224C29.8157 13.224 29.1437 13.392 28.6637 13.728C28.1997 14.048 27.9677 14.504 27.9677 15.096C27.9677 15.592 28.1117 15.984 28.3997 16.272C28.7037 16.56 29.1837 16.784 29.8397 16.944L31.8797 17.448C32.9997 17.704 33.8317 18.104 34.3757 18.648C34.9197 19.176 35.1917 19.872 35.1917 20.736C35.1917 21.776 34.7677 22.608 33.9197 23.232C33.0717 23.856 31.9197 24.168 30.4637 24.168ZM48.687 11.928L43.047 25.104C42.455 26.48 41.711 27.488 40.815 28.128C39.919 28.768 38.815 29.208 37.503 29.448L37.095 27.936C38.231 27.68 39.087 27.336 39.663 26.904C40.255 26.488 40.743 25.84 41.127 24.96L41.607 23.88L36.495 11.928H38.535L42.615 21.888L46.743 11.928H48.687ZM56.853 11.64C59.749 11.64 61.197 13.232 61.197 16.416V24H59.253V16.512C59.253 15.392 59.029 14.576 58.581 14.064C58.133 13.536 57.429 13.272 56.469 13.272C55.349 13.272 54.453 13.616 53.781 14.304C53.109 14.992 52.773 15.92 52.773 17.088V24H50.829V15.312C50.829 14.064 50.765 12.936 50.637 11.928H52.485L52.677 14.088C53.045 13.304 53.597 12.704 54.333 12.288C55.069 11.856 55.909 11.64 56.853 11.64ZM69.9321 24.168C68.7641 24.168 67.7401 23.912 66.8601 23.4C65.9961 22.888 65.3241 22.168 64.8441 21.24C64.3801 20.296 64.1481 19.2 64.1481 17.952C64.1481 16.704 64.3881 15.608 64.8681 14.664C65.3481 13.704 66.0281 12.96 66.9081 12.432C67.8041 11.904 68.8441 11.64 70.0281 11.64C70.8441 11.64 71.6281 11.784 72.3801 12.072C73.1481 12.344 73.7801 12.728 74.2761 13.224L73.6281 14.664C73.0201 14.184 72.4281 13.832 71.8521 13.608C71.2921 13.384 70.7161 13.272 70.1241 13.272C68.8921 13.272 67.9241 13.688 67.2201 14.52C66.5161 15.336 66.1641 16.48 66.1641 17.952C66.1641 19.408 66.5081 20.544 67.1961 21.36C67.9001 22.16 68.8761 22.56 70.1241 22.56C70.7161 22.56 71.2921 22.448 71.8521 22.224C72.4281 22 73.0201 21.648 73.6281 21.168L74.2761 22.608C73.7641 23.088 73.1161 23.472 72.3321 23.76C71.5641 24.032 70.7641 24.168 69.9321 24.168Z"
                    transform="translate(39 4)"
                    fill={isThemeDark ? "white" : "black"}
                  />
                </g>
              </svg>
              <MenuWithLinks
                options={[
                  {
                    text: "Index page",
                    href: "/",
                    highlighterSlug: "/",
                  },
                  {
                    text: "Your Settings",
                    href: "/your-settings",
                    highlighterSlug: "/your-settings",
                  },
                  {
                    separator: true,
                  },
                  {
                    text: "Log out",
                    href: "/logout",
                  },
                ]}
              >
                <Avatar
                  src={"https://storage.googleapis.com/async-await/default-user.png"}
                  alt="Add username here later in the book"
                  style={{
                    margin: "20px auto",
                    cursor: "pointer",
                    display: "inline-flex",
                    width: "40px",
                    height: "40px",
                  }}
                />

                <i className="material-icons" color="action" style={{ verticalAlign: "super" }}>
                  arrow_drop_down
                </i>
              </MenuWithLinks>
            </div>
            <hr />
            <p />
            <p />
          </Grid>
        ) : null}
        <Grid item sm={10} xs={12}>
          {isMobile ? <hr /> : null}
          {children}
        </Grid>
        <Notifier />
        <Confirmer />
      </Grid>
    );
  }
}

export default Layout;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-end\app\lib\confirm.ts -----

import { openConfirmDialogExternal } from '../components/common/Confirmer';

export default function confirm({
  title,
  message,
  onAnswer,
}: {
  title: string;
  message: string;
  onAnswer: (answer) => void;
}) {
  openConfirmDialogExternal({ title, message, onAnswer });
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-end\app\lib\isMobile.ts -----

const mobileRE = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i;

export function isMobile(opts) {
  if (!opts) {
    opts = {};
  }

  let ua = opts.ua;
  if (!ua && typeof navigator !== 'undefined') {
    ua = navigator.userAgent;
  }
  if (!ua && opts.req && opts.req.headers && typeof opts.req.headers['user-agent'] === 'string') {
    ua = opts.req.headers['user-agent'];
    console.log(ua);
  }

  if (typeof ua !== 'string') {
    return false;
  }

  return mobileRE.test(ua);
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-end\app\lib\notify.ts -----

import { openSnackbarExternal } from '../components/common/Notifier';

export default function notify(obj) {
  openSnackbarExternal({ message: obj.message || obj.toString() });
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-end\app\lib\sharedStyles.ts -----

const styleBigAvatar = {
  width: '80px',
  height: '80px',
  margin: '0px auto 15px',
};

const styleRaisedButton = {
  margin: '15px',
  font: '14px Roboto',
};

const styleToolbar = {
  background: '#FFF',
  height: '64px',
  paddingRight: '20px',
};

const styleTextField = {
  font: '15px Roboto',
  color: '#222',
  fontWeight: '300',
};

const styleForm = {
  margin: '7% auto',
  width: '360px',
};

export { styleBigAvatar, styleRaisedButton, styleToolbar, styleTextField, styleForm };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-end\app\lib\theme.ts -----

import { createMuiTheme } from "@mui/material/styles";

const themeDark = createMuiTheme({
  palette: {
    primary: { main: "#238636" },
    secondary: { main: "#b62324" },
    type: "dark",
    background: { default: "#0d1117" },
    text: {
      primary: "#c9d1d9",
    },
  },
  typography: {
    button: {
      textTransform: "none",
    },
  },
});

const themeLight = createMuiTheme({
  palette: {
    primary: { main: "#238636" },
    secondary: { main: "#b62324" },
    type: "light",
    background: { default: "#fff" },
    text: {
      primary: "#222",
    },
  },
  typography: {
    button: {
      textTransform: "none",
    },
  },
});

export { themeDark, themeLight };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-end\app\pages\csr-page.tsx -----

import Button from "@mui/material/Button";
import React from "react";
import Head from "next/head";

const CSRPage = () => (
  <div>
    <Head>
      <title>CSR page</title>
      <meta name="description" content="This is a description of the CSR page" />
    </Head>
    <div style={{ padding: "0px 30px", fontSize: "15px", height: "100%" }}>
      <p>Content on CSR page</p>
      <Button variant="outlined">Some button</Button>
    </div>
  </div>
);

console.log(process.env.NEXT_PUBLIC_URL_APP);

export default CSRPage;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-end\app\pages\index.tsx -----

import Button from "@mui/material/Button";
import React from "react";
import Head from "next/head";
import Link from "next/link";

import Layout from "../components/layout";
import NProgress from "nprogress";

import confirm from "../lib/confirm";
import notify from "../lib/notify";

class Index extends React.Component {
  public render() {
    return (
      <Layout {...this.props}>
        <Head>
          <title>Index page</title>
          <meta name="description" content="This is a description of the Index page" />
        </Head>
        <div style={{ padding: "0px 30px", fontSize: "15px", height: "100%" }}>
          <p>Content on Index page</p>
          <Link href="/csr-page" as="/csr-page">
            Go to CSR page
          </Link>
          <p />
          <Button
            variant="contained"
            onClick={() =>
              confirm({
                title: "Are you sure?",
                message: "explanatory message",
                onAnswer: async (answer) => {
                  console.log(answer);
                  if (!answer) {
                    return;
                  }

                  NProgress.start();

                  try {
                    notify("You successfully confirmed.");
                  } catch (error) {
                    console.error(error);
                    notify(error);
                  } finally {
                    NProgress.done();
                  }
                },
              })
            }
          >
            Test Confirmer and Notifier
          </Button>
        </div>
      </Layout>
    );
  }
}

export default Index;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-end\app\pages\_app.tsx -----

import CssBaseline from "@mui/material/CssBaseline";
import { ThemeProvider } from "@mui/material";
import App from "next/app";
import Head from "next/head";
import React from "react";
import { isMobile } from "../lib/isMobile";
import { themeDark, themeLight } from "../lib/theme";

class MyApp extends App {
  public static async getInitialProps({ Component, ctx }) {
    const pageProps = { isMobile: isMobile({ req: ctx.req }), firstGridItem: true };

    if (Component.getInitialProps) {
      Object.assign(pageProps, await Component.getInitialProps(ctx));
    }

    console.log(pageProps);

    return { pageProps };
  }

  public componentDidMount() {
    // Remove the server-side injected CSS.
    const jssStyles = document.querySelector("#jss-server-side");
    if (jssStyles && jssStyles.parentNode) {
      jssStyles.parentNode.removeChild(jssStyles);
    }
  }
  public render() {
    const { Component, pageProps } = this.props;

    return (
      <ThemeProvider theme={false ? themeDark : themeLight}>
        <Head>
          <meta name="viewport" content="width=device-width, initial-scale=1.0" />
          <link rel="stylesheet" href="https://storage.googleapis.com/async-await/nprogress-dark.min.css?v=1" />
        </Head>
        <CssBaseline />
        <Component {...pageProps} />
      </ThemeProvider>
    );
  }
}

export default MyApp;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-end\app\pages\_document.tsx -----

import Document, { Head, Html, Main, NextScript } from "next/document";
import React from "react";

class MyDocument extends Document {
  public static getInitialProps = async (ctx) => {
    const initialProps = await Document.getInitialProps(ctx);

    return {
      ...initialProps,
    };
  };

  public render() {
    // console.log('rendered on the server');

    return (
      <Html lang="en">
        <Head>
          <meta charSet="utf-8" />
          <meta name="google" content="notranslate" />
          <meta name="theme-color" content="#303030" />

          <link rel="shortcut icon" href="https://storage.googleapis.com/async-await/async-favicon32.png" />

          <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons" />
          <link rel="stylesheet" href="https://storage.googleapis.com/async-await/vs2015.min.css" />

          <style>
            {`
              #__next {
                width: 100%;
                height: 100%;
              }
              a {
                font-weight: 400;
                color: #58a6ff;
                text-decoration: none;
                outline: none;
              }
              hr {
                border: 0.5px #707070 solid;
                color: #000;
              }
              blockquote {
                padding: 0 0.5em;
                margin: 20px 1em;
                border-left: 0.25em solid #dfe2e5;
                color: #000;
              }
              pre {
                display: block;
                overflow-x: auto;
                padding: 0.5em;
                background: #d0d0d0;
                border: 1px solid #ddd;
                font-size: 14px;
                color: #000;
              }
              pre code {
                font-size: 13px;
                background: #d0d0d0;
                padding: 0px;
                color: #000;
              }
              code {
                font-size: 13px;
                background: #d0d0d0;
                padding: 3px 5px;
                color: #000;
              }
              mark {
                background-color: #ffff0060;
              }
              summary:focus {
                outline: none;
              }
              table {
                border-collapse: collapse;
                margin: 15px 0px;
              }
              table, th, td {
                border: 1px solid #a1a1a1;
              }
              th, td {
                line-height: 1.5em;
                padding: 10px;
              }
            `}
          </style>
        </Head>
        <body>
          <Main />
          <NextScript />
        </body>
      </Html>
    );
  }
}

export default MyDocument;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-end\app\server\app.ts -----

const a = 'someString';

// some comment

export default a;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-end\app\.eslintrc.js -----

module.exports = {
  settings: {
    react: { version: 'detect' },
  },
  parser: '@typescript-eslint/parser',
  extends: ['plugin:react/recommended', 'plugin:@typescript-eslint/recommended', 'prettier'],
  env: {
    es6: true,
    node: true,
  },
  plugins: ['prettier', 'react'],
  rules: {
    'prettier/prettier': [
      'error',
      {
        singleQuote: true,
        trailingComma: 'all',
        arrowParens: 'always',
        printWidth: 100,
        semi: true,
      },
    ],
    '@typescript-eslint/camelcase': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    'react/no-unescaped-entities': 'off',
    'react/jsx-filename-extension': ['error', { extensions: ['.tsx'] }],
    '@typescript-eslint/no-explicit-any': 'off',
    'prefer-arrow-callback': 'error',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
  },
};

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-end\app\next-env.d.ts -----

/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/pages/api-reference/config/typescript for more information.

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-end\app\next.config.js -----

module.exports = {
  poweredByHeader: false,
  typescript: {
    ignoreBuildErrors: true,
  },
};

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-end\app\package.json -----

{
  "name": "2-end-app",
  "version": "1",
  "license": "MIT",
  "scripts": {
    "dev": "next",
    "build": "next build && tsc --project tsconfig.server.json",
    "lint": "eslint . --ext .ts,.tsx"
  },
  "dependencies": {
    "@emotion/react": "^11.14.0",
    "@emotion/styled": "^11.14.0",
    "@mui/material": "^6.4.8",
    "@mui/system": "^6.4.8",
    "dotenv": "^16.4.7",
    "next": "^15.2.3",
    "nprogress": "^0.2.0",
    "react": "19.0.0",
    "react-dom": "19.0.0",
    "typescript": "^5.8.2"
  },
  "devDependencies": {
    "@types/node": "^22.13.10",
    "@types/react": "^19.0.12",
    "@types/react-dom": "^19.0.4",
    "@typescript-eslint/eslint-plugin": "^8.27.0",
    "@typescript-eslint/parser": "^8.27.0",
    "eslint": "^9.22.0",
    "eslint-config-prettier": "^10.1.1",
    "eslint-plugin-prettier": "^5.2.3",
    "eslint-plugin-react": "^7.37.4",
    "prettier": "^3.5.3"
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-end\app\tsconfig.json -----

{
  "compileOnSave": false,
  "compilerOptions": {
    "target": "esnext",
    "module": "esnext",
    "jsx": "preserve",
    "allowJs": true,
    "alwaysStrict": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "removeComments": true,
    "preserveConstEnums": true,
    "sourceMap": false,
    "skipLibCheck": true,
    "baseUrl": ".",
    "typeRoots": [
      "./node_modules/@types"
    ],
    "lib": [
      "dom",
      "es2017"
    ],
    "strict": false,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "incremental": true
  },
  "include": [
    "next-env.d.ts",
    "./**/*.tsx",
    "./**/*.ts"
  ],
  "exclude": [
    "dist",
    "production-server",
    ".next",
    "out",
    "next.config.js",
    "node_modules"
  ]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\2-end\app\tsconfig.server.json -----

{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "module": "commonjs",
    "outDir": "production-server/",
    "target": "es2017",
    "isolatedModules": false,
    "noEmit": false
  },
  "exclude": ["./server/types.d.ts"],
  "include": ["./server/**/*.ts"],
  "typeRoots": ["./node_modules/@types", "./server/types.d.ts"]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-begin\app\components\common\Confirmer.tsx -----

import Button from "@mui/material/Button";
import Dialog from "@mui/material/Dialog";
import DialogActions from "@mui/material/DialogActions";
import DialogContent from "@mui/material/DialogContent";
import DialogContentText from "@mui/material/DialogContentText";
import DialogTitle from "@mui/material/DialogTitle";
import React from "react";

export let openConfirmDialogExternal;

type State = {
  open: boolean;
  title: string;
  message: string;
  onAnswer: (answer) => void;
};

class Confirmer extends React.Component<any, State> {
  constructor(props) {
    super(props);

    this.state = {
      open: false,
      title: "Are you sure?",
      message: "",
      onAnswer: null,
    };

    openConfirmDialogExternal = this.openConfirmDialog;
  }

  public render() {
    return (
      <Dialog
        open={this.state.open}
        onClose={this.handleClose}
        aria-labelledby="alert-dialog-title"
        aria-describedby="alert-dialog-description"
      >
        <DialogTitle id="alert-dialog-title">{this.state.title}</DialogTitle>
        <DialogContent>
          <DialogContentText id="alert-dialog-description">{this.state.message}</DialogContentText>
        </DialogContent>
        <DialogActions style={{ padding: "10px" }}>
          <Button onClick={this.handleClose} variant="contained" color="primary" autoFocus>
            Cancel
          </Button>
          <Button onClick={this.handleYes} variant="contained" color="secondary">
            OK
          </Button>
        </DialogActions>
      </Dialog>
    );
  }

  public handleClose = () => {
    this.setState({ open: false });
    this.state.onAnswer(false);
  };

  public handleYes = () => {
    this.setState({ open: false });
    this.state.onAnswer(true);
  };

  public openConfirmDialog = ({ title, message, onAnswer }) => {
    this.setState({ open: true, title, message, onAnswer });
  };
}

export default Confirmer;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-begin\app\components\common\MenuWithLinks.tsx -----

import Menu from "@mui/material/Menu";
import MenuItem from "@mui/material/MenuItem";
import Link from "next/link";
import { NextRouter, withRouter } from "next/router";
import React from "react";

type Props = {
  options: {
    href: string;
    as: string;
    highlighterSlug: string;
    text: string;
    separator: boolean;
  }[];
  router: NextRouter;
  children: any;
};

type State = {
  anchorEl: Element | ((element: Element) => Element);
};

class MenuWithLinks extends React.PureComponent<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      anchorEl: null,
    };
  }

  public render() {
    const { options, children, router } = this.props;
    const { anchorEl } = this.state;

    return (
      <div style={{ textAlign: "center" }}>
        <div
          aria-controls={anchorEl ? "simple-menu" : null}
          aria-haspopup="true"
          onClick={this.handleClick}
          onKeyPress={this.handleClick}
        >
          {children}
        </div>
        <Menu id="simple-menu" anchorEl={anchorEl} open={Boolean(anchorEl)} onClose={this.handleClose} keepMounted>
          {options.map((option, i) =>
            option.separator ? (
              <hr style={{ width: "85%", margin: "10px auto" }} key={`separated-${i}`} />
            ) : (
              <Link key={option.href} href={option.href} as={option.as} passHref>
                <MenuItem
                  key={option.href}
                  style={{
                    fontWeight: router.asPath.includes(option.highlighterSlug) ? 600 : 300,
                    fontSize: "14px",
                  }}
                >
                  {option.text}
                </MenuItem>
              </Link>
            )
          )}
        </Menu>
      </div>
    );
  }

  public handleClick = (event) => {
    this.setState({ anchorEl: event.currentTarget });
  };

  public handleClose = () => {
    this.setState({ anchorEl: null });
  };
}

export default withRouter(MenuWithLinks);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-begin\app\components\common\Notifier.tsx -----

import Snackbar from "@mui/material/Snackbar";
import React from "react";

export let openSnackbarExternal;

type State = {
  open: boolean;
  message: string;
};

class Notifier extends React.PureComponent<any, State> {
  constructor(props) {
    super(props);
    openSnackbarExternal = this.openSnackbar;

    this.state = {
      open: false,
      message: "",
    };
  }

  public render() {
    const message = <span id="snackbar-message-id" dangerouslySetInnerHTML={{ __html: this.state.message }} />;

    return (
      <Snackbar
        anchorOrigin={{ vertical: "top", horizontal: "right" }}
        message={message}
        autoHideDuration={5000}
        onClose={this.handleSnackbarClose}
        open={this.state.open}
        ContentProps={{
          "aria-describedby": "snackbar-message-id",
        }}
      />
    );
  }

  public handleSnackbarClose = () => {
    this.setState({
      open: false,
      message: "",
    });
  };

  public openSnackbar = ({ message }) => {
    this.setState({ open: true, message });
  };
}

export default Notifier;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-begin\app\components\layout\index.tsx -----

import Avatar from "@mui/material/Avatar";
import Grid from "@mui/material/Grid";
import React from "react";
import MenuWithLinks from "../common/MenuWithLinks";
import Confirmer from "../common/Confirmer";
import Notifier from "../common/Notifier";

const styleGrid = {
  width: "100%",
  height: "100vh",
  maxWidth: "100%",
  padding: "0px 10px",
  display: "flex",
  overflow: "hidden",
};

const styleGridIsMobile = {
  width: "100%",
  height: "100vh",
  maxWidth: "100%",
  padding: "0px 0px 0px 10px",
  display: "flex",
  overflow: "hidden",
};

type Props = {
  children: React.ReactNode;
  firstGridItem?: boolean;
  isMobile?: boolean;
};

class Layout extends React.Component<Props> {
  public render() {
    const { children, firstGridItem, isMobile } = this.props;

    const isThemeDark = false;

    console.log(isMobile);

    return (
      <Grid
        container
        direction="row"
        justify="flex-start"
        alignItems="stretch"
        style={isMobile ? styleGridIsMobile : styleGrid}
      >
        {firstGridItem ? (
          <Grid
            item
            sm={2}
            xs={12}
            style={{
              borderRight: "1px #707070 solid",
              justifyContent: "center",
              overflow: "hidden",
            }}
          >
            <div style={{ display: "flex", justifyContent: "space-between" }}>
              <svg
                xmlns="http://www.w3.org/2000/svg"
                width="124"
                height="40"
                viewBox="0 0 124 40"
                style={{
                  marginTop: "20px",
                  display: "inline-flex",
                  height: "40px",
                }}
              >
                <g id="async-logo">
                  <g id="async-logo-40">
                    <circle id="Ellipse 2" cx="20" cy="20" r="20" fill="black" />
                    <path
                      id="path-async-logo"
                      d="M7.07825 -0.0960007V16H4.51825V13.088C4.04892 14.0907 3.33425 14.8693 2.37425 15.424C1.43558 15.9573 0.336917 16.224 -0.92175 16.224C-2.35108 16.224 -3.60975 15.8827 -4.69775 15.2C-5.76442 14.5173 -6.59642 13.5573 -7.19375 12.32C-7.76975 11.0613 -8.05775 9.6 -8.05775 7.936C-8.05775 6.272 -7.75908 4.81067 -7.16175 3.552C-6.56442 2.272 -5.73242 1.28 -4.66575 0.576C-3.57775 -0.128 -2.32975 -0.48 -0.92175 -0.48C0.336917 -0.48 1.43558 -0.202666 2.37425 0.352C3.31292 0.906667 4.02758 1.68533 4.51825 2.688V-0.0960007H7.07825ZM-0.40975 14.08C1.16892 14.08 2.38492 13.5467 3.23825 12.48C4.09158 11.392 4.51825 9.856 4.51825 7.872C4.51825 5.888 4.09158 4.36267 3.23825 3.296C2.38492 2.22933 1.16892 1.696 -0.40975 1.696C-1.98842 1.696 -3.22575 2.25067 -4.12175 3.36C-4.99642 4.448 -5.43375 5.97333 -5.43375 7.936C-5.43375 9.89867 -4.99642 11.4133 -4.12175 12.48C-3.24708 13.5467 -2.00975 14.08 -0.40975 14.08Z"
                      transform="translate(19.5938 12)"
                      fill="white"
                    />
                  </g>
                  <path
                    id="path-async-text"
                    d="M22.6251 11.928V24H20.7051V21.816C20.3531 22.568 19.8171 23.152 19.0971 23.568C18.3931 23.968 17.5691 24.168 16.6251 24.168C15.5531 24.168 14.6091 23.912 13.7931 23.4C12.9931 22.888 12.3691 22.168 11.9211 21.24C11.4891 20.296 11.2731 19.2 11.2731 17.952C11.2731 16.704 11.4971 15.608 11.9451 14.664C12.3931 13.704 13.0171 12.96 13.8171 12.432C14.6331 11.904 15.5691 11.64 16.6251 11.64C17.5691 11.64 18.3931 11.848 19.0971 12.264C19.8011 12.68 20.3371 13.264 20.7051 14.016V11.928H22.6251ZM17.0091 22.56C18.1931 22.56 19.1051 22.16 19.7451 21.36C20.3851 20.544 20.7051 19.392 20.7051 17.904C20.7051 16.416 20.3851 15.272 19.7451 14.472C19.1051 13.672 18.1931 13.272 17.0091 13.272C15.8251 13.272 14.8971 13.688 14.2251 14.52C13.5691 15.336 13.2411 16.48 13.2411 17.952C13.2411 19.424 13.5691 20.56 14.2251 21.36C14.8811 22.16 15.8091 22.56 17.0091 22.56ZM30.4637 24.168C28.4317 24.168 26.8237 23.648 25.6397 22.608L26.2877 21.168C26.9437 21.68 27.6077 22.048 28.2797 22.272C28.9517 22.496 29.7037 22.608 30.5357 22.608C31.4477 22.608 32.1357 22.456 32.5997 22.152C33.0797 21.832 33.3197 21.376 33.3197 20.784C33.3197 20.304 33.1597 19.92 32.8397 19.632C32.5197 19.344 31.9917 19.12 31.2557 18.96L29.2157 18.48C28.2077 18.256 27.4237 17.856 26.8637 17.28C26.3197 16.704 26.0477 16.016 26.0477 15.216C26.0477 14.16 26.4717 13.304 27.3197 12.648C28.1677 11.976 29.2877 11.64 30.6797 11.64C31.5277 11.64 32.3277 11.776 33.0797 12.048C33.8317 12.32 34.4637 12.712 34.9757 13.224L34.3277 14.64C33.1917 13.696 31.9757 13.224 30.6797 13.224C29.8157 13.224 29.1437 13.392 28.6637 13.728C28.1997 14.048 27.9677 14.504 27.9677 15.096C27.9677 15.592 28.1117 15.984 28.3997 16.272C28.7037 16.56 29.1837 16.784 29.8397 16.944L31.8797 17.448C32.9997 17.704 33.8317 18.104 34.3757 18.648C34.9197 19.176 35.1917 19.872 35.1917 20.736C35.1917 21.776 34.7677 22.608 33.9197 23.232C33.0717 23.856 31.9197 24.168 30.4637 24.168ZM48.687 11.928L43.047 25.104C42.455 26.48 41.711 27.488 40.815 28.128C39.919 28.768 38.815 29.208 37.503 29.448L37.095 27.936C38.231 27.68 39.087 27.336 39.663 26.904C40.255 26.488 40.743 25.84 41.127 24.96L41.607 23.88L36.495 11.928H38.535L42.615 21.888L46.743 11.928H48.687ZM56.853 11.64C59.749 11.64 61.197 13.232 61.197 16.416V24H59.253V16.512C59.253 15.392 59.029 14.576 58.581 14.064C58.133 13.536 57.429 13.272 56.469 13.272C55.349 13.272 54.453 13.616 53.781 14.304C53.109 14.992 52.773 15.92 52.773 17.088V24H50.829V15.312C50.829 14.064 50.765 12.936 50.637 11.928H52.485L52.677 14.088C53.045 13.304 53.597 12.704 54.333 12.288C55.069 11.856 55.909 11.64 56.853 11.64ZM69.9321 24.168C68.7641 24.168 67.7401 23.912 66.8601 23.4C65.9961 22.888 65.3241 22.168 64.8441 21.24C64.3801 20.296 64.1481 19.2 64.1481 17.952C64.1481 16.704 64.3881 15.608 64.8681 14.664C65.3481 13.704 66.0281 12.96 66.9081 12.432C67.8041 11.904 68.8441 11.64 70.0281 11.64C70.8441 11.64 71.6281 11.784 72.3801 12.072C73.1481 12.344 73.7801 12.728 74.2761 13.224L73.6281 14.664C73.0201 14.184 72.4281 13.832 71.8521 13.608C71.2921 13.384 70.7161 13.272 70.1241 13.272C68.8921 13.272 67.9241 13.688 67.2201 14.52C66.5161 15.336 66.1641 16.48 66.1641 17.952C66.1641 19.408 66.5081 20.544 67.1961 21.36C67.9001 22.16 68.8761 22.56 70.1241 22.56C70.7161 22.56 71.2921 22.448 71.8521 22.224C72.4281 22 73.0201 21.648 73.6281 21.168L74.2761 22.608C73.7641 23.088 73.1161 23.472 72.3321 23.76C71.5641 24.032 70.7641 24.168 69.9321 24.168Z"
                    transform="translate(39 4)"
                    fill={isThemeDark ? "white" : "black"}
                  />
                </g>
              </svg>
              <MenuWithLinks
                options={[
                  {
                    text: "Index page",
                    href: "/",
                    highlighterSlug: "/",
                  },
                  {
                    text: "Your Settings",
                    href: "/your-settings",
                    highlighterSlug: "/your-settings",
                  },
                  {
                    separator: true,
                  },
                  {
                    text: "Log out",
                    href: "/logout",
                  },
                ]}
              >
                <Avatar
                  src={"https://storage.googleapis.com/async-await/default-user.png"}
                  alt="Add username here later in the book"
                  style={{
                    margin: "20px auto",
                    cursor: "pointer",
                    display: "inline-flex",
                    width: "40px",
                    height: "40px",
                  }}
                />

                <i className="material-icons" color="action" style={{ verticalAlign: "super" }}>
                  arrow_drop_down
                </i>
              </MenuWithLinks>
            </div>
            <hr />
            <p />
            <p />
          </Grid>
        ) : null}
        <Grid item sm={10} xs={12}>
          {isMobile ? <hr /> : null}
          {children}
        </Grid>
        <Notifier />
        <Confirmer />
      </Grid>
    );
  }
}

export default Layout;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-begin\app\lib\confirm.ts -----

import { openConfirmDialogExternal } from '../components/common/Confirmer';

export default function confirm({
  title,
  message,
  onAnswer,
}: {
  title: string;
  message: string;
  onAnswer: (answer) => void;
}) {
  openConfirmDialogExternal({ title, message, onAnswer });
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-begin\app\lib\isMobile.ts -----

const mobileRE = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i;

export function isMobile(opts) {
  if (!opts) {
    opts = {};
  }

  let ua = opts.ua;
  if (!ua && typeof navigator !== 'undefined') {
    ua = navigator.userAgent;
  }
  if (!ua && opts.req && opts.req.headers && typeof opts.req.headers['user-agent'] === 'string') {
    ua = opts.req.headers['user-agent'];
    console.log(ua);
  }

  if (typeof ua !== 'string') {
    return false;
  }

  return mobileRE.test(ua);
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-begin\app\lib\notify.ts -----

import { openSnackbarExternal } from '../components/common/Notifier';

export default function notify(obj) {
  openSnackbarExternal({ message: obj.message || obj.toString() });
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-begin\app\lib\sharedStyles.ts -----

const styleBigAvatar = {
  width: '80px',
  height: '80px',
  margin: '0px auto 15px',
};

const styleRaisedButton = {
  margin: '15px',
  font: '14px Roboto',
};

const styleToolbar = {
  background: '#FFF',
  height: '64px',
  paddingRight: '20px',
};

const styleTextField = {
  font: '15px Roboto',
  color: '#222',
  fontWeight: '300',
};

const styleForm = {
  margin: '7% auto',
  width: '360px',
};

export { styleBigAvatar, styleRaisedButton, styleToolbar, styleTextField, styleForm };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-begin\app\lib\theme.ts -----

import { createMuiTheme } from "@mui/material/styles";

const themeDark = createMuiTheme({
  palette: {
    primary: { main: "#238636" },
    secondary: { main: "#b62324" },
    type: "dark",
    background: { default: "#0d1117" },
    text: {
      primary: "#c9d1d9",
    },
  },
  typography: {
    button: {
      textTransform: "none",
    },
  },
});

const themeLight = createMuiTheme({
  palette: {
    primary: { main: "#238636" },
    secondary: { main: "#b62324" },
    type: "light",
    background: { default: "#fff" },
    text: {
      primary: "#222",
    },
  },
  typography: {
    button: {
      textTransform: "none",
    },
  },
});

export { themeDark, themeLight };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-begin\app\pages\csr-page.tsx -----

import Button from "@mui/material/Button";
import React from "react";
import Head from "next/head";

const CSRPage = () => (
  <div>
    <Head>
      <title>CSR page</title>
      <meta name="description" content="This is a description of the CSR page" />
    </Head>
    <div style={{ padding: "0px 30px", fontSize: "15px", height: "100%" }}>
      <p>Content on CSR page</p>
      <Button variant="outlined">Some button</Button>
    </div>
  </div>
);

console.log(process.env.NEXT_PUBLIC_URL_APP);

export default CSRPage;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-begin\app\pages\index.tsx -----

import Button from "@mui/material/Button";
import React from "react";
import Head from "next/head";
import Link from "next/link";

import Layout from "../components/layout";
import NProgress from "nprogress";

import confirm from "../lib/confirm";
import notify from "../lib/notify";

class Index extends React.Component {
  public render() {
    return (
      <Layout {...this.props}>
        <Head>
          <title>Index page</title>
          <meta name="description" content="This is a description of the Index page" />
        </Head>
        <div style={{ padding: "0px 30px", fontSize: "15px", height: "100%" }}>
          <p>Content on Index page</p>
          <Link href="/csr-page" as="/csr-page">
            Go to CSR page
          </Link>
          <p />
          <Button
            variant="contained"
            onClick={() =>
              confirm({
                title: "Are you sure?",
                message: "explanatory message",
                onAnswer: async (answer) => {
                  console.log(answer);
                  if (!answer) {
                    return;
                  }

                  NProgress.start();

                  try {
                    notify("You successfully confirmed.");
                  } catch (error) {
                    console.error(error);
                    notify(error);
                  } finally {
                    NProgress.done();
                  }
                },
              })
            }
          >
            Test Confirmer and Notifier
          </Button>
        </div>
      </Layout>
    );
  }
}

export default Index;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-begin\app\pages\_app.tsx -----

import CssBaseline from "@mui/material/CssBaseline";
import { ThemeProvider } from "@mui/material";
import App from "next/app";
import Head from "next/head";
import React from "react";
import { isMobile } from "../lib/isMobile";
import { themeDark, themeLight } from "../lib/theme";

class MyApp extends App {
  public static async getInitialProps({ Component, ctx }) {
    const pageProps = { isMobile: isMobile({ req: ctx.req }), firstGridItem: true };

    if (Component.getInitialProps) {
      Object.assign(pageProps, await Component.getInitialProps(ctx));
    }

    console.log(pageProps);

    return { pageProps };
  }

  public componentDidMount() {
    // Remove the server-side injected CSS.
    const jssStyles = document.querySelector("#jss-server-side");
    if (jssStyles && jssStyles.parentNode) {
      jssStyles.parentNode.removeChild(jssStyles);
    }
  }
  public render() {
    const { Component, pageProps } = this.props;

    return (
      <ThemeProvider theme={false ? themeDark : themeLight}>
        <Head>
          <meta name="viewport" content="width=device-width, initial-scale=1.0" />
          <link rel="stylesheet" href="https://storage.googleapis.com/async-await/nprogress-dark.min.css?v=1" />
        </Head>
        <CssBaseline />
        <Component {...pageProps} />
      </ThemeProvider>
    );
  }
}

export default MyApp;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-begin\app\pages\_document.tsx -----

import Document, { Head, Html, Main, NextScript } from "next/document";
import React from "react";

class MyDocument extends Document {
  public static getInitialProps = async (ctx) => {
    const initialProps = await Document.getInitialProps(ctx);

    return {
      ...initialProps,
    };
  };

  public render() {
    // console.log('rendered on the server');

    return (
      <Html lang="en">
        <Head>
          <meta charSet="utf-8" />
          <meta name="google" content="notranslate" />
          <meta name="theme-color" content="#303030" />

          <link rel="shortcut icon" href="https://storage.googleapis.com/async-await/async-favicon32.png" />

          <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons" />
          <link rel="stylesheet" href="https://storage.googleapis.com/async-await/vs2015.min.css" />

          <style>
            {`
              #__next {
                width: 100%;
                height: 100%;
              }
              a {
                font-weight: 400;
                color: #58a6ff;
                text-decoration: none;
                outline: none;
              }
              hr {
                border: 0.5px #707070 solid;
                color: #000;
              }
              blockquote {
                padding: 0 0.5em;
                margin: 20px 1em;
                border-left: 0.25em solid #dfe2e5;
                color: #000;
              }
              pre {
                display: block;
                overflow-x: auto;
                padding: 0.5em;
                background: #d0d0d0;
                border: 1px solid #ddd;
                font-size: 14px;
                color: #000;
              }
              pre code {
                font-size: 13px;
                background: #d0d0d0;
                padding: 0px;
                color: #000;
              }
              code {
                font-size: 13px;
                background: #d0d0d0;
                padding: 3px 5px;
                color: #000;
              }
              mark {
                background-color: #ffff0060;
              }
              summary:focus {
                outline: none;
              }
              table {
                border-collapse: collapse;
                margin: 15px 0px;
              }
              table, th, td {
                border: 1px solid #a1a1a1;
              }
              th, td {
                line-height: 1.5em;
                padding: 10px;
              }
            `}
          </style>
        </Head>
        <body>
          <Main />
          <NextScript />
        </body>
      </Html>
    );
  }
}

export default MyDocument;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-begin\app\server\app.ts -----

const a = 'someString';

// some comment

export default a;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-begin\app\.eslintrc.js -----

module.exports = {
  settings: {
    react: { version: 'detect' },
  },
  parser: '@typescript-eslint/parser',
  extends: ['plugin:react/recommended', 'plugin:@typescript-eslint/recommended', 'prettier'],
  env: {
    es6: true,
    node: true,
  },
  plugins: ['prettier', 'react'],
  rules: {
    'prettier/prettier': [
      'error',
      {
        singleQuote: true,
        trailingComma: 'all',
        arrowParens: 'always',
        printWidth: 100,
        semi: true,
      },
    ],
    '@typescript-eslint/camelcase': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    'react/no-unescaped-entities': 'off',
    'react/jsx-filename-extension': ['error', { extensions: ['.tsx'] }],
    '@typescript-eslint/no-explicit-any': 'off',
    'prefer-arrow-callback': 'error',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
  },
};

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-begin\app\next-env.d.ts -----

/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/pages/api-reference/config/typescript for more information.

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-begin\app\next.config.js -----

module.exports = {
  poweredByHeader: false,
  typescript: {
    ignoreBuildErrors: true,
  },
};

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-begin\app\package.json -----

{
  "name": "2-end-app",
  "version": "1",
  "license": "MIT",
  "scripts": {
    "dev": "next",
    "build": "next build && tsc --project tsconfig.server.json",
    "lint": "eslint . --ext .ts,.tsx"
  },
  "dependencies": {
    "@emotion/react": "^11.14.0",
    "@emotion/styled": "^11.14.0",
    "@mui/material": "^6.4.8",
    "@mui/system": "^6.4.8",
    "dotenv": "^16.4.7",
    "next": "^15.2.3",
    "nprogress": "^0.2.0",
    "react": "19.0.0",
    "react-dom": "19.0.0",
    "typescript": "^5.8.2"
  },
  "devDependencies": {
    "@types/node": "^22.13.10",
    "@types/react": "^19.0.12",
    "@types/react-dom": "^19.0.4",
    "@typescript-eslint/eslint-plugin": "^8.27.0",
    "@typescript-eslint/parser": "^8.27.0",
    "eslint": "^9.22.0",
    "eslint-config-prettier": "^10.1.1",
    "eslint-plugin-prettier": "^5.2.3",
    "eslint-plugin-react": "^7.37.4",
    "prettier": "^3.5.3"
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-begin\app\tsconfig.json -----

{
  "compileOnSave": false,
  "compilerOptions": {
    "target": "esnext",
    "module": "esnext",
    "jsx": "preserve",
    "allowJs": true,
    "alwaysStrict": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "removeComments": true,
    "preserveConstEnums": true,
    "sourceMap": false,
    "skipLibCheck": true,
    "baseUrl": ".",
    "typeRoots": [
      "./node_modules/@types"
    ],
    "lib": [
      "dom",
      "es2017"
    ],
    "strict": false,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "incremental": true
  },
  "include": [
    "next-env.d.ts",
    "./**/*.tsx",
    "./**/*.ts"
  ],
  "exclude": [
    "dist",
    "production-server",
    ".next",
    "out",
    "next.config.js",
    "node_modules"
  ]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-begin\app\tsconfig.server.json -----

{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "module": "commonjs",
    "outDir": "production-server/",
    "target": "es2017",
    "isolatedModules": false,
    "noEmit": false
  },
  "exclude": ["./server/types.d.ts"],
  "include": ["./server/**/*.ts"],
  "typeRoots": ["./node_modules/@types", "./server/types.d.ts"]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\api\server\server.ts -----

import * as express from 'express';

// eslint-disable-next-line
require('dotenv').config();

const server = express();

server.use(express.json());

server.get('/api/v1/public/get-user', (_, res) => {
  console.log('API server got request from APP server or browser');
  res.json({ user: { email: 'team@builderbook.org' } });
});

server.get('*', (_, res) => {
  res.sendStatus(403);
});

console.log(process.env.PORT_API, process.env.URL_API);

server.listen(process.env.PORT_API, () => {
  console.log(`> Ready on ${process.env.URL_API}`);
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\api\.eslintrc.js -----

module.exports = {
  parser: "@typescript-eslint/parser",
  extends: ["plugin:@typescript-eslint/recommended", "prettier"],
  env: {
    "es6": true,
    "node": true,
  },
  plugins: ["prettier"],
  rules: {
    'prettier/prettier': [
      'error',
      {
        singleQuote: true,
        trailingComma: 'all',
        arrowParens: 'always',
        printWidth: 100,
        semi: true,
      },
    ],
    '@typescript-eslint/no-unused-vars': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/no-explicit-any': 'off',
    'prefer-arrow-callback': 'error',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
 },
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\api\nodemon.json -----

{
  "watch": ["server"],
  "exec": "ts-node --project tsconfig.server.json",
  "ext": "ts"
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\api\package.json -----

{
  "name": "3-end-api",
  "version": "1",
  "license": "MIT",
  "scripts": {
    "dev": "nodemon server/server.ts",
    "lint": "eslint . --ext .ts,.tsx"
  },
  "dependencies": {
    "dotenv": "^16.4.7",
    "express": "^4.21.2",
    "typescript": "^5.8.2"
  },
  "devDependencies": {
    "@types/dotenv": "^8.2.3",
    "@types/express": "^5.0.1",
    "@types/node": "^22.13.10",
    "@typescript-eslint/eslint-plugin": "^8.27.0",
    "@typescript-eslint/parser": "^8.27.0",
    "eslint": "^9.22.0",
    "eslint-config-prettier": "^10.1.1",
    "eslint-plugin-prettier": "^5.2.3",
    "nodemon": "^3.1.9",
    "prettier": "^3.5.3",
    "ts-node": "^10.9.2"
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\api\tsconfig.json -----

{
  "compileOnSave": false,
  "compilerOptions": {
    "jsx": "preserve",
    "allowJs": true,
    "alwaysStrict": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "removeComments": false,
    "preserveConstEnums": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "sourceMap": true,
    "skipLibCheck": true,
    "baseUrl": ".",
    "experimentalDecorators": true,
    "typeRoots": ["./node_modules/@types"],
    "lib": ["es2015", "es2016"]
  },
  "exclude": ["production-server", "node_modules"]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\api\tsconfig.server.json -----

{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "module": "commonjs",
    "outDir": "production-server/"
  },
  "include": ["./server/**/*.ts"],
  "exclude": ["./server/**/*.test.ts"]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app\components\common\Confirmer.tsx -----

import Button from "@mui/material/Button";
import Dialog from "@mui/material/Dialog";
import DialogActions from "@mui/material/DialogActions";
import DialogContent from "@mui/material/DialogContent";
import DialogContentText from "@mui/material/DialogContentText";
import DialogTitle from "@mui/material/DialogTitle";
import React from "react";

export let openConfirmDialogExternal;

type State = {
  open: boolean;
  title: string;
  message: string;
  onAnswer: (answer) => void;
};

class Confirmer extends React.Component<any, State> {
  constructor(props) {
    super(props);

    this.state = {
      open: false,
      title: "Are you sure?",
      message: "",
      onAnswer: null,
    };

    openConfirmDialogExternal = this.openConfirmDialog;
  }

  public render() {
    return (
      <Dialog
        open={this.state.open}
        onClose={this.handleClose}
        aria-labelledby="alert-dialog-title"
        aria-describedby="alert-dialog-description"
      >
        <DialogTitle id="alert-dialog-title">{this.state.title}</DialogTitle>
        <DialogContent>
          <DialogContentText id="alert-dialog-description">{this.state.message}</DialogContentText>
        </DialogContent>
        <DialogActions style={{ padding: "10px" }}>
          <Button onClick={this.handleClose} variant="contained" color="primary" autoFocus>
            Cancel
          </Button>
          <Button onClick={this.handleYes} variant="contained" color="secondary">
            OK
          </Button>
        </DialogActions>
      </Dialog>
    );
  }

  public handleClose = () => {
    this.setState({ open: false });
    this.state.onAnswer(false);
  };

  public handleYes = () => {
    this.setState({ open: false });
    this.state.onAnswer(true);
  };

  public openConfirmDialog = ({ title, message, onAnswer }) => {
    this.setState({ open: true, title, message, onAnswer });
  };
}

export default Confirmer;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app\components\common\MenuWithLinks.tsx -----

import Menu from "@mui/material/Menu";
import MenuItem from "@mui/material/MenuItem";
import Link from "next/link";
import { NextRouter, withRouter } from "next/router";
import React from "react";

type Props = {
  options: {
    href: string;
    as: string;
    highlighterSlug: string;
    text: string;
    separator: boolean;
  }[];
  router: NextRouter;
  children: any;
};

type State = {
  anchorEl: Element | ((element: Element) => Element);
};

class MenuWithLinks extends React.PureComponent<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      anchorEl: null,
    };
  }

  public render() {
    const { options, children, router } = this.props;
    const { anchorEl } = this.state;

    return (
      <div style={{ textAlign: "center" }}>
        <div
          aria-controls={anchorEl ? "simple-menu" : null}
          aria-haspopup="true"
          onClick={this.handleClick}
          onKeyPress={this.handleClick}
        >
          {children}
        </div>
        <Menu id="simple-menu" anchorEl={anchorEl} open={Boolean(anchorEl)} onClose={this.handleClose} keepMounted>
          {options.map((option, i) =>
            option.separator ? (
              <hr style={{ width: "85%", margin: "10px auto" }} key={`separated-${i}`} />
            ) : (
              <Link key={option.href} href={option.href} as={option.as} passHref>
                <MenuItem
                  key={option.href}
                  style={{
                    fontWeight: router.asPath.includes(option.highlighterSlug) ? 600 : 300,
                    fontSize: "14px",
                  }}
                >
                  {option.text}
                </MenuItem>
              </Link>
            )
          )}
        </Menu>
      </div>
    );
  }

  public handleClick = (event) => {
    this.setState({ anchorEl: event.currentTarget });
  };

  public handleClose = () => {
    this.setState({ anchorEl: null });
  };
}

export default withRouter(MenuWithLinks);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app\components\common\Notifier.tsx -----

import Snackbar from "@mui/material/Snackbar";
import React from "react";

export let openSnackbarExternal;

type State = {
  open: boolean;
  message: string;
};

class Notifier extends React.PureComponent<any, State> {
  constructor(props) {
    super(props);
    openSnackbarExternal = this.openSnackbar;

    this.state = {
      open: false,
      message: "",
    };
  }

  public render() {
    const message = <span id="snackbar-message-id" dangerouslySetInnerHTML={{ __html: this.state.message }} />;

    return (
      <Snackbar
        anchorOrigin={{ vertical: "top", horizontal: "right" }}
        message={message}
        autoHideDuration={5000}
        onClose={this.handleSnackbarClose}
        open={this.state.open}
        ContentProps={{
          "aria-describedby": "snackbar-message-id",
        }}
      />
    );
  }

  public handleSnackbarClose = () => {
    this.setState({
      open: false,
      message: "",
    });
  };

  public openSnackbar = ({ message }) => {
    this.setState({ open: true, message });
  };
}

export default Notifier;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app\components\layout\index.tsx -----

import Avatar from "@mui/material/Avatar";
import Grid from "@mui/material/Grid";
import React from "react";
import MenuWithLinks from "../common/MenuWithLinks";
import Confirmer from "../common/Confirmer";
import Notifier from "../common/Notifier";

const styleGrid = {
  width: "100%",
  height: "100vh",
  maxWidth: "100%",
  padding: "0px 10px",
  display: "flex",
  overflow: "hidden",
};

const styleGridIsMobile = {
  width: "100%",
  height: "100vh",
  maxWidth: "100%",
  padding: "0px 0px 0px 10px",
  display: "flex",
  overflow: "hidden",
};

type Props = {
  children: React.ReactNode;
  firstGridItem?: boolean;
  isMobile?: boolean;
};

class Layout extends React.Component<Props> {
  public render() {
    const { children, firstGridItem, isMobile } = this.props;

    const isThemeDark = false;

    // console.log(isMobile);

    return (
      <Grid
        container
        direction="row"
        justify="flex-start"
        alignItems="stretch"
        style={isMobile ? styleGridIsMobile : styleGrid}
      >
        {firstGridItem ? (
          <Grid
            item
            sm={2}
            xs={12}
            style={{
              borderRight: "1px #707070 solid",
              justifyContent: "center",
              overflow: "hidden",
            }}
          >
            <div style={{ display: "flex", justifyContent: "space-between" }}>
              <svg
                xmlns="http://www.w3.org/2000/svg"
                width="124"
                height="40"
                viewBox="0 0 124 40"
                style={{
                  marginTop: "20px",
                  display: "inline-flex",
                  height: "40px",
                }}
              >
                <g id="async-logo">
                  <g id="async-logo-40">
                    <circle id="Ellipse 2" cx="20" cy="20" r="20" fill="black" />
                    <path
                      id="path-async-logo"
                      d="M7.07825 -0.0960007V16H4.51825V13.088C4.04892 14.0907 3.33425 14.8693 2.37425 15.424C1.43558 15.9573 0.336917 16.224 -0.92175 16.224C-2.35108 16.224 -3.60975 15.8827 -4.69775 15.2C-5.76442 14.5173 -6.59642 13.5573 -7.19375 12.32C-7.76975 11.0613 -8.05775 9.6 -8.05775 7.936C-8.05775 6.272 -7.75908 4.81067 -7.16175 3.552C-6.56442 2.272 -5.73242 1.28 -4.66575 0.576C-3.57775 -0.128 -2.32975 -0.48 -0.92175 -0.48C0.336917 -0.48 1.43558 -0.202666 2.37425 0.352C3.31292 0.906667 4.02758 1.68533 4.51825 2.688V-0.0960007H7.07825ZM-0.40975 14.08C1.16892 14.08 2.38492 13.5467 3.23825 12.48C4.09158 11.392 4.51825 9.856 4.51825 7.872C4.51825 5.888 4.09158 4.36267 3.23825 3.296C2.38492 2.22933 1.16892 1.696 -0.40975 1.696C-1.98842 1.696 -3.22575 2.25067 -4.12175 3.36C-4.99642 4.448 -5.43375 5.97333 -5.43375 7.936C-5.43375 9.89867 -4.99642 11.4133 -4.12175 12.48C-3.24708 13.5467 -2.00975 14.08 -0.40975 14.08Z"
                      transform="translate(19.5938 12)"
                      fill="white"
                    />
                  </g>
                  <path
                    id="path-async-text"
                    d="M22.6251 11.928V24H20.7051V21.816C20.3531 22.568 19.8171 23.152 19.0971 23.568C18.3931 23.968 17.5691 24.168 16.6251 24.168C15.5531 24.168 14.6091 23.912 13.7931 23.4C12.9931 22.888 12.3691 22.168 11.9211 21.24C11.4891 20.296 11.2731 19.2 11.2731 17.952C11.2731 16.704 11.4971 15.608 11.9451 14.664C12.3931 13.704 13.0171 12.96 13.8171 12.432C14.6331 11.904 15.5691 11.64 16.6251 11.64C17.5691 11.64 18.3931 11.848 19.0971 12.264C19.8011 12.68 20.3371 13.264 20.7051 14.016V11.928H22.6251ZM17.0091 22.56C18.1931 22.56 19.1051 22.16 19.7451 21.36C20.3851 20.544 20.7051 19.392 20.7051 17.904C20.7051 16.416 20.3851 15.272 19.7451 14.472C19.1051 13.672 18.1931 13.272 17.0091 13.272C15.8251 13.272 14.8971 13.688 14.2251 14.52C13.5691 15.336 13.2411 16.48 13.2411 17.952C13.2411 19.424 13.5691 20.56 14.2251 21.36C14.8811 22.16 15.8091 22.56 17.0091 22.56ZM30.4637 24.168C28.4317 24.168 26.8237 23.648 25.6397 22.608L26.2877 21.168C26.9437 21.68 27.6077 22.048 28.2797 22.272C28.9517 22.496 29.7037 22.608 30.5357 22.608C31.4477 22.608 32.1357 22.456 32.5997 22.152C33.0797 21.832 33.3197 21.376 33.3197 20.784C33.3197 20.304 33.1597 19.92 32.8397 19.632C32.5197 19.344 31.9917 19.12 31.2557 18.96L29.2157 18.48C28.2077 18.256 27.4237 17.856 26.8637 17.28C26.3197 16.704 26.0477 16.016 26.0477 15.216C26.0477 14.16 26.4717 13.304 27.3197 12.648C28.1677 11.976 29.2877 11.64 30.6797 11.64C31.5277 11.64 32.3277 11.776 33.0797 12.048C33.8317 12.32 34.4637 12.712 34.9757 13.224L34.3277 14.64C33.1917 13.696 31.9757 13.224 30.6797 13.224C29.8157 13.224 29.1437 13.392 28.6637 13.728C28.1997 14.048 27.9677 14.504 27.9677 15.096C27.9677 15.592 28.1117 15.984 28.3997 16.272C28.7037 16.56 29.1837 16.784 29.8397 16.944L31.8797 17.448C32.9997 17.704 33.8317 18.104 34.3757 18.648C34.9197 19.176 35.1917 19.872 35.1917 20.736C35.1917 21.776 34.7677 22.608 33.9197 23.232C33.0717 23.856 31.9197 24.168 30.4637 24.168ZM48.687 11.928L43.047 25.104C42.455 26.48 41.711 27.488 40.815 28.128C39.919 28.768 38.815 29.208 37.503 29.448L37.095 27.936C38.231 27.68 39.087 27.336 39.663 26.904C40.255 26.488 40.743 25.84 41.127 24.96L41.607 23.88L36.495 11.928H38.535L42.615 21.888L46.743 11.928H48.687ZM56.853 11.64C59.749 11.64 61.197 13.232 61.197 16.416V24H59.253V16.512C59.253 15.392 59.029 14.576 58.581 14.064C58.133 13.536 57.429 13.272 56.469 13.272C55.349 13.272 54.453 13.616 53.781 14.304C53.109 14.992 52.773 15.92 52.773 17.088V24H50.829V15.312C50.829 14.064 50.765 12.936 50.637 11.928H52.485L52.677 14.088C53.045 13.304 53.597 12.704 54.333 12.288C55.069 11.856 55.909 11.64 56.853 11.64ZM69.9321 24.168C68.7641 24.168 67.7401 23.912 66.8601 23.4C65.9961 22.888 65.3241 22.168 64.8441 21.24C64.3801 20.296 64.1481 19.2 64.1481 17.952C64.1481 16.704 64.3881 15.608 64.8681 14.664C65.3481 13.704 66.0281 12.96 66.9081 12.432C67.8041 11.904 68.8441 11.64 70.0281 11.64C70.8441 11.64 71.6281 11.784 72.3801 12.072C73.1481 12.344 73.7801 12.728 74.2761 13.224L73.6281 14.664C73.0201 14.184 72.4281 13.832 71.8521 13.608C71.2921 13.384 70.7161 13.272 70.1241 13.272C68.8921 13.272 67.9241 13.688 67.2201 14.52C66.5161 15.336 66.1641 16.48 66.1641 17.952C66.1641 19.408 66.5081 20.544 67.1961 21.36C67.9001 22.16 68.8761 22.56 70.1241 22.56C70.7161 22.56 71.2921 22.448 71.8521 22.224C72.4281 22 73.0201 21.648 73.6281 21.168L74.2761 22.608C73.7641 23.088 73.1161 23.472 72.3321 23.76C71.5641 24.032 70.7641 24.168 69.9321 24.168Z"
                    transform="translate(39 4)"
                    fill={isThemeDark ? "white" : "black"}
                  />
                </g>
              </svg>
              <MenuWithLinks
                options={[
                  {
                    text: "Index page",
                    href: "/",
                    highlighterSlug: "/",
                  },
                  {
                    text: "Your Settings",
                    href: "/your-settings",
                    highlighterSlug: "/your-settings",
                  },
                  {
                    separator: true,
                  },
                  {
                    text: "Log out",
                    href: "/logout",
                  },
                ]}
              >
                <Avatar
                  src={"https://storage.googleapis.com/async-await/default-user.png"}
                  alt="Add username here later in the book"
                  style={{
                    margin: "20px auto",
                    cursor: "pointer",
                    display: "inline-flex",
                    width: "40px",
                    height: "40px",
                  }}
                />

                <i className="material-icons" color="action" style={{ verticalAlign: "super" }}>
                  arrow_drop_down
                </i>
              </MenuWithLinks>
            </div>
            <hr />
            <p />
            <p />
          </Grid>
        ) : null}
        <Grid item sm={10} xs={12}>
          {isMobile ? <hr /> : null}
          {children}
        </Grid>
        <Notifier />
        <Confirmer />
      </Grid>
    );
  }
}

export default Layout;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app\lib\api\public.ts -----

import sendRequestAndGetResponse from './sendRequestAndGetResponse';

const BASE_PATH = '/api/v1/public';

export const getUserApiMethod = (request) =>
  sendRequestAndGetResponse(`${BASE_PATH}/get-user`, {
    request,
    method: 'GET',
  });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app\lib\api\sendRequestAndGetResponse.ts -----

import 'isomorphic-unfetch';

export default async function sendRequestAndGetResponse(path, opts: any = {}) {
  const headers = Object.assign({}, opts.headers || {}, {
    'Content-type': 'application/json; charset=UTF-8',
  });

  const { request } = opts;
  if (request && request.headers && request.headers.cookie) {
    headers.cookie = request.headers.cookie;
  }

  const qs = opts.qs || '';

  const response = await fetch(
    `${process.env.NEXT_PUBLIC_URL_API}${path}${qs}`,
    Object.assign({ method: 'POST', credentials: 'include' }, opts, { headers }),
  );

  // console.log(`${process.env.NEXT_PUBLIC_URL_API}${path}${qs}`);
  // console.log(response.status);
  // console.log(response.statusText);

  const text = await response.text();

  if (response.status >= 400) {
    // console.error(text);
    throw new Error(response.status.toString());
  }

  try {
    const data = JSON.parse(text);

    return data;
  } catch (err) {
    if (err instanceof SyntaxError) {
      return text;
    }

    throw err;
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app\lib\confirm.ts -----

import { openConfirmDialogExternal } from '../components/common/Confirmer';

export default function confirm({
  title,
  message,
  onAnswer,
}: {
  title: string;
  message: string;
  onAnswer: (answer) => void;
}) {
  openConfirmDialogExternal({ title, message, onAnswer });
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app\lib\isMobile.ts -----

const mobileRE = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i;

export function isMobile(opts) {
  if (!opts) {
    opts = {};
  }

  let ua = opts.ua;

  if (!ua && typeof navigator !== 'undefined') {
    ua = navigator.userAgent;
  }

  if (!ua && opts.req && opts.req.headers && typeof opts.req.headers['user-agent'] === 'string') {
    ua = opts.req.headers['user-agent'];
    // console.log(ua);
  }

  if (typeof ua !== 'string') {
    return false;
  }

  return mobileRE.test(ua);
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app\lib\notify.ts -----

import { openSnackbarExternal } from '../components/common/Notifier';

export default function notify(obj) {
  openSnackbarExternal({ message: obj.message || obj.toString() });
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app\lib\sharedStyles.ts -----

const styleBigAvatar = {
  width: '80px',
  height: '80px',
  margin: '0px auto 15px',
};

const styleRaisedButton = {
  margin: '15px',
  font: '14px Roboto',
};

const styleToolbar = {
  background: '#FFF',
  height: '64px',
  paddingRight: '20px',
};

const styleTextField = {
  font: '15px Roboto',
  color: '#222',
  fontWeight: '300',
};

const styleForm = {
  margin: '7% auto',
  width: '360px',
};

export { styleBigAvatar, styleRaisedButton, styleToolbar, styleTextField, styleForm };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app\lib\theme.ts -----

import { createMuiTheme } from "@mui/material/styles";

const themeDark = createMuiTheme({
  palette: {
    primary: { main: "#238636" },
    secondary: { main: "#b62324" },
    type: "dark",
    background: { default: "#0d1117" },
    text: {
      primary: "#c9d1d9",
    },
  },
  typography: {
    button: {
      textTransform: "none",
    },
  },
});

const themeLight = createMuiTheme({
  palette: {
    primary: { main: "#238636" },
    secondary: { main: "#b62324" },
    type: "light",
    background: { default: "#fff" },
    text: {
      primary: "#222",
    },
  },
  typography: {
    button: {
      textTransform: "none",
    },
  },
});

export { themeDark, themeLight };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app\pages\csr-page.tsx -----

import Button from "@mui/material/Button";
import React from "react";
import Head from "next/head";

const CSRPage = () => (
  <div>
    <Head>
      <title>CSR page</title>
      <meta name="description" content="This is a description of the CSR page" />
    </Head>
    <div style={{ padding: "0px 30px", fontSize: "15px", height: "100%" }}>
      <p>Content on CSR page</p>
      <Button variant="outlined">Some button</Button>
    </div>
  </div>
);

console.log(process.env.NEXT_PUBLIC_URL_APP);

export default CSRPage;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app\pages\index.tsx -----

import Button from "@mui/material/Button";
import React from "react";
import Head from "next/head";
import Link from "next/link";

import Layout from "../components/layout";
import NProgress from "nprogress";

import confirm from "../lib/confirm";
import notify from "../lib/notify";
import { getUserApiMethod } from "../lib/api/public";

type Props = { user: { email: string } };

class Index extends React.Component<Props> {
  public static async getInitialProps(ctx) {
    const { req } = ctx;

    const user = await getUserApiMethod(req);

    console.log(user);

    return { ...user };
  }

  public render() {
    return (
      <Layout {...this.props}>
        <Head>
          <title>Index page</title>
          <meta name="description" content="This is a description of the Index page" />
        </Head>
        <div style={{ padding: "0px 30px", fontSize: "15px", height: "100%" }}>
          <p>Content on Index page</p>
          <Link href="/csr-page" as="/csr-page">
            Go to CSR page
          </Link>
          <p />
          <Button
            variant="contained"
            onClick={() =>
              confirm({
                title: "Are you sure?",
                message: "explanatory message",
                onAnswer: async (answer) => {
                  // console.log(answer);
                  if (!answer) {
                    return;
                  }

                  NProgress.start();

                  try {
                    notify("You successfully confirmed.");
                  } catch (error) {
                    console.error(error);
                    notify(error);
                  } finally {
                    NProgress.done();
                  }
                },
              })
            }
          >
            Test Confirmer and Notifier
          </Button>
          <p>Email: {this.props.user.email}</p>
        </div>
      </Layout>
    );
  }
}

export default Index;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app\pages\_app.tsx -----

import CssBaseline from "@mui/material/CssBaseline";
import { ThemeProvider } from "@mui/material";
import App from "next/app";
import Head from "next/head";
import React from "react";
import { isMobile } from "../lib/isMobile";
import { themeDark, themeLight } from "../lib/theme";

class MyApp extends App {
  public static async getInitialProps({ Component, ctx }) {
    const pageProps = { isMobile: isMobile({ req: ctx.req }), firstGridItem: true };

    if (Component.getInitialProps) {
      Object.assign(pageProps, await Component.getInitialProps(ctx));
    }

    // console.log(pageProps);

    return { pageProps };
  }

  public componentDidMount() {
    // Remove the server-side injected CSS.
    const jssStyles = document.querySelector("#jss-server-side");
    if (jssStyles && jssStyles.parentNode) {
      jssStyles.parentNode.removeChild(jssStyles);
    }
  }
  public render() {
    const { Component, pageProps } = this.props;

    return (
      <ThemeProvider theme={false ? themeDark : themeLight}>
        <Head>
          <meta name="viewport" content="width=device-width, initial-scale=1.0" />
          <link rel="stylesheet" href="https://storage.googleapis.com/async-await/nprogress-dark.min.css?v=1" />
        </Head>
        <CssBaseline />
        <Component {...pageProps} />
      </ThemeProvider>
    );
  }
}

export default MyApp;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app\pages\_document.tsx -----

import Document, { Head, Html, Main, NextScript } from "next/document";
import React from "react";

class MyDocument extends Document {
  public static getInitialProps = async (ctx) => {
    const initialProps = await Document.getInitialProps(ctx);

    return {
      ...initialProps,
    };
  };

  public render() {
    // console.log('rendered on the server');

    return (
      <Html lang="en">
        <Head>
          <meta charSet="utf-8" />
          <meta name="google" content="notranslate" />
          <meta name="theme-color" content="#303030" />

          <link rel="shortcut icon" href="https://storage.googleapis.com/async-await/async-favicon32.png" />

          <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons" />
          <link rel="stylesheet" href="https://storage.googleapis.com/async-await/vs2015.min.css" />

          <style>
            {`
              #__next {
                width: 100%;
                height: 100%;
              }
              a {
                font-weight: 400;
                color: #58a6ff;
                text-decoration: none;
                outline: none;
              }
              hr {
                border: 0.5px #707070 solid;
                color: #000;
              }
              blockquote {
                padding: 0 0.5em;
                margin: 20px 1em;
                border-left: 0.25em solid #dfe2e5;
                color: #000;
              }
              pre {
                display: block;
                overflow-x: auto;
                padding: 0.5em;
                background: #d0d0d0;
                border: 1px solid #ddd;
                font-size: 14px;
                color: #000;
              }
              pre code {
                font-size: 13px;
                background: #d0d0d0;
                padding: 0px;
                color: #000;
              }
              code {
                font-size: 13px;
                background: #d0d0d0;
                padding: 3px 5px;
                color: #000;
              }
              mark {
                background-color: #ffff0060;
              }
              summary:focus {
                outline: none;
              }
              table {
                border-collapse: collapse;
                margin: 15px 0px;
              }
              table, th, td {
                border: 1px solid #a1a1a1;
              }
              th, td {
                line-height: 1.5em;
                padding: 10px;
              }
            `}
          </style>
        </Head>
        <body>
          <Main />
          <NextScript />
        </body>
      </Html>
    );
  }
}

export default MyDocument;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app\server\server.ts -----

import express from 'express';
import next from 'next';

const NODE_ENV = process.env.NODE_ENV || 'development';
const IS_DEV = NODE_ENV !== 'production';

const app = next({ dev: IS_DEV });
const handle = app.getRequestHandler();

app.prepare().then(() => {
  const server = express();

  // give all Nextjs's request to Nextjs before anything else
  server.get('/_next/*', (req, res) => {
    // console.log('next server, page');
    handle(req, res);
  });

  server.use(express.json());

  // server.get('/api/v1/public/get-user', (_, res) => {
  //   res.json({ user: { email: 'team@builderbook.org' } });
  // });

  server.all('*', (req, res) => {
    handle(req, res);
  });

  server.listen(process.env.NEXT_PUBLIC_PORT_APP, () => {
    console.log(`> Ready on ${process.env.NEXT_PUBLIC_URL_APP}`);
  });
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app\.eslintrc.js -----

module.exports = {
  settings: {
    react: { version: 'detect' },
  },
  parser: '@typescript-eslint/parser',
  extends: ['plugin:react/recommended', 'plugin:@typescript-eslint/recommended', 'prettier'],
  env: {
    es6: true,
    node: true,
  },
  plugins: ['prettier', 'react'],
  rules: {
    'prettier/prettier': [
      'error',
      {
        singleQuote: true,
        trailingComma: 'all',
        arrowParens: 'always',
        printWidth: 100,
        semi: true,
      },
    ],
    '@typescript-eslint/camelcase': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    'react/no-unescaped-entities': 'off',
    'react/jsx-filename-extension': ['error', { extensions: ['.tsx'] }],
    '@typescript-eslint/no-explicit-any': 'off',
    'prefer-arrow-callback': 'error',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
  },
};

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app\next-env.d.ts -----

/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/basic-features/typescript for more information.

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app\next.config.js -----

module.exports = {
  poweredByHeader: false,
  webpack5: true,
  typescript: {
    ignoreBuildErrors: true,
  },
};

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app\nodemon.json -----

{
  "watch": ["server"],
  "exec": "ts-node --project tsconfig.server.json",
  "ext": "ts"
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app\package.json -----

{
  "name": "3-end-app",
  "version": "1",
  "license": "MIT",
  "scripts": {
    "dev": "nodemon server/server.ts",
    "build": "next build && tsc --project tsconfig.server.json",
    "lint": "eslint . --ext .ts,.tsx"
  },
  "dependencies": {
    "@emotion/react": "^11.14.0",
    "@emotion/styled": "^11.14.0",
    "@mui/material": "^6.4.8",
    "@mui/system": "^6.4.8",
    "dotenv": "^16.3.1",
    "express": "^4.18.2",
    "isomorphic-unfetch": "^4.0.2",
    "next": "^14.0.4",
    "nprogress": "^0.2.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "typescript": "^5.3.3"
  },
  "devDependencies": {
    "@types/express": "^4.17.21",
    "@types/node": "^20.10.4",
    "@types/react": "^18.2.42",
    "@types/react-dom": "^18.2.17",
    "@typescript-eslint/eslint-plugin": "^6.13.2",
    "@typescript-eslint/parser": "^6.13.2",
    "eslint": "^8.55.0",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-prettier": "^5.0.1",
    "eslint-plugin-react": "^7.33.2",
    "nodemon": "^3.0.2",
    "prettier": "^3.1.0",
    "ts-node": "^10.9.2"
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app\tsconfig.json -----

{
  "compileOnSave": false,
  "compilerOptions": {
    "target": "esnext",
    "module": "esnext",
    "jsx": "preserve",
    "allowJs": true,
    "alwaysStrict": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "removeComments": true,
    "preserveConstEnums": true,
    "sourceMap": false,
    "skipLibCheck": true,
    "baseUrl": ".",
    "typeRoots": [
      "./node_modules/@types"
    ],
    "lib": [
      "dom",
      "es2017"
    ],
    "strict": false,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "incremental": true
  },
  "include": [
    "next-env.d.ts",
    "./**/*.tsx",
    "./**/*.ts"
  ],
  "exclude": [
    "dist",
    "production-server",
    ".next",
    "out",
    "next.config.js",
    "node_modules"
  ]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\3-end\app\tsconfig.server.json -----

{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "module": "commonjs",
    "outDir": "production-server/",
    "target": "es2017",
    "isolatedModules": false,
    "noEmit": false
  },
  "exclude": ["./server/types.d.ts"],
  "include": ["./server/**/*.ts"],
  "typeRoots": ["./node_modules/@types", "./server/types.d.ts"]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\api\server\server.ts -----

import * as express from 'express';

// eslint-disable-next-line
require('dotenv').config();

const server = express();

server.use(express.json());

server.get('/api/v1/public/get-user', (_, res) => {
  console.log('API server got request from APP server or browser');
  res.json({ user: { email: 'team@builderbook.org' } });
});

server.get('*', (_, res) => {
  res.sendStatus(403);
});

console.log(process.env.PORT_API, process.env.URL_API);

server.listen(process.env.PORT_API, () => {
  console.log(`> Ready on ${process.env.URL_API}`);
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\api\.eslintrc.js -----

module.exports = {
  parser: "@typescript-eslint/parser",
  extends: ["plugin:@typescript-eslint/recommended", "prettier"],
  env: {
    "es6": true,
    "node": true,
  },
  plugins: ["prettier"],
  rules: {
    'prettier/prettier': [
      'error',
      {
        singleQuote: true,
        trailingComma: 'all',
        arrowParens: 'always',
        printWidth: 100,
        semi: true,
      },
    ],
    '@typescript-eslint/no-unused-vars': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/no-explicit-any': 'off',
    'prefer-arrow-callback': 'error',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
 },
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\api\nodemon.json -----

{
  "watch": ["server"],
  "exec": "ts-node --project tsconfig.server.json",
  "ext": "ts"
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\api\package.json -----

{
  "name": "4-begin-api",
  "version": "1",
  "license": "MIT",
  "scripts": {
    "dev": "nodemon server/server.ts",
    "lint": "eslint . --ext .ts,.tsx"
  },
  "dependencies": {
    "dotenv": "^16.4.7",
    "express": "^4.21.2",
    "typescript": "^5.8.2"
  },
  "devDependencies": {
    "@types/dotenv": "^8.2.3",
    "@types/express": "^5.0.1",
    "@types/node": "^22.13.10",
    "@typescript-eslint/eslint-plugin": "^8.27.0",
    "@typescript-eslint/parser": "^8.27.0",
    "eslint": "^9.22.0",
    "eslint-config-prettier": "^10.1.1",
    "eslint-plugin-prettier": "^5.2.3",
    "nodemon": "^3.1.9",
    "prettier": "^3.5.3",
    "ts-node": "^10.9.2"
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\api\tsconfig.json -----

{
  "compileOnSave": false,
  "compilerOptions": {
    "jsx": "preserve",
    "allowJs": true,
    "alwaysStrict": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "removeComments": false,
    "preserveConstEnums": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "sourceMap": true,
    "skipLibCheck": true,
    "baseUrl": ".",
    "experimentalDecorators": true,
    "typeRoots": ["./node_modules/@types"],
    "lib": ["es2015", "es2016"]
  },
  "exclude": ["production-server", "node_modules"]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\api\tsconfig.server.json -----

{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "module": "commonjs",
    "outDir": "production-server/"
  },
  "include": ["./server/**/*.ts"],
  "exclude": ["./server/**/*.test.ts"]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app\components\common\Confirmer.tsx -----

import Button from "@mui/material/Button";
import Dialog from "@mui/material/Dialog";
import DialogActions from "@mui/material/DialogActions";
import DialogContent from "@mui/material/DialogContent";
import DialogContentText from "@mui/material/DialogContentText";
import DialogTitle from "@mui/material/DialogTitle";
import React from "react";

export let openConfirmDialogExternal;

type State = {
  open: boolean;
  title: string;
  message: string;
  onAnswer: (answer) => void;
};

class Confirmer extends React.Component<any, State> {
  constructor(props) {
    super(props);

    this.state = {
      open: false,
      title: "Are you sure?",
      message: "",
      onAnswer: null,
    };

    openConfirmDialogExternal = this.openConfirmDialog;
  }

  public render() {
    return (
      <Dialog
        open={this.state.open}
        onClose={this.handleClose}
        aria-labelledby="alert-dialog-title"
        aria-describedby="alert-dialog-description"
      >
        <DialogTitle id="alert-dialog-title">{this.state.title}</DialogTitle>
        <DialogContent>
          <DialogContentText id="alert-dialog-description">{this.state.message}</DialogContentText>
        </DialogContent>
        <DialogActions style={{ padding: "10px" }}>
          <Button onClick={this.handleClose} variant="contained" color="primary" autoFocus>
            Cancel
          </Button>
          <Button onClick={this.handleYes} variant="contained" color="secondary">
            OK
          </Button>
        </DialogActions>
      </Dialog>
    );
  }

  public handleClose = () => {
    this.setState({ open: false });
    this.state.onAnswer(false);
  };

  public handleYes = () => {
    this.setState({ open: false });
    this.state.onAnswer(true);
  };

  public openConfirmDialog = ({ title, message, onAnswer }) => {
    this.setState({ open: true, title, message, onAnswer });
  };
}

export default Confirmer;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app\components\common\MenuWithLinks.tsx -----

import Menu from "@mui/material/Menu";
import MenuItem from "@mui/material/MenuItem";
import Link from "next/link";
import { NextRouter, withRouter } from "next/router";
import React from "react";

type Props = {
  options: {
    href: string;
    as: string;
    highlighterSlug: string;
    text: string;
    separator: boolean;
  }[];
  router: NextRouter;
  children: any;
};

type State = {
  anchorEl: Element | ((element: Element) => Element);
};

class MenuWithLinks extends React.PureComponent<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      anchorEl: null,
    };
  }

  public render() {
    const { options, children, router } = this.props;
    const { anchorEl } = this.state;

    return (
      <div style={{ textAlign: "center" }}>
        <div
          aria-controls={anchorEl ? "simple-menu" : null}
          aria-haspopup="true"
          onClick={this.handleClick}
          onKeyPress={this.handleClick}
        >
          {children}
        </div>
        <Menu id="simple-menu" anchorEl={anchorEl} open={Boolean(anchorEl)} onClose={this.handleClose} keepMounted>
          {options.map((option, i) =>
            option.separator ? (
              <hr style={{ width: "85%", margin: "10px auto" }} key={`separated-${i}`} />
            ) : (
              <Link key={option.href} href={option.href} as={option.as} passHref>
                <MenuItem
                  key={option.href}
                  style={{
                    fontWeight: router.asPath.includes(option.highlighterSlug) ? 600 : 300,
                    fontSize: "14px",
                  }}
                >
                  {option.text}
                </MenuItem>
              </Link>
            )
          )}
        </Menu>
      </div>
    );
  }

  public handleClick = (event) => {
    this.setState({ anchorEl: event.currentTarget });
  };

  public handleClose = () => {
    this.setState({ anchorEl: null });
  };
}

export default withRouter(MenuWithLinks);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app\components\common\Notifier.tsx -----

import Snackbar from "@mui/material/Snackbar";
import React from "react";

export let openSnackbarExternal;

type State = {
  open: boolean;
  message: string;
};

class Notifier extends React.PureComponent<any, State> {
  constructor(props) {
    super(props);
    openSnackbarExternal = this.openSnackbar;

    this.state = {
      open: false,
      message: "",
    };
  }

  public render() {
    const message = <span id="snackbar-message-id" dangerouslySetInnerHTML={{ __html: this.state.message }} />;

    return (
      <Snackbar
        anchorOrigin={{ vertical: "top", horizontal: "right" }}
        message={message}
        autoHideDuration={5000}
        onClose={this.handleSnackbarClose}
        open={this.state.open}
        ContentProps={{
          "aria-describedby": "snackbar-message-id",
        }}
      />
    );
  }

  public handleSnackbarClose = () => {
    this.setState({
      open: false,
      message: "",
    });
  };

  public openSnackbar = ({ message }) => {
    this.setState({ open: true, message });
  };
}

export default Notifier;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app\components\layout\index.tsx -----

import Avatar from "@mui/material/Avatar";
import Grid from "@mui/material/Grid";
import React from "react";
import MenuWithLinks from "../common/MenuWithLinks";
import Confirmer from "../common/Confirmer";
import Notifier from "../common/Notifier";

const styleGrid = {
  width: "100%",
  height: "100vh",
  maxWidth: "100%",
  padding: "0px 10px",
  display: "flex",
  overflow: "hidden",
};

const styleGridIsMobile = {
  width: "100%",
  height: "100vh",
  maxWidth: "100%",
  padding: "0px 0px 0px 10px",
  display: "flex",
  overflow: "hidden",
};

type Props = {
  children: React.ReactNode;
  firstGridItem?: boolean;
  isMobile?: boolean;
};

class Layout extends React.Component<Props> {
  public render() {
    const { children, firstGridItem, isMobile } = this.props;

    const isThemeDark = false;

    // console.log(isMobile);

    return (
      <Grid
        container
        direction="row"
        justify="flex-start"
        alignItems="stretch"
        style={isMobile ? styleGridIsMobile : styleGrid}
      >
        {firstGridItem ? (
          <Grid
            item
            sm={2}
            xs={12}
            style={{
              borderRight: "1px #707070 solid",
              justifyContent: "center",
              overflow: "hidden",
            }}
          >
            <div style={{ display: "flex", justifyContent: "space-between" }}>
              <svg
                xmlns="http://www.w3.org/2000/svg"
                width="124"
                height="40"
                viewBox="0 0 124 40"
                style={{
                  marginTop: "20px",
                  display: "inline-flex",
                  height: "40px",
                }}
              >
                <g id="async-logo">
                  <g id="async-logo-40">
                    <circle id="Ellipse 2" cx="20" cy="20" r="20" fill="black" />
                    <path
                      id="path-async-logo"
                      d="M7.07825 -0.0960007V16H4.51825V13.088C4.04892 14.0907 3.33425 14.8693 2.37425 15.424C1.43558 15.9573 0.336917 16.224 -0.92175 16.224C-2.35108 16.224 -3.60975 15.8827 -4.69775 15.2C-5.76442 14.5173 -6.59642 13.5573 -7.19375 12.32C-7.76975 11.0613 -8.05775 9.6 -8.05775 7.936C-8.05775 6.272 -7.75908 4.81067 -7.16175 3.552C-6.56442 2.272 -5.73242 1.28 -4.66575 0.576C-3.57775 -0.128 -2.32975 -0.48 -0.92175 -0.48C0.336917 -0.48 1.43558 -0.202666 2.37425 0.352C3.31292 0.906667 4.02758 1.68533 4.51825 2.688V-0.0960007H7.07825ZM-0.40975 14.08C1.16892 14.08 2.38492 13.5467 3.23825 12.48C4.09158 11.392 4.51825 9.856 4.51825 7.872C4.51825 5.888 4.09158 4.36267 3.23825 3.296C2.38492 2.22933 1.16892 1.696 -0.40975 1.696C-1.98842 1.696 -3.22575 2.25067 -4.12175 3.36C-4.99642 4.448 -5.43375 5.97333 -5.43375 7.936C-5.43375 9.89867 -4.99642 11.4133 -4.12175 12.48C-3.24708 13.5467 -2.00975 14.08 -0.40975 14.08Z"
                      transform="translate(19.5938 12)"
                      fill="white"
                    />
                  </g>
                  <path
                    id="path-async-text"
                    d="M22.6251 11.928V24H20.7051V21.816C20.3531 22.568 19.8171 23.152 19.0971 23.568C18.3931 23.968 17.5691 24.168 16.6251 24.168C15.5531 24.168 14.6091 23.912 13.7931 23.4C12.9931 22.888 12.3691 22.168 11.9211 21.24C11.4891 20.296 11.2731 19.2 11.2731 17.952C11.2731 16.704 11.4971 15.608 11.9451 14.664C12.3931 13.704 13.0171 12.96 13.8171 12.432C14.6331 11.904 15.5691 11.64 16.6251 11.64C17.5691 11.64 18.3931 11.848 19.0971 12.264C19.8011 12.68 20.3371 13.264 20.7051 14.016V11.928H22.6251ZM17.0091 22.56C18.1931 22.56 19.1051 22.16 19.7451 21.36C20.3851 20.544 20.7051 19.392 20.7051 17.904C20.7051 16.416 20.3851 15.272 19.7451 14.472C19.1051 13.672 18.1931 13.272 17.0091 13.272C15.8251 13.272 14.8971 13.688 14.2251 14.52C13.5691 15.336 13.2411 16.48 13.2411 17.952C13.2411 19.424 13.5691 20.56 14.2251 21.36C14.8811 22.16 15.8091 22.56 17.0091 22.56ZM30.4637 24.168C28.4317 24.168 26.8237 23.648 25.6397 22.608L26.2877 21.168C26.9437 21.68 27.6077 22.048 28.2797 22.272C28.9517 22.496 29.7037 22.608 30.5357 22.608C31.4477 22.608 32.1357 22.456 32.5997 22.152C33.0797 21.832 33.3197 21.376 33.3197 20.784C33.3197 20.304 33.1597 19.92 32.8397 19.632C32.5197 19.344 31.9917 19.12 31.2557 18.96L29.2157 18.48C28.2077 18.256 27.4237 17.856 26.8637 17.28C26.3197 16.704 26.0477 16.016 26.0477 15.216C26.0477 14.16 26.4717 13.304 27.3197 12.648C28.1677 11.976 29.2877 11.64 30.6797 11.64C31.5277 11.64 32.3277 11.776 33.0797 12.048C33.8317 12.32 34.4637 12.712 34.9757 13.224L34.3277 14.64C33.1917 13.696 31.9757 13.224 30.6797 13.224C29.8157 13.224 29.1437 13.392 28.6637 13.728C28.1997 14.048 27.9677 14.504 27.9677 15.096C27.9677 15.592 28.1117 15.984 28.3997 16.272C28.7037 16.56 29.1837 16.784 29.8397 16.944L31.8797 17.448C32.9997 17.704 33.8317 18.104 34.3757 18.648C34.9197 19.176 35.1917 19.872 35.1917 20.736C35.1917 21.776 34.7677 22.608 33.9197 23.232C33.0717 23.856 31.9197 24.168 30.4637 24.168ZM48.687 11.928L43.047 25.104C42.455 26.48 41.711 27.488 40.815 28.128C39.919 28.768 38.815 29.208 37.503 29.448L37.095 27.936C38.231 27.68 39.087 27.336 39.663 26.904C40.255 26.488 40.743 25.84 41.127 24.96L41.607 23.88L36.495 11.928H38.535L42.615 21.888L46.743 11.928H48.687ZM56.853 11.64C59.749 11.64 61.197 13.232 61.197 16.416V24H59.253V16.512C59.253 15.392 59.029 14.576 58.581 14.064C58.133 13.536 57.429 13.272 56.469 13.272C55.349 13.272 54.453 13.616 53.781 14.304C53.109 14.992 52.773 15.92 52.773 17.088V24H50.829V15.312C50.829 14.064 50.765 12.936 50.637 11.928H52.485L52.677 14.088C53.045 13.304 53.597 12.704 54.333 12.288C55.069 11.856 55.909 11.64 56.853 11.64ZM69.9321 24.168C68.7641 24.168 67.7401 23.912 66.8601 23.4C65.9961 22.888 65.3241 22.168 64.8441 21.24C64.3801 20.296 64.1481 19.2 64.1481 17.952C64.1481 16.704 64.3881 15.608 64.8681 14.664C65.3481 13.704 66.0281 12.96 66.9081 12.432C67.8041 11.904 68.8441 11.64 70.0281 11.64C70.8441 11.64 71.6281 11.784 72.3801 12.072C73.1481 12.344 73.7801 12.728 74.2761 13.224L73.6281 14.664C73.0201 14.184 72.4281 13.832 71.8521 13.608C71.2921 13.384 70.7161 13.272 70.1241 13.272C68.8921 13.272 67.9241 13.688 67.2201 14.52C66.5161 15.336 66.1641 16.48 66.1641 17.952C66.1641 19.408 66.5081 20.544 67.1961 21.36C67.9001 22.16 68.8761 22.56 70.1241 22.56C70.7161 22.56 71.2921 22.448 71.8521 22.224C72.4281 22 73.0201 21.648 73.6281 21.168L74.2761 22.608C73.7641 23.088 73.1161 23.472 72.3321 23.76C71.5641 24.032 70.7641 24.168 69.9321 24.168Z"
                    transform="translate(39 4)"
                    fill={isThemeDark ? "white" : "black"}
                  />
                </g>
              </svg>
              <MenuWithLinks
                options={[
                  {
                    text: "Index page",
                    href: "/",
                    highlighterSlug: "/",
                  },
                  {
                    text: "Your Settings",
                    href: "/your-settings",
                    highlighterSlug: "/your-settings",
                  },
                  {
                    separator: true,
                  },
                  {
                    text: "Log out",
                    href: "/logout",
                  },
                ]}
              >
                <Avatar
                  src={"https://storage.googleapis.com/async-await/default-user.png"}
                  alt="Add username here later in the book"
                  style={{
                    margin: "20px auto",
                    cursor: "pointer",
                    display: "inline-flex",
                    width: "40px",
                    height: "40px",
                  }}
                />

                <i className="material-icons" color="action" style={{ verticalAlign: "super" }}>
                  arrow_drop_down
                </i>
              </MenuWithLinks>
            </div>
            <hr />
            <p />
            <p />
          </Grid>
        ) : null}
        <Grid item sm={10} xs={12}>
          {isMobile ? <hr /> : null}
          {children}
        </Grid>
        <Notifier />
        <Confirmer />
      </Grid>
    );
  }
}

export default Layout;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app\lib\api\public.ts -----

import sendRequestAndGetResponse from './sendRequestAndGetResponse';

const BASE_PATH = '/api/v1/public';

export const getUserApiMethod = (request) =>
  sendRequestAndGetResponse(`${BASE_PATH}/get-user`, {
    request,
    method: 'GET',
  });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app\lib\api\sendRequestAndGetResponse.ts -----

import 'isomorphic-unfetch';

export default async function sendRequestAndGetResponse(path, opts: any = {}) {
  const headers = Object.assign({}, opts.headers || {}, {
    'Content-type': 'application/json; charset=UTF-8',
  });

  const { request } = opts;
  if (request && request.headers && request.headers.cookie) {
    headers.cookie = request.headers.cookie;
  }

  const qs = opts.qs || '';

  const response = await fetch(
    `${process.env.NEXT_PUBLIC_URL_API}${path}${qs}`,
    Object.assign({ method: 'POST', credentials: 'include' }, opts, { headers }),
  );

  // console.log(`${process.env.NEXT_PUBLIC_URL_API}${path}${qs}`);
  // console.log(response.status);
  // console.log(response.statusText);

  const text = await response.text();

  if (response.status >= 400) {
    // console.error(text);
    throw new Error(response.status.toString());
  }

  try {
    const data = JSON.parse(text);

    return data;
  } catch (err) {
    if (err instanceof SyntaxError) {
      return text;
    }

    throw err;
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app\lib\confirm.ts -----

import { openConfirmDialogExternal } from '../components/common/Confirmer';

export default function confirm({
  title,
  message,
  onAnswer,
}: {
  title: string;
  message: string;
  onAnswer: (answer) => void;
}) {
  openConfirmDialogExternal({ title, message, onAnswer });
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app\lib\isMobile.ts -----

const mobileRE = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i;

export function isMobile(opts) {
  if (!opts) {
    opts = {};
  }

  let ua = opts.ua;

  if (!ua && typeof navigator !== 'undefined') {
    ua = navigator.userAgent;
  }

  if (!ua && opts.req && opts.req.headers && typeof opts.req.headers['user-agent'] === 'string') {
    ua = opts.req.headers['user-agent'];
    // console.log(ua);
  }

  if (typeof ua !== 'string') {
    return false;
  }

  return mobileRE.test(ua);
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app\lib\notify.ts -----

import { openSnackbarExternal } from '../components/common/Notifier';

export default function notify(obj) {
  openSnackbarExternal({ message: obj.message || obj.toString() });
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app\lib\sharedStyles.ts -----

const styleBigAvatar = {
  width: '80px',
  height: '80px',
  margin: '0px auto 15px',
};

const styleRaisedButton = {
  margin: '15px',
  font: '14px Roboto',
};

const styleToolbar = {
  background: '#FFF',
  height: '64px',
  paddingRight: '20px',
};

const styleTextField = {
  font: '15px Roboto',
  color: '#222',
  fontWeight: '300',
};

const styleForm = {
  margin: '7% auto',
  width: '360px',
};

export { styleBigAvatar, styleRaisedButton, styleToolbar, styleTextField, styleForm };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app\lib\theme.ts -----

import { createMuiTheme } from "@mui/material/styles";

const themeDark = createMuiTheme({
  palette: {
    primary: { main: "#238636" },
    secondary: { main: "#b62324" },
    type: "dark",
    background: { default: "#0d1117" },
    text: {
      primary: "#c9d1d9",
    },
  },
  typography: {
    button: {
      textTransform: "none",
    },
  },
});

const themeLight = createMuiTheme({
  palette: {
    primary: { main: "#238636" },
    secondary: { main: "#b62324" },
    type: "light",
    background: { default: "#fff" },
    text: {
      primary: "#222",
    },
  },
  typography: {
    button: {
      textTransform: "none",
    },
  },
});

export { themeDark, themeLight };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app\pages\csr-page.tsx -----

import Button from "@mui/material/Button";
import React from "react";
import Head from "next/head";

const CSRPage = () => (
  <div>
    <Head>
      <title>CSR page</title>
      <meta name="description" content="This is a description of the CSR page" />
    </Head>
    <div style={{ padding: "0px 30px", fontSize: "15px", height: "100%" }}>
      <p>Content on CSR page</p>
      <Button variant="outlined">Some button</Button>
    </div>
  </div>
);

console.log(process.env.NEXT_PUBLIC_URL_APP);

export default CSRPage;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app\pages\index.tsx -----

import Button from "@mui/material/Button";
import React from "react";
import Head from "next/head";
import Link from "next/link";

import Layout from "../components/layout";
import NProgress from "nprogress";

import confirm from "../lib/confirm";
import notify from "../lib/notify";
import { getUserApiMethod } from "../lib/api/public";

type Props = { user: { email: string } };

class Index extends React.Component<Props> {
  public static async getInitialProps(ctx) {
    const { req } = ctx;

    const user = await getUserApiMethod(req);

    console.log(user);

    return { ...user };
  }

  public render() {
    return (
      <Layout {...this.props}>
        <Head>
          <title>Index page</title>
          <meta name="description" content="This is a description of the Index page" />
        </Head>
        <div style={{ padding: "0px 30px", fontSize: "15px", height: "100%" }}>
          <p>Content on Index page</p>
          <Link href="/csr-page" as="/csr-page">
            Go to CSR page
          </Link>
          <p />
          <Button
            variant="contained"
            onClick={() =>
              confirm({
                title: "Are you sure?",
                message: "explanatory message",
                onAnswer: async (answer) => {
                  // console.log(answer);
                  if (!answer) {
                    return;
                  }

                  NProgress.start();

                  try {
                    notify("You successfully confirmed.");
                  } catch (error) {
                    console.error(error);
                    notify(error);
                  } finally {
                    NProgress.done();
                  }
                },
              })
            }
          >
            Test Confirmer and Notifier
          </Button>
          <p>Email: {this.props.user.email}</p>
        </div>
      </Layout>
    );
  }
}

export default Index;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app\pages\_app.tsx -----

import CssBaseline from "@mui/material/CssBaseline";
import { ThemeProvider } from "@mui/material";
import App from "next/app";
import Head from "next/head";
import React from "react";
import { isMobile } from "../lib/isMobile";
import { themeDark, themeLight } from "../lib/theme";

class MyApp extends App {
  public static async getInitialProps({ Component, ctx }) {
    const pageProps = { isMobile: isMobile({ req: ctx.req }), firstGridItem: true };

    if (Component.getInitialProps) {
      Object.assign(pageProps, await Component.getInitialProps(ctx));
    }

    // console.log(pageProps);

    return { pageProps };
  }

  public componentDidMount() {
    // Remove the server-side injected CSS.
    const jssStyles = document.querySelector("#jss-server-side");
    if (jssStyles && jssStyles.parentNode) {
      jssStyles.parentNode.removeChild(jssStyles);
    }
  }
  public render() {
    const { Component, pageProps } = this.props;

    return (
      <ThemeProvider theme={false ? themeDark : themeLight}>
        <Head>
          <meta name="viewport" content="width=device-width, initial-scale=1.0" />
          <link rel="stylesheet" href="https://storage.googleapis.com/async-await/nprogress-dark.min.css?v=1" />
        </Head>
        <CssBaseline />
        <Component {...pageProps} />
      </ThemeProvider>
    );
  }
}

export default MyApp;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app\pages\_document.tsx -----

import Document, { Head, Html, Main, NextScript } from "next/document";
import React from "react";

class MyDocument extends Document {
  public static getInitialProps = async (ctx) => {
    const initialProps = await Document.getInitialProps(ctx);

    return {
      ...initialProps,
    };
  };

  public render() {
    // console.log('rendered on the server');

    return (
      <Html lang="en">
        <Head>
          <meta charSet="utf-8" />
          <meta name="google" content="notranslate" />
          <meta name="theme-color" content="#303030" />

          <link rel="shortcut icon" href="https://storage.googleapis.com/async-await/async-favicon32.png" />

          <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons" />
          <link rel="stylesheet" href="https://storage.googleapis.com/async-await/vs2015.min.css" />

          <style>
            {`
              #__next {
                width: 100%;
                height: 100%;
              }
              a {
                font-weight: 400;
                color: #58a6ff;
                text-decoration: none;
                outline: none;
              }
              hr {
                border: 0.5px #707070 solid;
                color: #000;
              }
              blockquote {
                padding: 0 0.5em;
                margin: 20px 1em;
                border-left: 0.25em solid #dfe2e5;
                color: #000;
              }
              pre {
                display: block;
                overflow-x: auto;
                padding: 0.5em;
                background: #d0d0d0;
                border: 1px solid #ddd;
                font-size: 14px;
                color: #000;
              }
              pre code {
                font-size: 13px;
                background: #d0d0d0;
                padding: 0px;
                color: #000;
              }
              code {
                font-size: 13px;
                background: #d0d0d0;
                padding: 3px 5px;
                color: #000;
              }
              mark {
                background-color: #ffff0060;
              }
              summary:focus {
                outline: none;
              }
              table {
                border-collapse: collapse;
                margin: 15px 0px;
              }
              table, th, td {
                border: 1px solid #a1a1a1;
              }
              th, td {
                line-height: 1.5em;
                padding: 10px;
              }
            `}
          </style>
        </Head>
        <body>
          <Main />
          <NextScript />
        </body>
      </Html>
    );
  }
}

export default MyDocument;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app\server\server.ts -----

import express from 'express';
import next from 'next';

const NODE_ENV = process.env.NODE_ENV || 'development';
const IS_DEV = NODE_ENV !== 'production';

const app = next({ dev: IS_DEV });
const handle = app.getRequestHandler();

app.prepare().then(() => {
  const server = express();

  // give all Nextjs's request to Nextjs before anything else
  server.get('/_next/*', (req, res) => {
    // console.log('next server, page');
    handle(req, res);
  });

  server.use(express.json());

  // server.get('/api/v1/public/get-user', (_, res) => {
  //   res.json({ user: { email: 'team@builderbook.org' } });
  // });

  server.all('*', (req, res) => {
    handle(req, res);
  });

  server.listen(process.env.NEXT_PUBLIC_PORT_APP, () => {
    console.log(`> Ready on ${process.env.NEXT_PUBLIC_URL_APP}`);
  });
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app\.eslintrc.js -----

module.exports = {
  settings: {
    react: { version: 'detect' },
  },
  parser: '@typescript-eslint/parser',
  extends: ['plugin:react/recommended', 'plugin:@typescript-eslint/recommended', 'prettier'],
  env: {
    es6: true,
    node: true,
  },
  plugins: ['prettier', 'react'],
  rules: {
    'prettier/prettier': [
      'error',
      {
        singleQuote: true,
        trailingComma: 'all',
        arrowParens: 'always',
        printWidth: 100,
        semi: true,
      },
    ],
    '@typescript-eslint/camelcase': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    'react/no-unescaped-entities': 'off',
    'react/jsx-filename-extension': ['error', { extensions: ['.tsx'] }],
    '@typescript-eslint/no-explicit-any': 'off',
    'prefer-arrow-callback': 'error',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
  },
};

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app\next-env.d.ts -----

/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/basic-features/typescript for more information.

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app\next.config.js -----

module.exports = {
  poweredByHeader: false,
  webpack5: true,
  typescript: {
    ignoreBuildErrors: true,
  },
};

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app\nodemon.json -----

{
  "watch": ["server"],
  "exec": "ts-node --project tsconfig.server.json",
  "ext": "ts"
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app\package.json -----

{
  "name": "4-begin-app",
  "version": "1",
  "license": "MIT",
  "scripts": {
    "dev": "nodemon server/server.ts",
    "build": "next build && tsc --project tsconfig.server.json",
    "lint": "eslint . --ext .ts,.tsx"
  },
  "dependencies": {
    "@emotion/react": "^11.14.0",
    "@emotion/styled": "^11.14.0",
    "@mui/material": "^6.4.8",
    "@mui/system": "^6.4.8",
    "dotenv": "^16.3.1",
    "express": "^4.18.2",
    "isomorphic-unfetch": "^4.0.2",
    "next": "^14.0.4",
    "nprogress": "^0.2.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "typescript": "^5.3.3"
  },
  "devDependencies": {
    "@types/express": "^4.17.21",
    "@types/node": "^20.10.4",
    "@types/react": "^18.2.42",
    "@types/react-dom": "^18.2.17",
    "@typescript-eslint/eslint-plugin": "^6.13.2",
    "@typescript-eslint/parser": "^6.13.2",
    "eslint": "^8.55.0",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-prettier": "^5.0.1",
    "eslint-plugin-react": "^7.33.2",
    "nodemon": "^3.0.2",
    "prettier": "^3.1.0",
    "ts-node": "^10.9.2"
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app\tsconfig.json -----

{
  "compileOnSave": false,
  "compilerOptions": {
    "target": "esnext",
    "module": "esnext",
    "jsx": "preserve",
    "allowJs": true,
    "alwaysStrict": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "removeComments": true,
    "preserveConstEnums": true,
    "sourceMap": false,
    "skipLibCheck": true,
    "baseUrl": ".",
    "typeRoots": [
      "./node_modules/@types"
    ],
    "lib": [
      "dom",
      "es2017"
    ],
    "strict": false,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "incremental": true
  },
  "include": [
    "next-env.d.ts",
    "./**/*.tsx",
    "./**/*.ts"
  ],
  "exclude": [
    "dist",
    "production-server",
    ".next",
    "out",
    "next.config.js",
    "node_modules"
  ]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-begin\app\tsconfig.server.json -----

{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "module": "commonjs",
    "outDir": "production-server/",
    "target": "es2017",
    "isolatedModules": false,
    "noEmit": false
  },
  "exclude": ["./server/types.d.ts"],
  "include": ["./server/**/*.ts"],
  "typeRoots": ["./node_modules/@types", "./server/types.d.ts"]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\api\server\api\index.ts -----

import * as express from 'express';

import publicExpressRoutes from './public';
import teamMemberExpressRoutes from './team-member';

function handleError(err, _, res, __) {
  console.error(err.stack);

  res.json({ error: err.message || err.toString() });
}

export default function api(server: express.Express) {
  server.use('/api/v1/public', publicExpressRoutes, handleError);
  server.use('/api/v1/team-member', teamMemberExpressRoutes, handleError);
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\api\server\api\public.ts -----

import * as express from 'express';

import User from '../models/User';

const router = express.Router();

// router.get('/get-user', (req, res) => {
//   res.json({ user: { email: 'team@builderbook.org' } });
// });

router.post('/get-user-by-slug', async (req, res, next) => {
  console.log('Express route: /get-user-by-slug');

  try {
    const { slug } = req.body;

    const user = await User.getUserBySlug({ slug });

    res.json({ user });
  } catch (err) {
    next(err);
  }
});

router.post('/user/update-profile', async (req: any, res, next) => {
  console.log('Express route: /user/update-profile');

  try {
    const { name, avatarUrl } = req.body;

    const userId = '5e6427a51c9d440000c9ba6f';

    const updatedUser = await User.updateProfile({
      userId: userId,
      name,
      avatarUrl,
    });

    res.json({ updatedUser });
  } catch (err) {
    next(err);
  }
});

export default router;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\api\server\api\team-member.ts -----

import * as express from 'express';

import { signRequestForUpload } from '../aws-s3';

const router = express.Router();

// Get signed request from AWS S3 server
router.post('/aws/get-signed-request-for-upload-to-s3', async (req, res, next) => {
  try {
    const { fileName, fileType, prefix, bucket } = req.body;

    const returnData = await signRequestForUpload({
      fileName,
      fileType,
      prefix,
      bucket,
    });

    console.log(returnData);

    res.json(returnData);
  } catch (err) {
    next(err);
  }
});

export default router;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\api\server\models\User.ts -----

// import * as _ from 'lodash';
import * as mongoose from 'mongoose';

import { generateSlug } from '../utils/slugify';

const mongoSchema = new mongoose.Schema({
  slug: {
    type: String,
    required: true,
    unique: true,
  },
  createdAt: {
    type: Date,
    required: true,
  },
  email: {
    type: String,
    required: true,
    unique: true,
  },
  displayName: String,
  avatarUrl: String,
});

interface UserDocument extends mongoose.Document {
  slug: string;
  createdAt: Date;
  email: string;
  displayName: string;
  avatarUrl: string;
}

interface UserModel extends mongoose.Model<UserDocument> {
  getUserBySlug({ slug }: { slug: string }): Promise<UserDocument>;

  updateProfile({
    userId,
    name,
    avatarUrl,
  }: {
    userId: string;
    name: string;
    avatarUrl: string;
  }): Promise<UserDocument[]>;
}

class UserClass extends mongoose.Model {
  public static async getUserBySlug({ slug }) {
    console.log('Static method: getUserBySlug');

    return this.findOne({ slug }, 'email displayName avatarUrl').setOptions({ lean: true });
  }

  public static async updateProfile({ userId, name, avatarUrl }) {
    console.log('Static method: updateProfile');

    const user = await this.findById(userId, 'slug displayName');

    const modifier = { displayName: user.displayName, avatarUrl, slug: user.slug };

    console.log(user.slug);

    if (name !== user.displayName) {
      modifier.displayName = name;
      modifier.slug = await generateSlug(this, name);
    }

    return this.findByIdAndUpdate(userId, { $set: modifier }, { new: true, runValidators: true })
      .select('displayName avatarUrl slug')
      .setOptions({ lean: true });
  }
}

mongoSchema.loadClass(UserClass);

const User = mongoose.model<UserDocument, UserModel>('User', mongoSchema);

export default User;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\api\server\utils\slugify.ts -----

import * as _ from 'lodash';

const slugify = (text) => _.kebabCase(text);

async function createUniqueSlug(Model, slug, count, filter) {
  const obj = await Model.findOne({ slug: `${slug}-${count}`, ...filter })
    .select('_id')
    .setOptions({ lean: true });

  if (!obj) {
    return `${slug}-${count}`;
  }

  return createUniqueSlug(Model, slug, count + 1, filter);
}

async function generateSlug(Model, name, filter = {}) {
  const origSlug = slugify(name);

  const obj = await Model.findOne({ slug: origSlug, ...filter })
    .select('_id')
    .setOptions({ lean: true });

  if (!obj) {
    return origSlug;
  }

  return createUniqueSlug(Model, origSlug, 1, filter);
}

export { generateSlug };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\api\server\utils\sum.ts -----

function sum(a, b) {
  return a + b;
}

export { sum };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\api\server\aws-s3.ts -----

import * as url from 'url';
import * as aws from 'aws-sdk';

async function signRequestForUpload({ fileName, fileType, prefix, bucket }) {
  const randomStringForPrefix =
    Math.random().toString(36).substring(2, 12) + Math.random().toString(36).substring(2, 12);

  const key = `${prefix}/${randomStringForPrefix}/${fileName}`;

  const acl = 'public-read';

  const params = {
    Bucket: bucket,
    Key: key,
    Expires: 60,
    ContentType: fileType,
    ACL: acl,
  };

  console.log(prefix);

  const s3 = new aws.S3({
    apiVersion: 'latest',
    region: process.env.AWS_REGION,
    accessKeyId: process.env.AWS_ACCESSKEYID,
    secretAccessKey: process.env.AWS_SECRETACCESSKEY,
  });

  return new Promise((resolve, reject) => {
    s3.getSignedUrl('putObject', params, (err, data) => {
      const parsedUrl = url.parse(data);

      const returnData = {
        signedRequest: data,
        url: `${parsedUrl.protocol}//${parsedUrl.hostname}${parsedUrl.pathname}`,
      };

      if (err) {
        console.error(err);
        reject(err);
      } else {
        resolve(returnData);
      }
    });
  });
}

export { signRequestForUpload };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\api\server\server.ts -----

import * as cors from 'cors';
import * as express from 'express';
import * as mongoose from 'mongoose';

import api from './api';

// eslint-disable-next-line
require('dotenv').config();

mongoose.connect(process.env.MONGO_URL_TEST);

const server = express();

server.use(
  cors({
    origin: process.env.URL_APP,
    methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',
    credentials: true,
  }),
);

server.use(express.json());

api(server);

server.get('*', (_, res) => {
  res.sendStatus(403);
});

server.listen(process.env.PORT_API, () => {
  console.log(`> Ready on ${process.env.URL_API}`);
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\api\test\server\utils\slugify.test.ts -----

import * as mongoose from 'mongoose';
import User from '../../../server/models/User';
import { generateSlug } from '../../../server/utils/slugify';

// eslint-disable-next-line
require('dotenv').config();

describe('slugify', () => {
  beforeAll(async () => {
    await mongoose.connect(process.env.MONGO_URL_TEST);

    const mockUsers = [
      {
        slug: 'john',
        email: 'john@example.com',
        createdAt: new Date(),
        displayName: 'abc',
        avatarUrl: 'def',
      },
      {
        slug: 'john-johnson',
        email: 'john-johnson@example.com',
        createdAt: new Date(),
        displayName: 'abc',
        avatarUrl: 'def',
      },
      {
        slug: 'john-johnson-1',
        email: 'john-johnson-1@example.com',
        createdAt: new Date(),
        displayName: 'abc',
        avatarUrl: 'def',
      },
    ];

    await User.insertMany(mockUsers);
  });

  test('not duplicated', async () => {
    expect.assertions(1);

    await expect(generateSlug(User, 'John J Johnson@#$')).resolves.toEqual('john-j-johnson');
  });

  test('one time duplicated', async () => {
    expect.assertions(1);

    await expect(generateSlug(User, ' John@#$')).resolves.toEqual('john-1');
  });

  test('multiple duplicated', async () => {
    expect.assertions(1);

    await expect(generateSlug(User, 'John & Johnson@#$')).resolves.toEqual('john-johnson-2');
  });

  afterAll(async () => {
    await User.deleteMany({ slug: { $in: ['john', 'john-johnson', 'john-johnson-1'] } });
    await mongoose.disconnect();
  });
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\api\test\server\utils\sum.test.ts -----

import { sum } from '../../../server/utils/sum';

console.log(sum(1, 2));

describe.skip('testing sum function', () => {
  test('adds 1 + 2 to equal 3', () => {
    expect(sum(1, 2)).toBe(3);
  });
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\api\.eslintrc.js -----

module.exports = {
  parser: "@typescript-eslint/parser",
  extends: ["plugin:@typescript-eslint/recommended", "prettier"],
  env: {
    "es6": true,
    "node": true,
  },
  plugins: ["prettier"],
  rules: {
    'prettier/prettier': [
      'error',
      {
        singleQuote: true,
        trailingComma: 'all',
        arrowParens: 'always',
        printWidth: 100,
        semi: true,
      },
    ],
    '@typescript-eslint/no-unused-vars': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/no-explicit-any': 'off',
    'prefer-arrow-callback': 'error',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
 },
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\api\nodemon.json -----

{
  "watch": ["server"],
  "exec": "ts-node --project tsconfig.server.json",
  "ext": "ts"
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\api\package.json -----

{
  "name": "4-end-api",
  "version": "1",
  "license": "MIT",
  "scripts": {
    "dev": "nodemon server/server.ts",
    "lint": "eslint . --ext .ts,.tsx",
    "test": "jest"
  },
  "jest": {
    "preset": "ts-jest",
    "testPathIgnorePatterns": [
      "production-server"
    ],
    "testEnvironment": "node"
  },
  "dependencies": {
    "aws-sdk": "^2.1692.0",
    "cors": "^2.8.5",
    "dotenv": "^16.4.7",
    "express": "^4.21.2",
    "lodash": "^4.17.20",
    "mongoose": "^8.12.1",
    "typescript": "^5.8.2"
  },
  "devDependencies": {
    "@types/dotenv": "^8.2.3",
    "@types/express": "^5.0.1",
    "@types/jest": "^29.5.14",
    "@types/lodash": "^4.17.16",
    "@types/mongoose": "^5.5.43",
    "@types/node": "^22.13.10",
    "@typescript-eslint/eslint-plugin": "^8.27.0",
    "@typescript-eslint/parser": "^8.27.0",
    "eslint": "^9.22.0",
    "eslint-config-prettier": "^10.1.1",
    "eslint-plugin-prettier": "^5.2.3",
    "jest": "^29.7.0",
    "nodemon": "^3.1.9",
    "prettier": "^3.5.3",
    "ts-jest": "^29.2.6",
    "ts-node": "^10.9.2"
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\api\tsconfig.json -----

{
  "compileOnSave": false,
  "compilerOptions": {
    "jsx": "preserve",
    "allowJs": true,
    "alwaysStrict": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "removeComments": false,
    "preserveConstEnums": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "sourceMap": true,
    "skipLibCheck": true,
    "baseUrl": ".",
    "experimentalDecorators": true,
    "typeRoots": ["./node_modules/@types"],
    "lib": ["es2015", "es2016"]
  },
  "exclude": ["production-server", "node_modules"]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\api\tsconfig.server.json -----

{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "module": "commonjs",
    "outDir": "production-server/"
  },
  "include": ["./server/**/*.ts"],
  "exclude": ["./server/**/*.test.ts"]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\components\common\Confirmer.tsx -----

import Button from "@mui/material/Button";
import Dialog from "@mui/material/Dialog";
import DialogActions from "@mui/material/DialogActions";
import DialogContent from "@mui/material/DialogContent";
import DialogContentText from "@mui/material/DialogContentText";
import DialogTitle from "@mui/material/DialogTitle";
import React from "react";

export let openConfirmDialogExternal;

type State = {
  open: boolean;
  title: string;
  message: string;
  onAnswer: (answer) => void;
};

class Confirmer extends React.Component<any, State> {
  constructor(props) {
    super(props);

    this.state = {
      open: false,
      title: "Are you sure?",
      message: "",
      onAnswer: null,
    };

    openConfirmDialogExternal = this.openConfirmDialog;
  }

  public render() {
    return (
      <Dialog
        open={this.state.open}
        onClose={this.handleClose}
        aria-labelledby="alert-dialog-title"
        aria-describedby="alert-dialog-description"
      >
        <DialogTitle id="alert-dialog-title">{this.state.title}</DialogTitle>
        <DialogContent>
          <DialogContentText id="alert-dialog-description">{this.state.message}</DialogContentText>
        </DialogContent>
        <DialogActions style={{ padding: "10px" }}>
          <Button onClick={this.handleClose} variant="contained" color="primary" autoFocus>
            Cancel
          </Button>
          <Button onClick={this.handleYes} variant="contained" color="secondary">
            OK
          </Button>
        </DialogActions>
      </Dialog>
    );
  }

  public handleClose = () => {
    this.setState({ open: false });
    this.state.onAnswer(false);
  };

  public handleYes = () => {
    this.setState({ open: false });
    this.state.onAnswer(true);
  };

  public openConfirmDialog = ({ title, message, onAnswer }) => {
    this.setState({ open: true, title, message, onAnswer });
  };
}

export default Confirmer;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\components\common\MenuWithLinks.tsx -----

import Menu from "@mui/material/Menu";
import MenuItem from "@mui/material/MenuItem";
import Link from "next/link";
import { NextRouter, withRouter } from "next/router";
import React from "react";

type Props = {
  options: {
    href: string;
    as: string;
    highlighterSlug: string;
    text: string;
    separator: boolean;
  }[];
  router: NextRouter;
  children: any;
};

type State = {
  anchorEl: Element | ((element: Element) => Element);
};

class MenuWithLinks extends React.PureComponent<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      anchorEl: null,
    };
  }

  public render() {
    const { options, children, router } = this.props;
    const { anchorEl } = this.state;

    return (
      <div style={{ textAlign: "center" }}>
        <div
          aria-controls={anchorEl ? "simple-menu" : null}
          aria-haspopup="true"
          onClick={this.handleClick}
          onKeyPress={this.handleClick}
        >
          {children}
        </div>
        <Menu id="simple-menu" anchorEl={anchorEl} open={Boolean(anchorEl)} onClose={this.handleClose} keepMounted>
          {options.map((option, i) =>
            option.separator ? (
              <hr style={{ width: "85%", margin: "10px auto" }} key={`separated-${i}`} />
            ) : (
              <Link key={option.href} href={option.href} as={option.as} passHref>
                <MenuItem
                  key={option.href}
                  style={{
                    fontWeight: router.asPath.includes(option.highlighterSlug) ? 600 : 300,
                    fontSize: "14px",
                  }}
                >
                  {option.text}
                </MenuItem>
              </Link>
            )
          )}
        </Menu>
      </div>
    );
  }

  public handleClick = (event) => {
    this.setState({ anchorEl: event.currentTarget });
  };

  public handleClose = () => {
    this.setState({ anchorEl: null });
  };
}

export default withRouter(MenuWithLinks);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\components\common\Notifier.tsx -----

import Snackbar from "@mui/material/Snackbar";
import React from "react";

export let openSnackbarExternal;

type State = {
  open: boolean;
  message: string;
};

class Notifier extends React.PureComponent<any, State> {
  constructor(props) {
    super(props);
    openSnackbarExternal = this.openSnackbar;

    this.state = {
      open: false,
      message: "",
    };
  }

  public render() {
    const message = <span id="snackbar-message-id" dangerouslySetInnerHTML={{ __html: this.state.message }} />;

    return (
      <Snackbar
        anchorOrigin={{ vertical: "top", horizontal: "right" }}
        message={message}
        autoHideDuration={5000}
        onClose={this.handleSnackbarClose}
        open={this.state.open}
        ContentProps={{
          "aria-describedby": "snackbar-message-id",
        }}
      />
    );
  }

  public handleSnackbarClose = () => {
    this.setState({
      open: false,
      message: "",
    });
  };

  public openSnackbar = ({ message }) => {
    this.setState({ open: true, message });
  };
}

export default Notifier;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\components\layout\index.tsx -----

import Avatar from "@mui/material/Avatar";
import Grid from "@mui/material/Grid";
import React from "react";
import MenuWithLinks from "../common/MenuWithLinks";
import Confirmer from "../common/Confirmer";
import Notifier from "../common/Notifier";

const styleGrid = {
  width: "100%",
  height: "100vh",
  maxWidth: "100%",
  padding: "0px 10px",
  display: "flex",
  overflow: "hidden",
};

const styleGridIsMobile = {
  width: "100%",
  height: "100vh",
  maxWidth: "100%",
  padding: "0px 0px 0px 10px",
  display: "flex",
  overflow: "hidden",
};

type Props = {
  children: React.ReactNode;
  firstGridItem?: boolean;
  isMobile?: boolean;
};

class Layout extends React.Component<Props> {
  public render() {
    const { children, firstGridItem, isMobile } = this.props;

    const isThemeDark = false;

    // console.log(isMobile);

    return (
      <Grid
        container
        direction="row"
        justify="flex-start"
        alignItems="stretch"
        style={isMobile ? styleGridIsMobile : styleGrid}
      >
        {firstGridItem ? (
          <Grid
            item
            sm={2}
            xs={12}
            style={{
              borderRight: "1px #707070 solid",
              justifyContent: "center",
              overflow: "hidden",
            }}
          >
            <div style={{ display: "flex", justifyContent: "space-between" }}>
              <svg
                xmlns="http://www.w3.org/2000/svg"
                width="124"
                height="40"
                viewBox="0 0 124 40"
                style={{
                  marginTop: "20px",
                  display: "inline-flex",
                  height: "40px",
                }}
              >
                <g id="async-logo">
                  <g id="async-logo-40">
                    <circle id="Ellipse 2" cx="20" cy="20" r="20" fill="black" />
                    <path
                      id="path-async-logo"
                      d="M7.07825 -0.0960007V16H4.51825V13.088C4.04892 14.0907 3.33425 14.8693 2.37425 15.424C1.43558 15.9573 0.336917 16.224 -0.92175 16.224C-2.35108 16.224 -3.60975 15.8827 -4.69775 15.2C-5.76442 14.5173 -6.59642 13.5573 -7.19375 12.32C-7.76975 11.0613 -8.05775 9.6 -8.05775 7.936C-8.05775 6.272 -7.75908 4.81067 -7.16175 3.552C-6.56442 2.272 -5.73242 1.28 -4.66575 0.576C-3.57775 -0.128 -2.32975 -0.48 -0.92175 -0.48C0.336917 -0.48 1.43558 -0.202666 2.37425 0.352C3.31292 0.906667 4.02758 1.68533 4.51825 2.688V-0.0960007H7.07825ZM-0.40975 14.08C1.16892 14.08 2.38492 13.5467 3.23825 12.48C4.09158 11.392 4.51825 9.856 4.51825 7.872C4.51825 5.888 4.09158 4.36267 3.23825 3.296C2.38492 2.22933 1.16892 1.696 -0.40975 1.696C-1.98842 1.696 -3.22575 2.25067 -4.12175 3.36C-4.99642 4.448 -5.43375 5.97333 -5.43375 7.936C-5.43375 9.89867 -4.99642 11.4133 -4.12175 12.48C-3.24708 13.5467 -2.00975 14.08 -0.40975 14.08Z"
                      transform="translate(19.5938 12)"
                      fill="white"
                    />
                  </g>
                  <path
                    id="path-async-text"
                    d="M22.6251 11.928V24H20.7051V21.816C20.3531 22.568 19.8171 23.152 19.0971 23.568C18.3931 23.968 17.5691 24.168 16.6251 24.168C15.5531 24.168 14.6091 23.912 13.7931 23.4C12.9931 22.888 12.3691 22.168 11.9211 21.24C11.4891 20.296 11.2731 19.2 11.2731 17.952C11.2731 16.704 11.4971 15.608 11.9451 14.664C12.3931 13.704 13.0171 12.96 13.8171 12.432C14.6331 11.904 15.5691 11.64 16.6251 11.64C17.5691 11.64 18.3931 11.848 19.0971 12.264C19.8011 12.68 20.3371 13.264 20.7051 14.016V11.928H22.6251ZM17.0091 22.56C18.1931 22.56 19.1051 22.16 19.7451 21.36C20.3851 20.544 20.7051 19.392 20.7051 17.904C20.7051 16.416 20.3851 15.272 19.7451 14.472C19.1051 13.672 18.1931 13.272 17.0091 13.272C15.8251 13.272 14.8971 13.688 14.2251 14.52C13.5691 15.336 13.2411 16.48 13.2411 17.952C13.2411 19.424 13.5691 20.56 14.2251 21.36C14.8811 22.16 15.8091 22.56 17.0091 22.56ZM30.4637 24.168C28.4317 24.168 26.8237 23.648 25.6397 22.608L26.2877 21.168C26.9437 21.68 27.6077 22.048 28.2797 22.272C28.9517 22.496 29.7037 22.608 30.5357 22.608C31.4477 22.608 32.1357 22.456 32.5997 22.152C33.0797 21.832 33.3197 21.376 33.3197 20.784C33.3197 20.304 33.1597 19.92 32.8397 19.632C32.5197 19.344 31.9917 19.12 31.2557 18.96L29.2157 18.48C28.2077 18.256 27.4237 17.856 26.8637 17.28C26.3197 16.704 26.0477 16.016 26.0477 15.216C26.0477 14.16 26.4717 13.304 27.3197 12.648C28.1677 11.976 29.2877 11.64 30.6797 11.64C31.5277 11.64 32.3277 11.776 33.0797 12.048C33.8317 12.32 34.4637 12.712 34.9757 13.224L34.3277 14.64C33.1917 13.696 31.9757 13.224 30.6797 13.224C29.8157 13.224 29.1437 13.392 28.6637 13.728C28.1997 14.048 27.9677 14.504 27.9677 15.096C27.9677 15.592 28.1117 15.984 28.3997 16.272C28.7037 16.56 29.1837 16.784 29.8397 16.944L31.8797 17.448C32.9997 17.704 33.8317 18.104 34.3757 18.648C34.9197 19.176 35.1917 19.872 35.1917 20.736C35.1917 21.776 34.7677 22.608 33.9197 23.232C33.0717 23.856 31.9197 24.168 30.4637 24.168ZM48.687 11.928L43.047 25.104C42.455 26.48 41.711 27.488 40.815 28.128C39.919 28.768 38.815 29.208 37.503 29.448L37.095 27.936C38.231 27.68 39.087 27.336 39.663 26.904C40.255 26.488 40.743 25.84 41.127 24.96L41.607 23.88L36.495 11.928H38.535L42.615 21.888L46.743 11.928H48.687ZM56.853 11.64C59.749 11.64 61.197 13.232 61.197 16.416V24H59.253V16.512C59.253 15.392 59.029 14.576 58.581 14.064C58.133 13.536 57.429 13.272 56.469 13.272C55.349 13.272 54.453 13.616 53.781 14.304C53.109 14.992 52.773 15.92 52.773 17.088V24H50.829V15.312C50.829 14.064 50.765 12.936 50.637 11.928H52.485L52.677 14.088C53.045 13.304 53.597 12.704 54.333 12.288C55.069 11.856 55.909 11.64 56.853 11.64ZM69.9321 24.168C68.7641 24.168 67.7401 23.912 66.8601 23.4C65.9961 22.888 65.3241 22.168 64.8441 21.24C64.3801 20.296 64.1481 19.2 64.1481 17.952C64.1481 16.704 64.3881 15.608 64.8681 14.664C65.3481 13.704 66.0281 12.96 66.9081 12.432C67.8041 11.904 68.8441 11.64 70.0281 11.64C70.8441 11.64 71.6281 11.784 72.3801 12.072C73.1481 12.344 73.7801 12.728 74.2761 13.224L73.6281 14.664C73.0201 14.184 72.4281 13.832 71.8521 13.608C71.2921 13.384 70.7161 13.272 70.1241 13.272C68.8921 13.272 67.9241 13.688 67.2201 14.52C66.5161 15.336 66.1641 16.48 66.1641 17.952C66.1641 19.408 66.5081 20.544 67.1961 21.36C67.9001 22.16 68.8761 22.56 70.1241 22.56C70.7161 22.56 71.2921 22.448 71.8521 22.224C72.4281 22 73.0201 21.648 73.6281 21.168L74.2761 22.608C73.7641 23.088 73.1161 23.472 72.3321 23.76C71.5641 24.032 70.7641 24.168 69.9321 24.168Z"
                    transform="translate(39 4)"
                    fill={isThemeDark ? "white" : "black"}
                  />
                </g>
              </svg>
              <MenuWithLinks
                options={[
                  {
                    text: "Index page",
                    href: "/",
                    highlighterSlug: "/",
                  },
                  {
                    text: "Your Settings",
                    href: "/your-settings",
                    highlighterSlug: "/your-settings",
                  },
                  {
                    separator: true,
                  },
                  {
                    text: "Log out",
                    href: "/logout",
                  },
                ]}
              >
                <Avatar
                  src={"https://storage.googleapis.com/async-await/default-user.png"}
                  alt="Add username here later in the book"
                  style={{
                    margin: "20px auto",
                    cursor: "pointer",
                    display: "inline-flex",
                    width: "40px",
                    height: "40px",
                  }}
                />

                <i className="material-icons" color="action" style={{ verticalAlign: "super" }}>
                  arrow_drop_down
                </i>
              </MenuWithLinks>
            </div>
            <hr />
            <p />
            <p />
          </Grid>
        ) : null}
        <Grid item sm={10} xs={12}>
          {isMobile ? <hr /> : null}
          {children}
        </Grid>
        <Notifier />
        <Confirmer />
      </Grid>
    );
  }
}

export default Layout;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\lib\api\public.ts -----

import sendRequestAndGetResponse from './sendRequestAndGetResponse';

const BASE_PATH = '/api/v1/public';

export const getUserApiMethod = (request) =>
  sendRequestAndGetResponse(`${BASE_PATH}/get-user`, {
    request,
    method: 'GET',
  });

export const getUserBySlugApiMethod = (slug) =>
  sendRequestAndGetResponse(`${BASE_PATH}/get-user-by-slug`, {
    body: JSON.stringify({ slug }),
  });

export const updateProfileApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/user/update-profile`, {
    body: JSON.stringify(data),
  });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\lib\api\sendRequestAndGetResponse.ts -----

import 'isomorphic-unfetch';

export default async function sendRequestAndGetResponse(path, opts: any = {}) {
  const headers = Object.assign(
    {},
    opts.headers || {},
    opts.externalServer
      ? {}
      : {
          'Content-type': 'application/json; charset=UTF-8',
        },
  );

  const { request } = opts;
  if (request && request.headers && request.headers.cookie) {
    headers.cookie = request.headers.cookie;
  }

  const qs = opts.qs || '';

  // console.log(`before: ${process.env.NEXT_PUBLIC_URL_API}${path}${qs}`);

  const response = await fetch(
    opts.externalServer ? `${path}${qs}` : `${process.env.NEXT_PUBLIC_URL_API}${path}${qs}`,
    Object.assign({ method: 'POST', credentials: 'include' }, opts, { headers }),
  );

  // console.log(`after: ${process.env.NEXT_PUBLIC_URL_API}${path}${qs}`);

  // console.log(response.status);
  // console.log(response.statusText);

  const text = await response.text();

  if (response.status >= 400) {
    console.error(text);
    throw new Error(response.status.toString());
  }

  try {
    const data = JSON.parse(text);

    return data;
  } catch (err) {
    if (err instanceof SyntaxError) {
      return text;
    }

    throw err;
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\lib\api\team-member.ts -----

import sendRequestAndGetResponse from './sendRequestAndGetResponse';

const BASE_PATH = '/api/v1/team-member';

export const getSignedRequestForUploadApiMethod = ({ fileName, fileType, prefix, bucket }) =>
  sendRequestAndGetResponse(`${BASE_PATH}/aws/get-signed-request-for-upload-to-s3`, {
    body: JSON.stringify({ fileName, fileType, prefix, bucket }),
  });

export const uploadFileUsingSignedPutRequestApiMethod = (file, signedRequest, headers = {}) =>
  sendRequestAndGetResponse(signedRequest, {
    externalServer: true,
    method: 'PUT',
    body: file,
    headers,
  });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\lib\confirm.ts -----

import { openConfirmDialogExternal } from '../components/common/Confirmer';

export default function confirm({
  title,
  message,
  onAnswer,
}: {
  title: string;
  message: string;
  onAnswer: (answer) => void;
}) {
  openConfirmDialogExternal({ title, message, onAnswer });
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\lib\isMobile.ts -----

const mobileRE = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i;

export function isMobile(opts) {
  if (!opts) {
    opts = {};
  }

  let ua = opts.ua;

  if (!ua && typeof navigator !== 'undefined') {
    ua = navigator.userAgent;
  }

  if (!ua && opts.req && opts.req.headers && typeof opts.req.headers['user-agent'] === 'string') {
    ua = opts.req.headers['user-agent'];
    // console.log(ua);
  }

  if (typeof ua !== 'string') {
    return false;
  }

  return mobileRE.test(ua);
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\lib\notify.ts -----

import { openSnackbarExternal } from '../components/common/Notifier';

export default function notify(obj) {
  openSnackbarExternal({ message: obj.message || obj.toString() });
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\lib\resizeImage.ts -----

function resizeImage(file: File, MAX_WIDTH, MAX_HEIGHT) {
  const image = document.createElement('img');

  const resize = (resolve) => () => {
    let isResizeNeeded = false;
    let width = image.width;
    let height = image.height;

    if (width > height) {
      if (width > MAX_WIDTH) {
        isResizeNeeded = true;
        height *= MAX_WIDTH / width;
        width = MAX_WIDTH;
      }
    } else {
      if (height > MAX_HEIGHT) {
        isResizeNeeded = true;
        width *= MAX_HEIGHT / height;
        height = MAX_HEIGHT;
      }
    }

    if (isResizeNeeded) {
      const canvas = document.createElement('canvas');

      canvas.width = width;
      canvas.height = height;

      console.log(width, height);

      const ctx = canvas.getContext('2d');
      ctx.drawImage(image, 0, 0, width, height);

      canvas.toBlob((blob) => {
        resolve(blob);
      }, file.type);
    } else {
      resolve(file);
    }
  };

  return new Promise((resolve) => {
    const reader = new FileReader();

    console.log(`before ${image.src}`);

    reader.readAsDataURL(file);

    reader.onload = (e) => {
      image.src = e.target.result.toString();

      image.onload = resize(resolve);

      console.log(`after ${image.src}`);
    };
  });
}

export { resizeImage };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\lib\sharedStyles.ts -----

const styleBigAvatar = {
  width: '80px',
  height: '80px',
  margin: '0px auto 15px',
};

const styleRaisedButton = {
  margin: '15px',
  font: '14px Roboto',
};

const styleToolbar = {
  background: '#FFF',
  height: '64px',
  paddingRight: '20px',
};

const styleTextField = {
  font: '15px Roboto',
  color: '#222',
  fontWeight: '300',
};

const styleForm = {
  margin: '7% auto',
  width: '360px',
};

export { styleBigAvatar, styleRaisedButton, styleToolbar, styleTextField, styleForm };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\lib\theme.ts -----

import { createMuiTheme } from "@mui/material/styles";

const themeDark = createMuiTheme({
  palette: {
    primary: { main: "#238636" },
    secondary: { main: "#b62324" },
    type: "dark",
    background: { default: "#0d1117" },
    text: {
      primary: "#c9d1d9",
    },
  },
  typography: {
    button: {
      textTransform: "none",
    },
  },
});

const themeLight = createMuiTheme({
  palette: {
    primary: { main: "#238636" },
    secondary: { main: "#b62324" },
    type: "light",
    background: { default: "#fff" },
    text: {
      primary: "#222",
    },
  },
  typography: {
    button: {
      textTransform: "none",
    },
  },
});

export { themeDark, themeLight };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\pages\csr-page.tsx -----

import Button from "@mui/material/Button";
import React from "react";
import Head from "next/head";

const CSRPage = () => (
  <div>
    <Head>
      <title>CSR page</title>
      <meta name="description" content="This is a description of the CSR page" />
    </Head>
    <div style={{ padding: "0px 30px", fontSize: "15px", height: "100%" }}>
      <p>Content on CSR page</p>
      <Button variant="outlined">Some button</Button>
    </div>
  </div>
);

console.log(process.env.NEXT_PUBLIC_URL_APP);

export default CSRPage;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\pages\index.tsx -----

import Button from "@mui/material/Button";
import React from "react";
import Head from "next/head";
import Link from "next/link";

import Layout from "../components/layout";
import NProgress from "nprogress";

import confirm from "../lib/confirm";
import notify from "../lib/notify";
import { getUserBySlugApiMethod } from "../lib/api/public";

type Props = { user: { email: string; displayName: string } };

class Index extends React.Component<Props> {
  public static async getInitialProps() {
    const slug = "team-builder-book";

    const user = await getUserBySlugApiMethod(slug);

    console.log(user);

    return { ...user };
  }

  public render() {
    return (
      <Layout {...this.props}>
        <Head>
          <title>Index page</title>
          <meta name="description" content="This is a description of the Index page" />
        </Head>
        <div style={{ padding: "0px 30px", fontSize: "15px", height: "100%" }}>
          <p>Content on Index page</p>
          <Link href="/csr-page" as="/csr-page">
            Go to CSR page
          </Link>
          <p />
          <Button
            variant="contained"
            onClick={() =>
              confirm({
                title: "Are you sure?",
                message: "explanatory message",
                onAnswer: async (answer) => {
                  // console.log(answer);
                  if (!answer) {
                    return;
                  }

                  NProgress.start();

                  try {
                    notify("You successfully confirmed.");
                  } catch (error) {
                    console.error(error);
                    notify(error);
                  } finally {
                    NProgress.done();
                  }
                },
              })
            }
          >
            Test Confirmer and Notifier
          </Button>
          <p>Your email: {this.props.user.email}</p>
          <p>Your username: {this.props.user.displayName}</p>
        </div>
      </Layout>
    );
  }
}

export default Index;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\pages\your-settings.tsx -----

import Avatar from "@mui/material/Avatar";
import Button from "@mui/material/Button";
import TextField from "@mui/material/TextField";
import Head from "next/head";
import NProgress from "nprogress";
import * as React from "react";

import Layout from "../components/layout";

import { getUserBySlugApiMethod, updateProfileApiMethod } from "../lib/api/public";
import { getSignedRequestForUploadApiMethod, uploadFileUsingSignedPutRequestApiMethod } from "../lib/api/team-member";

import { resizeImage } from "../lib/resizeImage";

import notify from "../lib/notify";

type Props = {
  isMobile: boolean;
  user: { email: string; displayName: string; slug: string; avatarUrl: string };
};

type State = { newName: string; newAvatarUrl: string; disabled: boolean };

class YourSettings extends React.Component<Props, State> {
  public static async getInitialProps() {
    const slug = "team-builder-book";

    const user = await getUserBySlugApiMethod(slug);

    console.log(user);

    return { ...user };
  }

  constructor(props) {
    super(props);

    this.state = {
      newName: this.props.user.displayName,
      newAvatarUrl: this.props.user.avatarUrl,
      disabled: false,
    };
  }

  public render() {
    const { user } = this.props;
    const { newName, newAvatarUrl } = this.state;

    return (
      <Layout {...this.props}>
        <Head>
          <title>Your Settings at Async</title>
          <meta name="description" content="description" />
        </Head>
        <div
          style={{
            padding: this.props.isMobile ? "0px" : "0px 30px",
            fontSize: "15px",
            height: "100%",
          }}
        >
          <h3>Your Settings</h3>
          <h4 style={{ marginTop: "40px" }}>Your account</h4>
          <ul>
            <li>
              Your email: <b>{user.email}</b>
            </li>
            <li>
              Your username: <b>{user.displayName}</b>
            </li>
          </ul>
          <form onSubmit={this.onSubmit} autoComplete="off">
            <h4>Your username</h4>
            <TextField
              autoComplete="off"
              value={newName}
              helperText="Your username as seen by your team members"
              onChange={(event) => {
                this.setState({ newName: event.target.value });
              }}
            />
            <br />
            <br />
            <Button variant="contained" color="primary" type="submit" disabled={this.state.disabled}>
              Update username
            </Button>
          </form>

          <br />
          <h4>Your photo</h4>
          <Avatar
            src={newAvatarUrl}
            style={{
              display: "inline-flex",
              verticalAlign: "middle",
              marginRight: 20,
              width: 60,
              height: 60,
            }}
          />
          <label htmlFor="upload-file-user-avatar">
            <Button variant="outlined" color="primary" component="span" disabled={this.state.disabled}>
              Update avatar
            </Button>
          </label>
          <input
            accept="image/*"
            name="upload-file-user-avatar"
            id="upload-file-user-avatar"
            type="file"
            style={{ display: "none" }}
            onChange={this.uploadFile}
          />
          <p />
          <br />
        </div>
      </Layout>
    );
  }

  private onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();

    const { newName, newAvatarUrl } = this.state;

    console.log(newName);

    if (!newName) {
      notify("Name is required");
      return;
    }

    NProgress.start();
    this.setState({ disabled: true });

    try {
      await updateProfileApiMethod({
        name: newName,
        avatarUrl: newAvatarUrl,
      });

      notify("You successfully updated your profile.");
    } catch (error) {
      notify(error);
    } finally {
      this.setState({ disabled: false });
      NProgress.done();
    }
  };

  private uploadFile = async () => {
    const fileElement = document.getElementById("upload-file-user-avatar") as HTMLFormElement;
    const file = fileElement.files[0];

    if (file == null) {
      notify("No file selected for upload.");
      return;
    }

    const fileName = file.name;
    const fileType = file.type;

    NProgress.start();
    this.setState({ disabled: true });

    const bucket = process.env.NEXT_PUBLIC_BUCKET_FOR_AVATARS;

    const prefix = "team-builder-book";

    try {
      const responseFromApiServerForUpload = await getSignedRequestForUploadApiMethod({
        fileName,
        fileType,
        prefix,
        bucket,
      });

      const resizedFile = await resizeImage(file, 128, 128);

      console.log(file);
      console.log(resizedFile);

      await uploadFileUsingSignedPutRequestApiMethod(resizedFile, responseFromApiServerForUpload.signedRequest, {
        "Cache-Control": "max-age=2592000",
      });

      this.setState({
        newAvatarUrl: responseFromApiServerForUpload.url,
      });

      await updateProfileApiMethod({
        name: this.state.newName,
        avatarUrl: this.state.newAvatarUrl,
      });

      notify("You successfully uploaded new avatar.");
    } catch (error) {
      notify(error);
    } finally {
      fileElement.value = "";
      this.setState({ disabled: false });
      NProgress.done();
    }
  };
}

export default YourSettings;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\pages\_app.tsx -----

import CssBaseline from "@mui/material/CssBaseline";
import { ThemeProvider } from "@mui/material";
import App from "next/app";
import Head from "next/head";
import React from "react";
import { isMobile } from "../lib/isMobile";
import { themeDark, themeLight } from "../lib/theme";

class MyApp extends App {
  public static async getInitialProps({ Component, ctx }) {
    const pageProps = { isMobile: isMobile({ req: ctx.req }), firstGridItem: true };

    if (Component.getInitialProps) {
      Object.assign(pageProps, await Component.getInitialProps(ctx));
    }

    // console.log(pageProps);

    return { pageProps };
  }

  public componentDidMount() {
    // Remove the server-side injected CSS.
    const jssStyles = document.querySelector("#jss-server-side");
    if (jssStyles && jssStyles.parentNode) {
      jssStyles.parentNode.removeChild(jssStyles);
    }
  }
  public render() {
    const { Component, pageProps } = this.props;

    return (
      <ThemeProvider theme={false ? themeDark : themeLight}>
        <Head>
          <meta name="viewport" content="width=device-width, initial-scale=1.0" />
          <link rel="stylesheet" href="https://storage.googleapis.com/async-await/nprogress-dark.min.css?v=1" />
        </Head>
        <CssBaseline />
        <Component {...pageProps} />
      </ThemeProvider>
    );
  }
}

export default MyApp;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\pages\_document.tsx -----

import Document, { Head, Html, Main, NextScript } from "next/document";
import React from "react";

class MyDocument extends Document {
  public static getInitialProps = async (ctx) => {
    const initialProps = await Document.getInitialProps(ctx);

    return {
      ...initialProps,
    };
  };

  public render() {
    // console.log('rendered on the server');

    return (
      <Html lang="en">
        <Head>
          <meta charSet="utf-8" />
          <meta name="google" content="notranslate" />
          <meta name="theme-color" content="#303030" />

          <link rel="shortcut icon" href="https://storage.googleapis.com/async-await/async-favicon32.png" />

          <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons" />
          <link rel="stylesheet" href="https://storage.googleapis.com/async-await/vs2015.min.css" />

          <style>
            {`
              #__next {
                width: 100%;
                height: 100%;
              }
              a {
                font-weight: 400;
                color: #58a6ff;
                text-decoration: none;
                outline: none;
              }
              hr {
                border: 0.5px #707070 solid;
                color: #000;
              }
              blockquote {
                padding: 0 0.5em;
                margin: 20px 1em;
                border-left: 0.25em solid #dfe2e5;
                color: #000;
              }
              pre {
                display: block;
                overflow-x: auto;
                padding: 0.5em;
                background: #d0d0d0;
                border: 1px solid #ddd;
                font-size: 14px;
                color: #000;
              }
              pre code {
                font-size: 13px;
                background: #d0d0d0;
                padding: 0px;
                color: #000;
              }
              code {
                font-size: 13px;
                background: #d0d0d0;
                padding: 3px 5px;
                color: #000;
              }
              mark {
                background-color: #ffff0060;
              }
              summary:focus {
                outline: none;
              }
              table {
                border-collapse: collapse;
                margin: 15px 0px;
              }
              table, th, td {
                border: 1px solid #a1a1a1;
              }
              th, td {
                line-height: 1.5em;
                padding: 10px;
              }
            `}
          </style>
        </Head>
        <body>
          <Main />
          <NextScript />
        </body>
      </Html>
    );
  }
}

export default MyDocument;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\server\server.ts -----

import express from 'express';
import next from 'next';

const NODE_ENV = process.env.NODE_ENV || 'development';
const IS_DEV = NODE_ENV !== 'production';

const app = next({ dev: IS_DEV });
const handle = app.getRequestHandler();

app.prepare().then(() => {
  const server = express();

  // give all Nextjs's request to Nextjs before anything else
  server.get('/_next/*', (req, res) => {
    // console.log('next server, page');
    handle(req, res);
  });

  server.use(express.json());

  // server.get('/api/v1/public/get-user', (_, res) => {
  //   res.json({ user: { email: 'team@builderbook.org' } });
  // });

  server.all('*', (req, res) => {
    handle(req, res);
  });

  server.listen(process.env.NEXT_PUBLIC_PORT_APP, () => {
    console.log(`> Ready on ${process.env.NEXT_PUBLIC_URL_APP}`);
  });
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\.eslintrc.js -----

module.exports = {
  settings: {
    react: { version: 'detect' },
  },
  parser: '@typescript-eslint/parser',
  extends: ['plugin:react/recommended', 'plugin:@typescript-eslint/recommended', 'prettier'],
  env: {
    es6: true,
    node: true,
  },
  plugins: ['prettier', 'react'],
  rules: {
    'prettier/prettier': [
      'error',
      {
        singleQuote: true,
        trailingComma: 'all',
        arrowParens: 'always',
        printWidth: 100,
        semi: true,
      },
    ],
    '@typescript-eslint/camelcase': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    'react/no-unescaped-entities': 'off',
    'react/jsx-filename-extension': ['error', { extensions: ['.tsx'] }],
    '@typescript-eslint/no-explicit-any': 'off',
    'prefer-arrow-callback': 'error',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
  },
};

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\next-env.d.ts -----

/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/pages/api-reference/config/typescript for more information.

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\next.config.js -----

module.exports = {
  poweredByHeader: false,
  webpack5: true,
  typescript: {
    ignoreBuildErrors: true,
  },
};

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\nodemon.json -----

{
  "watch": ["server"],
  "exec": "ts-node --project tsconfig.server.json",
  "ext": "ts"
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\package.json -----

{
  "name": "4-end-app",
  "version": "1",
  "license": "MIT",
  "scripts": {
    "dev": "nodemon server/server.ts",
    "build": "next build",
    "lint": "eslint . --ext .ts,.tsx"
  },
  "dependencies": {
    "@emotion/react": "^11.14.0",
    "@emotion/styled": "^11.14.0",
    "@mui/material": "^6.4.8",
    "@mui/system": "^6.4.8",
    "dotenv": "^16.4.7",
    "express": "^4.21.2",
    "isomorphic-unfetch": "^4.0.2",
    "next": "^15.2.3",
    "nprogress": "^0.2.0",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "typescript": "^5.8.2"
  },
  "devDependencies": {
    "@types/express": "^5.0.1",
    "@types/node": "^22.13.10",
    "@types/react": "^19.0.12",
    "@types/react-dom": "^19.0.4",
    "@typescript-eslint/eslint-plugin": "^8.27.0",
    "@typescript-eslint/parser": "^8.27.0",
    "eslint": "^9.22.0",
    "eslint-config-prettier": "^10.1.1",
    "eslint-plugin-prettier": "^5.2.3",
    "eslint-plugin-react": "^7.37.4",
    "nodemon": "^3.1.9",
    "prettier": "^3.5.3",
    "ts-node": "^10.9.2"
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\tsconfig.json -----

{
  "compileOnSave": false,
  "compilerOptions": {
    "target": "esnext",
    "module": "esnext",
    "jsx": "preserve",
    "allowJs": true,
    "alwaysStrict": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "removeComments": true,
    "preserveConstEnums": true,
    "sourceMap": false,
    "skipLibCheck": true,
    "baseUrl": ".",
    "typeRoots": [
      "./node_modules/@types"
    ],
    "lib": [
      "dom",
      "es2017"
    ],
    "strict": false,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "incremental": true
  },
  "include": [
    "next-env.d.ts",
    "./**/*.tsx",
    "./**/*.ts"
  ],
  "exclude": [
    "dist",
    "production-server",
    ".next",
    "out",
    "next.config.js",
    "node_modules"
  ]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\4-end\app\tsconfig.server.json -----

{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "module": "commonjs",
    "outDir": "production-server/",
    "target": "es2017",
    "isolatedModules": false,
    "noEmit": false
  },
  "exclude": ["./server/types.d.ts"],
  "include": ["./server/**/*.ts"],
  "typeRoots": ["./node_modules/@types", "./server/types.d.ts"]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\api\server\api\index.ts -----

import * as express from 'express';

import publicExpressRoutes from './public';
import teamMemberExpressRoutes from './team-member';

function handleError(err, _, res, __) {
  console.error(err.stack);

  res.json({ error: err.message || err.toString() });
}

export default function api(server: express.Express) {
  server.use('/api/v1/public', publicExpressRoutes, handleError);
  server.use('/api/v1/team-member', teamMemberExpressRoutes, handleError);
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\api\server\api\public.ts -----

import * as express from 'express';

import User from '../models/User';

const router = express.Router();

// router.get('/get-user', (req, res) => {
//   res.json({ user: { email: 'team@builderbook.org' } });
// });

router.post('/get-user-by-slug', async (req, res, next) => {
  console.log('Express route: /get-user-by-slug');

  try {
    const { slug } = req.body;

    const user = await User.getUserBySlug({ slug });

    res.json({ user });
  } catch (err) {
    next(err);
  }
});

router.post('/user/update-profile', async (req: any, res, next) => {
  console.log('Express route: /user/update-profile');

  try {
    const { name, avatarUrl } = req.body;

    const userId = '5e6427a51c9d440000c9ba6f';

    const updatedUser = await User.updateProfile({
      userId: userId,
      name,
      avatarUrl,
    });

    res.json({ updatedUser });
  } catch (err) {
    next(err);
  }
});

export default router;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\api\server\api\team-member.ts -----

import * as express from 'express';

import { signRequestForUpload } from '../aws-s3';

const router = express.Router();

// Get signed request from AWS S3 server
router.post('/aws/get-signed-request-for-upload-to-s3', async (req, res, next) => {
  try {
    const { fileName, fileType, prefix, bucket } = req.body;

    const returnData = await signRequestForUpload({
      fileName,
      fileType,
      prefix,
      bucket,
    });

    console.log(returnData);

    res.json(returnData);
  } catch (err) {
    next(err);
  }
});

export default router;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\api\server\models\User.ts -----

// import * as _ from 'lodash';
import * as mongoose from 'mongoose';

import { generateSlug } from '../utils/slugify';

const mongoSchema = new mongoose.Schema({
  slug: {
    type: String,
    required: true,
    unique: true,
  },
  createdAt: {
    type: Date,
    required: true,
  },
  email: {
    type: String,
    required: true,
    unique: true,
  },
  displayName: String,
  avatarUrl: String,
});

interface UserDocument extends mongoose.Document {
  slug: string;
  createdAt: Date;
  email: string;
  displayName: string;
  avatarUrl: string;
}

interface UserModel extends mongoose.Model<UserDocument> {
  getUserBySlug({ slug }: { slug: string }): Promise<UserDocument>;

  updateProfile({
    userId,
    name,
    avatarUrl,
  }: {
    userId: string;
    name: string;
    avatarUrl: string;
  }): Promise<UserDocument[]>;
}

class UserClass extends mongoose.Model {
  public static async getUserBySlug({ slug }) {
    console.log('Static method: getUserBySlug');

    return this.findOne({ slug }, 'email displayName avatarUrl').setOptions({ lean: true });
  }

  public static async updateProfile({ userId, name, avatarUrl }) {
    console.log('Static method: updateProfile');

    const user = await this.findById(userId, 'slug displayName');

    const modifier = { displayName: user.displayName, avatarUrl, slug: user.slug };

    console.log(user.slug);

    if (name !== user.displayName) {
      modifier.displayName = name;
      modifier.slug = await generateSlug(this, name);
    }

    return this.findByIdAndUpdate(userId, { $set: modifier }, { new: true, runValidators: true })
      .select('displayName avatarUrl slug')
      .setOptions({ lean: true });
  }
}

mongoSchema.loadClass(UserClass);

const User = mongoose.model<UserDocument, UserModel>('User', mongoSchema);

export default User;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\api\server\utils\slugify.ts -----

import * as _ from 'lodash';

const slugify = (text) => _.kebabCase(text);

async function createUniqueSlug(Model, slug, count, filter) {
  const obj = await Model.findOne({ slug: `${slug}-${count}`, ...filter })
    .select('_id')
    .setOptions({ lean: true });

  if (!obj) {
    return `${slug}-${count}`;
  }

  return createUniqueSlug(Model, slug, count + 1, filter);
}

async function generateSlug(Model, name, filter = {}) {
  const origSlug = slugify(name);

  const obj = await Model.findOne({ slug: origSlug, ...filter })
    .select('_id')
    .setOptions({ lean: true });

  if (!obj) {
    return origSlug;
  }

  return createUniqueSlug(Model, origSlug, 1, filter);
}

export { generateSlug };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\api\server\utils\sum.ts -----

function sum(a, b) {
  return a + b;
}

export { sum };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\api\server\aws-s3.ts -----

import * as url from 'url';
import * as aws from 'aws-sdk';

async function signRequestForUpload({ fileName, fileType, prefix, bucket }) {
  const randomStringForPrefix =
    Math.random().toString(36).substring(2, 12) + Math.random().toString(36).substring(2, 12);

  const key = `${prefix}/${randomStringForPrefix}/${fileName}`;

  const acl = 'public-read';

  const params = {
    Bucket: bucket,
    Key: key,
    Expires: 60,
    ContentType: fileType,
    ACL: acl,
  };

  console.log(prefix);

  const s3 = new aws.S3({
    apiVersion: 'latest',
    region: process.env.AWS_REGION,
    accessKeyId: process.env.AWS_ACCESSKEYID,
    secretAccessKey: process.env.AWS_SECRETACCESSKEY,
  });

  return new Promise((resolve, reject) => {
    s3.getSignedUrl('putObject', params, (err, data) => {
      const parsedUrl = url.parse(data);

      const returnData = {
        signedRequest: data,
        url: `${parsedUrl.protocol}//${parsedUrl.hostname}${parsedUrl.pathname}`,
      };

      if (err) {
        console.error(err);
        reject(err);
      } else {
        resolve(returnData);
      }
    });
  });
}

export { signRequestForUpload };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\api\server\server.ts -----

import * as cors from 'cors';
import * as express from 'express';
import * as mongoose from 'mongoose';

import api from './api';

// eslint-disable-next-line
require('dotenv').config();

mongoose.connect(process.env.MONGO_URL_TEST);

const server = express();

server.use(
  cors({
    origin: process.env.URL_APP,
    methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',
    credentials: true,
  }),
);

server.use(express.json());

api(server);

server.get('*', (_, res) => {
  res.sendStatus(403);
});

server.listen(process.env.PORT_API, () => {
  console.log(`> Ready on ${process.env.URL_API}`);
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\api\test\server\utils\slugify.test.ts -----

import * as mongoose from 'mongoose';
import User from '../../../server/models/User';
import { generateSlug } from '../../../server/utils/slugify';

// eslint-disable-next-line
require('dotenv').config();

describe('slugify', () => {
  beforeAll(async () => {
    await mongoose.connect(process.env.MONGO_URL_TEST);

    const mockUsers = [
      {
        slug: 'john',
        email: 'john@example.com',
        createdAt: new Date(),
        displayName: 'abc',
        avatarUrl: 'def',
      },
      {
        slug: 'john-johnson',
        email: 'john-johnson@example.com',
        createdAt: new Date(),
        displayName: 'abc',
        avatarUrl: 'def',
      },
      {
        slug: 'john-johnson-1',
        email: 'john-johnson-1@example.com',
        createdAt: new Date(),
        displayName: 'abc',
        avatarUrl: 'def',
      },
    ];

    await User.insertMany(mockUsers);
  });

  test('not duplicated', async () => {
    expect.assertions(1);

    await expect(generateSlug(User, 'John J Johnson@#$')).resolves.toEqual('john-j-johnson');
  });

  test('one time duplicated', async () => {
    expect.assertions(1);

    await expect(generateSlug(User, ' John@#$')).resolves.toEqual('john-1');
  });

  test('multiple duplicated', async () => {
    expect.assertions(1);

    await expect(generateSlug(User, 'John & Johnson@#$')).resolves.toEqual('john-johnson-2');
  });

  afterAll(async () => {
    await User.deleteMany({ slug: { $in: ['john', 'john-johnson', 'john-johnson-1'] } });
    await mongoose.disconnect();
  });
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\api\test\server\utils\sum.test.ts -----

import { sum } from '../../../server/utils/sum';

console.log(sum(1, 2));

describe.skip('testing sum function', () => {
  test('adds 1 + 2 to equal 3', () => {
    expect(sum(1, 2)).toBe(3);
  });
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\api\.eslintrc.js -----

module.exports = {
  parser: "@typescript-eslint/parser",
  extends: ["plugin:@typescript-eslint/recommended", "prettier"],
  env: {
    "es6": true,
    "node": true,
  },
  plugins: ["prettier"],
  rules: {
    'prettier/prettier': [
      'error',
      {
        singleQuote: true,
        trailingComma: 'all',
        arrowParens: 'always',
        printWidth: 100,
        semi: true,
      },
    ],
    '@typescript-eslint/no-unused-vars': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/no-explicit-any': 'off',
    'prefer-arrow-callback': 'error',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
 },
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\api\nodemon.json -----

{
  "watch": ["server"],
  "exec": "ts-node --project tsconfig.server.json",
  "ext": "ts"
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\api\package.json -----

{
  "name": "5-begin-api",
  "version": "1",
  "license": "MIT",
  "scripts": {
    "dev": "nodemon server/server.ts",
    "lint": "eslint . --ext .ts,.tsx",
    "test": "jest"
  },
  "jest": {
    "preset": "ts-jest",
    "testPathIgnorePatterns": [
      "production-server"
    ],
    "testEnvironment": "node"
  },
  "dependencies": {
    "aws-sdk": "^2.1692.0",
    "cors": "^2.8.5",
    "dotenv": "^16.4.7",
    "express": "^4.21.2",
    "lodash": "^4.17.20",
    "mongoose": "^8.12.1",
    "typescript": "^5.8.2"
  },
  "devDependencies": {
    "@types/dotenv": "^8.2.3",
    "@types/express": "^5.0.1",
    "@types/jest": "^29.5.14",
    "@types/lodash": "^4.17.16",
    "@types/mongoose": "^5.5.43",
    "@types/node": "^22.13.10",
    "@typescript-eslint/eslint-plugin": "^8.27.0",
    "@typescript-eslint/parser": "^8.27.0",
    "eslint": "^9.22.0",
    "eslint-config-prettier": "^10.1.1",
    "eslint-plugin-prettier": "^5.2.3",
    "jest": "^29.7.0",
    "nodemon": "^3.1.9",
    "prettier": "^3.5.3",
    "ts-jest": "^29.2.6",
    "ts-node": "^10.9.2"
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\api\tsconfig.json -----

{
  "compileOnSave": false,
  "compilerOptions": {
    "jsx": "preserve",
    "allowJs": true,
    "alwaysStrict": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "removeComments": false,
    "preserveConstEnums": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "sourceMap": true,
    "skipLibCheck": true,
    "baseUrl": ".",
    "experimentalDecorators": true,
    "typeRoots": ["./node_modules/@types"],
    "lib": ["es2015", "es2016"]
  },
  "exclude": ["production-server", "node_modules"]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\api\tsconfig.server.json -----

{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "module": "commonjs",
    "outDir": "production-server/"
  },
  "include": ["./server/**/*.ts"],
  "exclude": ["./server/**/*.test.ts"]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\components\common\Confirmer.tsx -----

import Button from "@mui/material/Button";
import Dialog from "@mui/material/Dialog";
import DialogActions from "@mui/material/DialogActions";
import DialogContent from "@mui/material/DialogContent";
import DialogContentText from "@mui/material/DialogContentText";
import DialogTitle from "@mui/material/DialogTitle";
import React from "react";

export let openConfirmDialogExternal;

type State = {
  open: boolean;
  title: string;
  message: string;
  onAnswer: (answer) => void;
};

class Confirmer extends React.Component<any, State> {
  constructor(props) {
    super(props);

    this.state = {
      open: false,
      title: "Are you sure?",
      message: "",
      onAnswer: null,
    };

    openConfirmDialogExternal = this.openConfirmDialog;
  }

  public render() {
    return (
      <Dialog
        open={this.state.open}
        onClose={this.handleClose}
        aria-labelledby="alert-dialog-title"
        aria-describedby="alert-dialog-description"
      >
        <DialogTitle id="alert-dialog-title">{this.state.title}</DialogTitle>
        <DialogContent>
          <DialogContentText id="alert-dialog-description">{this.state.message}</DialogContentText>
        </DialogContent>
        <DialogActions style={{ padding: "10px" }}>
          <Button onClick={this.handleClose} variant="contained" color="primary" autoFocus>
            Cancel
          </Button>
          <Button onClick={this.handleYes} variant="contained" color="secondary">
            OK
          </Button>
        </DialogActions>
      </Dialog>
    );
  }

  public handleClose = () => {
    this.setState({ open: false });
    this.state.onAnswer(false);
  };

  public handleYes = () => {
    this.setState({ open: false });
    this.state.onAnswer(true);
  };

  public openConfirmDialog = ({ title, message, onAnswer }) => {
    this.setState({ open: true, title, message, onAnswer });
  };
}

export default Confirmer;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\components\common\MenuWithLinks.tsx -----

import Menu from "@mui/material/Menu";
import MenuItem from "@mui/material/MenuItem";
import Link from "next/link";
import { NextRouter, withRouter } from "next/router";
import React from "react";

type Props = {
  options: {
    href: string;
    as: string;
    highlighterSlug: string;
    text: string;
    separator: boolean;
  }[];
  router: NextRouter;
  children: any;
};

type State = {
  anchorEl: Element | ((element: Element) => Element);
};

class MenuWithLinks extends React.PureComponent<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      anchorEl: null,
    };
  }

  public render() {
    const { options, children, router } = this.props;
    const { anchorEl } = this.state;

    return (
      <div style={{ textAlign: "center" }}>
        <div
          aria-controls={anchorEl ? "simple-menu" : null}
          aria-haspopup="true"
          onClick={this.handleClick}
          onKeyPress={this.handleClick}
        >
          {children}
        </div>
        <Menu id="simple-menu" anchorEl={anchorEl} open={Boolean(anchorEl)} onClose={this.handleClose} keepMounted>
          {options.map((option, i) =>
            option.separator ? (
              <hr style={{ width: "85%", margin: "10px auto" }} key={`separated-${i}`} />
            ) : (
              <Link key={option.href} href={option.href} as={option.as} passHref>
                <MenuItem
                  key={option.href}
                  style={{
                    fontWeight: router.asPath.includes(option.highlighterSlug) ? 600 : 300,
                    fontSize: "14px",
                  }}
                >
                  {option.text}
                </MenuItem>
              </Link>
            )
          )}
        </Menu>
      </div>
    );
  }

  public handleClick = (event) => {
    this.setState({ anchorEl: event.currentTarget });
  };

  public handleClose = () => {
    this.setState({ anchorEl: null });
  };
}

export default withRouter(MenuWithLinks);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\components\common\Notifier.tsx -----

import Snackbar from "@mui/material/Snackbar";
import React from "react";

export let openSnackbarExternal;

type State = {
  open: boolean;
  message: string;
};

class Notifier extends React.PureComponent<any, State> {
  constructor(props) {
    super(props);
    openSnackbarExternal = this.openSnackbar;

    this.state = {
      open: false,
      message: "",
    };
  }

  public render() {
    const message = <span id="snackbar-message-id" dangerouslySetInnerHTML={{ __html: this.state.message }} />;

    return (
      <Snackbar
        anchorOrigin={{ vertical: "top", horizontal: "right" }}
        message={message}
        autoHideDuration={5000}
        onClose={this.handleSnackbarClose}
        open={this.state.open}
        ContentProps={{
          "aria-describedby": "snackbar-message-id",
        }}
      />
    );
  }

  public handleSnackbarClose = () => {
    this.setState({
      open: false,
      message: "",
    });
  };

  public openSnackbar = ({ message }) => {
    this.setState({ open: true, message });
  };
}

export default Notifier;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\components\layout\index.tsx -----

import Avatar from "@mui/material/Avatar";
import Grid from "@mui/material/Grid";
import React from "react";
import MenuWithLinks from "../common/MenuWithLinks";
import Confirmer from "../common/Confirmer";
import Notifier from "../common/Notifier";

const styleGrid = {
  width: "100%",
  height: "100vh",
  maxWidth: "100%",
  padding: "0px 10px",
  display: "flex",
  overflow: "hidden",
};

const styleGridIsMobile = {
  width: "100%",
  height: "100vh",
  maxWidth: "100%",
  padding: "0px 0px 0px 10px",
  display: "flex",
  overflow: "hidden",
};

type Props = {
  children: React.ReactNode;
  firstGridItem?: boolean;
  isMobile?: boolean;
};

class Layout extends React.Component<Props> {
  public render() {
    const { children, firstGridItem, isMobile } = this.props;

    const isThemeDark = false;

    // console.log(isMobile);

    return (
      <Grid
        container
        direction="row"
        justify="flex-start"
        alignItems="stretch"
        style={isMobile ? styleGridIsMobile : styleGrid}
      >
        {firstGridItem ? (
          <Grid
            item
            sm={2}
            xs={12}
            style={{
              borderRight: "1px #707070 solid",
              justifyContent: "center",
              overflow: "hidden",
            }}
          >
            <div style={{ display: "flex", justifyContent: "space-between" }}>
              <svg
                xmlns="http://www.w3.org/2000/svg"
                width="124"
                height="40"
                viewBox="0 0 124 40"
                style={{
                  marginTop: "20px",
                  display: "inline-flex",
                  height: "40px",
                }}
              >
                <g id="async-logo">
                  <g id="async-logo-40">
                    <circle id="Ellipse 2" cx="20" cy="20" r="20" fill="black" />
                    <path
                      id="path-async-logo"
                      d="M7.07825 -0.0960007V16H4.51825V13.088C4.04892 14.0907 3.33425 14.8693 2.37425 15.424C1.43558 15.9573 0.336917 16.224 -0.92175 16.224C-2.35108 16.224 -3.60975 15.8827 -4.69775 15.2C-5.76442 14.5173 -6.59642 13.5573 -7.19375 12.32C-7.76975 11.0613 -8.05775 9.6 -8.05775 7.936C-8.05775 6.272 -7.75908 4.81067 -7.16175 3.552C-6.56442 2.272 -5.73242 1.28 -4.66575 0.576C-3.57775 -0.128 -2.32975 -0.48 -0.92175 -0.48C0.336917 -0.48 1.43558 -0.202666 2.37425 0.352C3.31292 0.906667 4.02758 1.68533 4.51825 2.688V-0.0960007H7.07825ZM-0.40975 14.08C1.16892 14.08 2.38492 13.5467 3.23825 12.48C4.09158 11.392 4.51825 9.856 4.51825 7.872C4.51825 5.888 4.09158 4.36267 3.23825 3.296C2.38492 2.22933 1.16892 1.696 -0.40975 1.696C-1.98842 1.696 -3.22575 2.25067 -4.12175 3.36C-4.99642 4.448 -5.43375 5.97333 -5.43375 7.936C-5.43375 9.89867 -4.99642 11.4133 -4.12175 12.48C-3.24708 13.5467 -2.00975 14.08 -0.40975 14.08Z"
                      transform="translate(19.5938 12)"
                      fill="white"
                    />
                  </g>
                  <path
                    id="path-async-text"
                    d="M22.6251 11.928V24H20.7051V21.816C20.3531 22.568 19.8171 23.152 19.0971 23.568C18.3931 23.968 17.5691 24.168 16.6251 24.168C15.5531 24.168 14.6091 23.912 13.7931 23.4C12.9931 22.888 12.3691 22.168 11.9211 21.24C11.4891 20.296 11.2731 19.2 11.2731 17.952C11.2731 16.704 11.4971 15.608 11.9451 14.664C12.3931 13.704 13.0171 12.96 13.8171 12.432C14.6331 11.904 15.5691 11.64 16.6251 11.64C17.5691 11.64 18.3931 11.848 19.0971 12.264C19.8011 12.68 20.3371 13.264 20.7051 14.016V11.928H22.6251ZM17.0091 22.56C18.1931 22.56 19.1051 22.16 19.7451 21.36C20.3851 20.544 20.7051 19.392 20.7051 17.904C20.7051 16.416 20.3851 15.272 19.7451 14.472C19.1051 13.672 18.1931 13.272 17.0091 13.272C15.8251 13.272 14.8971 13.688 14.2251 14.52C13.5691 15.336 13.2411 16.48 13.2411 17.952C13.2411 19.424 13.5691 20.56 14.2251 21.36C14.8811 22.16 15.8091 22.56 17.0091 22.56ZM30.4637 24.168C28.4317 24.168 26.8237 23.648 25.6397 22.608L26.2877 21.168C26.9437 21.68 27.6077 22.048 28.2797 22.272C28.9517 22.496 29.7037 22.608 30.5357 22.608C31.4477 22.608 32.1357 22.456 32.5997 22.152C33.0797 21.832 33.3197 21.376 33.3197 20.784C33.3197 20.304 33.1597 19.92 32.8397 19.632C32.5197 19.344 31.9917 19.12 31.2557 18.96L29.2157 18.48C28.2077 18.256 27.4237 17.856 26.8637 17.28C26.3197 16.704 26.0477 16.016 26.0477 15.216C26.0477 14.16 26.4717 13.304 27.3197 12.648C28.1677 11.976 29.2877 11.64 30.6797 11.64C31.5277 11.64 32.3277 11.776 33.0797 12.048C33.8317 12.32 34.4637 12.712 34.9757 13.224L34.3277 14.64C33.1917 13.696 31.9757 13.224 30.6797 13.224C29.8157 13.224 29.1437 13.392 28.6637 13.728C28.1997 14.048 27.9677 14.504 27.9677 15.096C27.9677 15.592 28.1117 15.984 28.3997 16.272C28.7037 16.56 29.1837 16.784 29.8397 16.944L31.8797 17.448C32.9997 17.704 33.8317 18.104 34.3757 18.648C34.9197 19.176 35.1917 19.872 35.1917 20.736C35.1917 21.776 34.7677 22.608 33.9197 23.232C33.0717 23.856 31.9197 24.168 30.4637 24.168ZM48.687 11.928L43.047 25.104C42.455 26.48 41.711 27.488 40.815 28.128C39.919 28.768 38.815 29.208 37.503 29.448L37.095 27.936C38.231 27.68 39.087 27.336 39.663 26.904C40.255 26.488 40.743 25.84 41.127 24.96L41.607 23.88L36.495 11.928H38.535L42.615 21.888L46.743 11.928H48.687ZM56.853 11.64C59.749 11.64 61.197 13.232 61.197 16.416V24H59.253V16.512C59.253 15.392 59.029 14.576 58.581 14.064C58.133 13.536 57.429 13.272 56.469 13.272C55.349 13.272 54.453 13.616 53.781 14.304C53.109 14.992 52.773 15.92 52.773 17.088V24H50.829V15.312C50.829 14.064 50.765 12.936 50.637 11.928H52.485L52.677 14.088C53.045 13.304 53.597 12.704 54.333 12.288C55.069 11.856 55.909 11.64 56.853 11.64ZM69.9321 24.168C68.7641 24.168 67.7401 23.912 66.8601 23.4C65.9961 22.888 65.3241 22.168 64.8441 21.24C64.3801 20.296 64.1481 19.2 64.1481 17.952C64.1481 16.704 64.3881 15.608 64.8681 14.664C65.3481 13.704 66.0281 12.96 66.9081 12.432C67.8041 11.904 68.8441 11.64 70.0281 11.64C70.8441 11.64 71.6281 11.784 72.3801 12.072C73.1481 12.344 73.7801 12.728 74.2761 13.224L73.6281 14.664C73.0201 14.184 72.4281 13.832 71.8521 13.608C71.2921 13.384 70.7161 13.272 70.1241 13.272C68.8921 13.272 67.9241 13.688 67.2201 14.52C66.5161 15.336 66.1641 16.48 66.1641 17.952C66.1641 19.408 66.5081 20.544 67.1961 21.36C67.9001 22.16 68.8761 22.56 70.1241 22.56C70.7161 22.56 71.2921 22.448 71.8521 22.224C72.4281 22 73.0201 21.648 73.6281 21.168L74.2761 22.608C73.7641 23.088 73.1161 23.472 72.3321 23.76C71.5641 24.032 70.7641 24.168 69.9321 24.168Z"
                    transform="translate(39 4)"
                    fill={isThemeDark ? "white" : "black"}
                  />
                </g>
              </svg>
              <MenuWithLinks
                options={[
                  {
                    text: "Index page",
                    href: "/",
                    highlighterSlug: "/",
                  },
                  {
                    text: "Your Settings",
                    href: "/your-settings",
                    highlighterSlug: "/your-settings",
                  },
                  {
                    separator: true,
                  },
                  {
                    text: "Log out",
                    href: "/logout",
                  },
                ]}
              >
                <Avatar
                  src={"https://storage.googleapis.com/async-await/default-user.png"}
                  alt="Add username here later in the book"
                  style={{
                    margin: "20px auto",
                    cursor: "pointer",
                    display: "inline-flex",
                    width: "40px",
                    height: "40px",
                  }}
                />

                <i className="material-icons" color="action" style={{ verticalAlign: "super" }}>
                  arrow_drop_down
                </i>
              </MenuWithLinks>
            </div>
            <hr />
            <p />
            <p />
          </Grid>
        ) : null}
        <Grid item sm={10} xs={12}>
          {isMobile ? <hr /> : null}
          {children}
        </Grid>
        <Notifier />
        <Confirmer />
      </Grid>
    );
  }
}

export default Layout;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\lib\api\public.ts -----

import sendRequestAndGetResponse from './sendRequestAndGetResponse';

const BASE_PATH = '/api/v1/public';

export const getUserApiMethod = (request) =>
  sendRequestAndGetResponse(`${BASE_PATH}/get-user`, {
    request,
    method: 'GET',
  });

export const getUserBySlugApiMethod = (slug) =>
  sendRequestAndGetResponse(`${BASE_PATH}/get-user-by-slug`, {
    body: JSON.stringify({ slug }),
  });

export const updateProfileApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/user/update-profile`, {
    body: JSON.stringify(data),
  });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\lib\api\sendRequestAndGetResponse.ts -----

import 'isomorphic-unfetch';

export default async function sendRequestAndGetResponse(path, opts: any = {}) {
  const headers = Object.assign(
    {},
    opts.headers || {},
    opts.externalServer
      ? {}
      : {
          'Content-type': 'application/json; charset=UTF-8',
        },
  );

  const { request } = opts;
  if (request && request.headers && request.headers.cookie) {
    headers.cookie = request.headers.cookie;
  }

  const qs = opts.qs || '';

  // console.log(`before: ${process.env.NEXT_PUBLIC_URL_API}${path}${qs}`);

  const response = await fetch(
    opts.externalServer ? `${path}${qs}` : `${process.env.NEXT_PUBLIC_URL_API}${path}${qs}`,
    Object.assign({ method: 'POST', credentials: 'include' }, opts, { headers }),
  );

  // console.log(`after: ${process.env.NEXT_PUBLIC_URL_API}${path}${qs}`);

  // console.log(response.status);
  // console.log(response.statusText);

  const text = await response.text();

  if (response.status >= 400) {
    console.error(text);
    throw new Error(response.status.toString());
  }

  try {
    const data = JSON.parse(text);

    return data;
  } catch (err) {
    if (err instanceof SyntaxError) {
      return text;
    }

    throw err;
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\lib\api\team-member.ts -----

import sendRequestAndGetResponse from './sendRequestAndGetResponse';

const BASE_PATH = '/api/v1/team-member';

export const getSignedRequestForUploadApiMethod = ({ fileName, fileType, prefix, bucket }) =>
  sendRequestAndGetResponse(`${BASE_PATH}/aws/get-signed-request-for-upload-to-s3`, {
    body: JSON.stringify({ fileName, fileType, prefix, bucket }),
  });

export const uploadFileUsingSignedPutRequestApiMethod = (file, signedRequest, headers = {}) =>
  sendRequestAndGetResponse(signedRequest, {
    externalServer: true,
    method: 'PUT',
    body: file,
    headers,
  });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\lib\confirm.ts -----

import { openConfirmDialogExternal } from '../components/common/Confirmer';

export default function confirm({
  title,
  message,
  onAnswer,
}: {
  title: string;
  message: string;
  onAnswer: (answer) => void;
}) {
  openConfirmDialogExternal({ title, message, onAnswer });
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\lib\isMobile.ts -----

const mobileRE = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i;

export function isMobile(opts) {
  if (!opts) {
    opts = {};
  }

  let ua = opts.ua;

  if (!ua && typeof navigator !== 'undefined') {
    ua = navigator.userAgent;
  }

  if (!ua && opts.req && opts.req.headers && typeof opts.req.headers['user-agent'] === 'string') {
    ua = opts.req.headers['user-agent'];
    // console.log(ua);
  }

  if (typeof ua !== 'string') {
    return false;
  }

  return mobileRE.test(ua);
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\lib\notify.ts -----

import { openSnackbarExternal } from '../components/common/Notifier';

export default function notify(obj) {
  openSnackbarExternal({ message: obj.message || obj.toString() });
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\lib\resizeImage.ts -----

function resizeImage(file: File, MAX_WIDTH, MAX_HEIGHT) {
  const image = document.createElement('img');

  const resize = (resolve) => () => {
    let isResizeNeeded = false;
    let width = image.width;
    let height = image.height;

    if (width > height) {
      if (width > MAX_WIDTH) {
        isResizeNeeded = true;
        height *= MAX_WIDTH / width;
        width = MAX_WIDTH;
      }
    } else {
      if (height > MAX_HEIGHT) {
        isResizeNeeded = true;
        width *= MAX_HEIGHT / height;
        height = MAX_HEIGHT;
      }
    }

    if (isResizeNeeded) {
      const canvas = document.createElement('canvas');

      canvas.width = width;
      canvas.height = height;

      console.log(width, height);

      const ctx = canvas.getContext('2d');
      ctx.drawImage(image, 0, 0, width, height);

      canvas.toBlob((blob) => {
        resolve(blob);
      }, file.type);
    } else {
      resolve(file);
    }
  };

  return new Promise((resolve) => {
    const reader = new FileReader();

    console.log(`before ${image.src}`);

    reader.readAsDataURL(file);

    reader.onload = (e) => {
      image.src = e.target.result.toString();

      image.onload = resize(resolve);

      console.log(`after ${image.src}`);
    };
  });
}

export { resizeImage };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\lib\sharedStyles.ts -----

const styleBigAvatar = {
  width: '80px',
  height: '80px',
  margin: '0px auto 15px',
};

const styleRaisedButton = {
  margin: '15px',
  font: '14px Roboto',
};

const styleToolbar = {
  background: '#FFF',
  height: '64px',
  paddingRight: '20px',
};

const styleTextField = {
  font: '15px Roboto',
  color: '#222',
  fontWeight: '300',
};

const styleForm = {
  margin: '7% auto',
  width: '360px',
};

export { styleBigAvatar, styleRaisedButton, styleToolbar, styleTextField, styleForm };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\lib\theme.ts -----

import { createMuiTheme } from "@mui/material/styles";

const themeDark = createMuiTheme({
  palette: {
    primary: { main: "#238636" },
    secondary: { main: "#b62324" },
    type: "dark",
    background: { default: "#0d1117" },
    text: {
      primary: "#c9d1d9",
    },
  },
  typography: {
    button: {
      textTransform: "none",
    },
  },
});

const themeLight = createMuiTheme({
  palette: {
    primary: { main: "#238636" },
    secondary: { main: "#b62324" },
    type: "light",
    background: { default: "#fff" },
    text: {
      primary: "#222",
    },
  },
  typography: {
    button: {
      textTransform: "none",
    },
  },
});

export { themeDark, themeLight };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\pages\csr-page.tsx -----

import Button from "@mui/material/Button";
import React from "react";
import Head from "next/head";

const CSRPage = () => (
  <div>
    <Head>
      <title>CSR page</title>
      <meta name="description" content="This is a description of the CSR page" />
    </Head>
    <div style={{ padding: "0px 30px", fontSize: "15px", height: "100%" }}>
      <p>Content on CSR page</p>
      <Button variant="outlined">Some button</Button>
    </div>
  </div>
);

console.log(process.env.NEXT_PUBLIC_URL_APP);

export default CSRPage;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\pages\index.tsx -----

import Button from "@mui/material/Button";
import React from "react";
import Head from "next/head";
import Link from "next/link";

import Layout from "../components/layout";
import NProgress from "nprogress";

import confirm from "../lib/confirm";
import notify from "../lib/notify";
import { getUserBySlugApiMethod } from "../lib/api/public";

type Props = { user: { email: string; displayName: string } };

class Index extends React.Component<Props> {
  public static async getInitialProps() {
    const slug = "team-builder-book";

    const user = await getUserBySlugApiMethod(slug);

    console.log(user);

    return { ...user };
  }

  public render() {
    return (
      <Layout {...this.props}>
        <Head>
          <title>Index page</title>
          <meta name="description" content="This is a description of the Index page" />
        </Head>
        <div style={{ padding: "0px 30px", fontSize: "15px", height: "100%" }}>
          <p>Content on Index page</p>
          <Link href="/csr-page" as="/csr-page">
            Go to CSR page
          </Link>
          <p />
          <Button
            variant="contained"
            onClick={() =>
              confirm({
                title: "Are you sure?",
                message: "explanatory message",
                onAnswer: async (answer) => {
                  // console.log(answer);
                  if (!answer) {
                    return;
                  }

                  NProgress.start();

                  try {
                    notify("You successfully confirmed.");
                  } catch (error) {
                    console.error(error);
                    notify(error);
                  } finally {
                    NProgress.done();
                  }
                },
              })
            }
          >
            Test Confirmer and Notifier
          </Button>
          <p>Your email: {this.props.user.email}</p>
          <p>Your username: {this.props.user.displayName}</p>
        </div>
      </Layout>
    );
  }
}

export default Index;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\pages\your-settings.tsx -----

import Avatar from "@mui/material/Avatar";
import Button from "@mui/material/Button";
import TextField from "@mui/material/TextField";
import Head from "next/head";
import NProgress from "nprogress";
import * as React from "react";

import Layout from "../components/layout";

import { getUserBySlugApiMethod, updateProfileApiMethod } from "../lib/api/public";
import { getSignedRequestForUploadApiMethod, uploadFileUsingSignedPutRequestApiMethod } from "../lib/api/team-member";

import { resizeImage } from "../lib/resizeImage";

import notify from "../lib/notify";

type Props = {
  isMobile: boolean;
  user: { email: string; displayName: string; slug: string; avatarUrl: string };
};

type State = { newName: string; newAvatarUrl: string; disabled: boolean };

class YourSettings extends React.Component<Props, State> {
  public static async getInitialProps() {
    const slug = "team-builder-book";

    const user = await getUserBySlugApiMethod(slug);

    console.log(user);

    return { ...user };
  }

  constructor(props) {
    super(props);

    this.state = {
      newName: this.props.user.displayName,
      newAvatarUrl: this.props.user.avatarUrl,
      disabled: false,
    };
  }

  public render() {
    const { user } = this.props;
    const { newName, newAvatarUrl } = this.state;

    return (
      <Layout {...this.props}>
        <Head>
          <title>Your Settings at Async</title>
          <meta name="description" content="description" />
        </Head>
        <div
          style={{
            padding: this.props.isMobile ? "0px" : "0px 30px",
            fontSize: "15px",
            height: "100%",
          }}
        >
          <h3>Your Settings</h3>
          <h4 style={{ marginTop: "40px" }}>Your account</h4>
          <ul>
            <li>
              Your email: <b>{user.email}</b>
            </li>
            <li>
              Your username: <b>{user.displayName}</b>
            </li>
          </ul>
          <form onSubmit={this.onSubmit} autoComplete="off">
            <h4>Your username</h4>
            <TextField
              autoComplete="off"
              value={newName}
              helperText="Your username as seen by your team members"
              onChange={(event) => {
                this.setState({ newName: event.target.value });
              }}
            />
            <br />
            <br />
            <Button variant="contained" color="primary" type="submit" disabled={this.state.disabled}>
              Update username
            </Button>
          </form>

          <br />
          <h4>Your photo</h4>
          <Avatar
            src={newAvatarUrl}
            style={{
              display: "inline-flex",
              verticalAlign: "middle",
              marginRight: 20,
              width: 60,
              height: 60,
            }}
          />
          <label htmlFor="upload-file-user-avatar">
            <Button variant="outlined" color="primary" component="span" disabled={this.state.disabled}>
              Update avatar
            </Button>
          </label>
          <input
            accept="image/*"
            name="upload-file-user-avatar"
            id="upload-file-user-avatar"
            type="file"
            style={{ display: "none" }}
            onChange={this.uploadFile}
          />
          <p />
          <br />
        </div>
      </Layout>
    );
  }

  private onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();

    const { newName, newAvatarUrl } = this.state;

    console.log(newName);

    if (!newName) {
      notify("Name is required");
      return;
    }

    NProgress.start();
    this.setState({ disabled: true });

    try {
      await updateProfileApiMethod({
        name: newName,
        avatarUrl: newAvatarUrl,
      });

      notify("You successfully updated your profile.");
    } catch (error) {
      notify(error);
    } finally {
      this.setState({ disabled: false });
      NProgress.done();
    }
  };

  private uploadFile = async () => {
    const fileElement = document.getElementById("upload-file-user-avatar") as HTMLFormElement;
    const file = fileElement.files[0];

    if (file == null) {
      notify("No file selected for upload.");
      return;
    }

    const fileName = file.name;
    const fileType = file.type;

    NProgress.start();
    this.setState({ disabled: true });

    const bucket = process.env.NEXT_PUBLIC_BUCKET_FOR_AVATARS;

    const prefix = "team-builder-book";

    try {
      const responseFromApiServerForUpload = await getSignedRequestForUploadApiMethod({
        fileName,
        fileType,
        prefix,
        bucket,
      });

      const resizedFile = await resizeImage(file, 128, 128);

      console.log(file);
      console.log(resizedFile);

      await uploadFileUsingSignedPutRequestApiMethod(resizedFile, responseFromApiServerForUpload.signedRequest, {
        "Cache-Control": "max-age=2592000",
      });

      this.setState({
        newAvatarUrl: responseFromApiServerForUpload.url,
      });

      await updateProfileApiMethod({
        name: this.state.newName,
        avatarUrl: this.state.newAvatarUrl,
      });

      notify("You successfully uploaded new avatar.");
    } catch (error) {
      notify(error);
    } finally {
      fileElement.value = "";
      this.setState({ disabled: false });
      NProgress.done();
    }
  };
}

export default YourSettings;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\pages\_app.tsx -----

import CssBaseline from "@mui/material/CssBaseline";
import { ThemeProvider } from "@mui/material";
import App from "next/app";
import Head from "next/head";
import React from "react";
import { isMobile } from "../lib/isMobile";
import { themeDark, themeLight } from "../lib/theme";

class MyApp extends App {
  public static async getInitialProps({ Component, ctx }) {
    const pageProps = { isMobile: isMobile({ req: ctx.req }), firstGridItem: true };

    if (Component.getInitialProps) {
      Object.assign(pageProps, await Component.getInitialProps(ctx));
    }

    // console.log(pageProps);

    return { pageProps };
  }

  public componentDidMount() {
    // Remove the server-side injected CSS.
    const jssStyles = document.querySelector("#jss-server-side");
    if (jssStyles && jssStyles.parentNode) {
      jssStyles.parentNode.removeChild(jssStyles);
    }
  }
  public render() {
    const { Component, pageProps } = this.props;

    return (
      <ThemeProvider theme={false ? themeDark : themeLight}>
        <Head>
          <meta name="viewport" content="width=device-width, initial-scale=1.0" />
          <link rel="stylesheet" href="https://storage.googleapis.com/async-await/nprogress-dark.min.css?v=1" />
        </Head>
        <CssBaseline />
        <Component {...pageProps} />
      </ThemeProvider>
    );
  }
}

export default MyApp;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\pages\_document.tsx -----

import Document, { Head, Html, Main, NextScript } from "next/document";
import React from "react";

class MyDocument extends Document {
  public static getInitialProps = async (ctx) => {
    const initialProps = await Document.getInitialProps(ctx);

    return {
      ...initialProps,
    };
  };

  public render() {
    // console.log('rendered on the server');

    return (
      <Html lang="en">
        <Head>
          <meta charSet="utf-8" />
          <meta name="google" content="notranslate" />
          <meta name="theme-color" content="#303030" />

          <link rel="shortcut icon" href="https://storage.googleapis.com/async-await/async-favicon32.png" />

          <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons" />
          <link rel="stylesheet" href="https://storage.googleapis.com/async-await/vs2015.min.css" />

          <style>
            {`
              #__next {
                width: 100%;
                height: 100%;
              }
              a {
                font-weight: 400;
                color: #58a6ff;
                text-decoration: none;
                outline: none;
              }
              hr {
                border: 0.5px #707070 solid;
                color: #000;
              }
              blockquote {
                padding: 0 0.5em;
                margin: 20px 1em;
                border-left: 0.25em solid #dfe2e5;
                color: #000;
              }
              pre {
                display: block;
                overflow-x: auto;
                padding: 0.5em;
                background: #d0d0d0;
                border: 1px solid #ddd;
                font-size: 14px;
                color: #000;
              }
              pre code {
                font-size: 13px;
                background: #d0d0d0;
                padding: 0px;
                color: #000;
              }
              code {
                font-size: 13px;
                background: #d0d0d0;
                padding: 3px 5px;
                color: #000;
              }
              mark {
                background-color: #ffff0060;
              }
              summary:focus {
                outline: none;
              }
              table {
                border-collapse: collapse;
                margin: 15px 0px;
              }
              table, th, td {
                border: 1px solid #a1a1a1;
              }
              th, td {
                line-height: 1.5em;
                padding: 10px;
              }
            `}
          </style>
        </Head>
        <body>
          <Main />
          <NextScript />
        </body>
      </Html>
    );
  }
}

export default MyDocument;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\server\server.ts -----

import express from 'express';
import next from 'next';

const NODE_ENV = process.env.NODE_ENV || 'development';
const IS_DEV = NODE_ENV !== 'production';

const app = next({ dev: IS_DEV });
const handle = app.getRequestHandler();

app.prepare().then(() => {
  const server = express();

  // give all Nextjs's request to Nextjs before anything else
  server.get('/_next/*', (req, res) => {
    // console.log('next server, page');
    handle(req, res);
  });

  server.use(express.json());

  // server.get('/api/v1/public/get-user', (_, res) => {
  //   res.json({ user: { email: 'team@builderbook.org' } });
  // });

  server.all('*', (req, res) => {
    handle(req, res);
  });

  server.listen(process.env.NEXT_PUBLIC_PORT_APP, () => {
    console.log(`> Ready on ${process.env.NEXT_PUBLIC_URL_APP}`);
  });
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\.eslintrc.js -----

module.exports = {
  settings: {
    react: { version: 'detect' },
  },
  parser: '@typescript-eslint/parser',
  extends: ['plugin:react/recommended', 'plugin:@typescript-eslint/recommended', 'prettier'],
  env: {
    es6: true,
    node: true,
  },
  plugins: ['prettier', 'react'],
  rules: {
    'prettier/prettier': [
      'error',
      {
        singleQuote: true,
        trailingComma: 'all',
        arrowParens: 'always',
        printWidth: 100,
        semi: true,
      },
    ],
    '@typescript-eslint/camelcase': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    'react/no-unescaped-entities': 'off',
    'react/jsx-filename-extension': ['error', { extensions: ['.tsx'] }],
    '@typescript-eslint/no-explicit-any': 'off',
    'prefer-arrow-callback': 'error',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
  },
};

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\next-env.d.ts -----

/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/pages/api-reference/config/typescript for more information.

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\next.config.js -----

module.exports = {
  poweredByHeader: false,
  webpack5: true,
  typescript: {
    ignoreBuildErrors: true,
  },
};

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\nodemon.json -----

{
  "watch": ["server"],
  "exec": "ts-node --project tsconfig.server.json",
  "ext": "ts"
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\package.json -----

{
  "name": "5-begin-app",
  "version": "1",
  "license": "MIT",
  "scripts": {
    "dev": "nodemon server/server.ts",
    "build": "next build",
    "lint": "eslint . --ext .ts,.tsx"
  },
  "dependencies": {
    "@emotion/react": "^11.14.0",
    "@emotion/styled": "^11.14.0",
    "@mui/material": "^6.4.8",
    "@mui/system": "^6.4.8",
    "dotenv": "^16.4.7",
    "express": "^4.21.2",
    "isomorphic-unfetch": "^4.0.2",
    "next": "^15.2.3",
    "nprogress": "^0.2.0",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "typescript": "^5.8.2"
  },
  "devDependencies": {
    "@types/express": "^5.0.1",
    "@types/node": "^22.13.10",
    "@types/react": "^19.0.12",
    "@types/react-dom": "^19.0.4",
    "@typescript-eslint/eslint-plugin": "^8.27.0",
    "@typescript-eslint/parser": "^8.27.0",
    "eslint": "^9.22.0",
    "eslint-config-prettier": "^10.1.1",
    "eslint-plugin-prettier": "^5.2.3",
    "eslint-plugin-react": "^7.37.4",
    "nodemon": "^3.1.9",
    "prettier": "^3.5.3",
    "ts-node": "^10.9.2"
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\tsconfig.json -----

{
  "compileOnSave": false,
  "compilerOptions": {
    "target": "esnext",
    "module": "esnext",
    "jsx": "preserve",
    "allowJs": true,
    "alwaysStrict": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "removeComments": true,
    "preserveConstEnums": true,
    "sourceMap": false,
    "skipLibCheck": true,
    "baseUrl": ".",
    "typeRoots": [
      "./node_modules/@types"
    ],
    "lib": [
      "dom",
      "es2017"
    ],
    "strict": false,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "incremental": true
  },
  "include": [
    "next-env.d.ts",
    "./**/*.tsx",
    "./**/*.ts"
  ],
  "exclude": [
    "dist",
    "production-server",
    ".next",
    "out",
    "next.config.js",
    "node_modules"
  ]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-begin\app\tsconfig.server.json -----

{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "module": "commonjs",
    "outDir": "production-server/",
    "target": "es2017",
    "isolatedModules": false,
    "noEmit": false
  },
  "exclude": ["./server/types.d.ts"],
  "include": ["./server/**/*.ts"],
  "typeRoots": ["./node_modules/@types", "./server/types.d.ts"]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\api\server\api\index.ts -----

import * as express from 'express';

import publicExpressRoutes from './public';
import teamMemberExpressRoutes from './team-member';

function handleError(err, _, res, __) {
  console.error(err.stack);

  res.json({ error: err.message || err.toString() });
}

export default function api(server: express.Express) {
  server.use('/api/v1/public', publicExpressRoutes, handleError);
  server.use('/api/v1/team-member', teamMemberExpressRoutes, handleError);
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\api\server\api\public.ts -----

import * as express from 'express';

import User from '../models/User';

const router = express.Router();

router.get('/get-user', (req, res) => {
  console.log(req.user);
  res.json({ user: req.user || null });
});

router.post('/get-user-by-slug', async (req, res, next) => {
  console.log('Express route: /get-user-by-slug');

  // req.session.foo = 'bar';

  try {
    const { slug } = req.body;

    const user = await User.getUserBySlug({ slug });

    res.json({ user });
  } catch (err) {
    next(err);
  }
});

router.post('/user/update-profile', async (req: any, res, next) => {
  try {
    const { name, avatarUrl } = req.body;

    const updatedUser = await User.updateProfile({
      userId: req.user.id,
      name,
      avatarUrl,
    });

    res.json({ updatedUser });
  } catch (err) {
    next(err);
  }
});

export default router;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\api\server\api\team-member.ts -----

import * as express from 'express';

import { signRequestForUpload } from '../aws-s3';

const router = express.Router();

// Get signed request from AWS S3 server
router.post('/aws/get-signed-request-for-upload-to-s3', async (req, res, next) => {
  try {
    const { fileName, fileType, prefix, bucket } = req.body;

    const returnData = await signRequestForUpload({
      fileName,
      fileType,
      prefix,
      bucket,
    });

    console.log(returnData);

    res.json(returnData);
  } catch (err) {
    next(err);
  }
});

export default router;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\api\server\models\User.ts -----

import * as _ from 'lodash';
import * as mongoose from 'mongoose';

import { generateSlug } from '../utils/slugify';

const mongoSchema = new mongoose.Schema({
  slug: {
    type: String,
    required: true,
    unique: true,
  },
  createdAt: {
    type: Date,
    required: true,
  },
  email: {
    type: String,
    required: true,
    unique: true,
  },
  displayName: String,
  avatarUrl: String,
  googleId: {
    type: String,
    unique: true,
    sparse: true,
  },
  googleToken: {
    accessToken: String,
    refreshToken: String,
  },
  isSignedupViaGoogle: {
    type: Boolean,
    required: true,
    default: false,
  },
});

export interface UserDocument extends mongoose.Document {
  slug: string;
  createdAt: Date;
  email: string;
  displayName: string;
  avatarUrl: string;
  googleId: string;
  googleToken: { accessToken: string; refreshToken: string };
  isSignedupViaGoogle: boolean;
}

interface UserModel extends mongoose.Model<UserDocument> {
  getUserBySlug({ slug }: { slug: string }): Promise<UserDocument>;

  updateProfile({
    userId,
    name,
    avatarUrl,
  }: {
    userId: string;
    name: string;
    avatarUrl: string;
  }): Promise<UserDocument[]>;

  publicFields(): string[];

  signInOrSignUpViaGoogle({
    googleId,
    email,
    displayName,
    avatarUrl,
    googleToken,
  }: {
    googleId: string;
    email: string;
    displayName: string;
    avatarUrl: string;
    googleToken: { accessToken?: string; refreshToken?: string };
  }): Promise<UserDocument>;
}

class UserClass extends mongoose.Model {
  public static async getUserBySlug({ slug }) {
    console.log('Static method: getUserBySlug');

    return this.findOne({ slug }, 'email displayName avatarUrl').setOptions({ lean: true });
  }

  public static async updateProfile({ userId, name, avatarUrl }) {
    console.log('Static method: updateProfile');

    const user = await this.findById(userId, 'slug displayName');

    const modifier = { displayName: user.displayName, avatarUrl, slug: user.slug };

    console.log(user.slug);

    if (name !== user.displayName) {
      modifier.displayName = name;
      modifier.slug = await generateSlug(this, name);
    }

    return this.findByIdAndUpdate(userId, { $set: modifier }, { new: true, runValidators: true })
      .select('displayName avatarUrl slug')
      .setOptions({ lean: true });
  }

  public static publicFields(): string[] {
    return ['_id', 'id', 'displayName', 'email', 'avatarUrl', 'slug', 'isSignedupViaGoogle'];
  }

  public static async signInOrSignUpViaGoogle({
    googleId,
    email,
    displayName,
    avatarUrl,
    googleToken,
  }) {
    const user = await this.findOne({ email })
      .select([...this.publicFields(), 'googleId'].join(' '))
      .setOptions({ lean: true });

    if (user) {
      if (_.isEmpty(googleToken) && user.googleId) {
        return user;
      }

      const modifier = { googleId };
      if (googleToken.accessToken) {
        modifier['googleToken.accessToken'] = googleToken.accessToken;
      }

      if (googleToken.refreshToken) {
        modifier['googleToken.refreshToken'] = googleToken.refreshToken;
      }

      await this.updateOne({ email }, { $set: modifier });

      return user;
    }

    const slug = await generateSlug(this, displayName);

    const newUser = await this.create({
      createdAt: new Date(),
      googleId,
      email,
      googleToken,
      displayName,
      avatarUrl,
      slug,
      isSignedupViaGoogle: true,
      darkTheme: false,
    });

    return _.pick(newUser, this.publicFields());
  }
}

mongoSchema.loadClass(UserClass);

const User = mongoose.model<UserDocument, UserModel>('User', mongoSchema);

export default User;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\api\server\utils\slugify.ts -----

import * as _ from 'lodash';

const slugify = (text) => _.kebabCase(text);

async function createUniqueSlug(Model, slug, count, filter) {
  const obj = await Model.findOne({ slug: `${slug}-${count}`, ...filter })
    .select('_id')
    .setOptions({ lean: true });

  if (!obj) {
    return `${slug}-${count}`;
  }

  return createUniqueSlug(Model, slug, count + 1, filter);
}

async function generateSlug(Model, name, filter = {}) {
  const origSlug = slugify(name);

  const obj = await Model.findOne({ slug: origSlug, ...filter })
    .select('_id')
    .setOptions({ lean: true });

  if (!obj) {
    return origSlug;
  }

  return createUniqueSlug(Model, origSlug, 1, filter);
}

export { generateSlug };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\api\server\utils\sum.ts -----

function sum(a, b) {
  return a + b;
}

export { sum };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\api\server\aws-s3.ts -----

import * as url from 'url';
import * as aws from 'aws-sdk';

async function signRequestForUpload({ fileName, fileType, prefix, bucket }) {
  const randomStringForPrefix =
    Math.random().toString(36).substring(2, 12) + Math.random().toString(36).substring(2, 12);

  const key = `${prefix}/${randomStringForPrefix}/${fileName}`;

  const acl = 'public-read';

  const params = {
    Bucket: bucket,
    Key: key,
    Expires: 60,
    ContentType: fileType,
    ACL: acl,
  };

  console.log(prefix);

  const s3 = new aws.S3({
    apiVersion: 'latest',
    region: process.env.AWS_REGION,
    accessKeyId: process.env.AWS_ACCESSKEYID,
    secretAccessKey: process.env.AWS_SECRETACCESSKEY,
  });

  return new Promise((resolve, reject) => {
    s3.getSignedUrl('putObject', params, (err, data) => {
      const parsedUrl = url.parse(data);

      const returnData = {
        signedRequest: data,
        url: `${parsedUrl.protocol}//${parsedUrl.hostname}${parsedUrl.pathname}`,
      };

      if (err) {
        console.error(err);
        reject(err);
      } else {
        resolve(returnData);
      }
    });
  });
}

export { signRequestForUpload };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\api\server\google-auth.ts -----

import * as passport from 'passport';
import { OAuth2Strategy as Strategy } from 'passport-google-oauth';

import User, { UserDocument } from './models/User';

function setupGoogle({ server }) {
  if (!process.env.GOOGLE_CLIENTID) {
    return;
  }

  const verify = async (accessToken, refreshToken, profile, done) => {
    let email;
    let avatarUrl;

    if (profile.emails) {
      email = profile.emails[0].value;
    }

    if (profile.photos && profile.photos.length > 0) {
      avatarUrl = profile.photos[0].value.replace('sz=50', 'sz=128');
    }

    try {
      const user = await User.signInOrSignUpViaGoogle({
        googleId: profile.id,
        email,
        googleToken: { accessToken, refreshToken },
        displayName: profile.displayName,
        avatarUrl,
      });

      done(null, user);
    } catch (err) {
      done(err);
      console.error(err);
    }
  };

  passport.use(
    new Strategy(
      {
        clientID: process.env.GOOGLE_CLIENTID,
        clientSecret: process.env.GOOGLE_CLIENTSECRET,
        callbackURL: `${process.env.URL_API}/oauth2callback`,
      },
      verify,
    ),
  );

  passport.serializeUser((user: UserDocument, done) => {
    done(null, user._id);
  });

  passport.deserializeUser((id, done) => {
    User.findById(id, User.publicFields())
      .then((user) => {
        done(null, user);
      })
      .catch((error) => {
        done(error, null);
      });
  });

  server.use(passport.initialize());
  server.use(passport.session());

  server.get('/auth/google', (req, res, next) => {
    const options = {
      scope: ['profile', 'email'],
      prompt: 'select_account',
    };

    passport.authenticate('google', options)(req, res, next);

    console.log('/auth/google');
  });

  server.get(
    '/oauth2callback',
    passport.authenticate('google', {
      failureRedirect: '/login',
    }),
    (_, res) => {
      console.log('/oauth2callback');
      res.redirect(`${process.env.URL_APP}/your-settings`);
    },
  );

  server.get('/logout', (req, res, next) => {
    req.logout((err) => {
      if (err) {
        next(err);
      }
      res.redirect(`${process.env.URL_APP}/login`);
    });
  });
}

export { setupGoogle };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\api\server\server.ts -----

// eslint-disable-next-line @typescript-eslint/no-var-requires
const MongoStore = require('connect-mongo');

import * as cors from 'cors';
import * as express from 'express';
import * as session from 'express-session';
import * as mongoose from 'mongoose';

import api from './api';
import { setupGoogle } from './google-auth';

// eslint-disable-next-line
require('dotenv').config();

mongoose.connect(process.env.MONGO_URL_TEST);

const server = express();

server.use(
  cors({
    origin: process.env.URL_APP,
    methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',
    credentials: true,
  }),
);

server.use(express.json());

const sessionOptions = {
  name: process.env.SESSION_NAME,
  secret: process.env.SESSION_SECRET,
  resave: false,
  saveUninitialized: false,
  store: MongoStore.create({
    mongoUrl: process.env.MONGO_URL_TEST,
    ttl: 14 * 24 * 60 * 60, // save session 14 days
    autoRemove: 'interval',
    autoRemoveInterval: 1440, // clears every day
  }),
  cookie: {
    httpOnly: true,
    maxAge: 14 * 24 * 60 * 60 * 1000, // expires in 14 days
    secure: false,
  },
};

const sessionMiddleware = session(sessionOptions);
server.use(sessionMiddleware);

setupGoogle({ server });

api(server);

server.get('*', (_, res) => {
  res.sendStatus(403);
});

server.listen(process.env.PORT_API, () => {
  console.log(`> Ready on ${process.env.URL_API}`);
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\api\test\server\utils\slugify.test.ts -----

import * as mongoose from 'mongoose';
import User from '../../../server/models/User';
import { generateSlug } from '../../../server/utils/slugify';

// eslint-disable-next-line
require('dotenv').config();

describe('slugify', () => {
  beforeAll(async () => {
    await mongoose.connect(process.env.MONGO_URL_TEST);

    const mockUsers = [
      {
        slug: 'john',
        email: 'john@example.com',
        createdAt: new Date(),
        displayName: 'abc',
        avatarUrl: 'def',
      },
      {
        slug: 'john-johnson',
        email: 'john-johnson@example.com',
        createdAt: new Date(),
        displayName: 'abc',
        avatarUrl: 'def',
      },
      {
        slug: 'john-johnson-1',
        email: 'john-johnson-1@example.com',
        createdAt: new Date(),
        displayName: 'abc',
        avatarUrl: 'def',
      },
    ];

    await User.insertMany(mockUsers);
  });

  test('not duplicated', async () => {
    expect.assertions(1);

    await expect(generateSlug(User, 'John J Johnson@#$')).resolves.toEqual('john-j-johnson');
  });

  test('one time duplicated', async () => {
    expect.assertions(1);

    await expect(generateSlug(User, ' John@#$')).resolves.toEqual('john-1');
  });

  test('multiple duplicated', async () => {
    expect.assertions(1);

    await expect(generateSlug(User, 'John & Johnson@#$')).resolves.toEqual('john-johnson-2');
  });

  afterAll(async () => {
    await User.deleteMany({ slug: { $in: ['john', 'john-johnson', 'john-johnson-1'] } });
    await mongoose.disconnect();
  });
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\api\test\server\utils\sum.test.ts -----

import { sum } from '../../../server/utils/sum';

console.log(sum(1, 2));

describe.skip('testing sum function', () => {
  test('adds 1 + 2 to equal 3', () => {
    expect(sum(1, 2)).toBe(3);
  });
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\api\.eslintrc.js -----

module.exports = {
  parser: "@typescript-eslint/parser",
  extends: ["plugin:@typescript-eslint/recommended", "prettier"],
  env: {
    "es6": true,
    "node": true,
  },
  plugins: ["prettier"],
  rules: {
    'prettier/prettier': [
      'error',
      {
        singleQuote: true,
        trailingComma: 'all',
        arrowParens: 'always',
        printWidth: 100,
        semi: true,
      },
    ],
    '@typescript-eslint/no-unused-vars': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/no-explicit-any': 'off',
    'prefer-arrow-callback': 'error',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
 },
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\api\nodemon.json -----

{
  "watch": ["server"],
  "exec": "ts-node --project tsconfig.server.json",
  "ext": "ts"
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\api\package.json -----

{
  "name": "5-end-api",
  "version": "1",
  "license": "MIT",
  "scripts": {
    "dev": "nodemon server/server.ts",
    "lint": "eslint . --ext .ts,.tsx",
    "test": "jest"
  },
  "jest": {
    "preset": "ts-jest",
    "testPathIgnorePatterns": [
      "production-server"
    ],
    "testEnvironment": "node"
  },
  "dependencies": {
    "aws-sdk": "^2.1692.0",
    "connect-mongo": "^5.1.0",
    "cors": "^2.8.5",
    "dotenv": "^16.4.7",
    "express": "^4.21.2",
    "express-session": "^1.18.1",
    "lodash": "^4.17.21",
    "mongoose": "^8.12.1",
    "passport": "^0.7.0",
    "passport-google-oauth": "^2.0.0",
    "typescript": "^5.8.2"
  },
  "devDependencies": {
    "@types/connect-mongo": "^3.1.6",
    "@types/dotenv": "^8.2.3",
    "@types/express": "^5.0.1",
    "@types/express-session": "^1.18.1",
    "@types/jest": "^29.5.14",
    "@types/lodash": "^4.17.16",
    "@types/mongoose": "^5.11.97",
    "@types/node": "^22.13.10",
    "@types/passport": "^1.0.17",
    "@typescript-eslint/eslint-plugin": "^8.27.0",
    "@typescript-eslint/parser": "^8.27.0",
    "eslint": "^9.22.0",
    "eslint-config-prettier": "^10.1.1",
    "eslint-plugin-prettier": "^5.2.3",
    "jest": "^29.7.0",
    "nodemon": "^3.1.9",
    "prettier": "^3.5.3",
    "ts-jest": "^29.2.6",
    "ts-node": "^10.9.2"
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\api\tsconfig.json -----

{
  "compileOnSave": false,
  "compilerOptions": {
    "jsx": "preserve",
    "allowJs": true,
    "alwaysStrict": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "removeComments": false,
    "preserveConstEnums": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "sourceMap": true,
    "skipLibCheck": true,
    "baseUrl": ".",
    "experimentalDecorators": true,
    "typeRoots": ["./node_modules/@types"],
    "lib": ["es2015", "es2016"]
  },
  "exclude": ["production-server", "node_modules"]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\api\tsconfig.server.json -----

{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "module": "commonjs",
    "outDir": "production-server/"
  },
  "include": ["./server/**/*.ts"],
  "exclude": ["./server/**/*.test.ts"]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\components\common\Confirmer.tsx -----

import Button from "@mui/material/Button";
import Dialog from "@mui/material/Dialog";
import DialogActions from "@mui/material/DialogActions";
import DialogContent from "@mui/material/DialogContent";
import DialogContentText from "@mui/material/DialogContentText";
import DialogTitle from "@mui/material/DialogTitle";
import React from "react";

export let openConfirmDialogExternal;

type State = {
  open: boolean;
  title: string;
  message: string;
  onAnswer: (answer) => void;
};

class Confirmer extends React.Component<any, State> {
  constructor(props) {
    super(props);

    this.state = {
      open: false,
      title: "Are you sure?",
      message: "",
      onAnswer: null,
    };

    openConfirmDialogExternal = this.openConfirmDialog;
  }

  public render() {
    return (
      <Dialog
        open={this.state.open}
        onClose={this.handleClose}
        aria-labelledby="alert-dialog-title"
        aria-describedby="alert-dialog-description"
      >
        <DialogTitle id="alert-dialog-title">{this.state.title}</DialogTitle>
        <DialogContent>
          <DialogContentText id="alert-dialog-description">{this.state.message}</DialogContentText>
        </DialogContent>
        <DialogActions style={{ padding: "10px" }}>
          <Button onClick={this.handleClose} variant="contained" color="primary" autoFocus>
            Cancel
          </Button>
          <Button onClick={this.handleYes} variant="contained" color="secondary">
            OK
          </Button>
        </DialogActions>
      </Dialog>
    );
  }

  public handleClose = () => {
    this.setState({ open: false });
    this.state.onAnswer(false);
  };

  public handleYes = () => {
    this.setState({ open: false });
    this.state.onAnswer(true);
  };

  public openConfirmDialog = ({ title, message, onAnswer }) => {
    this.setState({ open: true, title, message, onAnswer });
  };
}

export default Confirmer;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\components\common\LoginButton.tsx -----

import Button from "@mui/material/Button";
import React from "react";

class LoginButton extends React.PureComponent {
  public render() {
    const url = `${process.env.NEXT_PUBLIC_URL_API}/auth/google`;

    console.log(url);

    return (
      <React.Fragment>
        <Button variant="contained" color="secondary" href={url}>
          <img src="https://storage.googleapis.com/async-await-all/G.svg" alt="Log in with Google" />
          &nbsp;&nbsp;&nbsp; Log in with Google
        </Button>
        <p />
        <br />
      </React.Fragment>
    );
  }
}

export default LoginButton;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\components\common\MenuWithLinks.tsx -----

import Menu from "@mui/material/Menu";
import MenuItem from "@mui/material/MenuItem";
import Link from "next/link";
import { NextRouter, withRouter } from "next/router";
import React from "react";

type Props = {
  options: {
    href: string;
    as: string;
    highlighterSlug: string;
    text: string;
    externalServer: boolean;
    separator: boolean;
  }[];
  router: NextRouter;
  children: any;
};

type State = {
  anchorEl: Element | ((element: Element) => Element);
};

class MenuWithLinks extends React.PureComponent<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      anchorEl: null,
    };
  }

  public render() {
    const { options, children, router } = this.props;
    const { anchorEl } = this.state;

    return (
      <div style={{ textAlign: "center" }}>
        <div
          aria-controls={anchorEl ? "simple-menu" : null}
          aria-haspopup="true"
          onClick={this.handleClick}
          onKeyPress={this.handleClick}
        >
          {children}
        </div>
        <Menu id="simple-menu" anchorEl={anchorEl} open={Boolean(anchorEl)} onClose={this.handleClose} keepMounted>
          {options.map((option, i) =>
            option.separator ? (
              <hr style={{ width: "95%", margin: "10px auto" }} key={`separated-${i}`} />
            ) : option.externalServer ? (
              <MenuItem
                onClick={(event) => {
                  event.preventDefault();
                  window.location.href = option.href;
                  this.handleClose();
                }}
                key={option.href || option.text}
              >
                {option.text}
              </MenuItem>
            ) : (
              <Link key={option.href} href={option.href} as={option.as} passHref>
                <MenuItem
                  key={option.href}
                  style={{
                    fontWeight: router.asPath.includes(option.highlighterSlug) ? 600 : 300,
                    fontSize: "14px",
                  }}
                >
                  {option.text}
                </MenuItem>
              </Link>
            )
          )}
        </Menu>
      </div>
    );
  }

  public handleClick = (event) => {
    this.setState({ anchorEl: event.currentTarget });
  };

  public handleClose = () => {
    this.setState({ anchorEl: null });
  };
}

export default withRouter(MenuWithLinks);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\components\common\Notifier.tsx -----

import Snackbar from "@mui/material/Snackbar";
import React from "react";

export let openSnackbarExternal;

type State = {
  open: boolean;
  message: string;
};

class Notifier extends React.PureComponent<any, State> {
  constructor(props) {
    super(props);
    openSnackbarExternal = this.openSnackbar;

    this.state = {
      open: false,
      message: "",
    };
  }

  public render() {
    const message = <span id="snackbar-message-id" dangerouslySetInnerHTML={{ __html: this.state.message }} />;

    return (
      <Snackbar
        anchorOrigin={{ vertical: "top", horizontal: "right" }}
        message={message}
        autoHideDuration={5000}
        onClose={this.handleSnackbarClose}
        open={this.state.open}
        ContentProps={{
          "aria-describedby": "snackbar-message-id",
        }}
      />
    );
  }

  public handleSnackbarClose = () => {
    this.setState({
      open: false,
      message: "",
    });
  };

  public openSnackbar = ({ message }) => {
    this.setState({ open: true, message });
  };
}

export default Notifier;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\components\layout\index.tsx -----

import Avatar from "@mui/material/Avatar";
import Grid from "@mui/material/Grid";
import React from "react";
import MenuWithLinks from "../common/MenuWithLinks";
import Confirmer from "../common/Confirmer";
import Notifier from "../common/Notifier";

const styleGrid = {
  width: "100%",
  height: "100vh",
  maxWidth: "100%",
  padding: "0px 10px",
  display: "flex",
  overflow: "hidden",
};

const styleGridIsMobile = {
  width: "100%",
  height: "100vh",
  maxWidth: "100%",
  padding: "0px 0px 0px 10px",
  display: "flex",
  overflow: "hidden",
};

type Props = {
  children: React.ReactNode;
  firstGridItem?: boolean;
  isMobile?: boolean;
};

class Layout extends React.Component<Props> {
  public render() {
    const { children, firstGridItem, isMobile } = this.props;

    const isThemeDark = false;

    // console.log(isMobile);

    return (
      <Grid
        container
        direction="row"
        justify="flex-start"
        alignItems="stretch"
        style={isMobile ? styleGridIsMobile : styleGrid}
      >
        {firstGridItem ? (
          <Grid
            item
            sm={2}
            xs={12}
            style={{
              borderRight: "1px #707070 solid",
              justifyContent: "center",
              overflow: "hidden",
            }}
          >
            <div style={{ display: "flex", justifyContent: "space-between" }}>
              <svg
                xmlns="http://www.w3.org/2000/svg"
                width="124"
                height="40"
                viewBox="0 0 124 40"
                style={{
                  marginTop: "20px",
                  display: "inline-flex",
                  height: "40px",
                }}
              >
                <g id="async-logo">
                  <g id="async-logo-40">
                    <circle id="Ellipse 2" cx="20" cy="20" r="20" fill="black" />
                    <path
                      id="path-async-logo"
                      d="M7.07825 -0.0960007V16H4.51825V13.088C4.04892 14.0907 3.33425 14.8693 2.37425 15.424C1.43558 15.9573 0.336917 16.224 -0.92175 16.224C-2.35108 16.224 -3.60975 15.8827 -4.69775 15.2C-5.76442 14.5173 -6.59642 13.5573 -7.19375 12.32C-7.76975 11.0613 -8.05775 9.6 -8.05775 7.936C-8.05775 6.272 -7.75908 4.81067 -7.16175 3.552C-6.56442 2.272 -5.73242 1.28 -4.66575 0.576C-3.57775 -0.128 -2.32975 -0.48 -0.92175 -0.48C0.336917 -0.48 1.43558 -0.202666 2.37425 0.352C3.31292 0.906667 4.02758 1.68533 4.51825 2.688V-0.0960007H7.07825ZM-0.40975 14.08C1.16892 14.08 2.38492 13.5467 3.23825 12.48C4.09158 11.392 4.51825 9.856 4.51825 7.872C4.51825 5.888 4.09158 4.36267 3.23825 3.296C2.38492 2.22933 1.16892 1.696 -0.40975 1.696C-1.98842 1.696 -3.22575 2.25067 -4.12175 3.36C-4.99642 4.448 -5.43375 5.97333 -5.43375 7.936C-5.43375 9.89867 -4.99642 11.4133 -4.12175 12.48C-3.24708 13.5467 -2.00975 14.08 -0.40975 14.08Z"
                      transform="translate(19.5938 12)"
                      fill="white"
                    />
                  </g>
                  <path
                    id="path-async-text"
                    d="M22.6251 11.928V24H20.7051V21.816C20.3531 22.568 19.8171 23.152 19.0971 23.568C18.3931 23.968 17.5691 24.168 16.6251 24.168C15.5531 24.168 14.6091 23.912 13.7931 23.4C12.9931 22.888 12.3691 22.168 11.9211 21.24C11.4891 20.296 11.2731 19.2 11.2731 17.952C11.2731 16.704 11.4971 15.608 11.9451 14.664C12.3931 13.704 13.0171 12.96 13.8171 12.432C14.6331 11.904 15.5691 11.64 16.6251 11.64C17.5691 11.64 18.3931 11.848 19.0971 12.264C19.8011 12.68 20.3371 13.264 20.7051 14.016V11.928H22.6251ZM17.0091 22.56C18.1931 22.56 19.1051 22.16 19.7451 21.36C20.3851 20.544 20.7051 19.392 20.7051 17.904C20.7051 16.416 20.3851 15.272 19.7451 14.472C19.1051 13.672 18.1931 13.272 17.0091 13.272C15.8251 13.272 14.8971 13.688 14.2251 14.52C13.5691 15.336 13.2411 16.48 13.2411 17.952C13.2411 19.424 13.5691 20.56 14.2251 21.36C14.8811 22.16 15.8091 22.56 17.0091 22.56ZM30.4637 24.168C28.4317 24.168 26.8237 23.648 25.6397 22.608L26.2877 21.168C26.9437 21.68 27.6077 22.048 28.2797 22.272C28.9517 22.496 29.7037 22.608 30.5357 22.608C31.4477 22.608 32.1357 22.456 32.5997 22.152C33.0797 21.832 33.3197 21.376 33.3197 20.784C33.3197 20.304 33.1597 19.92 32.8397 19.632C32.5197 19.344 31.9917 19.12 31.2557 18.96L29.2157 18.48C28.2077 18.256 27.4237 17.856 26.8637 17.28C26.3197 16.704 26.0477 16.016 26.0477 15.216C26.0477 14.16 26.4717 13.304 27.3197 12.648C28.1677 11.976 29.2877 11.64 30.6797 11.64C31.5277 11.64 32.3277 11.776 33.0797 12.048C33.8317 12.32 34.4637 12.712 34.9757 13.224L34.3277 14.64C33.1917 13.696 31.9757 13.224 30.6797 13.224C29.8157 13.224 29.1437 13.392 28.6637 13.728C28.1997 14.048 27.9677 14.504 27.9677 15.096C27.9677 15.592 28.1117 15.984 28.3997 16.272C28.7037 16.56 29.1837 16.784 29.8397 16.944L31.8797 17.448C32.9997 17.704 33.8317 18.104 34.3757 18.648C34.9197 19.176 35.1917 19.872 35.1917 20.736C35.1917 21.776 34.7677 22.608 33.9197 23.232C33.0717 23.856 31.9197 24.168 30.4637 24.168ZM48.687 11.928L43.047 25.104C42.455 26.48 41.711 27.488 40.815 28.128C39.919 28.768 38.815 29.208 37.503 29.448L37.095 27.936C38.231 27.68 39.087 27.336 39.663 26.904C40.255 26.488 40.743 25.84 41.127 24.96L41.607 23.88L36.495 11.928H38.535L42.615 21.888L46.743 11.928H48.687ZM56.853 11.64C59.749 11.64 61.197 13.232 61.197 16.416V24H59.253V16.512C59.253 15.392 59.029 14.576 58.581 14.064C58.133 13.536 57.429 13.272 56.469 13.272C55.349 13.272 54.453 13.616 53.781 14.304C53.109 14.992 52.773 15.92 52.773 17.088V24H50.829V15.312C50.829 14.064 50.765 12.936 50.637 11.928H52.485L52.677 14.088C53.045 13.304 53.597 12.704 54.333 12.288C55.069 11.856 55.909 11.64 56.853 11.64ZM69.9321 24.168C68.7641 24.168 67.7401 23.912 66.8601 23.4C65.9961 22.888 65.3241 22.168 64.8441 21.24C64.3801 20.296 64.1481 19.2 64.1481 17.952C64.1481 16.704 64.3881 15.608 64.8681 14.664C65.3481 13.704 66.0281 12.96 66.9081 12.432C67.8041 11.904 68.8441 11.64 70.0281 11.64C70.8441 11.64 71.6281 11.784 72.3801 12.072C73.1481 12.344 73.7801 12.728 74.2761 13.224L73.6281 14.664C73.0201 14.184 72.4281 13.832 71.8521 13.608C71.2921 13.384 70.7161 13.272 70.1241 13.272C68.8921 13.272 67.9241 13.688 67.2201 14.52C66.5161 15.336 66.1641 16.48 66.1641 17.952C66.1641 19.408 66.5081 20.544 67.1961 21.36C67.9001 22.16 68.8761 22.56 70.1241 22.56C70.7161 22.56 71.2921 22.448 71.8521 22.224C72.4281 22 73.0201 21.648 73.6281 21.168L74.2761 22.608C73.7641 23.088 73.1161 23.472 72.3321 23.76C71.5641 24.032 70.7641 24.168 69.9321 24.168Z"
                    transform="translate(39 4)"
                    fill={isThemeDark ? "white" : "black"}
                  />
                </g>
              </svg>
              <MenuWithLinks
                options={[
                  {
                    text: "Index page",
                    href: "/",
                    highlighterSlug: "/",
                  },
                  {
                    text: "Your Settings",
                    href: "/your-settings",
                    highlighterSlug: "/your-settings",
                  },
                  {
                    separator: true,
                  },
                  {
                    text: "Log out",
                    href: `${process.env.NEXT_PUBLIC_URL_API}/logout`,
                    as: `${process.env.NEXT_PUBLIC_URL_API}/logout`,
                    externalServer: true,
                  },
                ]}
              >
                <Avatar
                  src={"https://storage.googleapis.com/async-await/default-user.png"}
                  alt="Add username here later in the book"
                  style={{
                    margin: "20px auto",
                    cursor: "pointer",
                    display: "inline-flex",
                    width: "40px",
                    height: "40px",
                  }}
                />

                <i className="material-icons" color="action" style={{ verticalAlign: "super" }}>
                  arrow_drop_down
                </i>
              </MenuWithLinks>
            </div>
            <hr />
            <p />
            <p />
          </Grid>
        ) : null}
        <Grid item sm={firstGridItem ? 10 : 12} xs={12}>
          {isMobile ? <hr /> : null}
          {children}
        </Grid>
        <Notifier />
        <Confirmer />
      </Grid>
    );
  }
}

export default Layout;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\lib\api\public.ts -----

import sendRequestAndGetResponse from './sendRequestAndGetResponse';

const BASE_PATH = '/api/v1/public';

export const getUserApiMethod = (request) =>
  sendRequestAndGetResponse(`${BASE_PATH}/get-user`, {
    request,
    method: 'GET',
  });

export const getUserBySlugApiMethod = (slug) =>
  sendRequestAndGetResponse(`${BASE_PATH}/get-user-by-slug`, {
    body: JSON.stringify({ slug }),
  });

export const updateProfileApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/user/update-profile`, {
    body: JSON.stringify(data),
  });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\lib\api\sendRequestAndGetResponse.ts -----

import 'isomorphic-unfetch';

export default async function sendRequestAndGetResponse(path, opts: any = {}) {
  const headers = Object.assign(
    {},
    opts.headers || {},
    opts.externalServer
      ? {}
      : {
          'Content-type': 'application/json; charset=UTF-8',
        },
  );

  const { request } = opts;

  if (request && request.headers && request.headers.cookie) {
    headers.cookie = request.headers.cookie;
  }

  const qs = opts.qs || '';

  // console.log(`before: ${process.env.NEXT_PUBLIC_URL_API}${path}${qs}`);

  const response = await fetch(
    opts.externalServer ? `${path}${qs}` : `${process.env.NEXT_PUBLIC_URL_API}${path}${qs}`,
    Object.assign({ method: 'POST', credentials: 'include' }, opts, { headers }),
  );

  // console.log(`after: ${process.env.NEXT_PUBLIC_URL_API}${path}${qs}`);

  // console.log(response.status);
  // console.log(response.statusText);

  const text = await response.text();

  if (response.status >= 400) {
    console.error(text);
    throw new Error(response.status.toString());
  }

  try {
    const data = JSON.parse(text);

    return data;
  } catch (err) {
    if (err instanceof SyntaxError) {
      return text;
    }

    throw err;
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\lib\api\team-member.ts -----

import sendRequestAndGetResponse from './sendRequestAndGetResponse';

const BASE_PATH = '/api/v1/team-member';

export const getSignedRequestForUploadApiMethod = ({ fileName, fileType, prefix, bucket }) =>
  sendRequestAndGetResponse(`${BASE_PATH}/aws/get-signed-request-for-upload-to-s3`, {
    body: JSON.stringify({ fileName, fileType, prefix, bucket }),
  });

export const uploadFileUsingSignedPutRequestApiMethod = (file, signedRequest, headers = {}) =>
  sendRequestAndGetResponse(signedRequest, {
    externalServer: true,
    method: 'PUT',
    body: file,
    headers,
  });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\lib\confirm.ts -----

import { openConfirmDialogExternal } from '../components/common/Confirmer';

export default function confirm({
  title,
  message,
  onAnswer,
}: {
  title: string;
  message: string;
  onAnswer: (answer) => void;
}) {
  openConfirmDialogExternal({ title, message, onAnswer });
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\lib\isMobile.ts -----

const mobileRE = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i;

export function isMobile(opts) {
  if (!opts) {
    opts = {};
  }

  let ua = opts.ua;

  if (!ua && typeof navigator !== 'undefined') {
    ua = navigator.userAgent;
  }

  if (!ua && opts.req && opts.req.headers && typeof opts.req.headers['user-agent'] === 'string') {
    ua = opts.req.headers['user-agent'];
    // console.log(ua);
  }

  if (typeof ua !== 'string') {
    return false;
  }

  return mobileRE.test(ua);
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\lib\notify.ts -----

import { openSnackbarExternal } from '../components/common/Notifier';

export default function notify(obj) {
  openSnackbarExternal({ message: obj.message || obj.toString() });
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\lib\resizeImage.ts -----

function resizeImage(file: File, MAX_WIDTH, MAX_HEIGHT) {
  const image = document.createElement('img');

  const resize = (resolve) => () => {
    let isResizeNeeded = false;
    let width = image.width;
    let height = image.height;

    if (width > height) {
      if (width > MAX_WIDTH) {
        isResizeNeeded = true;
        height *= MAX_WIDTH / width;
        width = MAX_WIDTH;
      }
    } else {
      if (height > MAX_HEIGHT) {
        isResizeNeeded = true;
        width *= MAX_HEIGHT / height;
        height = MAX_HEIGHT;
      }
    }

    if (isResizeNeeded) {
      const canvas = document.createElement('canvas');

      canvas.width = width;
      canvas.height = height;

      console.log(width, height);

      const ctx = canvas.getContext('2d');
      ctx.drawImage(image, 0, 0, width, height);

      canvas.toBlob((blob) => {
        resolve(blob);
      }, file.type);
    } else {
      resolve(file);
    }
  };

  return new Promise((resolve) => {
    const reader = new FileReader();

    console.log(`before ${image.src}`);

    reader.readAsDataURL(file);

    reader.onload = (e) => {
      image.src = e.target.result.toString();

      image.onload = resize(resolve);

      console.log(`after ${image.src}`);
    };
  });
}

export { resizeImage };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\lib\sharedStyles.ts -----

const styleBigAvatar = {
  width: '80px',
  height: '80px',
  margin: '0px auto 15px',
};

const styleRaisedButton = {
  margin: '15px',
  font: '14px Roboto',
};

const styleToolbar = {
  background: '#FFF',
  height: '64px',
  paddingRight: '20px',
};

const styleTextField = {
  font: '15px Roboto',
  color: '#222',
  fontWeight: '300',
};

const styleForm = {
  margin: '7% auto',
  width: '360px',
};

export { styleBigAvatar, styleRaisedButton, styleToolbar, styleTextField, styleForm };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\lib\theme.ts -----

import { createMuiTheme } from "@mui/material/styles";

const themeDark = createMuiTheme({
  palette: {
    primary: { main: "#238636" },
    secondary: { main: "#b62324" },
    type: "dark",
    background: { default: "#0d1117" },
    text: {
      primary: "#c9d1d9",
    },
  },
  typography: {
    button: {
      textTransform: "none",
    },
  },
});

const themeLight = createMuiTheme({
  palette: {
    primary: { main: "#238636" },
    secondary: { main: "#b62324" },
    type: "light",
    background: { default: "#fff" },
    text: {
      primary: "#222",
    },
  },
  typography: {
    button: {
      textTransform: "none",
    },
  },
});

export { themeDark, themeLight };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\lib\withAuth.tsx -----

import Router from 'next/router';
import React from 'react';

import * as NProgress from 'nprogress';

import { getUserApiMethod } from '../lib/api/public';

Router.events.on('routeChangeStart', () => {
  NProgress.start();
});

Router.events.on('routeChangeComplete', () => {
  NProgress.done();
});

Router.events.on('routeChangeError', () => NProgress.done());

type Props = {
  user: { email: string; displayName: string; slug: string; avatarUrl: string };
};

export default function withAuth(Component, { loginRequired = true, logoutRequired = false } = {}) {
  class WithAuth extends React.Component<Props> {
    public static async getInitialProps(ctx) {
      const { req, res } = ctx;

      let pageComponentProps = {};

      if (Component.getInitialProps) {
        pageComponentProps = await Component.getInitialProps(ctx);
      }

      const { user } = await getUserApiMethod(req);

      console.log(user);

      if (loginRequired && !logoutRequired && !user) {
        if (res) {
          res.redirect('/login');
        } else {
          Router.push('/login');
        }
        return;
      }

      let redirectUrl = '/login';
      let asUrl = '/login';

      if (user) {
        redirectUrl = `/your-settings`;
        asUrl = `/your-settings`;
      }

      if (logoutRequired && user) {
        if (res) {
          res.redirect(`${redirectUrl}`);
        } else {
          Router.push(redirectUrl, asUrl);
        }
      }

      return {
        ...pageComponentProps,
        user,
      };
    }

    public render() {
      const { user } = this.props;

      if (loginRequired && !logoutRequired && !user) {
        return null;
      }

      if (logoutRequired && user) {
        return null;
      }

      return <Component {...this.props} />;
    }
  }

  return WithAuth;
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\pages\csr-page.tsx -----

import Button from "@mui/material/Button";
import React from "react";
import Head from "next/head";

const CSRPage = () => (
  <div>
    <Head>
      <title>CSR page</title>
      <meta name="description" content="This is a description of the CSR page" />
    </Head>
    <div style={{ padding: "0px 30px", fontSize: "15px", height: "100%" }}>
      <p>Content on CSR page</p>
      <Button variant="outlined">Some button</Button>
    </div>
  </div>
);

console.log(process.env.NEXT_PUBLIC_URL_APP);

export default CSRPage;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\pages\index.tsx -----

import Button from "@mui/material/Button";
import React from "react";
import Head from "next/head";
import Link from "next/link";

import Layout from "../components/layout";
import NProgress from "nprogress";

import confirm from "../lib/confirm";
import notify from "../lib/notify";
import { getUserBySlugApiMethod } from "../lib/api/public";

type Props = { user: { email: string; displayName: string } };

class Index extends React.Component<Props> {
  public static async getInitialProps() {
    const slug = "team-builder-book";

    const user = await getUserBySlugApiMethod(slug);

    console.log(user);

    return { ...user };
  }

  public render() {
    return (
      <Layout {...this.props}>
        <Head>
          <title>Index page</title>
          <meta name="description" content="This is a description of the Index page" />
        </Head>
        <div style={{ padding: "0px 30px", fontSize: "15px", height: "100%" }}>
          <p>Content on Index page</p>
          <Link href="/your-settings" as="/your-settings">
            Go to Your Settings page
          </Link>
          <p />
          <Button
            variant="contained"
            onClick={() =>
              confirm({
                title: "Are you sure?",
                message: "explanatory message",
                onAnswer: async (answer) => {
                  // console.log(answer);
                  if (!answer) {
                    return;
                  }

                  NProgress.start();

                  try {
                    notify("You successfully confirmed.");
                  } catch (error) {
                    console.error(error);
                    notify(error);
                  } finally {
                    NProgress.done();
                  }
                },
              })
            }
          >
            Test Confirmer and Notifier
          </Button>
          <p>Your email: {this.props.user.email}</p>
          <p>Your username: {this.props.user.displayName}</p>
        </div>
      </Layout>
    );
  }
}

export default Index;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\pages\login.tsx -----

import Head from 'next/head';
import React from 'react';
import LoginButton from '../components/common/LoginButton';
import Layout from '../components/layout';
import withAuth from '../lib/withAuth';

class Login extends React.Component {
  public render() {
    return (
      <Layout {...this.props}>
        <div style={{ textAlign: 'center', margin: '0 20px' }}>
          <Head>
            <title>Log in to SaaS boilerplate by Async</title>
            <meta
              name="description"
              content="Login and signup page for SaaS boilerplate demo by Async"
            />
          </Head>
          <br />
          <p style={{ margin: '45px auto', fontSize: '44px', fontWeight: 400 }}>Log in</p>
          <p>Youll be logged in for 14 days unless you log out manually.</p>
          <br />

          <LoginButton />
        </div>
      </Layout>
    );
  }
}

export default withAuth(Login, { logoutRequired: true });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\pages\your-settings.tsx -----

import Avatar from "@mui/material/Avatar";
import Button from "@mui/material/Button";
import TextField from "@mui/material/TextField";
import Head from "next/head";
import NProgress from "nprogress";
import * as React from "react";

import Layout from "../components/layout";

import { updateProfileApiMethod } from "../lib/api/public";
import { getSignedRequestForUploadApiMethod, uploadFileUsingSignedPutRequestApiMethod } from "../lib/api/team-member";

import { resizeImage } from "../lib/resizeImage";

import notify from "../lib/notify";

import withAuth from "../lib/withAuth";

type Props = {
  isMobile: boolean;
  user: { email: string; displayName: string; slug: string; avatarUrl: string };
};

type State = { newName: string; newAvatarUrl: string; disabled: boolean };

class YourSettings extends React.Component<Props, State> {
  // public static async getInitialProps(ctx) {
  //   const user = await getUserApiMethod(ctx.req);

  //   console.log(user);

  //   return { ...user };
  // }

  // public static async getInitialProps() {
  //   const slug = 'team-builder-book';

  //   const user = await getUserBySlugApiMethod(slug);

  //   console.log(user);

  //   return { ...user };
  // }

  constructor(props) {
    super(props);

    this.state = {
      newName: this.props.user.displayName,
      newAvatarUrl: this.props.user.avatarUrl,
      disabled: false,
    };
  }

  public render() {
    const { user } = this.props;
    const { newName, newAvatarUrl } = this.state;

    return (
      <Layout {...this.props}>
        <Head>
          <title>Your Settings at Async</title>
          <meta name="description" content="description" />
        </Head>
        <div
          style={{
            padding: this.props.isMobile ? "0px" : "0px 30px",
            fontSize: "15px",
            height: "100%",
          }}
        >
          <h3>Your Settings</h3>
          <h4 style={{ marginTop: "40px" }}>Your account</h4>
          <ul>
            <li>
              Your email: <b>{user.email}</b>
            </li>
            <li>
              Your username: <b>{user.displayName}</b>
            </li>
          </ul>
          <form onSubmit={this.onSubmit} autoComplete="off">
            <h4>Your username</h4>
            <TextField
              autoComplete="off"
              value={newName}
              helperText="Your username as seen by your team members"
              onChange={(event) => {
                this.setState({ newName: event.target.value });
              }}
            />
            <br />
            <br />
            <Button variant="contained" color="primary" type="submit" disabled={this.state.disabled}>
              Update username
            </Button>
          </form>

          <br />
          <h4>Your photo</h4>
          <Avatar
            src={newAvatarUrl}
            style={{
              display: "inline-flex",
              verticalAlign: "middle",
              marginRight: 20,
              width: 60,
              height: 60,
            }}
          />
          <label htmlFor="upload-file-user-avatar">
            <Button variant="outlined" color="primary" component="span" disabled={this.state.disabled}>
              Update avatar
            </Button>
          </label>
          <input
            accept="image/*"
            name="upload-file-user-avatar"
            id="upload-file-user-avatar"
            type="file"
            style={{ display: "none" }}
            onChange={this.uploadFile}
          />
          <p />
          <br />
        </div>
      </Layout>
    );
  }

  private onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();

    const { newName, newAvatarUrl } = this.state;

    console.log(newName);

    if (!newName) {
      notify("Name is required");
      return;
    }

    NProgress.start();
    this.setState({ disabled: true });

    try {
      await updateProfileApiMethod({
        name: newName,
        avatarUrl: newAvatarUrl,
      });

      notify("You successfully updated your profile.");
    } catch (error) {
      notify(error);
    } finally {
      this.setState({ disabled: false });
      NProgress.done();
    }
  };

  private uploadFile = async () => {
    const fileElement = document.getElementById("upload-file-user-avatar") as HTMLFormElement;
    const file = fileElement.files[0];

    if (file == null) {
      notify("No file selected for upload.");
      return;
    }

    const fileName = file.name;
    const fileType = file.type;

    NProgress.start();
    this.setState({ disabled: true });

    const bucket = process.env.NEXT_PUBLIC_BUCKET_FOR_AVATARS;

    const prefix = "team-builder-book";

    try {
      const responseFromApiServerForUpload = await getSignedRequestForUploadApiMethod({
        fileName,
        fileType,
        prefix,
        bucket,
      });

      const resizedFile = await resizeImage(file, 128, 128);

      console.log(file);
      console.log(resizedFile);

      await uploadFileUsingSignedPutRequestApiMethod(resizedFile, responseFromApiServerForUpload.signedRequest, {
        "Cache-Control": "max-age=2592000",
      });

      this.setState({
        newAvatarUrl: responseFromApiServerForUpload.url,
      });

      await updateProfileApiMethod({
        name: this.state.newName,
        avatarUrl: this.state.newAvatarUrl,
      });

      notify("You successfully uploaded new avatar.");
    } catch (error) {
      notify(error);
    } finally {
      fileElement.value = "";
      this.setState({ disabled: false });
      NProgress.done();
    }
  };
}

export default withAuth(YourSettings);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\pages\_app.tsx -----

import CssBaseline from "@mui/material/CssBaseline";
import { ThemeProvider } from "@mui/material";
import App from "next/app";
import Head from "next/head";
import React from "react";
import { isMobile } from "../lib/isMobile";
import { themeDark, themeLight } from "../lib/theme";

class MyApp extends App {
  public static async getInitialProps({ Component, ctx }) {
    let firstGridItem = true;

    if (ctx.pathname.includes("/login")) {
      firstGridItem = false;
    }

    const pageProps = { isMobile: isMobile({ req: ctx.req }), firstGridItem };

    if (Component.getInitialProps) {
      Object.assign(pageProps, await Component.getInitialProps(ctx));
    }

    return { pageProps };
  }

  public componentDidMount() {
    // Remove the server-side injected CSS.
    const jssStyles = document.querySelector("#jss-server-side");
    if (jssStyles && jssStyles.parentNode) {
      jssStyles.parentNode.removeChild(jssStyles);
    }
  }
  public render() {
    const { Component, pageProps } = this.props;

    return (
      <ThemeProvider theme={false ? themeDark : themeLight}>
        <Head>
          <meta name="viewport" content="width=device-width, initial-scale=1.0" />
          <link rel="stylesheet" href="https://storage.googleapis.com/async-await/nprogress-dark.min.css?v=1" />
        </Head>
        <CssBaseline />
        <Component {...pageProps} />
      </ThemeProvider>
    );
  }
}

export default MyApp;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\pages\_document.tsx -----

import Document, { Head, Html, Main, NextScript } from "next/document";
import React from "react";

class MyDocument extends Document {
  public static getInitialProps = async (ctx) => {
    const initialProps = await Document.getInitialProps(ctx);

    return {
      ...initialProps,
    };
  };

  public render() {
    // console.log('rendered on the server');

    return (
      <Html lang="en">
        <Head>
          <meta charSet="utf-8" />
          <meta name="google" content="notranslate" />
          <meta name="theme-color" content="#303030" />

          <link rel="shortcut icon" href="https://storage.googleapis.com/async-await/async-favicon32.png" />

          <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons" />
          <link rel="stylesheet" href="https://storage.googleapis.com/async-await/vs2015.min.css" />

          <style>
            {`
              #__next {
                width: 100%;
                height: 100%;
              }
              a {
                font-weight: 400;
                color: #58a6ff;
                text-decoration: none;
                outline: none;
              }
              hr {
                border: 0.5px #707070 solid;
                color: #000;
              }
              blockquote {
                padding: 0 0.5em;
                margin: 20px 1em;
                border-left: 0.25em solid #dfe2e5;
                color: #000;
              }
              pre {
                display: block;
                overflow-x: auto;
                padding: 0.5em;
                background: #d0d0d0;
                border: 1px solid #ddd;
                font-size: 14px;
                color: #000;
              }
              pre code {
                font-size: 13px;
                background: #d0d0d0;
                padding: 0px;
                color: #000;
              }
              code {
                font-size: 13px;
                background: #d0d0d0;
                padding: 3px 5px;
                color: #000;
              }
              mark {
                background-color: #ffff0060;
              }
              summary:focus {
                outline: none;
              }
              table {
                border-collapse: collapse;
                margin: 15px 0px;
              }
              table, th, td {
                border: 1px solid #a1a1a1;
              }
              th, td {
                line-height: 1.5em;
                padding: 10px;
              }
            `}
          </style>
        </Head>
        <body>
          <Main />
          <NextScript />
        </body>
      </Html>
    );
  }
}

export default MyDocument;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\server\server.ts -----

import express from 'express';
import next from 'next';

const NODE_ENV = process.env.NODE_ENV || 'development';
const IS_DEV = NODE_ENV !== 'production';

const app = next({ dev: IS_DEV });
const handle = app.getRequestHandler();

app.prepare().then(() => {
  const server = express();

  // give all Nextjs's request to Nextjs before anything else
  server.get('/_next/*', (req, res) => {
    // console.log('next server, page');
    handle(req, res);
  });

  server.use(express.json());

  // server.get('/api/v1/public/get-user', (_, res) => {
  //   res.json({ user: { email: 'team@builderbook.org' } });
  // });

  server.all('*', (req, res) => {
    handle(req, res);
  });

  server.listen(process.env.NEXT_PUBLIC_PORT_APP, () => {
    console.log(`> Ready on ${process.env.NEXT_PUBLIC_URL_APP}`);
  });
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\.eslintrc.js -----

module.exports = {
  settings: {
    react: { version: 'detect' },
  },
  parser: '@typescript-eslint/parser',
  extends: ['plugin:react/recommended', 'plugin:@typescript-eslint/recommended', 'prettier'],
  env: {
    es6: true,
    node: true,
  },
  plugins: ['prettier', 'react'],
  rules: {
    'prettier/prettier': [
      'error',
      {
        singleQuote: true,
        trailingComma: 'all',
        arrowParens: 'always',
        printWidth: 100,
        semi: true,
      },
    ],
    '@typescript-eslint/camelcase': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    'react/no-unescaped-entities': 'off',
    'react/jsx-filename-extension': ['error', { extensions: ['.tsx'] }],
    '@typescript-eslint/no-explicit-any': 'off',
    'prefer-arrow-callback': 'error',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
  },
};

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\next-env.d.ts -----

/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/pages/api-reference/config/typescript for more information.

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\next.config.js -----

module.exports = {
  poweredByHeader: false,
  webpack5: true,
  typescript: {
    ignoreBuildErrors: true,
  },
};

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\nodemon.json -----

{
  "watch": ["server"],
  "exec": "ts-node --project tsconfig.server.json",
  "ext": "ts"
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\package.json -----

{
  "name": "5-end-app",
  "version": "1",
  "license": "MIT",
  "scripts": {
    "dev": "nodemon server/server.ts",
    "build": "next build",
    "lint": "eslint . --ext .ts,.tsx"
  },
  "dependencies": {
    "@emotion/react": "^11.14.0",
    "@emotion/styled": "^11.14.0",
    "@mui/material": "^6.4.8",
    "@mui/system": "^6.4.8",
    "dotenv": "^16.4.7",
    "express": "^4.21.2",
    "isomorphic-unfetch": "^4.0.2",
    "next": "^15.2.3",
    "nprogress": "^0.2.0",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "typescript": "^5.8.2"
  },
  "devDependencies": {
    "@types/express": "^5.0.1",
    "@types/helmet": "^4.0.0",
    "@types/node": "^22.13.10",
    "@types/react": "^19.0.12",
    "@types/react-dom": "^19.0.4",
    "@typescript-eslint/eslint-plugin": "^8.27.0",
    "@typescript-eslint/parser": "^8.27.0",
    "eslint": "^9.22.0",
    "eslint-config-prettier": "^10.1.1",
    "eslint-plugin-prettier": "^5.2.3",
    "eslint-plugin-react": "^7.37.4",
    "nodemon": "^3.1.9",
    "prettier": "^3.5.3",
    "ts-node": "^10.9.2"
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\tsconfig.json -----

{
  "compileOnSave": false,
  "compilerOptions": {
    "target": "esnext",
    "module": "esnext",
    "jsx": "preserve",
    "allowJs": true,
    "alwaysStrict": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "removeComments": true,
    "preserveConstEnums": true,
    "sourceMap": false,
    "skipLibCheck": true,
    "baseUrl": ".",
    "typeRoots": [
      "./node_modules/@types"
    ],
    "lib": [
      "dom",
      "es2017"
    ],
    "strict": false,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "incremental": true
  },
  "include": [
    "next-env.d.ts",
    "./**/*.tsx",
    "./**/*.ts"
  ],
  "exclude": [
    "dist",
    "production-server",
    ".next",
    "out",
    "next.config.js",
    "node_modules"
  ]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\5-end\app\tsconfig.server.json -----

{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "module": "commonjs",
    "outDir": "production-server/",
    "target": "es2017",
    "isolatedModules": false,
    "noEmit": false
  },
  "exclude": ["./server/types.d.ts"],
  "include": ["./server/**/*.ts"],
  "typeRoots": ["./node_modules/@types", "./server/types.d.ts"]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\api\server\api\index.ts -----

import * as express from 'express';

import publicExpressRoutes from './public';
import teamMemberExpressRoutes from './team-member';

function handleError(err, _, res, __) {
  console.error(err.stack);

  res.json({ error: err.message || err.toString() });
}

export default function api(server: express.Express) {
  server.use('/api/v1/public', publicExpressRoutes, handleError);
  server.use('/api/v1/team-member', teamMemberExpressRoutes, handleError);
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\api\server\api\public.ts -----

import * as express from 'express';

import User from '../models/User';

const router = express.Router();

router.get('/get-user', (req, res) => {
  console.log(req.user);
  res.json({ user: req.user || null });
});

router.post('/get-user-by-slug', async (req, res, next) => {
  console.log('Express route: /get-user-by-slug');

  // req.session.foo = 'bar';

  try {
    const { slug } = req.body;

    const user = await User.getUserBySlug({ slug });

    res.json({ user });
  } catch (err) {
    next(err);
  }
});

router.post('/user/update-profile', async (req: any, res, next) => {
  try {
    const { name, avatarUrl } = req.body;

    const updatedUser = await User.updateProfile({
      userId: req.user.id,
      name,
      avatarUrl,
    });

    res.json({ updatedUser });
  } catch (err) {
    next(err);
  }
});

export default router;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\api\server\api\team-member.ts -----

import * as express from 'express';

import { signRequestForUpload } from '../aws-s3';

const router = express.Router();

// Get signed request from AWS S3 server
router.post('/aws/get-signed-request-for-upload-to-s3', async (req, res, next) => {
  try {
    const { fileName, fileType, prefix, bucket } = req.body;

    const returnData = await signRequestForUpload({
      fileName,
      fileType,
      prefix,
      bucket,
    });

    console.log(returnData);

    res.json(returnData);
  } catch (err) {
    next(err);
  }
});

export default router;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\api\server\models\User.ts -----

import * as _ from 'lodash';
import * as mongoose from 'mongoose';

import { generateSlug } from '../utils/slugify';

const mongoSchema = new mongoose.Schema({
  slug: {
    type: String,
    required: true,
    unique: true,
  },
  createdAt: {
    type: Date,
    required: true,
  },
  email: {
    type: String,
    required: true,
    unique: true,
  },
  displayName: String,
  avatarUrl: String,
  googleId: {
    type: String,
    unique: true,
    sparse: true,
  },
  googleToken: {
    accessToken: String,
    refreshToken: String,
  },
  isSignedupViaGoogle: {
    type: Boolean,
    required: true,
    default: false,
  },
});

export interface UserDocument extends mongoose.Document {
  slug: string;
  createdAt: Date;
  email: string;
  displayName: string;
  avatarUrl: string;
  googleId: string;
  googleToken: { accessToken: string; refreshToken: string };
  isSignedupViaGoogle: boolean;
}

interface UserModel extends mongoose.Model<UserDocument> {
  getUserBySlug({ slug }: { slug: string }): Promise<UserDocument>;

  updateProfile({
    userId,
    name,
    avatarUrl,
  }: {
    userId: string;
    name: string;
    avatarUrl: string;
  }): Promise<UserDocument[]>;

  publicFields(): string[];

  signInOrSignUpViaGoogle({
    googleId,
    email,
    displayName,
    avatarUrl,
    googleToken,
  }: {
    googleId: string;
    email: string;
    displayName: string;
    avatarUrl: string;
    googleToken: { accessToken?: string; refreshToken?: string };
  }): Promise<UserDocument>;
}

class UserClass extends mongoose.Model {
  public static async getUserBySlug({ slug }) {
    console.log('Static method: getUserBySlug');

    return this.findOne({ slug }, 'email displayName avatarUrl').setOptions({ lean: true });
  }

  public static async updateProfile({ userId, name, avatarUrl }) {
    console.log('Static method: updateProfile');

    const user = await this.findById(userId, 'slug displayName');

    const modifier = { displayName: user.displayName, avatarUrl, slug: user.slug };

    console.log(user.slug);

    if (name !== user.displayName) {
      modifier.displayName = name;
      modifier.slug = await generateSlug(this, name);
    }

    return this.findByIdAndUpdate(userId, { $set: modifier }, { new: true, runValidators: true })
      .select('displayName avatarUrl slug')
      .setOptions({ lean: true });
  }

  public static publicFields(): string[] {
    return ['_id', 'id', 'displayName', 'email', 'avatarUrl', 'slug', 'isSignedupViaGoogle'];
  }

  public static async signInOrSignUpViaGoogle({
    googleId,
    email,
    displayName,
    avatarUrl,
    googleToken,
  }) {
    const user = await this.findOne({ email })
      .select([...this.publicFields(), 'googleId'].join(' '))
      .setOptions({ lean: true });

    if (user) {
      if (_.isEmpty(googleToken) && user.googleId) {
        return user;
      }

      const modifier = { googleId };
      if (googleToken.accessToken) {
        modifier['googleToken.accessToken'] = googleToken.accessToken;
      }

      if (googleToken.refreshToken) {
        modifier['googleToken.refreshToken'] = googleToken.refreshToken;
      }

      await this.updateOne({ email }, { $set: modifier });

      return user;
    }

    const slug = await generateSlug(this, displayName);

    const newUser = await this.create({
      createdAt: new Date(),
      googleId,
      email,
      googleToken,
      displayName,
      avatarUrl,
      slug,
      isSignedupViaGoogle: true,
      darkTheme: false,
    });

    return _.pick(newUser, this.publicFields());
  }
}

mongoSchema.loadClass(UserClass);

const User = mongoose.model<UserDocument, UserModel>('User', mongoSchema);

export default User;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\api\server\utils\slugify.ts -----

import * as _ from 'lodash';

const slugify = (text) => _.kebabCase(text);

async function createUniqueSlug(Model, slug, count, filter) {
  const obj = await Model.findOne({ slug: `${slug}-${count}`, ...filter })
    .select('_id')
    .setOptions({ lean: true });

  if (!obj) {
    return `${slug}-${count}`;
  }

  return createUniqueSlug(Model, slug, count + 1, filter);
}

async function generateSlug(Model, name, filter = {}) {
  const origSlug = slugify(name);

  const obj = await Model.findOne({ slug: origSlug, ...filter })
    .select('_id')
    .setOptions({ lean: true });

  if (!obj) {
    return origSlug;
  }

  return createUniqueSlug(Model, origSlug, 1, filter);
}

export { generateSlug };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\api\server\utils\sum.ts -----

function sum(a, b) {
  return a + b;
}

export { sum };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\api\server\aws-s3.ts -----

import * as url from 'url';
import * as aws from 'aws-sdk';

async function signRequestForUpload({ fileName, fileType, prefix, bucket }) {
  const randomStringForPrefix =
    Math.random().toString(36).substring(2, 12) + Math.random().toString(36).substring(2, 12);

  const key = `${prefix}/${randomStringForPrefix}/${fileName}`;

  const acl = 'public-read';

  const params = {
    Bucket: bucket,
    Key: key,
    Expires: 60,
    ContentType: fileType,
    ACL: acl,
  };

  console.log(prefix);

  const s3 = new aws.S3({
    apiVersion: 'latest',
    region: process.env.AWS_REGION,
    accessKeyId: process.env.AWS_ACCESSKEYID,
    secretAccessKey: process.env.AWS_SECRETACCESSKEY,
  });

  return new Promise((resolve, reject) => {
    s3.getSignedUrl('putObject', params, (err, data) => {
      const parsedUrl = url.parse(data);

      const returnData = {
        signedRequest: data,
        url: `${parsedUrl.protocol}//${parsedUrl.hostname}${parsedUrl.pathname}`,
      };

      if (err) {
        console.error(err);
        reject(err);
      } else {
        resolve(returnData);
      }
    });
  });
}

export { signRequestForUpload };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\api\server\google-auth.ts -----

import * as passport from 'passport';
import { OAuth2Strategy as Strategy } from 'passport-google-oauth';

import User, { UserDocument } from './models/User';

function setupGoogle({ server }) {
  if (!process.env.GOOGLE_CLIENTID) {
    return;
  }

  const verify = async (accessToken, refreshToken, profile, done) => {
    let email;
    let avatarUrl;

    if (profile.emails) {
      email = profile.emails[0].value;
    }

    if (profile.photos && profile.photos.length > 0) {
      avatarUrl = profile.photos[0].value.replace('sz=50', 'sz=128');
    }

    try {
      const user = await User.signInOrSignUpViaGoogle({
        googleId: profile.id,
        email,
        googleToken: { accessToken, refreshToken },
        displayName: profile.displayName,
        avatarUrl,
      });

      done(null, user);
    } catch (err) {
      done(err);
      console.error(err);
    }
  };

  passport.use(
    new Strategy(
      {
        clientID: process.env.GOOGLE_CLIENTID,
        clientSecret: process.env.GOOGLE_CLIENTSECRET,
        callbackURL: `${process.env.URL_API}/oauth2callback`,
      },
      verify,
    ),
  );

  passport.serializeUser((user: UserDocument, done) => {
    done(null, user._id);
  });

  passport.deserializeUser((id, done) => {
    User.findById(id, User.publicFields())
      .then((user) => {
        done(null, user);
      })
      .catch((error) => {
        done(error, null);
      });
  });

  server.use(passport.initialize());
  server.use(passport.session());

  server.get('/auth/google', (req, res, next) => {
    const options = {
      scope: ['profile', 'email'],
      prompt: 'select_account',
    };

    passport.authenticate('google', options)(req, res, next);

    console.log('/auth/google');
  });

  server.get(
    '/oauth2callback',
    passport.authenticate('google', {
      failureRedirect: '/login',
    }),
    (_, res) => {
      console.log('/oauth2callback');
      res.redirect(`${process.env.URL_APP}/your-settings`);
    },
  );

  server.get('/logout', (req, res, next) => {
    req.logout((err) => {
      if (err) {
        next(err);
      }
      res.redirect(`${process.env.URL_APP}/login`);
    });
  });
}

export { setupGoogle };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\api\server\server.ts -----

// eslint-disable-next-line @typescript-eslint/no-var-requires
const MongoStore = require('connect-mongo');

import * as cors from 'cors';
import * as express from 'express';
import * as session from 'express-session';
import * as mongoose from 'mongoose';

import api from './api';
import { setupGoogle } from './google-auth';

// eslint-disable-next-line
require('dotenv').config();

mongoose.connect(process.env.MONGO_URL_TEST);

const server = express();

server.use(
  cors({
    origin: process.env.URL_APP,
    methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',
    credentials: true,
  }),
);

server.use(express.json());

const sessionOptions = {
  name: process.env.SESSION_NAME,
  secret: process.env.SESSION_SECRET,
  resave: false,
  saveUninitialized: false,
  store: MongoStore.create({
    mongoUrl: process.env.MONGO_URL_TEST,
    ttl: 14 * 24 * 60 * 60, // save session 14 days
    autoRemove: 'interval',
    autoRemoveInterval: 1440, // clears every day
  }),
  cookie: {
    httpOnly: true,
    maxAge: 14 * 24 * 60 * 60 * 1000, // expires in 14 days
    secure: false,
  },
};

const sessionMiddleware = session(sessionOptions);
server.use(sessionMiddleware);

setupGoogle({ server });

api(server);

server.get('*', (_, res) => {
  res.sendStatus(403);
});

server.listen(process.env.PORT_API, () => {
  console.log(`> Ready on ${process.env.URL_API}`);
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\api\test\server\utils\slugify.test.ts -----

import * as mongoose from 'mongoose';
import User from '../../../server/models/User';
import { generateSlug } from '../../../server/utils/slugify';

// eslint-disable-next-line
require('dotenv').config();

describe('slugify', () => {
  beforeAll(async () => {
    await mongoose.connect(process.env.MONGO_URL_TEST);

    const mockUsers = [
      {
        slug: 'john',
        email: 'john@example.com',
        createdAt: new Date(),
        displayName: 'abc',
        avatarUrl: 'def',
      },
      {
        slug: 'john-johnson',
        email: 'john-johnson@example.com',
        createdAt: new Date(),
        displayName: 'abc',
        avatarUrl: 'def',
      },
      {
        slug: 'john-johnson-1',
        email: 'john-johnson-1@example.com',
        createdAt: new Date(),
        displayName: 'abc',
        avatarUrl: 'def',
      },
    ];

    await User.insertMany(mockUsers);
  });

  test('not duplicated', async () => {
    expect.assertions(1);

    await expect(generateSlug(User, 'John J Johnson@#$')).resolves.toEqual('john-j-johnson');
  });

  test('one time duplicated', async () => {
    expect.assertions(1);

    await expect(generateSlug(User, ' John@#$')).resolves.toEqual('john-1');
  });

  test('multiple duplicated', async () => {
    expect.assertions(1);

    await expect(generateSlug(User, 'John & Johnson@#$')).resolves.toEqual('john-johnson-2');
  });

  afterAll(async () => {
    await User.deleteMany({ slug: { $in: ['john', 'john-johnson', 'john-johnson-1'] } });
    await mongoose.disconnect();
  });
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\api\test\server\utils\sum.test.ts -----

import { sum } from '../../../server/utils/sum';

console.log(sum(1, 2));

describe.skip('testing sum function', () => {
  test('adds 1 + 2 to equal 3', () => {
    expect(sum(1, 2)).toBe(3);
  });
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\api\.eslintrc.js -----

module.exports = {
  parser: "@typescript-eslint/parser",
  extends: ["plugin:@typescript-eslint/recommended", "prettier"],
  env: {
    "es6": true,
    "node": true,
  },
  plugins: ["prettier"],
  rules: {
    'prettier/prettier': [
      'error',
      {
        singleQuote: true,
        trailingComma: 'all',
        arrowParens: 'always',
        printWidth: 100,
        semi: true,
      },
    ],
    '@typescript-eslint/no-unused-vars': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/no-explicit-any': 'off',
    'prefer-arrow-callback': 'error',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
 },
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\api\nodemon.json -----

{
  "watch": ["server"],
  "exec": "ts-node --project tsconfig.server.json",
  "ext": "ts"
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\api\package.json -----

{
  "name": "6-begin-api",
  "version": "1",
  "license": "MIT",
  "scripts": {
    "dev": "nodemon server/server.ts",
    "lint": "eslint . --ext .ts,.tsx",
    "test": "jest"
  },
  "jest": {
    "preset": "ts-jest",
    "testPathIgnorePatterns": [
      "production-server"
    ],
    "testEnvironment": "node"
  },
  "dependencies": {
    "aws-sdk": "^2.1692.0",
    "connect-mongo": "^5.1.0",
    "cors": "^2.8.5",
    "dotenv": "^16.4.7",
    "express": "^4.21.2",
    "express-session": "^1.18.1",
    "lodash": "^4.17.21",
    "mongoose": "^8.12.1",
    "passport": "^0.7.0",
    "passport-google-oauth": "^2.0.0",
    "typescript": "^5.8.2"
  },
  "devDependencies": {
    "@types/connect-mongo": "^3.1.6",
    "@types/dotenv": "^8.2.3",
    "@types/express": "^5.0.1",
    "@types/express-session": "^1.18.1",
    "@types/jest": "^29.5.14",
    "@types/lodash": "^4.17.16",
    "@types/mongoose": "^5.11.97",
    "@types/node": "^22.13.10",
    "@types/passport": "^1.0.17",
    "@typescript-eslint/eslint-plugin": "^8.27.0",
    "@typescript-eslint/parser": "^8.27.0",
    "eslint": "^9.22.0",
    "eslint-config-prettier": "^10.1.1",
    "eslint-plugin-prettier": "^5.2.3",
    "jest": "^29.7.0",
    "nodemon": "^3.1.9",
    "prettier": "^3.5.3",
    "ts-jest": "^29.2.6",
    "ts-node": "^10.9.2"
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\api\tsconfig.json -----

{
  "compileOnSave": false,
  "compilerOptions": {
    "jsx": "preserve",
    "allowJs": true,
    "alwaysStrict": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "removeComments": false,
    "preserveConstEnums": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "sourceMap": true,
    "skipLibCheck": true,
    "baseUrl": ".",
    "experimentalDecorators": true,
    "typeRoots": ["./node_modules/@types"],
    "lib": ["es2015", "es2016"]
  },
  "exclude": ["production-server", "node_modules"]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\api\tsconfig.server.json -----

{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "module": "commonjs",
    "outDir": "production-server/"
  },
  "include": ["./server/**/*.ts"],
  "exclude": ["./server/**/*.test.ts"]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\components\common\Confirmer.tsx -----

import Button from "@mui/material/Button";
import Dialog from "@mui/material/Dialog";
import DialogActions from "@mui/material/DialogActions";
import DialogContent from "@mui/material/DialogContent";
import DialogContentText from "@mui/material/DialogContentText";
import DialogTitle from "@mui/material/DialogTitle";
import React from "react";

export let openConfirmDialogExternal;

type State = {
  open: boolean;
  title: string;
  message: string;
  onAnswer: (answer) => void;
};

class Confirmer extends React.Component<any, State> {
  constructor(props) {
    super(props);

    this.state = {
      open: false,
      title: "Are you sure?",
      message: "",
      onAnswer: null,
    };

    openConfirmDialogExternal = this.openConfirmDialog;
  }

  public render() {
    return (
      <Dialog
        open={this.state.open}
        onClose={this.handleClose}
        aria-labelledby="alert-dialog-title"
        aria-describedby="alert-dialog-description"
      >
        <DialogTitle id="alert-dialog-title">{this.state.title}</DialogTitle>
        <DialogContent>
          <DialogContentText id="alert-dialog-description">{this.state.message}</DialogContentText>
        </DialogContent>
        <DialogActions style={{ padding: "10px" }}>
          <Button onClick={this.handleClose} variant="contained" color="primary" autoFocus>
            Cancel
          </Button>
          <Button onClick={this.handleYes} variant="contained" color="secondary">
            OK
          </Button>
        </DialogActions>
      </Dialog>
    );
  }

  public handleClose = () => {
    this.setState({ open: false });
    this.state.onAnswer(false);
  };

  public handleYes = () => {
    this.setState({ open: false });
    this.state.onAnswer(true);
  };

  public openConfirmDialog = ({ title, message, onAnswer }) => {
    this.setState({ open: true, title, message, onAnswer });
  };
}

export default Confirmer;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\components\common\LoginButton.tsx -----

import Button from "@mui/material/Button";
import React from "react";

class LoginButton extends React.PureComponent {
  public render() {
    const url = `${process.env.NEXT_PUBLIC_URL_API}/auth/google`;

    console.log(url);

    return (
      <React.Fragment>
        <Button variant="contained" color="secondary" href={url}>
          <img src="https://storage.googleapis.com/async-await-all/G.svg" alt="Log in with Google" />
          &nbsp;&nbsp;&nbsp; Log in with Google
        </Button>
        <p />
        <br />
      </React.Fragment>
    );
  }
}

export default LoginButton;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\components\common\MenuWithLinks.tsx -----

import Menu from "@mui/material/Menu";
import MenuItem from "@mui/material/MenuItem";
import Link from "next/link";
import { NextRouter, withRouter } from "next/router";
import React from "react";

type Props = {
  options: {
    href: string;
    as: string;
    highlighterSlug: string;
    text: string;
    externalServer: boolean;
    separator: boolean;
  }[];
  router: NextRouter;
  children: any;
};

type State = {
  anchorEl: Element | ((element: Element) => Element);
};

class MenuWithLinks extends React.PureComponent<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      anchorEl: null,
    };
  }

  public render() {
    const { options, children, router } = this.props;
    const { anchorEl } = this.state;

    return (
      <div style={{ textAlign: "center" }}>
        <div
          aria-controls={anchorEl ? "simple-menu" : null}
          aria-haspopup="true"
          onClick={this.handleClick}
          onKeyPress={this.handleClick}
        >
          {children}
        </div>
        <Menu id="simple-menu" anchorEl={anchorEl} open={Boolean(anchorEl)} onClose={this.handleClose} keepMounted>
          {options.map((option, i) =>
            option.separator ? (
              <hr style={{ width: "95%", margin: "10px auto" }} key={`separated-${i}`} />
            ) : option.externalServer ? (
              <MenuItem
                onClick={(event) => {
                  event.preventDefault();
                  window.location.href = option.href;
                  this.handleClose();
                }}
                key={option.href || option.text}
              >
                {option.text}
              </MenuItem>
            ) : (
              <Link key={option.href} href={option.href} as={option.as} passHref>
                <MenuItem
                  key={option.href}
                  style={{
                    fontWeight: router.asPath.includes(option.highlighterSlug) ? 600 : 300,
                    fontSize: "14px",
                  }}
                >
                  {option.text}
                </MenuItem>
              </Link>
            )
          )}
        </Menu>
      </div>
    );
  }

  public handleClick = (event) => {
    this.setState({ anchorEl: event.currentTarget });
  };

  public handleClose = () => {
    this.setState({ anchorEl: null });
  };
}

export default withRouter(MenuWithLinks);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\components\common\Notifier.tsx -----

import Snackbar from "@mui/material/Snackbar";
import React from "react";

export let openSnackbarExternal;

type State = {
  open: boolean;
  message: string;
};

class Notifier extends React.PureComponent<any, State> {
  constructor(props) {
    super(props);
    openSnackbarExternal = this.openSnackbar;

    this.state = {
      open: false,
      message: "",
    };
  }

  public render() {
    const message = <span id="snackbar-message-id" dangerouslySetInnerHTML={{ __html: this.state.message }} />;

    return (
      <Snackbar
        anchorOrigin={{ vertical: "top", horizontal: "right" }}
        message={message}
        autoHideDuration={5000}
        onClose={this.handleSnackbarClose}
        open={this.state.open}
        ContentProps={{
          "aria-describedby": "snackbar-message-id",
        }}
      />
    );
  }

  public handleSnackbarClose = () => {
    this.setState({
      open: false,
      message: "",
    });
  };

  public openSnackbar = ({ message }) => {
    this.setState({ open: true, message });
  };
}

export default Notifier;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\components\layout\index.tsx -----

import Avatar from "@mui/material/Avatar";
import Grid from "@mui/material/Grid";
import React from "react";
import MenuWithLinks from "../common/MenuWithLinks";
import Confirmer from "../common/Confirmer";
import Notifier from "../common/Notifier";

const styleGrid = {
  width: "100%",
  height: "100vh",
  maxWidth: "100%",
  padding: "0px 10px",
  display: "flex",
  overflow: "hidden",
};

const styleGridIsMobile = {
  width: "100%",
  height: "100vh",
  maxWidth: "100%",
  padding: "0px 0px 0px 10px",
  display: "flex",
  overflow: "hidden",
};

type Props = {
  children: React.ReactNode;
  firstGridItem?: boolean;
  isMobile?: boolean;
};

class Layout extends React.Component<Props> {
  public render() {
    const { children, firstGridItem, isMobile } = this.props;

    const isThemeDark = false;

    // console.log(isMobile);

    return (
      <Grid
        container
        direction="row"
        justify="flex-start"
        alignItems="stretch"
        style={isMobile ? styleGridIsMobile : styleGrid}
      >
        {firstGridItem ? (
          <Grid
            item
            sm={2}
            xs={12}
            style={{
              borderRight: "1px #707070 solid",
              justifyContent: "center",
              overflow: "hidden",
            }}
          >
            <div style={{ display: "flex", justifyContent: "space-between" }}>
              <svg
                xmlns="http://www.w3.org/2000/svg"
                width="124"
                height="40"
                viewBox="0 0 124 40"
                style={{
                  marginTop: "20px",
                  display: "inline-flex",
                  height: "40px",
                }}
              >
                <g id="async-logo">
                  <g id="async-logo-40">
                    <circle id="Ellipse 2" cx="20" cy="20" r="20" fill="black" />
                    <path
                      id="path-async-logo"
                      d="M7.07825 -0.0960007V16H4.51825V13.088C4.04892 14.0907 3.33425 14.8693 2.37425 15.424C1.43558 15.9573 0.336917 16.224 -0.92175 16.224C-2.35108 16.224 -3.60975 15.8827 -4.69775 15.2C-5.76442 14.5173 -6.59642 13.5573 -7.19375 12.32C-7.76975 11.0613 -8.05775 9.6 -8.05775 7.936C-8.05775 6.272 -7.75908 4.81067 -7.16175 3.552C-6.56442 2.272 -5.73242 1.28 -4.66575 0.576C-3.57775 -0.128 -2.32975 -0.48 -0.92175 -0.48C0.336917 -0.48 1.43558 -0.202666 2.37425 0.352C3.31292 0.906667 4.02758 1.68533 4.51825 2.688V-0.0960007H7.07825ZM-0.40975 14.08C1.16892 14.08 2.38492 13.5467 3.23825 12.48C4.09158 11.392 4.51825 9.856 4.51825 7.872C4.51825 5.888 4.09158 4.36267 3.23825 3.296C2.38492 2.22933 1.16892 1.696 -0.40975 1.696C-1.98842 1.696 -3.22575 2.25067 -4.12175 3.36C-4.99642 4.448 -5.43375 5.97333 -5.43375 7.936C-5.43375 9.89867 -4.99642 11.4133 -4.12175 12.48C-3.24708 13.5467 -2.00975 14.08 -0.40975 14.08Z"
                      transform="translate(19.5938 12)"
                      fill="white"
                    />
                  </g>
                  <path
                    id="path-async-text"
                    d="M22.6251 11.928V24H20.7051V21.816C20.3531 22.568 19.8171 23.152 19.0971 23.568C18.3931 23.968 17.5691 24.168 16.6251 24.168C15.5531 24.168 14.6091 23.912 13.7931 23.4C12.9931 22.888 12.3691 22.168 11.9211 21.24C11.4891 20.296 11.2731 19.2 11.2731 17.952C11.2731 16.704 11.4971 15.608 11.9451 14.664C12.3931 13.704 13.0171 12.96 13.8171 12.432C14.6331 11.904 15.5691 11.64 16.6251 11.64C17.5691 11.64 18.3931 11.848 19.0971 12.264C19.8011 12.68 20.3371 13.264 20.7051 14.016V11.928H22.6251ZM17.0091 22.56C18.1931 22.56 19.1051 22.16 19.7451 21.36C20.3851 20.544 20.7051 19.392 20.7051 17.904C20.7051 16.416 20.3851 15.272 19.7451 14.472C19.1051 13.672 18.1931 13.272 17.0091 13.272C15.8251 13.272 14.8971 13.688 14.2251 14.52C13.5691 15.336 13.2411 16.48 13.2411 17.952C13.2411 19.424 13.5691 20.56 14.2251 21.36C14.8811 22.16 15.8091 22.56 17.0091 22.56ZM30.4637 24.168C28.4317 24.168 26.8237 23.648 25.6397 22.608L26.2877 21.168C26.9437 21.68 27.6077 22.048 28.2797 22.272C28.9517 22.496 29.7037 22.608 30.5357 22.608C31.4477 22.608 32.1357 22.456 32.5997 22.152C33.0797 21.832 33.3197 21.376 33.3197 20.784C33.3197 20.304 33.1597 19.92 32.8397 19.632C32.5197 19.344 31.9917 19.12 31.2557 18.96L29.2157 18.48C28.2077 18.256 27.4237 17.856 26.8637 17.28C26.3197 16.704 26.0477 16.016 26.0477 15.216C26.0477 14.16 26.4717 13.304 27.3197 12.648C28.1677 11.976 29.2877 11.64 30.6797 11.64C31.5277 11.64 32.3277 11.776 33.0797 12.048C33.8317 12.32 34.4637 12.712 34.9757 13.224L34.3277 14.64C33.1917 13.696 31.9757 13.224 30.6797 13.224C29.8157 13.224 29.1437 13.392 28.6637 13.728C28.1997 14.048 27.9677 14.504 27.9677 15.096C27.9677 15.592 28.1117 15.984 28.3997 16.272C28.7037 16.56 29.1837 16.784 29.8397 16.944L31.8797 17.448C32.9997 17.704 33.8317 18.104 34.3757 18.648C34.9197 19.176 35.1917 19.872 35.1917 20.736C35.1917 21.776 34.7677 22.608 33.9197 23.232C33.0717 23.856 31.9197 24.168 30.4637 24.168ZM48.687 11.928L43.047 25.104C42.455 26.48 41.711 27.488 40.815 28.128C39.919 28.768 38.815 29.208 37.503 29.448L37.095 27.936C38.231 27.68 39.087 27.336 39.663 26.904C40.255 26.488 40.743 25.84 41.127 24.96L41.607 23.88L36.495 11.928H38.535L42.615 21.888L46.743 11.928H48.687ZM56.853 11.64C59.749 11.64 61.197 13.232 61.197 16.416V24H59.253V16.512C59.253 15.392 59.029 14.576 58.581 14.064C58.133 13.536 57.429 13.272 56.469 13.272C55.349 13.272 54.453 13.616 53.781 14.304C53.109 14.992 52.773 15.92 52.773 17.088V24H50.829V15.312C50.829 14.064 50.765 12.936 50.637 11.928H52.485L52.677 14.088C53.045 13.304 53.597 12.704 54.333 12.288C55.069 11.856 55.909 11.64 56.853 11.64ZM69.9321 24.168C68.7641 24.168 67.7401 23.912 66.8601 23.4C65.9961 22.888 65.3241 22.168 64.8441 21.24C64.3801 20.296 64.1481 19.2 64.1481 17.952C64.1481 16.704 64.3881 15.608 64.8681 14.664C65.3481 13.704 66.0281 12.96 66.9081 12.432C67.8041 11.904 68.8441 11.64 70.0281 11.64C70.8441 11.64 71.6281 11.784 72.3801 12.072C73.1481 12.344 73.7801 12.728 74.2761 13.224L73.6281 14.664C73.0201 14.184 72.4281 13.832 71.8521 13.608C71.2921 13.384 70.7161 13.272 70.1241 13.272C68.8921 13.272 67.9241 13.688 67.2201 14.52C66.5161 15.336 66.1641 16.48 66.1641 17.952C66.1641 19.408 66.5081 20.544 67.1961 21.36C67.9001 22.16 68.8761 22.56 70.1241 22.56C70.7161 22.56 71.2921 22.448 71.8521 22.224C72.4281 22 73.0201 21.648 73.6281 21.168L74.2761 22.608C73.7641 23.088 73.1161 23.472 72.3321 23.76C71.5641 24.032 70.7641 24.168 69.9321 24.168Z"
                    transform="translate(39 4)"
                    fill={isThemeDark ? "white" : "black"}
                  />
                </g>
              </svg>
              <MenuWithLinks
                options={[
                  {
                    text: "Index page",
                    href: "/",
                    highlighterSlug: "/",
                  },
                  {
                    text: "Your Settings",
                    href: "/your-settings",
                    highlighterSlug: "/your-settings",
                  },
                  {
                    separator: true,
                  },
                  {
                    text: "Log out",
                    href: `${process.env.NEXT_PUBLIC_URL_API}/logout`,
                    as: `${process.env.NEXT_PUBLIC_URL_API}/logout`,
                    externalServer: true,
                  },
                ]}
              >
                <Avatar
                  src={"https://storage.googleapis.com/async-await/default-user.png"}
                  alt="Add username here later in the book"
                  style={{
                    margin: "20px auto",
                    cursor: "pointer",
                    display: "inline-flex",
                    width: "40px",
                    height: "40px",
                  }}
                />

                <i className="material-icons" color="action" style={{ verticalAlign: "super" }}>
                  arrow_drop_down
                </i>
              </MenuWithLinks>
            </div>
            <hr />
            <p />
            <p />
          </Grid>
        ) : null}
        <Grid item sm={firstGridItem ? 10 : 12} xs={12}>
          {isMobile ? <hr /> : null}
          {children}
        </Grid>
        <Notifier />
        <Confirmer />
      </Grid>
    );
  }
}

export default Layout;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\lib\api\public.ts -----

import sendRequestAndGetResponse from './sendRequestAndGetResponse';

const BASE_PATH = '/api/v1/public';

export const getUserApiMethod = (request) =>
  sendRequestAndGetResponse(`${BASE_PATH}/get-user`, {
    request,
    method: 'GET',
  });

export const getUserBySlugApiMethod = (slug) =>
  sendRequestAndGetResponse(`${BASE_PATH}/get-user-by-slug`, {
    body: JSON.stringify({ slug }),
  });

export const updateProfileApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/user/update-profile`, {
    body: JSON.stringify(data),
  });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\lib\api\sendRequestAndGetResponse.ts -----

import 'isomorphic-unfetch';

export default async function sendRequestAndGetResponse(path, opts: any = {}) {
  const headers = Object.assign(
    {},
    opts.headers || {},
    opts.externalServer
      ? {}
      : {
          'Content-type': 'application/json; charset=UTF-8',
        },
  );

  const { request } = opts;

  if (request && request.headers && request.headers.cookie) {
    headers.cookie = request.headers.cookie;
  }

  const qs = opts.qs || '';

  // console.log(`before: ${process.env.NEXT_PUBLIC_URL_API}${path}${qs}`);

  const response = await fetch(
    opts.externalServer ? `${path}${qs}` : `${process.env.NEXT_PUBLIC_URL_API}${path}${qs}`,
    Object.assign({ method: 'POST', credentials: 'include' }, opts, { headers }),
  );

  // console.log(`after: ${process.env.NEXT_PUBLIC_URL_API}${path}${qs}`);

  // console.log(response.status);
  // console.log(response.statusText);

  const text = await response.text();

  if (response.status >= 400) {
    console.error(text);
    throw new Error(response.status.toString());
  }

  try {
    const data = JSON.parse(text);

    return data;
  } catch (err) {
    if (err instanceof SyntaxError) {
      return text;
    }

    throw err;
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\lib\api\team-member.ts -----

import sendRequestAndGetResponse from './sendRequestAndGetResponse';

const BASE_PATH = '/api/v1/team-member';

export const getSignedRequestForUploadApiMethod = ({ fileName, fileType, prefix, bucket }) =>
  sendRequestAndGetResponse(`${BASE_PATH}/aws/get-signed-request-for-upload-to-s3`, {
    body: JSON.stringify({ fileName, fileType, prefix, bucket }),
  });

export const uploadFileUsingSignedPutRequestApiMethod = (file, signedRequest, headers = {}) =>
  sendRequestAndGetResponse(signedRequest, {
    externalServer: true,
    method: 'PUT',
    body: file,
    headers,
  });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\lib\confirm.ts -----

import { openConfirmDialogExternal } from '../components/common/Confirmer';

export default function confirm({
  title,
  message,
  onAnswer,
}: {
  title: string;
  message: string;
  onAnswer: (answer) => void;
}) {
  openConfirmDialogExternal({ title, message, onAnswer });
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\lib\isMobile.ts -----

const mobileRE = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i;

export function isMobile(opts) {
  if (!opts) {
    opts = {};
  }

  let ua = opts.ua;

  if (!ua && typeof navigator !== 'undefined') {
    ua = navigator.userAgent;
  }

  if (!ua && opts.req && opts.req.headers && typeof opts.req.headers['user-agent'] === 'string') {
    ua = opts.req.headers['user-agent'];
    // console.log(ua);
  }

  if (typeof ua !== 'string') {
    return false;
  }

  return mobileRE.test(ua);
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\lib\notify.ts -----

import { openSnackbarExternal } from '../components/common/Notifier';

export default function notify(obj) {
  openSnackbarExternal({ message: obj.message || obj.toString() });
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\lib\resizeImage.ts -----

function resizeImage(file: File, MAX_WIDTH, MAX_HEIGHT) {
  const image = document.createElement('img');

  const resize = (resolve) => () => {
    let isResizeNeeded = false;
    let width = image.width;
    let height = image.height;

    if (width > height) {
      if (width > MAX_WIDTH) {
        isResizeNeeded = true;
        height *= MAX_WIDTH / width;
        width = MAX_WIDTH;
      }
    } else {
      if (height > MAX_HEIGHT) {
        isResizeNeeded = true;
        width *= MAX_HEIGHT / height;
        height = MAX_HEIGHT;
      }
    }

    if (isResizeNeeded) {
      const canvas = document.createElement('canvas');

      canvas.width = width;
      canvas.height = height;

      console.log(width, height);

      const ctx = canvas.getContext('2d');
      ctx.drawImage(image, 0, 0, width, height);

      canvas.toBlob((blob) => {
        resolve(blob);
      }, file.type);
    } else {
      resolve(file);
    }
  };

  return new Promise((resolve) => {
    const reader = new FileReader();

    console.log(`before ${image.src}`);

    reader.readAsDataURL(file);

    reader.onload = (e) => {
      image.src = e.target.result.toString();

      image.onload = resize(resolve);

      console.log(`after ${image.src}`);
    };
  });
}

export { resizeImage };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\lib\sharedStyles.ts -----

const styleBigAvatar = {
  width: '80px',
  height: '80px',
  margin: '0px auto 15px',
};

const styleRaisedButton = {
  margin: '15px',
  font: '14px Roboto',
};

const styleToolbar = {
  background: '#FFF',
  height: '64px',
  paddingRight: '20px',
};

const styleTextField = {
  font: '15px Roboto',
  color: '#222',
  fontWeight: '300',
};

const styleForm = {
  margin: '7% auto',
  width: '360px',
};

export { styleBigAvatar, styleRaisedButton, styleToolbar, styleTextField, styleForm };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\lib\theme.ts -----

import { createMuiTheme } from "@mui/material/styles";

const themeDark = createMuiTheme({
  palette: {
    primary: { main: "#238636" },
    secondary: { main: "#b62324" },
    type: "dark",
    background: { default: "#0d1117" },
    text: {
      primary: "#c9d1d9",
    },
  },
  typography: {
    button: {
      textTransform: "none",
    },
  },
});

const themeLight = createMuiTheme({
  palette: {
    primary: { main: "#238636" },
    secondary: { main: "#b62324" },
    type: "light",
    background: { default: "#fff" },
    text: {
      primary: "#222",
    },
  },
  typography: {
    button: {
      textTransform: "none",
    },
  },
});

export { themeDark, themeLight };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\lib\withAuth.tsx -----

import Router from 'next/router';
import React from 'react';

import * as NProgress from 'nprogress';

import { getUserApiMethod } from '../lib/api/public';

Router.events.on('routeChangeStart', () => {
  NProgress.start();
});

Router.events.on('routeChangeComplete', () => {
  NProgress.done();
});

Router.events.on('routeChangeError', () => NProgress.done());

type Props = {
  user: { email: string; displayName: string; slug: string; avatarUrl: string };
};

export default function withAuth(Component, { loginRequired = true, logoutRequired = false } = {}) {
  class WithAuth extends React.Component<Props> {
    public static async getInitialProps(ctx) {
      const { req, res } = ctx;

      let pageComponentProps = {};

      if (Component.getInitialProps) {
        pageComponentProps = await Component.getInitialProps(ctx);
      }

      const { user } = await getUserApiMethod(req);

      console.log(user);

      if (loginRequired && !logoutRequired && !user) {
        if (res) {
          res.redirect('/login');
        } else {
          Router.push('/login');
        }
        return;
      }

      let redirectUrl = '/login';
      let asUrl = '/login';

      if (user) {
        redirectUrl = `/your-settings`;
        asUrl = `/your-settings`;
      }

      if (logoutRequired && user) {
        if (res) {
          res.redirect(`${redirectUrl}`);
        } else {
          Router.push(redirectUrl, asUrl);
        }
      }

      return {
        ...pageComponentProps,
        user,
      };
    }

    public render() {
      const { user } = this.props;

      if (loginRequired && !logoutRequired && !user) {
        return null;
      }

      if (logoutRequired && user) {
        return null;
      }

      return <Component {...this.props} />;
    }
  }

  return WithAuth;
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\pages\csr-page.tsx -----

import Button from "@mui/material/Button";
import React from "react";
import Head from "next/head";

const CSRPage = () => (
  <div>
    <Head>
      <title>CSR page</title>
      <meta name="description" content="This is a description of the CSR page" />
    </Head>
    <div style={{ padding: "0px 30px", fontSize: "15px", height: "100%" }}>
      <p>Content on CSR page</p>
      <Button variant="outlined">Some button</Button>
    </div>
  </div>
);

console.log(process.env.NEXT_PUBLIC_URL_APP);

export default CSRPage;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\pages\index.tsx -----

import Button from "@mui/material/Button";
import React from "react";
import Head from "next/head";
import Link from "next/link";

import Layout from "../components/layout";
import NProgress from "nprogress";

import confirm from "../lib/confirm";
import notify from "../lib/notify";
import { getUserBySlugApiMethod } from "../lib/api/public";

type Props = { user: { email: string; displayName: string } };

class Index extends React.Component<Props> {
  public static async getInitialProps() {
    const slug = "team-builder-book";

    const user = await getUserBySlugApiMethod(slug);

    console.log(user);

    return { ...user };
  }

  public render() {
    return (
      <Layout {...this.props}>
        <Head>
          <title>Index page</title>
          <meta name="description" content="This is a description of the Index page" />
        </Head>
        <div style={{ padding: "0px 30px", fontSize: "15px", height: "100%" }}>
          <p>Content on Index page</p>
          <Link href="/your-settings" as="/your-settings">
            Go to Your Settings page
          </Link>
          <p />
          <Button
            variant="contained"
            onClick={() =>
              confirm({
                title: "Are you sure?",
                message: "explanatory message",
                onAnswer: async (answer) => {
                  // console.log(answer);
                  if (!answer) {
                    return;
                  }

                  NProgress.start();

                  try {
                    notify("You successfully confirmed.");
                  } catch (error) {
                    console.error(error);
                    notify(error);
                  } finally {
                    NProgress.done();
                  }
                },
              })
            }
          >
            Test Confirmer and Notifier
          </Button>
          <p>Your email: {this.props.user.email}</p>
          <p>Your username: {this.props.user.displayName}</p>
        </div>
      </Layout>
    );
  }
}

export default Index;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\pages\login.tsx -----

import Head from 'next/head';
import React from 'react';
import LoginButton from '../components/common/LoginButton';
import Layout from '../components/layout';
import withAuth from '../lib/withAuth';

class Login extends React.Component {
  public render() {
    return (
      <Layout {...this.props}>
        <div style={{ textAlign: 'center', margin: '0 20px' }}>
          <Head>
            <title>Log in to SaaS boilerplate by Async</title>
            <meta
              name="description"
              content="Login and signup page for SaaS boilerplate demo by Async"
            />
          </Head>
          <br />
          <p style={{ margin: '45px auto', fontSize: '44px', fontWeight: 400 }}>Log in</p>
          <p>Youll be logged in for 14 days unless you log out manually.</p>
          <br />

          <LoginButton />
        </div>
      </Layout>
    );
  }
}

export default withAuth(Login, { logoutRequired: true });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\pages\your-settings.tsx -----

import Avatar from "@mui/material/Avatar";
import Button from "@mui/material/Button";
import TextField from "@mui/material/TextField";
import Head from "next/head";
import NProgress from "nprogress";
import * as React from "react";

import Layout from "../components/layout";

import { updateProfileApiMethod } from "../lib/api/public";
import { getSignedRequestForUploadApiMethod, uploadFileUsingSignedPutRequestApiMethod } from "../lib/api/team-member";

import { resizeImage } from "../lib/resizeImage";

import notify from "../lib/notify";

import withAuth from "../lib/withAuth";

type Props = {
  isMobile: boolean;
  user: { email: string; displayName: string; slug: string; avatarUrl: string };
};

type State = { newName: string; newAvatarUrl: string; disabled: boolean };

class YourSettings extends React.Component<Props, State> {
  // public static async getInitialProps(ctx) {
  //   const user = await getUserApiMethod(ctx.req);

  //   console.log(user);

  //   return { ...user };
  // }

  // public static async getInitialProps() {
  //   const slug = 'team-builder-book';

  //   const user = await getUserBySlugApiMethod(slug);

  //   console.log(user);

  //   return { ...user };
  // }

  constructor(props) {
    super(props);

    this.state = {
      newName: this.props.user.displayName,
      newAvatarUrl: this.props.user.avatarUrl,
      disabled: false,
    };
  }

  public render() {
    const { user } = this.props;
    const { newName, newAvatarUrl } = this.state;

    return (
      <Layout {...this.props}>
        <Head>
          <title>Your Settings at Async</title>
          <meta name="description" content="description" />
        </Head>
        <div
          style={{
            padding: this.props.isMobile ? "0px" : "0px 30px",
            fontSize: "15px",
            height: "100%",
          }}
        >
          <h3>Your Settings</h3>
          <h4 style={{ marginTop: "40px" }}>Your account</h4>
          <ul>
            <li>
              Your email: <b>{user.email}</b>
            </li>
            <li>
              Your username: <b>{user.displayName}</b>
            </li>
          </ul>
          <form onSubmit={this.onSubmit} autoComplete="off">
            <h4>Your username</h4>
            <TextField
              autoComplete="off"
              value={newName}
              helperText="Your username as seen by your team members"
              onChange={(event) => {
                this.setState({ newName: event.target.value });
              }}
            />
            <br />
            <br />
            <Button variant="contained" color="primary" type="submit" disabled={this.state.disabled}>
              Update username
            </Button>
          </form>

          <br />
          <h4>Your photo</h4>
          <Avatar
            src={newAvatarUrl}
            style={{
              display: "inline-flex",
              verticalAlign: "middle",
              marginRight: 20,
              width: 60,
              height: 60,
            }}
          />
          <label htmlFor="upload-file-user-avatar">
            <Button variant="outlined" color="primary" component="span" disabled={this.state.disabled}>
              Update avatar
            </Button>
          </label>
          <input
            accept="image/*"
            name="upload-file-user-avatar"
            id="upload-file-user-avatar"
            type="file"
            style={{ display: "none" }}
            onChange={this.uploadFile}
          />
          <p />
          <br />
        </div>
      </Layout>
    );
  }

  private onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();

    const { newName, newAvatarUrl } = this.state;

    console.log(newName);

    if (!newName) {
      notify("Name is required");
      return;
    }

    NProgress.start();
    this.setState({ disabled: true });

    try {
      await updateProfileApiMethod({
        name: newName,
        avatarUrl: newAvatarUrl,
      });

      notify("You successfully updated your profile.");
    } catch (error) {
      notify(error);
    } finally {
      this.setState({ disabled: false });
      NProgress.done();
    }
  };

  private uploadFile = async () => {
    const fileElement = document.getElementById("upload-file-user-avatar") as HTMLFormElement;
    const file = fileElement.files[0];

    if (file == null) {
      notify("No file selected for upload.");
      return;
    }

    const fileName = file.name;
    const fileType = file.type;

    NProgress.start();
    this.setState({ disabled: true });

    const bucket = process.env.NEXT_PUBLIC_BUCKET_FOR_AVATARS;

    const prefix = "team-builder-book";

    try {
      const responseFromApiServerForUpload = await getSignedRequestForUploadApiMethod({
        fileName,
        fileType,
        prefix,
        bucket,
      });

      const resizedFile = await resizeImage(file, 128, 128);

      console.log(file);
      console.log(resizedFile);

      await uploadFileUsingSignedPutRequestApiMethod(resizedFile, responseFromApiServerForUpload.signedRequest, {
        "Cache-Control": "max-age=2592000",
      });

      this.setState({
        newAvatarUrl: responseFromApiServerForUpload.url,
      });

      await updateProfileApiMethod({
        name: this.state.newName,
        avatarUrl: this.state.newAvatarUrl,
      });

      notify("You successfully uploaded new avatar.");
    } catch (error) {
      notify(error);
    } finally {
      fileElement.value = "";
      this.setState({ disabled: false });
      NProgress.done();
    }
  };
}

export default withAuth(YourSettings);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\pages\_app.tsx -----

import CssBaseline from "@mui/material/CssBaseline";
import { ThemeProvider } from "@mui/material";
import App from "next/app";
import Head from "next/head";
import React from "react";
import { isMobile } from "../lib/isMobile";
import { themeDark, themeLight } from "../lib/theme";

class MyApp extends App {
  public static async getInitialProps({ Component, ctx }) {
    let firstGridItem = true;

    if (ctx.pathname.includes("/login")) {
      firstGridItem = false;
    }

    const pageProps = { isMobile: isMobile({ req: ctx.req }), firstGridItem };

    if (Component.getInitialProps) {
      Object.assign(pageProps, await Component.getInitialProps(ctx));
    }

    return { pageProps };
  }

  public componentDidMount() {
    // Remove the server-side injected CSS.
    const jssStyles = document.querySelector("#jss-server-side");
    if (jssStyles && jssStyles.parentNode) {
      jssStyles.parentNode.removeChild(jssStyles);
    }
  }
  public render() {
    const { Component, pageProps } = this.props;

    return (
      <ThemeProvider theme={false ? themeDark : themeLight}>
        <Head>
          <meta name="viewport" content="width=device-width, initial-scale=1.0" />
          <link rel="stylesheet" href="https://storage.googleapis.com/async-await/nprogress-dark.min.css?v=1" />
        </Head>
        <CssBaseline />
        <Component {...pageProps} />
      </ThemeProvider>
    );
  }
}

export default MyApp;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\pages\_document.tsx -----

import Document, { Head, Html, Main, NextScript } from "next/document";
import React from "react";

class MyDocument extends Document {
  public static getInitialProps = async (ctx) => {
    const initialProps = await Document.getInitialProps(ctx);

    return {
      ...initialProps,
    };
  };

  public render() {
    // console.log('rendered on the server');

    return (
      <Html lang="en">
        <Head>
          <meta charSet="utf-8" />
          <meta name="google" content="notranslate" />
          <meta name="theme-color" content="#303030" />

          <link rel="shortcut icon" href="https://storage.googleapis.com/async-await/async-favicon32.png" />

          <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons" />
          <link rel="stylesheet" href="https://storage.googleapis.com/async-await/vs2015.min.css" />

          <style>
            {`
              #__next {
                width: 100%;
                height: 100%;
              }
              a {
                font-weight: 400;
                color: #58a6ff;
                text-decoration: none;
                outline: none;
              }
              hr {
                border: 0.5px #707070 solid;
                color: #000;
              }
              blockquote {
                padding: 0 0.5em;
                margin: 20px 1em;
                border-left: 0.25em solid #dfe2e5;
                color: #000;
              }
              pre {
                display: block;
                overflow-x: auto;
                padding: 0.5em;
                background: #d0d0d0;
                border: 1px solid #ddd;
                font-size: 14px;
                color: #000;
              }
              pre code {
                font-size: 13px;
                background: #d0d0d0;
                padding: 0px;
                color: #000;
              }
              code {
                font-size: 13px;
                background: #d0d0d0;
                padding: 3px 5px;
                color: #000;
              }
              mark {
                background-color: #ffff0060;
              }
              summary:focus {
                outline: none;
              }
              table {
                border-collapse: collapse;
                margin: 15px 0px;
              }
              table, th, td {
                border: 1px solid #a1a1a1;
              }
              th, td {
                line-height: 1.5em;
                padding: 10px;
              }
            `}
          </style>
        </Head>
        <body>
          <Main />
          <NextScript />
        </body>
      </Html>
    );
  }
}

export default MyDocument;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\server\server.ts -----

import express from 'express';
import next from 'next';

const NODE_ENV = process.env.NODE_ENV || 'development';
const IS_DEV = NODE_ENV !== 'production';

const app = next({ dev: IS_DEV });
const handle = app.getRequestHandler();

app.prepare().then(() => {
  const server = express();

  // give all Nextjs's request to Nextjs before anything else
  server.get('/_next/*', (req, res) => {
    // console.log('next server, page');
    handle(req, res);
  });

  server.use(express.json());

  // server.get('/api/v1/public/get-user', (_, res) => {
  //   res.json({ user: { email: 'team@builderbook.org' } });
  // });

  server.all('*', (req, res) => {
    handle(req, res);
  });

  server.listen(process.env.NEXT_PUBLIC_PORT_APP, () => {
    console.log(`> Ready on ${process.env.NEXT_PUBLIC_URL_APP}`);
  });
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\.eslintrc.js -----

module.exports = {
  settings: {
    react: { version: 'detect' },
  },
  parser: '@typescript-eslint/parser',
  extends: ['plugin:react/recommended', 'plugin:@typescript-eslint/recommended', 'prettier'],
  env: {
    es6: true,
    node: true,
  },
  plugins: ['prettier', 'react'],
  rules: {
    'prettier/prettier': [
      'error',
      {
        singleQuote: true,
        trailingComma: 'all',
        arrowParens: 'always',
        printWidth: 100,
        semi: true,
      },
    ],
    '@typescript-eslint/camelcase': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    'react/no-unescaped-entities': 'off',
    'react/jsx-filename-extension': ['error', { extensions: ['.tsx'] }],
    '@typescript-eslint/no-explicit-any': 'off',
    'prefer-arrow-callback': 'error',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
  },
};

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\next-env.d.ts -----

/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/pages/api-reference/config/typescript for more information.

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\next.config.js -----

module.exports = {
  poweredByHeader: false,
  webpack5: true,
  typescript: {
    ignoreBuildErrors: true,
  },
};

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\nodemon.json -----

{
  "watch": ["server"],
  "exec": "ts-node --project tsconfig.server.json",
  "ext": "ts"
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\package.json -----

{
  "name": "6-begin-app",
  "version": "1",
  "license": "MIT",
  "scripts": {
    "dev": "nodemon server/server.ts",
    "build": "next build",
    "lint": "eslint . --ext .ts,.tsx"
  },
  "dependencies": {
    "@emotion/react": "^11.14.0",
    "@emotion/styled": "^11.14.0",
    "@mui/material": "^6.4.8",
    "@mui/system": "^6.4.8",
    "dotenv": "^16.4.7",
    "express": "^4.21.2",
    "isomorphic-unfetch": "^4.0.2",
    "next": "^15.2.3",
    "nprogress": "^0.2.0",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "typescript": "^5.8.2"
  },
  "devDependencies": {
    "@types/express": "^5.0.1",
    "@types/helmet": "^4.0.0",
    "@types/node": "^22.13.10",
    "@types/react": "^19.0.12",
    "@types/react-dom": "^19.0.4",
    "@typescript-eslint/eslint-plugin": "^8.27.0",
    "@typescript-eslint/parser": "^8.27.0",
    "eslint": "^9.22.0",
    "eslint-config-prettier": "^10.1.1",
    "eslint-plugin-prettier": "^5.2.3",
    "eslint-plugin-react": "^7.37.4",
    "nodemon": "^3.1.9",
    "prettier": "^3.5.3",
    "ts-node": "^10.9.2"
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\tsconfig.json -----

{
  "compileOnSave": false,
  "compilerOptions": {
    "target": "esnext",
    "module": "esnext",
    "jsx": "preserve",
    "allowJs": true,
    "alwaysStrict": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "removeComments": true,
    "preserveConstEnums": true,
    "sourceMap": false,
    "skipLibCheck": true,
    "baseUrl": ".",
    "typeRoots": [
      "./node_modules/@types"
    ],
    "lib": [
      "dom",
      "es2017"
    ],
    "strict": false,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "incremental": true
  },
  "include": [
    "next-env.d.ts",
    "./**/*.tsx",
    "./**/*.ts"
  ],
  "exclude": [
    "dist",
    "production-server",
    ".next",
    "out",
    "next.config.js",
    "node_modules"
  ]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-begin\app\tsconfig.server.json -----

{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "module": "commonjs",
    "outDir": "production-server/",
    "target": "es2017",
    "isolatedModules": false,
    "noEmit": false
  },
  "exclude": ["./server/types.d.ts"],
  "include": ["./server/**/*.ts"],
  "typeRoots": ["./node_modules/@types", "./server/types.d.ts"]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\api\server\api\index.ts -----

import * as express from 'express';

import publicExpressRoutes from './public';
import teamMemberExpressRoutes from './team-member';

function handleError(err, _, res, __) {
  console.error(err.stack);

  res.json({ error: err.message || err.toString() });
}

export default function api(server: express.Express) {
  server.use('/api/v1/public', publicExpressRoutes, handleError);
  server.use('/api/v1/team-member', teamMemberExpressRoutes, handleError);
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\api\server\api\public.ts -----

import * as express from 'express';

import User from '../models/User';

const router = express.Router();

router.get('/get-user', (req, res) => {
  console.log(req.user);
  res.json({ user: req.user || null });
});

router.post('/get-user-by-slug', async (req, res, next) => {
  console.log('Express route: /get-user-by-slug');

  // req.session.foo = 'bar';

  try {
    const { slug } = req.body;

    const user = await User.getUserBySlug({ slug });

    res.json({ user });
  } catch (err) {
    next(err);
  }
});

router.post('/user/update-profile', async (req: any, res, next) => {
  try {
    const { name, avatarUrl } = req.body;

    const updatedUser = await User.updateProfile({
      userId: req.user.id,
      name,
      avatarUrl,
    });

    res.json({ updatedUser });
  } catch (err) {
    next(err);
  }
});

export default router;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\api\server\api\team-member.ts -----

import * as express from 'express';

import { signRequestForUpload } from '../aws-s3';

const router = express.Router();

router.use((req, res, next) => {
  console.log('team member API', req.path);
  if (!req.user) {
    res.status(401).json({ error: 'Unauthorized' });
    return;
  }

  next();
});

// Get signed request from AWS S3 server
router.post('/aws/get-signed-request-for-upload-to-s3', async (req, res, next) => {
  try {
    const { fileName, fileType, prefix, bucket } = req.body;

    const returnData = await signRequestForUpload({
      fileName,
      fileType,
      prefix,
      bucket,
    });

    console.log(returnData);

    res.json(returnData);
  } catch (err) {
    next(err);
  }
});

export default router;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\api\server\models\EmailTemplate.ts -----

import * as _ from 'lodash';
import * as mongoose from 'mongoose';

interface EmailTemplateDocument extends mongoose.Document {
  name: string;
  subject: string;
  message: string;
}

const EmailTemplate = mongoose.model<EmailTemplateDocument>(
  'EmailTemplate',
  new mongoose.Schema({
    name: {
      type: String,
      required: true,
      unique: true,
    },
    subject: {
      type: String,
      required: true,
    },
    message: {
      type: String,
      required: true,
    },
  }),
);

export async function insertTemplates() {
  const templates = [
    {
      name: 'welcome',
      subject: 'Welcome to SaaS boilerplate by Async',
      message: `Welcome <%= userName %>,
        <p>
          Thanks for signing up on our <a href="https://github.com/async-labs/saas" target="blank">SaaS boilerplate</a>!
        </p>
        <p>
          If you are learning how to build a SaaS web app, check out our 2 books:
           <a href="https://builderbook.org" target="blank">Builder Book</a>
           and
           <a href="https://builderbook.org/book" target="blank">SaaS Boilerplate</a>.
        </p>
        <p>
          Also check out
          <a href="https://async-await.com" target="blank"> Async</a>
          , our communication tool for small teams of software developers.
        </p>
        Kelly & Timur, Team Async
      `,
    },
    {
      name: 'login',
      subject: 'Login link for saas-app.async-await.com',
      message: `
        <p>Log into your account by clicking on this link: <a href="<%= loginURL %>"><%= loginURL %></a>.</p>`,
    },
  ];

  for (const t of templates) {
    const et = await EmailTemplate.findOne({ name: t.name }).setOptions({ lean: true });
    const message = t.message.replace(/\n/g, '').replace(/[ ]+/g, ' ').trim();

    if (!et) {
      EmailTemplate.create(Object.assign({}, t, { message }));
    } else if (et.subject !== t.subject || et.message !== message) {
      EmailTemplate.updateOne({ _id: et._id }, { $set: { message, subject: t.subject } }).exec();
    }
  }
}

export default async function getEmailTemplate(name: string, params: any) {
  await insertTemplates();

  const et = await EmailTemplate.findOne({ name }).setOptions({ lean: true });

  if (!et) {
    throw new Error('Email Template is not found in database.');
  }

  return {
    message: _.template(et.message)(params),
    subject: _.template(et.subject)(params),
  };
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\api\server\models\User.ts -----

import * as _ from 'lodash';
import * as mongoose from 'mongoose';

import sendEmail from '../aws-ses';
import { addToMailchimp } from '../mailchimp';
import { generateSlug } from '../utils/slugify';
import getEmailTemplate from './EmailTemplate';

const mongoSchema = new mongoose.Schema({
  slug: {
    type: String,
    required: true,
    unique: true,
  },
  createdAt: {
    type: Date,
    required: true,
  },
  email: {
    type: String,
    required: true,
    unique: true,
  },
  displayName: String,
  avatarUrl: String,
  googleId: {
    type: String,
    unique: true,
    sparse: true,
  },
  googleToken: {
    accessToken: String,
    refreshToken: String,
  },
  isSignedupViaGoogle: {
    type: Boolean,
    required: true,
    default: false,
  },
});

export interface UserDocument extends mongoose.Document {
  slug: string;
  createdAt: Date;
  email: string;
  displayName: string;
  avatarUrl: string;
  googleId: string;
  googleToken: { accessToken: string; refreshToken: string };
  isSignedupViaGoogle: boolean;
}

interface UserModel extends mongoose.Model<UserDocument> {
  getUserBySlug({ slug }: { slug: string }): Promise<UserDocument>;

  updateProfile({
    userId,
    name,
    avatarUrl,
  }: {
    userId: string;
    name: string;
    avatarUrl: string;
  }): Promise<UserDocument[]>;

  publicFields(): string[];

  signInOrSignUpViaGoogle({
    googleId,
    email,
    displayName,
    avatarUrl,
    googleToken,
  }: {
    googleId: string;
    email: string;
    displayName: string;
    avatarUrl: string;
    googleToken: { accessToken?: string; refreshToken?: string };
  }): Promise<UserDocument>;

  signInOrSignUpByPasswordless({
    uid,
    email,
  }: {
    uid: string;
    email: string;
  }): Promise<UserDocument>;
}

class UserClass extends mongoose.Model {
  public static async getUserBySlug({ slug }) {
    console.log('Static method: getUserBySlug');

    return this.findOne({ slug }, 'email displayName avatarUrl').setOptions({ lean: true });
  }

  public static async updateProfile({ userId, name, avatarUrl }) {
    console.log('Static method: updateProfile');

    const user = await this.findById(userId, 'slug displayName');

    const modifier = { displayName: user.displayName, avatarUrl, slug: user.slug };

    console.log(user.slug);

    if (name !== user.displayName) {
      modifier.displayName = name;
      modifier.slug = await generateSlug(this, name);
    }

    return this.findByIdAndUpdate(userId, { $set: modifier }, { new: true, runValidators: true })
      .select('displayName avatarUrl slug')
      .setOptions({ lean: true });
  }

  public static publicFields(): string[] {
    return ['_id', 'id', 'displayName', 'email', 'avatarUrl', 'slug', 'isSignedupViaGoogle'];
  }

  public static async signInOrSignUpViaGoogle({
    googleId,
    email,
    displayName,
    avatarUrl,
    googleToken,
  }) {
    const user = await this.findOne({ email })
      .select([...this.publicFields(), 'googleId'].join(' '))
      .setOptions({ lean: true });

    if (user) {
      if (_.isEmpty(googleToken) && user.googleId) {
        return user;
      }

      const modifier = { googleId };
      if (googleToken.accessToken) {
        modifier['googleToken.accessToken'] = googleToken.accessToken;
      }

      if (googleToken.refreshToken) {
        modifier['googleToken.refreshToken'] = googleToken.refreshToken;
      }

      await this.updateOne({ email }, { $set: modifier });

      return user;
    }

    const slug = await generateSlug(this, displayName);

    const newUser = await this.create({
      createdAt: new Date(),
      googleId,
      email,
      googleToken,
      displayName,
      avatarUrl,
      slug,
      isSignedupViaGoogle: true,
      darkTheme: false,
    });

    const emailTemplate = await getEmailTemplate('welcome', { userName: displayName });

    if (!emailTemplate) {
      throw new Error('Welcome email template not found');
    }

    try {
      await sendEmail({
        from: `Kelly from saas-app.async-await.com <${process.env.EMAIL_SUPPORT_FROM_ADDRESS}>`,
        to: [email],
        subject: emailTemplate.subject,
        body: emailTemplate.message,
      });
    } catch (err) {
      console.error('Email sending error:', err);
    }

    try {
      await addToMailchimp({ email, listName: 'signups' });
    } catch (error) {
      console.error('Mailchimp error:', error);
    }

    return _.pick(newUser, this.publicFields());
  }

  public static async signInOrSignUpByPasswordless({ uid, email }) {
    const user = await this.findOne({ email })
      .select(this.publicFields().join(' '))
      .setOptions({ lean: true });

    if (user) {
      throw Error('User already exists');
    }

    const slug = await generateSlug(this, email);

    const newUser = await this.create({
      _id: uid,
      createdAt: new Date(),
      email,
      slug,
    });

    const emailTemplate = await getEmailTemplate('welcome', { userName: email });

    if (!emailTemplate) {
      throw new Error('Email template "welcome" not found in database.');
    }

    try {
      await sendEmail({
        from: `Kelly from saas-app.async-await.com <${process.env.EMAIL_SUPPORT_FROM_ADDRESS}>`,
        to: [email],
        subject: emailTemplate.subject,
        body: emailTemplate.message,
      });
    } catch (err) {
      console.error('Email sending error:', err);
    }

    try {
      await addToMailchimp({ email, listName: 'signups' });
    } catch (error) {
      console.error('Mailchimp error:', error);
    }

    return _.pick(newUser, this.publicFields());
  }
}

mongoSchema.loadClass(UserClass);

const User = mongoose.model<UserDocument, UserModel>('User', mongoSchema);

export default User;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\api\server\utils\slugify.ts -----

import * as _ from 'lodash';

const slugify = (text) => _.kebabCase(text);

async function createUniqueSlug(Model, slug, count, filter) {
  const obj = await Model.findOne({ slug: `${slug}-${count}`, ...filter })
    .select('_id')
    .setOptions({ lean: true });

  if (!obj) {
    return `${slug}-${count}`;
  }

  return createUniqueSlug(Model, slug, count + 1, filter);
}

async function generateSlug(Model, name, filter = {}) {
  const origSlug = slugify(name);

  const obj = await Model.findOne({ slug: origSlug, ...filter })
    .select('_id')
    .setOptions({ lean: true });

  if (!obj) {
    return origSlug;
  }

  return createUniqueSlug(Model, origSlug, 1, filter);
}

export { generateSlug };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\api\server\utils\sum.ts -----

function sum(a, b) {
  return a + b;
}

export { sum };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\api\server\aws-s3.ts -----

import * as url from 'url';
import * as aws from 'aws-sdk';

async function signRequestForUpload({ fileName, fileType, prefix, bucket }) {
  const randomStringForPrefix =
    Math.random().toString(36).substring(2, 12) + Math.random().toString(36).substring(2, 12);

  const key = `${prefix}/${randomStringForPrefix}/${fileName}`;

  const acl = 'public-read';

  const params = {
    Bucket: bucket,
    Key: key,
    Expires: 60,
    ContentType: fileType,
    ACL: acl,
  };

  console.log(prefix);

  const s3 = new aws.S3({
    apiVersion: 'latest',
    region: process.env.AWS_REGION,
    accessKeyId: process.env.AWS_ACCESSKEYID,
    secretAccessKey: process.env.AWS_SECRETACCESSKEY,
  });

  return new Promise((resolve, reject) => {
    s3.getSignedUrl('putObject', params, (err, data) => {
      const parsedUrl = url.parse(data);

      const returnData = {
        signedRequest: data,
        url: `${parsedUrl.protocol}//${parsedUrl.hostname}${parsedUrl.pathname}`,
      };

      if (err) {
        console.error(err);
        reject(err);
      } else {
        resolve(returnData);
      }
    });
  });
}

export { signRequestForUpload };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\api\server\aws-ses.ts -----

import * as aws from 'aws-sdk';

export default function sendEmail(options) {
  const ses = new aws.SES({
    apiVersion: 'latest',
    region: process.env.AWS_REGION,
    accessKeyId: process.env.AWS_ACCESSKEYID,
    secretAccessKey: process.env.AWS_SECRETACCESSKEY,
  });

  return new Promise((resolve, reject) => {
    ses.sendEmail(
      {
        Source: options.from,
        Destination: {
          CcAddresses: options.cc,
          ToAddresses: options.to,
        },
        Message: {
          Subject: {
            Data: options.subject,
          },
          Body: {
            Html: {
              Data: options.body,
            },
          },
        },
        ReplyToAddresses: options.replyTo,
      },
      (err, info) => {
        if (err) {
          reject(err);
        } else {
          resolve(info);
        }
      },
    );
  });
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\api\server\google-auth.ts -----

import * as passport from 'passport';
import { OAuth2Strategy as Strategy } from 'passport-google-oauth';

import User, { UserDocument } from './models/User';

function setupGoogle({ server }) {
  if (!process.env.GOOGLE_CLIENTID) {
    return;
  }

  const verify = async (accessToken, refreshToken, profile, done) => {
    let email;
    let avatarUrl;

    if (profile.emails) {
      email = profile.emails[0].value;
    }

    if (profile.photos && profile.photos.length > 0) {
      avatarUrl = profile.photos[0].value.replace('sz=50', 'sz=128');
    }

    try {
      const user = await User.signInOrSignUpViaGoogle({
        googleId: profile.id,
        email,
        googleToken: { accessToken, refreshToken },
        displayName: profile.displayName,
        avatarUrl,
      });

      done(null, user);
    } catch (err) {
      done(err);
      console.error(err);
    }
  };

  passport.use(
    new Strategy(
      {
        clientID: process.env.GOOGLE_CLIENTID,
        clientSecret: process.env.GOOGLE_CLIENTSECRET,
        callbackURL: `${process.env.URL_API}/oauth2callback`,
      },
      verify,
    ),
  );

  passport.serializeUser((user: UserDocument, done) => {
    done(null, user._id);
  });

  passport.deserializeUser((id, done) => {
    User.findById(id, User.publicFields())
      .then((user) => {
        done(null, user);
      })
      .catch((error) => {
        done(error, null);
      });
  });

  server.use(passport.initialize());
  server.use(passport.session());

  server.get('/auth/google', (req, res, next) => {
    const options = {
      scope: ['profile', 'email'],
      prompt: 'select_account',
    };

    passport.authenticate('google', options)(req, res, next);

    console.log('/auth/google');
  });

  server.get(
    '/oauth2callback',
    passport.authenticate('google', {
      failureRedirect: '/login',
    }),
    (_, res) => {
      console.log('/oauth2callback');
      res.redirect(`${process.env.URL_APP}/your-settings`);
    },
  );

  // server.get('/logout', (req, res, next) => {
  //  req.logout((err) => {
  //    if (err) {
  //      next(err);
  //    }
  //    res.redirect(`${process.env.URL_APP}/login`);
  //  });
  //});
}

export { setupGoogle };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\api\server\mailchimp.ts -----

import fetch, { Response } from 'node-fetch';

// eslint-disable-next-line
require('dotenv').config();

const LIST_IDS = {
  signups: process.env.MAILCHIMP_SAAS_ALL_LIST_ID,
};

function callAPI({ path, method, data }): Promise<Response> {
  const ROOT_URI = `https://${process.env.MAILCHIMP_REGION}.api.mailchimp.com/3.0`;

  return fetch(`${ROOT_URI}${path}`, {
    method,
    headers: {
      Accept: 'application/json',
      Authorization: `Basic ${Buffer.from(`apikey:${process.env.MAILCHIMP_API_KEY}`).toString(
        'base64',
      )}`,
    },
    body: JSON.stringify(data),
  });
}

async function addToMailchimp({ email, listName }) {
  const data = {
    // eslint-disable-next-line
    email_address: email,
    status: 'subscribed',
  };

  const path = `/lists/${LIST_IDS[listName]}/members/`;

  await callAPI({ path, method: 'POST', data });
}

export { addToMailchimp };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\api\server\passwordless-auth.ts -----

import * as passwordless from 'passwordless';

import sendEmail from './aws-ses';
import getEmailTemplate from './models/EmailTemplate';
import User from './models/User';
import PasswordlessMongoStore from './passwordless-token-mongostore';

function setupPasswordless({ server }) {
  const mongoStore = new PasswordlessMongoStore();

  passwordless.addDelivery(async (tokenToSend, uidToSend, recipient, callback) => {
    try {
      const template = await getEmailTemplate('login', {
        loginURL: `${
          process.env.URL_API
        }/auth/logged_in?token=${tokenToSend}&uid=${encodeURIComponent(uidToSend)}`,
      });

      await sendEmail({
        from: `Kelly from saas-app.async-await.com <${process.env.EMAIL_SUPPORT_FROM_ADDRESS}>`,
        to: [recipient],
        subject: template.subject,
        body: template.message,
      });

      callback();
    } catch (err) {
      console.error('Email sending error:', err);
      callback(err);
    }
  });

  passwordless.init(mongoStore);
  server.use(passwordless.sessionSupport());

  server.use((req, __, next) => {
    if (req.user && typeof req.user === 'string') {
      User.findById(req.user, User.publicFields())
        .then((user) => {
          req.user = user;
          console.log('passwordless middleware');
          next();
        })
        .catch((err) => {
          next(err);
        });
    } else {
      next();
    }
  });

  server.post(
    '/auth/email-login-link',
    passwordless.requestToken(async (email, __, callback) => {
      try {
        const user = await User.findOne({ email }).select('_id').setOptions({ lean: true });

        if (user) {
          callback(null, user._id);
        } else {
          const id = await mongoStore.storeOrUpdateByEmail(email);
          callback(null, id);
        }
      } catch (error) {
        callback(error, null);
      }
    }),
    (_, res) => {
      res.json({ done: 1 });
    },
  );

  server.get(
    '/auth/logged_in',
    passwordless.acceptToken(),
    (req, __, next) => {
      if (req.user && typeof req.user === 'string') {
        User.findById(req.user, User.publicFields())
          .then((user) => {
            req.user = user;
            next();
          })
          .catch((err) => {
            next(err);
          });
      } else {
        next();
      }
    },
    (_, res) => {
      res.redirect(`${process.env.URL_APP}/your-settings`);
    },
  );

  server.get('/logout', (req, res, next) => {
    req.logout((err) => {
      if (err) {
        next(err);
      }
      res.redirect(`${process.env.URL_APP}/login`);
    });
  });
}

export { setupPasswordless };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\api\server\passwordless-token-mongostore.ts -----

import * as bcrypt from 'bcrypt';
import * as mongoose from 'mongoose';
import * as TokenStore from 'passwordless-tokenstore';
import * as util from 'util';

import User from './models/User';

interface TokenDocument extends mongoose.Document {
  hashedToken: string;
  uid: string;
  ttl: Date;
  originUrl: string;
  email: string;
}

const mongoSchema = new mongoose.Schema({
  hashedToken: {
    type: String,
    required: true,
  },
  uid: {
    type: String,
    required: true,
    unique: true,
  },
  ttl: {
    type: Date,
    required: true,
    expires: 0,
  },
  originUrl: String,
  email: String,
});

const PasswordlessToken = mongoose.model<TokenDocument>(
  'PasswordlessToken',
  mongoSchema,
  'passwordless-token',
);

function MongoStore(options = {}) {
  TokenStore.call(this);

  this._options = options || {};
}

util.inherits(MongoStore, TokenStore);

MongoStore.prototype.authenticate = async function (token, uid, callback) {
  if (!token || !uid || !callback) {
    throw new Error('TokenStore:authenticate called with invalid parameters');
  }

  try {
    const tokenDoc = await PasswordlessToken.findOne({ uid, ttl: { $gt: new Date() } }).setOptions({
      lean: true,
    });

    if (tokenDoc) {
      const isMatch = await bcrypt.compare(token, tokenDoc.hashedToken);
      if (isMatch) {
        if (tokenDoc.email) {
          await User.signInOrSignUpByPasswordless({ uid, email: tokenDoc.email });
        }

        callback(null, true, tokenDoc.originUrl);
      } else {
        callback(null, false, null);
      }
    } else {
      callback(null, false, null);
    }
  } catch (error) {
    callback(error, false, null);
  }
};

MongoStore.prototype.storeOrUpdate = async function (token, uid, msToLive, originUrl, callback) {
  if (!token || !uid || !msToLive || !callback) {
    throw new Error('TokenStore:storeOrUpdate called with invalid parameters');
  }

  const saltRounds = 10;

  try {
    const hashedToken = await bcrypt.hash(token, saltRounds);
    const newRecord = { hashedToken, uid, ttl: new Date(Date.now() + msToLive), originUrl };

    await PasswordlessToken.updateOne(
      { uid },
      { $set: newRecord },
      { upsert: true, runValidators: true },
    );
    callback();
  } catch (error) {
    callback(error);
  }
};

MongoStore.prototype.invalidateUser = async function (uid, callback) {
  if (!uid || !callback) {
    throw new Error('TokenStore:invalidateUser called with invalid parameters');
  }

  try {
    await PasswordlessToken.deleteOne({ uid });
    callback();
  } catch (error) {
    callback(error);
  }
};

MongoStore.prototype.clear = async function (callback) {
  if (!callback) {
    throw new Error('TokenStore:clear called with invalid parameters');
  }

  try {
    await PasswordlessToken.deleteMany({});
    callback();
  } catch (error) {
    callback(error);
  }
};

MongoStore.prototype.length = function (callback) {
  PasswordlessToken.countDocuments(callback);
};

MongoStore.prototype.storeOrUpdateByEmail = async function addEmail(email: string) {
  if (!email) {
    throw new Error('TokenStore:addEmail called with invalid parameters');
  }

  const obj = await PasswordlessToken.findOne({ email }).select('uid').setOptions({ lean: true });

  if (obj) {
    return obj.uid;
  }

  const uid = new mongoose.Types.ObjectId().toHexString();
  await PasswordlessToken.updateOne({ uid }, { email }, { upsert: true });

  return uid;
};

export default MongoStore;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\api\server\server.ts -----

// eslint-disable-next-line @typescript-eslint/no-var-requires
const MongoStore = require('connect-mongo');

import * as cors from 'cors';
import * as express from 'express';
import * as session from 'express-session';
import * as mongoose from 'mongoose';

import api from './api';
import { setupGoogle } from './google-auth';
import { setupPasswordless } from './passwordless-auth';

// eslint-disable-next-line
require('dotenv').config();

mongoose.connect(process.env.MONGO_URL_TEST);

const server = express();

server.use(
  cors({
    origin: process.env.URL_APP,
    methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',
    credentials: true,
  }),
);

server.use(express.json());

const sessionOptions = {
  name: process.env.SESSION_NAME,
  secret: process.env.SESSION_SECRET,
  resave: false,
  saveUninitialized: false,
  store: MongoStore.create({
    mongoUrl: process.env.MONGO_URL_TEST,
    ttl: 14 * 24 * 60 * 60, // save session 14 days
    autoRemove: 'interval',
    autoRemoveInterval: 1440, // clears every day
  }),
  cookie: {
    httpOnly: true,
    maxAge: 14 * 24 * 60 * 60 * 1000, // expires in 14 days
    secure: false,
  },
};

const sessionMiddleware = session(sessionOptions);
server.use(sessionMiddleware);

setupGoogle({ server });
setupPasswordless({ server });

api(server);

server.get('*', (_, res) => {
  res.sendStatus(403);
});

server.listen(process.env.PORT_API, () => {
  console.log(`> Ready on ${process.env.URL_API}`);
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\api\test\server\utils\slugify.test.ts -----

import * as mongoose from 'mongoose';
import User from '../../../server/models/User';
import { generateSlug } from '../../../server/utils/slugify';

// eslint-disable-next-line
require('dotenv').config();

describe('slugify', () => {
  beforeAll(async () => {
    await mongoose.connect(process.env.MONGO_URL_TEST);

    const mockUsers = [
      {
        slug: 'john',
        email: 'john@example.com',
        createdAt: new Date(),
        displayName: 'abc',
        avatarUrl: 'def',
      },
      {
        slug: 'john-johnson',
        email: 'john-johnson@example.com',
        createdAt: new Date(),
        displayName: 'abc',
        avatarUrl: 'def',
      },
      {
        slug: 'john-johnson-1',
        email: 'john-johnson-1@example.com',
        createdAt: new Date(),
        displayName: 'abc',
        avatarUrl: 'def',
      },
    ];

    await User.insertMany(mockUsers);
  });

  test('not duplicated', async () => {
    expect.assertions(1);

    await expect(generateSlug(User, 'John J Johnson@#$')).resolves.toEqual('john-j-johnson');
  });

  test('one time duplicated', async () => {
    expect.assertions(1);

    await expect(generateSlug(User, ' John@#$')).resolves.toEqual('john-1');
  });

  test('multiple duplicated', async () => {
    expect.assertions(1);

    await expect(generateSlug(User, 'John & Johnson@#$')).resolves.toEqual('john-johnson-2');
  });

  afterAll(async () => {
    await User.deleteMany({ slug: { $in: ['john', 'john-johnson', 'john-johnson-1'] } });
    await mongoose.disconnect();
  });
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\api\test\server\utils\sum.test.ts -----

import { sum } from '../../../server/utils/sum';

console.log(sum(1, 2));

describe.skip('testing sum function', () => {
  test('adds 1 + 2 to equal 3', () => {
    expect(sum(1, 2)).toBe(3);
  });
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\api\.eslintrc.js -----

module.exports = {
  parser: "@typescript-eslint/parser",
  extends: ["plugin:@typescript-eslint/recommended", "prettier"],
  env: {
    "es6": true,
    "node": true,
  },
  plugins: ["prettier"],
  rules: {
    'prettier/prettier': [
      'error',
      {
        singleQuote: true,
        trailingComma: 'all',
        arrowParens: 'always',
        printWidth: 100,
        semi: true,
      },
    ],
    '@typescript-eslint/no-unused-vars': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/no-explicit-any': 'off',
    'prefer-arrow-callback': 'error',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
 },
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\api\nodemon.json -----

{
  "watch": ["server"],
  "exec": "ts-node --project tsconfig.server.json",
  "ext": "ts"
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\api\package.json -----

{
  "name": "6-end-api",
  "version": "1",
  "license": "MIT",
  "scripts": {
    "dev": "nodemon server/server.ts",
    "lint": "eslint . --ext .ts,.tsx",
    "test": "jest"
  },
  "jest": {
    "preset": "ts-jest",
    "testPathIgnorePatterns": [
      "production-server"
    ],
    "testEnvironment": "node"
  },
  "dependencies": {
    "aws-sdk": "^2.1692.0",
    "bcrypt": "^5.1.1",
    "connect-mongo": "^5.1.0",
    "cors": "^2.8.5",
    "dotenv": "^16.4.7",
    "express": "^4.21.2",
    "express-session": "^1.18.1",
    "lodash": "^4.17.21",
    "mongoose": "^8.12.1",
    "node-fetch": "2",
    "passport": "^0.7.0",
    "passport-google-oauth": "^2.0.0",
    "passwordless": "^1.1.3",
    "passwordless-tokenstore": "^0.0.10",
    "typescript": "^5.8.2"
  },
  "devDependencies": {
    "@types/connect-mongo": "^3.1.6",
    "@types/dotenv": "^8.2.3",
    "@types/express": "^5.0.1",
    "@types/express-session": "^1.18.1",
    "@types/jest": "^29.5.14",
    "@types/lodash": "^4.17.16",
    "@types/mongoose": "^5.11.97",
    "@types/node": "^22.13.10",
    "@types/node-fetch": "^2.6.12",
    "@types/passport": "^1.0.17",
    "@typescript-eslint/eslint-plugin": "^8.27.0",
    "@typescript-eslint/parser": "^8.27.0",
    "eslint": "^9.22.0",
    "eslint-config-prettier": "^10.1.1",
    "eslint-plugin-prettier": "^5.2.3",
    "jest": "^29.7.0",
    "nodemon": "^3.1.9",
    "prettier": "^3.5.3",
    "ts-jest": "^29.2.6",
    "ts-node": "^10.9.2"
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\api\tsconfig.json -----

{
  "compileOnSave": false,
  "compilerOptions": {
    "jsx": "preserve",
    "allowJs": true,
    "alwaysStrict": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "removeComments": false,
    "preserveConstEnums": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "sourceMap": true,
    "skipLibCheck": true,
    "baseUrl": ".",
    "experimentalDecorators": true,
    "typeRoots": ["./node_modules/@types"],
    "lib": ["es2015", "es2016"]
  },
  "exclude": ["production-server", "node_modules"]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\api\tsconfig.server.json -----

{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "module": "commonjs",
    "outDir": "production-server/"
  },
  "include": ["./server/**/*.ts"],
  "exclude": ["./server/**/*.test.ts"]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\components\common\Confirmer.tsx -----

import Button from "@mui/material/Button";
import Dialog from "@mui/material/Dialog";
import DialogActions from "@mui/material/DialogActions";
import DialogContent from "@mui/material/DialogContent";
import DialogContentText from "@mui/material/DialogContentText";
import DialogTitle from "@mui/material/DialogTitle";
import React from "react";

export let openConfirmDialogExternal;

type State = {
  open: boolean;
  title: string;
  message: string;
  onAnswer: (answer) => void;
};

class Confirmer extends React.Component<any, State> {
  constructor(props) {
    super(props);

    this.state = {
      open: false,
      title: "Are you sure?",
      message: "",
      onAnswer: null,
    };

    openConfirmDialogExternal = this.openConfirmDialog;
  }

  public render() {
    return (
      <Dialog
        open={this.state.open}
        onClose={this.handleClose}
        aria-labelledby="alert-dialog-title"
        aria-describedby="alert-dialog-description"
      >
        <DialogTitle id="alert-dialog-title">{this.state.title}</DialogTitle>
        <DialogContent>
          <DialogContentText id="alert-dialog-description">{this.state.message}</DialogContentText>
        </DialogContent>
        <DialogActions style={{ padding: "10px" }}>
          <Button onClick={this.handleClose} variant="contained" color="primary" autoFocus>
            Cancel
          </Button>
          <Button onClick={this.handleYes} variant="contained" color="secondary">
            OK
          </Button>
        </DialogActions>
      </Dialog>
    );
  }

  public handleClose = () => {
    this.setState({ open: false });
    this.state.onAnswer(false);
  };

  public handleYes = () => {
    this.setState({ open: false });
    this.state.onAnswer(true);
  };

  public openConfirmDialog = ({ title, message, onAnswer }) => {
    this.setState({ open: true, title, message, onAnswer });
  };
}

export default Confirmer;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\components\common\LoginButton.tsx -----

import Button from "@mui/material/Button";
import TextField from "@mui/material/TextField";
import React from "react";

import { emailLoginLinkApiMethod } from "../../lib/api/public";
import notify from "../../lib/notify";

type State = { email: string };

class LoginButton extends React.PureComponent<any, State> {
  constructor(props) {
    super(props);

    this.state = { email: "" };
  }

  public render() {
    const url = `${process.env.NEXT_PUBLIC_URL_API}/auth/google`;

    console.log(url);

    return (
      <React.Fragment>
        <Button variant="contained" color="secondary" href={url}>
          <img src="https://storage.googleapis.com/async-await-all/G.svg" alt="Log in with Google" />
          &nbsp;&nbsp;&nbsp; Log in with Google
        </Button>
        <p />
        <br />
        <hr style={{ width: "60px" }} /> <h4>OR</h4> <hr style={{ width: "60px" }} />
        <p />
        <br />
        <div>
          <form autoComplete="off" onSubmit={this.onSubmit}>
            <TextField
              required
              type="email"
              label="Email address"
              value={this.state.email}
              onChange={(event) => {
                this.setState({ email: event.target.value });
              }}
              style={{ width: "300px" }}
            />
            <p />
            <Button variant="contained" color="primary" type="submit">
              Log in with email
            </Button>
          </form>
          <p />
          <br />
        </div>
      </React.Fragment>
    );
  }

  private onSubmit = async (event) => {
    event.preventDefault();
    const { email } = this.state;

    if (!email) {
      notify("Email is required");
    }

    try {
      await emailLoginLinkApiMethod({ email });
      this.setState({ email: "" });
      notify("SaaS boilerplate emailed you a login link.");
    } catch (error) {
      notify(error);
    }
  };
}

export default LoginButton;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\components\common\MenuWithLinks.tsx -----

import Menu from "@mui/material/Menu";
import MenuItem from "@mui/material/MenuItem";
import Link from "next/link";
import { NextRouter, withRouter } from "next/router";
import React from "react";

type Props = {
  options: {
    href: string;
    as: string;
    highlighterSlug: string;
    text: string;
    externalServer: boolean;
    separator: boolean;
  }[];
  router: NextRouter;
  children: any;
};

type State = {
  anchorEl: Element | ((element: Element) => Element);
};

class MenuWithLinks extends React.PureComponent<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      anchorEl: null,
    };
  }

  public render() {
    const { options, children, router } = this.props;
    const { anchorEl } = this.state;

    return (
      <div style={{ textAlign: "center" }}>
        <div
          aria-controls={anchorEl ? "simple-menu" : null}
          aria-haspopup="true"
          onClick={this.handleClick}
          onKeyPress={this.handleClick}
        >
          {children}
        </div>
        <Menu id="simple-menu" anchorEl={anchorEl} open={Boolean(anchorEl)} onClose={this.handleClose} keepMounted>
          {options.map((option, i) =>
            option.separator ? (
              <hr style={{ width: "95%", margin: "10px auto" }} key={`separated-${i}`} />
            ) : option.externalServer ? (
              <MenuItem
                onClick={(event) => {
                  event.preventDefault();
                  window.location.href = option.href;
                  this.handleClose();
                }}
                key={option.href || option.text}
              >
                {option.text}
              </MenuItem>
            ) : (
              <Link key={option.href} href={option.href} as={option.as} passHref>
                <MenuItem
                  key={option.href}
                  style={{
                    fontWeight: router.asPath.includes(option.highlighterSlug) ? 600 : 300,
                    fontSize: "14px",
                  }}
                >
                  {option.text}
                </MenuItem>
              </Link>
            )
          )}
        </Menu>
      </div>
    );
  }

  public handleClick = (event) => {
    this.setState({ anchorEl: event.currentTarget });
  };

  public handleClose = () => {
    this.setState({ anchorEl: null });
  };
}

export default withRouter(MenuWithLinks);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\components\common\Notifier.tsx -----

import Snackbar from "@mui/material/Snackbar";
import React from "react";

export let openSnackbarExternal;

type State = {
  open: boolean;
  message: string;
};

class Notifier extends React.PureComponent<any, State> {
  constructor(props) {
    super(props);
    openSnackbarExternal = this.openSnackbar;

    this.state = {
      open: false,
      message: "",
    };
  }

  public render() {
    const message = <span id="snackbar-message-id" dangerouslySetInnerHTML={{ __html: this.state.message }} />;

    return (
      <Snackbar
        anchorOrigin={{ vertical: "top", horizontal: "right" }}
        message={message}
        autoHideDuration={5000}
        onClose={this.handleSnackbarClose}
        open={this.state.open}
        ContentProps={{
          "aria-describedby": "snackbar-message-id",
        }}
      />
    );
  }

  public handleSnackbarClose = () => {
    this.setState({
      open: false,
      message: "",
    });
  };

  public openSnackbar = ({ message }) => {
    this.setState({ open: true, message });
  };
}

export default Notifier;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\components\layout\index.tsx -----

import Avatar from "@mui/material/Avatar";
import Grid from "@mui/material/Grid";
import React from "react";
import MenuWithLinks from "../common/MenuWithLinks";
import Confirmer from "../common/Confirmer";
import Notifier from "../common/Notifier";

const styleGrid = {
  width: "100%",
  height: "100vh",
  maxWidth: "100%",
  padding: "0px 10px",
  display: "flex",
  overflow: "hidden",
};

const styleGridIsMobile = {
  width: "100%",
  height: "100vh",
  maxWidth: "100%",
  padding: "0px 0px 0px 10px",
  display: "flex",
  overflow: "hidden",
};

type Props = {
  children: React.ReactNode;
  firstGridItem?: boolean;
  isMobile?: boolean;
};

class Layout extends React.Component<Props> {
  public render() {
    const { children, firstGridItem, isMobile } = this.props;

    const isThemeDark = false;

    // console.log(isMobile);

    return (
      <Grid
        container
        direction="row"
        justify="flex-start"
        alignItems="stretch"
        style={isMobile ? styleGridIsMobile : styleGrid}
      >
        {firstGridItem ? (
          <Grid
            item
            sm={2}
            xs={12}
            style={{
              borderRight: "1px #707070 solid",
              justifyContent: "center",
              overflow: "hidden",
            }}
          >
            <div style={{ display: "flex", justifyContent: "space-between" }}>
              <svg
                xmlns="http://www.w3.org/2000/svg"
                width="124"
                height="40"
                viewBox="0 0 124 40"
                style={{
                  marginTop: "20px",
                  display: "inline-flex",
                  height: "40px",
                }}
              >
                <g id="async-logo">
                  <g id="async-logo-40">
                    <circle id="Ellipse 2" cx="20" cy="20" r="20" fill="black" />
                    <path
                      id="path-async-logo"
                      d="M7.07825 -0.0960007V16H4.51825V13.088C4.04892 14.0907 3.33425 14.8693 2.37425 15.424C1.43558 15.9573 0.336917 16.224 -0.92175 16.224C-2.35108 16.224 -3.60975 15.8827 -4.69775 15.2C-5.76442 14.5173 -6.59642 13.5573 -7.19375 12.32C-7.76975 11.0613 -8.05775 9.6 -8.05775 7.936C-8.05775 6.272 -7.75908 4.81067 -7.16175 3.552C-6.56442 2.272 -5.73242 1.28 -4.66575 0.576C-3.57775 -0.128 -2.32975 -0.48 -0.92175 -0.48C0.336917 -0.48 1.43558 -0.202666 2.37425 0.352C3.31292 0.906667 4.02758 1.68533 4.51825 2.688V-0.0960007H7.07825ZM-0.40975 14.08C1.16892 14.08 2.38492 13.5467 3.23825 12.48C4.09158 11.392 4.51825 9.856 4.51825 7.872C4.51825 5.888 4.09158 4.36267 3.23825 3.296C2.38492 2.22933 1.16892 1.696 -0.40975 1.696C-1.98842 1.696 -3.22575 2.25067 -4.12175 3.36C-4.99642 4.448 -5.43375 5.97333 -5.43375 7.936C-5.43375 9.89867 -4.99642 11.4133 -4.12175 12.48C-3.24708 13.5467 -2.00975 14.08 -0.40975 14.08Z"
                      transform="translate(19.5938 12)"
                      fill="white"
                    />
                  </g>
                  <path
                    id="path-async-text"
                    d="M22.6251 11.928V24H20.7051V21.816C20.3531 22.568 19.8171 23.152 19.0971 23.568C18.3931 23.968 17.5691 24.168 16.6251 24.168C15.5531 24.168 14.6091 23.912 13.7931 23.4C12.9931 22.888 12.3691 22.168 11.9211 21.24C11.4891 20.296 11.2731 19.2 11.2731 17.952C11.2731 16.704 11.4971 15.608 11.9451 14.664C12.3931 13.704 13.0171 12.96 13.8171 12.432C14.6331 11.904 15.5691 11.64 16.6251 11.64C17.5691 11.64 18.3931 11.848 19.0971 12.264C19.8011 12.68 20.3371 13.264 20.7051 14.016V11.928H22.6251ZM17.0091 22.56C18.1931 22.56 19.1051 22.16 19.7451 21.36C20.3851 20.544 20.7051 19.392 20.7051 17.904C20.7051 16.416 20.3851 15.272 19.7451 14.472C19.1051 13.672 18.1931 13.272 17.0091 13.272C15.8251 13.272 14.8971 13.688 14.2251 14.52C13.5691 15.336 13.2411 16.48 13.2411 17.952C13.2411 19.424 13.5691 20.56 14.2251 21.36C14.8811 22.16 15.8091 22.56 17.0091 22.56ZM30.4637 24.168C28.4317 24.168 26.8237 23.648 25.6397 22.608L26.2877 21.168C26.9437 21.68 27.6077 22.048 28.2797 22.272C28.9517 22.496 29.7037 22.608 30.5357 22.608C31.4477 22.608 32.1357 22.456 32.5997 22.152C33.0797 21.832 33.3197 21.376 33.3197 20.784C33.3197 20.304 33.1597 19.92 32.8397 19.632C32.5197 19.344 31.9917 19.12 31.2557 18.96L29.2157 18.48C28.2077 18.256 27.4237 17.856 26.8637 17.28C26.3197 16.704 26.0477 16.016 26.0477 15.216C26.0477 14.16 26.4717 13.304 27.3197 12.648C28.1677 11.976 29.2877 11.64 30.6797 11.64C31.5277 11.64 32.3277 11.776 33.0797 12.048C33.8317 12.32 34.4637 12.712 34.9757 13.224L34.3277 14.64C33.1917 13.696 31.9757 13.224 30.6797 13.224C29.8157 13.224 29.1437 13.392 28.6637 13.728C28.1997 14.048 27.9677 14.504 27.9677 15.096C27.9677 15.592 28.1117 15.984 28.3997 16.272C28.7037 16.56 29.1837 16.784 29.8397 16.944L31.8797 17.448C32.9997 17.704 33.8317 18.104 34.3757 18.648C34.9197 19.176 35.1917 19.872 35.1917 20.736C35.1917 21.776 34.7677 22.608 33.9197 23.232C33.0717 23.856 31.9197 24.168 30.4637 24.168ZM48.687 11.928L43.047 25.104C42.455 26.48 41.711 27.488 40.815 28.128C39.919 28.768 38.815 29.208 37.503 29.448L37.095 27.936C38.231 27.68 39.087 27.336 39.663 26.904C40.255 26.488 40.743 25.84 41.127 24.96L41.607 23.88L36.495 11.928H38.535L42.615 21.888L46.743 11.928H48.687ZM56.853 11.64C59.749 11.64 61.197 13.232 61.197 16.416V24H59.253V16.512C59.253 15.392 59.029 14.576 58.581 14.064C58.133 13.536 57.429 13.272 56.469 13.272C55.349 13.272 54.453 13.616 53.781 14.304C53.109 14.992 52.773 15.92 52.773 17.088V24H50.829V15.312C50.829 14.064 50.765 12.936 50.637 11.928H52.485L52.677 14.088C53.045 13.304 53.597 12.704 54.333 12.288C55.069 11.856 55.909 11.64 56.853 11.64ZM69.9321 24.168C68.7641 24.168 67.7401 23.912 66.8601 23.4C65.9961 22.888 65.3241 22.168 64.8441 21.24C64.3801 20.296 64.1481 19.2 64.1481 17.952C64.1481 16.704 64.3881 15.608 64.8681 14.664C65.3481 13.704 66.0281 12.96 66.9081 12.432C67.8041 11.904 68.8441 11.64 70.0281 11.64C70.8441 11.64 71.6281 11.784 72.3801 12.072C73.1481 12.344 73.7801 12.728 74.2761 13.224L73.6281 14.664C73.0201 14.184 72.4281 13.832 71.8521 13.608C71.2921 13.384 70.7161 13.272 70.1241 13.272C68.8921 13.272 67.9241 13.688 67.2201 14.52C66.5161 15.336 66.1641 16.48 66.1641 17.952C66.1641 19.408 66.5081 20.544 67.1961 21.36C67.9001 22.16 68.8761 22.56 70.1241 22.56C70.7161 22.56 71.2921 22.448 71.8521 22.224C72.4281 22 73.0201 21.648 73.6281 21.168L74.2761 22.608C73.7641 23.088 73.1161 23.472 72.3321 23.76C71.5641 24.032 70.7641 24.168 69.9321 24.168Z"
                    transform="translate(39 4)"
                    fill={isThemeDark ? "white" : "black"}
                  />
                </g>
              </svg>
              <MenuWithLinks
                options={[
                  {
                    text: "Index page",
                    href: "/",
                    highlighterSlug: "/",
                  },
                  {
                    text: "Your Settings",
                    href: "/your-settings",
                    highlighterSlug: "/your-settings",
                  },
                  {
                    separator: true,
                  },
                  {
                    text: "Log out",
                    href: `${process.env.NEXT_PUBLIC_URL_API}/logout`,
                    as: `${process.env.NEXT_PUBLIC_URL_API}/logout`,
                    externalServer: true,
                  },
                ]}
              >
                <Avatar
                  src={"https://storage.googleapis.com/async-await/default-user.png"}
                  alt="Add username here later in the book"
                  style={{
                    margin: "20px auto",
                    cursor: "pointer",
                    display: "inline-flex",
                    width: "40px",
                    height: "40px",
                  }}
                />

                <i className="material-icons" color="action" style={{ verticalAlign: "super" }}>
                  arrow_drop_down
                </i>
              </MenuWithLinks>
            </div>
            <hr />
            <p />
            <p />
          </Grid>
        ) : null}
        <Grid item sm={firstGridItem ? 10 : 12} xs={12}>
          {isMobile ? <hr /> : null}
          {children}
        </Grid>
        <Notifier />
        <Confirmer />
      </Grid>
    );
  }
}

export default Layout;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\lib\api\public.ts -----

import sendRequestAndGetResponse from './sendRequestAndGetResponse';

const BASE_PATH = '/api/v1/public';

export const getUserApiMethod = (request) =>
  sendRequestAndGetResponse(`${BASE_PATH}/get-user`, {
    request,
    method: 'GET',
  });

export const getUserBySlugApiMethod = (slug) =>
  sendRequestAndGetResponse(`${BASE_PATH}/get-user-by-slug`, {
    body: JSON.stringify({ slug }),
  });

export const updateProfileApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/user/update-profile`, {
    body: JSON.stringify(data),
  });

export const emailLoginLinkApiMethod = ({ email }: { email: string }) =>
  sendRequestAndGetResponse('/auth/email-login-link', {
    body: JSON.stringify({ user: email }),
  });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\lib\api\sendRequestAndGetResponse.ts -----

import 'isomorphic-unfetch';

export default async function sendRequestAndGetResponse(path, opts: any = {}) {
  const headers = Object.assign(
    {},
    opts.headers || {},
    opts.externalServer
      ? {}
      : {
          'Content-type': 'application/json; charset=UTF-8',
        },
  );

  const { request } = opts;

  if (request && request.headers && request.headers.cookie) {
    headers.cookie = request.headers.cookie;
  }

  const qs = opts.qs || '';

  // console.log(`before: ${process.env.NEXT_PUBLIC_URL_API}${path}${qs}`);

  const response = await fetch(
    opts.externalServer ? `${path}${qs}` : `${process.env.NEXT_PUBLIC_URL_API}${path}${qs}`,
    Object.assign({ method: 'POST', credentials: 'include' }, opts, { headers }),
  );

  // console.log(`after: ${process.env.NEXT_PUBLIC_URL_API}${path}${qs}`);

  // console.log(response.status);
  // console.log(response.statusText);

  const text = await response.text();

  if (response.status >= 400) {
    console.error(text);
    throw new Error(response.status.toString());
  }

  try {
    const data = JSON.parse(text);

    return data;
  } catch (err) {
    if (err instanceof SyntaxError) {
      return text;
    }

    throw err;
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\lib\api\team-member.ts -----

import sendRequestAndGetResponse from './sendRequestAndGetResponse';

const BASE_PATH = '/api/v1/team-member';

export const getSignedRequestForUploadApiMethod = ({ fileName, fileType, prefix, bucket }) =>
  sendRequestAndGetResponse(`${BASE_PATH}/aws/get-signed-request-for-upload-to-s3`, {
    body: JSON.stringify({ fileName, fileType, prefix, bucket }),
  });

export const uploadFileUsingSignedPutRequestApiMethod = (file, signedRequest, headers = {}) =>
  sendRequestAndGetResponse(signedRequest, {
    externalServer: true,
    method: 'PUT',
    body: file,
    headers,
  });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\lib\confirm.ts -----

import { openConfirmDialogExternal } from '../components/common/Confirmer';

export default function confirm({
  title,
  message,
  onAnswer,
}: {
  title: string;
  message: string;
  onAnswer: (answer) => void;
}) {
  openConfirmDialogExternal({ title, message, onAnswer });
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\lib\isMobile.ts -----

const mobileRE = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i;

export function isMobile(opts) {
  if (!opts) {
    opts = {};
  }

  let ua = opts.ua;

  if (!ua && typeof navigator !== 'undefined') {
    ua = navigator.userAgent;
  }

  if (!ua && opts.req && opts.req.headers && typeof opts.req.headers['user-agent'] === 'string') {
    ua = opts.req.headers['user-agent'];
    // console.log(ua);
  }

  if (typeof ua !== 'string') {
    return false;
  }

  return mobileRE.test(ua);
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\lib\notify.ts -----

import { openSnackbarExternal } from '../components/common/Notifier';

export default function notify(obj) {
  openSnackbarExternal({ message: obj.message || obj.toString() });
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\lib\resizeImage.ts -----

function resizeImage(file: File, MAX_WIDTH, MAX_HEIGHT) {
  const image = document.createElement('img');

  const resize = (resolve) => () => {
    let isResizeNeeded = false;
    let width = image.width;
    let height = image.height;

    if (width > height) {
      if (width > MAX_WIDTH) {
        isResizeNeeded = true;
        height *= MAX_WIDTH / width;
        width = MAX_WIDTH;
      }
    } else {
      if (height > MAX_HEIGHT) {
        isResizeNeeded = true;
        width *= MAX_HEIGHT / height;
        height = MAX_HEIGHT;
      }
    }

    if (isResizeNeeded) {
      const canvas = document.createElement('canvas');

      canvas.width = width;
      canvas.height = height;

      console.log(width, height);

      const ctx = canvas.getContext('2d');
      ctx.drawImage(image, 0, 0, width, height);

      canvas.toBlob((blob) => {
        resolve(blob);
      }, file.type);
    } else {
      resolve(file);
    }
  };

  return new Promise((resolve) => {
    const reader = new FileReader();

    console.log(`before ${image.src}`);

    reader.readAsDataURL(file);

    reader.onload = (e) => {
      image.src = e.target.result.toString();

      image.onload = resize(resolve);

      console.log(`after ${image.src}`);
    };
  });
}

export { resizeImage };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\lib\sharedStyles.ts -----

const styleBigAvatar = {
  width: '80px',
  height: '80px',
  margin: '0px auto 15px',
};

const styleRaisedButton = {
  margin: '15px',
  font: '14px Roboto',
};

const styleToolbar = {
  background: '#FFF',
  height: '64px',
  paddingRight: '20px',
};

const styleTextField = {
  font: '15px Roboto',
  color: '#222',
  fontWeight: '300',
};

const styleForm = {
  margin: '7% auto',
  width: '360px',
};

export { styleBigAvatar, styleRaisedButton, styleToolbar, styleTextField, styleForm };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\lib\theme.ts -----

import { createMuiTheme } from "@mui/material/styles";

const themeDark = createMuiTheme({
  palette: {
    primary: { main: "#238636" },
    secondary: { main: "#b62324" },
    type: "dark",
    background: { default: "#0d1117" },
    text: {
      primary: "#c9d1d9",
    },
  },
  typography: {
    button: {
      textTransform: "none",
    },
  },
});

const themeLight = createMuiTheme({
  palette: {
    primary: { main: "#238636" },
    secondary: { main: "#b62324" },
    type: "light",
    background: { default: "#fff" },
    text: {
      primary: "#222",
    },
  },
  typography: {
    button: {
      textTransform: "none",
    },
  },
});

export { themeDark, themeLight };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\lib\withAuth.tsx -----

import Router from 'next/router';
import React from 'react';

import * as NProgress from 'nprogress';

import { getUserApiMethod } from '../lib/api/public';

Router.events.on('routeChangeStart', () => {
  NProgress.start();
});

Router.events.on('routeChangeComplete', () => {
  NProgress.done();
});

Router.events.on('routeChangeError', () => NProgress.done());

type Props = {
  user: { email: string; displayName: string; slug: string; avatarUrl: string };
};

export default function withAuth(Component, { loginRequired = true, logoutRequired = false } = {}) {
  class WithAuth extends React.Component<Props> {
    public static async getInitialProps(ctx) {
      const { req, res } = ctx;

      let pageComponentProps = {};

      if (Component.getInitialProps) {
        pageComponentProps = await Component.getInitialProps(ctx);
      }

      const { user } = await getUserApiMethod(req);

      console.log(user);

      if (loginRequired && !logoutRequired && !user) {
        if (res) {
          res.redirect('/login');
        } else {
          Router.push('/login');
        }
        return;
      }

      let redirectUrl = '/login';
      let asUrl = '/login';

      if (user) {
        redirectUrl = `/your-settings`;
        asUrl = `/your-settings`;
      }

      if (logoutRequired && user) {
        if (res) {
          res.redirect(`${redirectUrl}`);
        } else {
          Router.push(redirectUrl, asUrl);
        }
      }

      return {
        ...pageComponentProps,
        user,
      };
    }

    public render() {
      const { user } = this.props;

      if (loginRequired && !logoutRequired && !user) {
        return null;
      }

      if (logoutRequired && user) {
        return null;
      }

      return <Component {...this.props} />;
    }
  }

  return WithAuth;
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\pages\csr-page.tsx -----

import Button from "@mui/material/Button";
import React from "react";
import Head from "next/head";

const CSRPage = () => (
  <div>
    <Head>
      <title>CSR page</title>
      <meta name="description" content="This is a description of the CSR page" />
    </Head>
    <div style={{ padding: "0px 30px", fontSize: "15px", height: "100%" }}>
      <p>Content on CSR page</p>
      <Button variant="outlined">Some button</Button>
    </div>
  </div>
);

console.log(process.env.NEXT_PUBLIC_URL_APP);

export default CSRPage;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\pages\index.tsx -----

import Button from "@mui/material/Button";
import React from "react";
import Head from "next/head";
import Link from "next/link";

import Layout from "../components/layout";
import NProgress from "nprogress";

import confirm from "../lib/confirm";
import notify from "../lib/notify";
import { getUserBySlugApiMethod } from "../lib/api/public";

type Props = { user: { email: string; displayName: string } };

class Index extends React.Component<Props> {
  public static async getInitialProps() {
    const slug = "team-builder-book";

    const user = await getUserBySlugApiMethod(slug);

    console.log(user);

    return { ...user };
  }

  public render() {
    return (
      <Layout {...this.props}>
        <Head>
          <title>Index page</title>
          <meta name="description" content="This is a description of the Index page" />
        </Head>
        <div style={{ padding: "0px 30px", fontSize: "15px", height: "100%" }}>
          <p>Content on Index page</p>
          <Link href="/your-settings" as="/your-settings">
            Go to Your Settings page
          </Link>
          <p />
          <Button
            variant="contained"
            onClick={() =>
              confirm({
                title: "Are you sure?",
                message: "explanatory message",
                onAnswer: async (answer) => {
                  // console.log(answer);
                  if (!answer) {
                    return;
                  }

                  NProgress.start();

                  try {
                    notify("You successfully confirmed.");
                  } catch (error) {
                    console.error(error);
                    notify(error);
                  } finally {
                    NProgress.done();
                  }
                },
              })
            }
          >
            Test Confirmer and Notifier
          </Button>
          <p>Your email: {this.props.user.email}</p>
          <p>Your username: {this.props.user.displayName}</p>
        </div>
      </Layout>
    );
  }
}

export default Index;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\pages\login.tsx -----

import Head from 'next/head';
import React from 'react';
import LoginButton from '../components/common/LoginButton';
import Layout from '../components/layout';
import withAuth from '../lib/withAuth';

class Login extends React.Component {
  public render() {
    return (
      <Layout {...this.props}>
        <div style={{ textAlign: 'center', margin: '0 20px' }}>
          <Head>
            <title>Log in to SaaS boilerplate by Async</title>
            <meta
              name="description"
              content="Login and signup page for SaaS boilerplate demo by Async"
            />
          </Head>
          <br />
          <p style={{ margin: '45px auto', fontSize: '44px', fontWeight: 400 }}>Log in</p>
          <p>Youll be logged in for 14 days unless you log out manually.</p>
          <br />

          <LoginButton />
        </div>
      </Layout>
    );
  }
}

export default withAuth(Login, { logoutRequired: true });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\pages\your-settings.tsx -----

import Avatar from "@mui/material/Avatar";
import Button from "@mui/material/Button";
import TextField from "@mui/material/TextField";
import Head from "next/head";
import NProgress from "nprogress";
import * as React from "react";

import Layout from "../components/layout";

import { updateProfileApiMethod } from "../lib/api/public";
import { getSignedRequestForUploadApiMethod, uploadFileUsingSignedPutRequestApiMethod } from "../lib/api/team-member";

import { resizeImage } from "../lib/resizeImage";

import notify from "../lib/notify";

import withAuth from "../lib/withAuth";

type Props = {
  isMobile: boolean;
  user: { email: string; displayName: string; slug: string; avatarUrl: string };
};

type State = { newName: string; newAvatarUrl: string; disabled: boolean };

class YourSettings extends React.Component<Props, State> {
  // public static async getInitialProps(ctx) {
  //   const user = await getUserApiMethod(ctx.req);

  //   console.log(user);

  //   return { ...user };
  // }

  // public static async getInitialProps() {
  //   const slug = 'team-builder-book';

  //   const user = await getUserBySlugApiMethod(slug);

  //   console.log(user);

  //   return { ...user };
  // }

  constructor(props) {
    super(props);

    this.state = {
      newName: this.props.user.displayName,
      newAvatarUrl: this.props.user.avatarUrl,
      disabled: false,
    };
  }

  public render() {
    const { user } = this.props;
    const { newName, newAvatarUrl } = this.state;

    return (
      <Layout {...this.props}>
        <Head>
          <title>Your Settings at Async</title>
          <meta name="description" content="description" />
        </Head>
        <div
          style={{
            padding: this.props.isMobile ? "0px" : "0px 30px",
            fontSize: "15px",
            height: "100%",
          }}
        >
          <h3>Your Settings</h3>
          <h4 style={{ marginTop: "40px" }}>Your account</h4>
          <ul>
            <li>
              Your email: <b>{user.email}</b>
            </li>
            <li>
              Your username: <b>{user.displayName}</b>
            </li>
          </ul>
          <form onSubmit={this.onSubmit} autoComplete="off">
            <h4>Your username</h4>
            <TextField
              autoComplete="off"
              value={newName}
              helperText="Your username as seen by your team members"
              onChange={(event) => {
                this.setState({ newName: event.target.value });
              }}
            />
            <br />
            <br />
            <Button variant="contained" color="primary" type="submit" disabled={this.state.disabled}>
              Update username
            </Button>
          </form>

          <br />
          <h4>Your photo</h4>
          <Avatar
            src={newAvatarUrl}
            style={{
              display: "inline-flex",
              verticalAlign: "middle",
              marginRight: 20,
              width: 60,
              height: 60,
            }}
          />
          <label htmlFor="upload-file-user-avatar">
            <Button variant="outlined" color="primary" component="span" disabled={this.state.disabled}>
              Update avatar
            </Button>
          </label>
          <input
            accept="image/*"
            name="upload-file-user-avatar"
            id="upload-file-user-avatar"
            type="file"
            style={{ display: "none" }}
            onChange={this.uploadFile}
          />
          <p />
          <br />
        </div>
      </Layout>
    );
  }

  private onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();

    const { newName, newAvatarUrl } = this.state;

    console.log(newName);

    if (!newName) {
      notify("Name is required");
      return;
    }

    NProgress.start();
    this.setState({ disabled: true });

    try {
      await updateProfileApiMethod({
        name: newName,
        avatarUrl: newAvatarUrl,
      });

      notify("You successfully updated your profile.");
    } catch (error) {
      notify(error);
    } finally {
      this.setState({ disabled: false });
      NProgress.done();
    }
  };

  private uploadFile = async () => {
    const fileElement = document.getElementById("upload-file-user-avatar") as HTMLFormElement;
    const file = fileElement.files[0];

    if (file == null) {
      notify("No file selected for upload.");
      return;
    }

    const fileName = file.name;
    const fileType = file.type;

    NProgress.start();
    this.setState({ disabled: true });

    const bucket = process.env.NEXT_PUBLIC_BUCKET_FOR_AVATARS;

    const prefix = "team-builder-book";

    try {
      const responseFromApiServerForUpload = await getSignedRequestForUploadApiMethod({
        fileName,
        fileType,
        prefix,
        bucket,
      });

      const resizedFile = await resizeImage(file, 128, 128);

      console.log(file);
      console.log(resizedFile);

      await uploadFileUsingSignedPutRequestApiMethod(resizedFile, responseFromApiServerForUpload.signedRequest, {
        "Cache-Control": "max-age=2592000",
      });

      this.setState({
        newAvatarUrl: responseFromApiServerForUpload.url,
      });

      await updateProfileApiMethod({
        name: this.state.newName,
        avatarUrl: this.state.newAvatarUrl,
      });

      notify("You successfully uploaded new avatar.");
    } catch (error) {
      notify(error);
    } finally {
      fileElement.value = "";
      this.setState({ disabled: false });
      NProgress.done();
    }
  };
}

export default withAuth(YourSettings);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\pages\_app.tsx -----

import CssBaseline from "@mui/material/CssBaseline";
import { ThemeProvider } from "@mui/material";
import App from "next/app";
import Head from "next/head";
import React from "react";
import { isMobile } from "../lib/isMobile";
import { themeDark, themeLight } from "../lib/theme";

class MyApp extends App {
  public static async getInitialProps({ Component, ctx }) {
    let firstGridItem = true;

    if (ctx.pathname.includes("/login")) {
      firstGridItem = false;
    }

    const pageProps = { isMobile: isMobile({ req: ctx.req }), firstGridItem };

    if (Component.getInitialProps) {
      Object.assign(pageProps, await Component.getInitialProps(ctx));
    }

    return { pageProps };
  }

  public componentDidMount() {
    // Remove the server-side injected CSS.
    const jssStyles = document.querySelector("#jss-server-side");
    if (jssStyles && jssStyles.parentNode) {
      jssStyles.parentNode.removeChild(jssStyles);
    }
  }
  public render() {
    const { Component, pageProps } = this.props;

    return (
      <ThemeProvider theme={false ? themeDark : themeLight}>
        <Head>
          <meta name="viewport" content="width=device-width, initial-scale=1.0" />
          <link rel="stylesheet" href="https://storage.googleapis.com/async-await/nprogress-dark.min.css?v=1" />
        </Head>
        <CssBaseline />
        <Component {...pageProps} />
      </ThemeProvider>
    );
  }
}

export default MyApp;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\pages\_document.tsx -----

import Document, { Head, Html, Main, NextScript } from "next/document";
import React from "react";

class MyDocument extends Document {
  public static getInitialProps = async (ctx) => {
    const initialProps = await Document.getInitialProps(ctx);

    return {
      ...initialProps,
    };
  };

  public render() {
    // console.log('rendered on the server');

    return (
      <Html lang="en">
        <Head>
          <meta charSet="utf-8" />
          <meta name="google" content="notranslate" />
          <meta name="theme-color" content="#303030" />

          <link rel="shortcut icon" href="https://storage.googleapis.com/async-await/async-favicon32.png" />

          <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons" />
          <link rel="stylesheet" href="https://storage.googleapis.com/async-await/vs2015.min.css" />

          <style>
            {`
              #__next {
                width: 100%;
                height: 100%;
              }
              a {
                font-weight: 400;
                color: #58a6ff;
                text-decoration: none;
                outline: none;
              }
              hr {
                border: 0.5px #707070 solid;
                color: #000;
              }
              blockquote {
                padding: 0 0.5em;
                margin: 20px 1em;
                border-left: 0.25em solid #dfe2e5;
                color: #000;
              }
              pre {
                display: block;
                overflow-x: auto;
                padding: 0.5em;
                background: #d0d0d0;
                border: 1px solid #ddd;
                font-size: 14px;
                color: #000;
              }
              pre code {
                font-size: 13px;
                background: #d0d0d0;
                padding: 0px;
                color: #000;
              }
              code {
                font-size: 13px;
                background: #d0d0d0;
                padding: 3px 5px;
                color: #000;
              }
              mark {
                background-color: #ffff0060;
              }
              summary:focus {
                outline: none;
              }
              table {
                border-collapse: collapse;
                margin: 15px 0px;
              }
              table, th, td {
                border: 1px solid #a1a1a1;
              }
              th, td {
                line-height: 1.5em;
                padding: 10px;
              }
            `}
          </style>
        </Head>
        <body>
          <Main />
          <NextScript />
        </body>
      </Html>
    );
  }
}

export default MyDocument;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\server\server.ts -----

import express from 'express';
import next from 'next';

const NODE_ENV = process.env.NODE_ENV || 'development';
const IS_DEV = NODE_ENV !== 'production';

const app = next({ dev: IS_DEV });
const handle = app.getRequestHandler();

app.prepare().then(() => {
  const server = express();

  // give all Nextjs's request to Nextjs before anything else
  server.get('/_next/*', (req, res) => {
    // console.log('next server, page');
    handle(req, res);
  });

  server.use(express.json());

  // server.get('/api/v1/public/get-user', (_, res) => {
  //   res.json({ user: { email: 'team@builderbook.org' } });
  // });

  server.all('*', (req, res) => {
    handle(req, res);
  });

  server.listen(process.env.NEXT_PUBLIC_PORT_APP, () => {
    console.log(`> Ready on ${process.env.NEXT_PUBLIC_URL_APP}`);
  });
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\.eslintrc.js -----

module.exports = {
  settings: {
    react: { version: 'detect' },
  },
  parser: '@typescript-eslint/parser',
  extends: ['plugin:react/recommended', 'plugin:@typescript-eslint/recommended', 'prettier'],
  env: {
    es6: true,
    node: true,
  },
  plugins: ['prettier', 'react'],
  rules: {
    'prettier/prettier': [
      'error',
      {
        singleQuote: true,
        trailingComma: 'all',
        arrowParens: 'always',
        printWidth: 100,
        semi: true,
      },
    ],
    '@typescript-eslint/camelcase': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    'react/no-unescaped-entities': 'off',
    'react/jsx-filename-extension': ['error', { extensions: ['.tsx'] }],
    '@typescript-eslint/no-explicit-any': 'off',
    'prefer-arrow-callback': 'error',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
  },
};

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\next-env.d.ts -----

/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/pages/api-reference/config/typescript for more information.

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\next.config.js -----

module.exports = {
  poweredByHeader: false,
  webpack5: true,
  typescript: {
    ignoreBuildErrors: true,
  },
};

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\nodemon.json -----

{
  "watch": ["server"],
  "exec": "ts-node --project tsconfig.server.json",
  "ext": "ts"
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\package.json -----

{
  "name": "6-end-app",
  "version": "1",
  "license": "MIT",
  "scripts": {
    "dev": "nodemon server/server.ts",
    "build": "next build",
    "lint": "eslint . --ext .ts,.tsx"
  },
  "dependencies": {
    "@emotion/react": "^11.14.0",
    "@emotion/styled": "^11.14.0",
    "@material-ui/core": "^4.12.4",
    "@material-ui/styles": "^4.11.5",
    "@mui/material": "^6.4.8",
    "@mui/system": "^6.4.8",
    "dotenv": "^16.4.7",
    "express": "^4.21.2",
    "isomorphic-unfetch": "^4.0.2",
    "next": "^15.2.3",
    "nprogress": "^0.2.0",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "typescript": "^5.8.2"
  },
  "devDependencies": {
    "@types/express": "^5.0.1",
    "@types/node": "^22.13.10",
    "@types/react": "^19.0.12",
    "@types/react-dom": "^19.0.4",
    "@typescript-eslint/eslint-plugin": "^8.27.0",
    "@typescript-eslint/parser": "^8.27.0",
    "eslint": "^9.22.0",
    "eslint-config-prettier": "^10.1.1",
    "eslint-plugin-prettier": "^5.2.3",
    "eslint-plugin-react": "^7.37.4",
    "nodemon": "^3.1.9",
    "prettier": "^3.5.3",
    "ts-node": "^10.9.2"
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\tsconfig.json -----

{
  "compileOnSave": false,
  "compilerOptions": {
    "target": "esnext",
    "module": "esnext",
    "jsx": "preserve",
    "allowJs": true,
    "alwaysStrict": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "removeComments": true,
    "preserveConstEnums": true,
    "sourceMap": false,
    "skipLibCheck": true,
    "baseUrl": ".",
    "typeRoots": [
      "./node_modules/@types"
    ],
    "lib": [
      "dom",
      "es2017"
    ],
    "strict": false,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "incremental": true
  },
  "include": [
    "next-env.d.ts",
    "./**/*.tsx",
    "./**/*.ts"
  ],
  "exclude": [
    "dist",
    "production-server",
    ".next",
    "out",
    "next.config.js",
    "node_modules"
  ]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\6-end\app\tsconfig.server.json -----

{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "module": "commonjs",
    "outDir": "production-server/",
    "target": "es2017",
    "isolatedModules": false,
    "noEmit": false
  },
  "exclude": ["./server/types.d.ts"],
  "include": ["./server/**/*.ts"],
  "typeRoots": ["./node_modules/@types", "./server/types.d.ts"]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\api\server\api\index.ts -----

import * as express from 'express';

import publicExpressRoutes from './public';
import teamMemberExpressRoutes from './team-member';

function handleError(err, _, res, __) {
  console.error(err.stack);

  res.json({ error: err.message || err.toString() });
}

export default function api(server: express.Express) {
  server.use('/api/v1/public', publicExpressRoutes, handleError);
  server.use('/api/v1/team-member', teamMemberExpressRoutes, handleError);
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\api\server\api\public.ts -----

import * as express from 'express';

import User from '../models/User';

const router = express.Router();

router.get('/get-user', (req, res) => {
  console.log(req.user);
  res.json({ user: req.user || null });
});

router.post('/get-user-by-slug', async (req, res, next) => {
  console.log('Express route: /get-user-by-slug');

  // req.session.foo = 'bar';

  try {
    const { slug } = req.body;

    const user = await User.getUserBySlug({ slug });

    res.json({ user });
  } catch (err) {
    next(err);
  }
});

router.post('/user/update-profile', async (req: any, res, next) => {
  try {
    const { name, avatarUrl } = req.body;

    const updatedUser = await User.updateProfile({
      userId: req.user.id,
      name,
      avatarUrl,
    });

    res.json({ updatedUser });
  } catch (err) {
    next(err);
  }
});

export default router;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\api\server\api\team-member.ts -----

import * as express from 'express';

import { signRequestForUpload } from '../aws-s3';

const router = express.Router();

router.use((req, res, next) => {
  console.log('team member API', req.path);
  if (!req.user) {
    res.status(401).json({ error: 'Unauthorized' });
    return;
  }

  next();
});

// Get signed request from AWS S3 server
router.post('/aws/get-signed-request-for-upload-to-s3', async (req, res, next) => {
  try {
    const { fileName, fileType, prefix, bucket } = req.body;

    const returnData = await signRequestForUpload({
      fileName,
      fileType,
      prefix,
      bucket,
    });

    console.log(returnData);

    res.json(returnData);
  } catch (err) {
    next(err);
  }
});

export default router;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\api\server\models\EmailTemplate.ts -----

import * as _ from 'lodash';
import * as mongoose from 'mongoose';

interface EmailTemplateDocument extends mongoose.Document {
  name: string;
  subject: string;
  message: string;
}

const EmailTemplate = mongoose.model<EmailTemplateDocument>(
  'EmailTemplate',
  new mongoose.Schema({
    name: {
      type: String,
      required: true,
      unique: true,
    },
    subject: {
      type: String,
      required: true,
    },
    message: {
      type: String,
      required: true,
    },
  }),
);

export async function insertTemplates() {
  const templates = [
    {
      name: 'welcome',
      subject: 'Welcome to SaaS boilerplate by Async',
      message: `Welcome <%= userName %>,
        <p>
          Thanks for signing up on our <a href="https://github.com/async-labs/saas" target="blank">SaaS boilerplate</a>!
        </p>
        <p>
          If you are learning how to build a SaaS web app, check out our 2 books:
           <a href="https://builderbook.org" target="blank">Builder Book</a>
           and
           <a href="https://builderbook.org/book" target="blank">SaaS Boilerplate</a>.
        </p>
        <p>
          Also check out
          <a href="https://async-await.com" target="blank"> Async</a>
          , our communication tool for small teams of software developers.
        </p>
        Kelly & Timur, Team Async
      `,
    },
    {
      name: 'login',
      subject: 'Login link for saas-app.async-await.com',
      message: `
        <p>Log into your account by clicking on this link: <a href="<%= loginURL %>"><%= loginURL %></a>.</p>`,
    },
  ];

  for (const t of templates) {
    const et = await EmailTemplate.findOne({ name: t.name }).setOptions({ lean: true });
    const message = t.message.replace(/\n/g, '').replace(/[ ]+/g, ' ').trim();

    if (!et) {
      EmailTemplate.create(Object.assign({}, t, { message }));
    } else if (et.subject !== t.subject || et.message !== message) {
      EmailTemplate.updateOne({ _id: et._id }, { $set: { message, subject: t.subject } }).exec();
    }
  }
}

export default async function getEmailTemplate(name: string, params: any) {
  await insertTemplates();

  const et = await EmailTemplate.findOne({ name }).setOptions({ lean: true });

  if (!et) {
    throw new Error('Email Template is not found in database.');
  }

  return {
    message: _.template(et.message)(params),
    subject: _.template(et.subject)(params),
  };
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\api\server\models\User.ts -----

import * as _ from 'lodash';
import * as mongoose from 'mongoose';

import sendEmail from '../aws-ses';
import { addToMailchimp } from '../mailchimp';
import { generateSlug } from '../utils/slugify';
import getEmailTemplate from './EmailTemplate';

const mongoSchema = new mongoose.Schema({
  slug: {
    type: String,
    required: true,
    unique: true,
  },
  createdAt: {
    type: Date,
    required: true,
  },
  email: {
    type: String,
    required: true,
    unique: true,
  },
  displayName: String,
  avatarUrl: String,
  googleId: {
    type: String,
    unique: true,
    sparse: true,
  },
  googleToken: {
    accessToken: String,
    refreshToken: String,
  },
  isSignedupViaGoogle: {
    type: Boolean,
    required: true,
    default: false,
  },
});

export interface UserDocument extends mongoose.Document {
  slug: string;
  createdAt: Date;
  email: string;
  displayName: string;
  avatarUrl: string;
  googleId: string;
  googleToken: { accessToken: string; refreshToken: string };
  isSignedupViaGoogle: boolean;
}

interface UserModel extends mongoose.Model<UserDocument> {
  getUserBySlug({ slug }: { slug: string }): Promise<UserDocument>;

  updateProfile({
    userId,
    name,
    avatarUrl,
  }: {
    userId: string;
    name: string;
    avatarUrl: string;
  }): Promise<UserDocument[]>;

  publicFields(): string[];

  signInOrSignUpViaGoogle({
    googleId,
    email,
    displayName,
    avatarUrl,
    googleToken,
  }: {
    googleId: string;
    email: string;
    displayName: string;
    avatarUrl: string;
    googleToken: { accessToken?: string; refreshToken?: string };
  }): Promise<UserDocument>;

  signInOrSignUpByPasswordless({
    uid,
    email,
  }: {
    uid: string;
    email: string;
  }): Promise<UserDocument>;
}

class UserClass extends mongoose.Model {
  public static async getUserBySlug({ slug }) {
    console.log('Static method: getUserBySlug');

    return this.findOne({ slug }, 'email displayName avatarUrl').setOptions({ lean: true });
  }

  public static async updateProfile({ userId, name, avatarUrl }) {
    console.log('Static method: updateProfile');

    const user = await this.findById(userId, 'slug displayName');

    const modifier = { displayName: user.displayName, avatarUrl, slug: user.slug };

    console.log(user.slug);

    if (name !== user.displayName) {
      modifier.displayName = name;
      modifier.slug = await generateSlug(this, name);
    }

    return this.findByIdAndUpdate(userId, { $set: modifier }, { new: true, runValidators: true })
      .select('displayName avatarUrl slug')
      .setOptions({ lean: true });
  }

  public static publicFields(): string[] {
    return ['_id', 'id', 'displayName', 'email', 'avatarUrl', 'slug', 'isSignedupViaGoogle'];
  }

  public static async signInOrSignUpViaGoogle({
    googleId,
    email,
    displayName,
    avatarUrl,
    googleToken,
  }) {
    const user = await this.findOne({ email })
      .select([...this.publicFields(), 'googleId'].join(' '))
      .setOptions({ lean: true });

    if (user) {
      if (_.isEmpty(googleToken) && user.googleId) {
        return user;
      }

      const modifier = { googleId };
      if (googleToken.accessToken) {
        modifier['googleToken.accessToken'] = googleToken.accessToken;
      }

      if (googleToken.refreshToken) {
        modifier['googleToken.refreshToken'] = googleToken.refreshToken;
      }

      await this.updateOne({ email }, { $set: modifier });

      return user;
    }

    const slug = await generateSlug(this, displayName);

    const newUser = await this.create({
      createdAt: new Date(),
      googleId,
      email,
      googleToken,
      displayName,
      avatarUrl,
      slug,
      isSignedupViaGoogle: true,
      darkTheme: false,
    });

    const emailTemplate = await getEmailTemplate('welcome', { userName: displayName });

    if (!emailTemplate) {
      throw new Error('Welcome email template not found');
    }

    try {
      await sendEmail({
        from: `Kelly from saas-app.async-await.com <${process.env.EMAIL_SUPPORT_FROM_ADDRESS}>`,
        to: [email],
        subject: emailTemplate.subject,
        body: emailTemplate.message,
      });
    } catch (err) {
      console.error('Email sending error:', err);
    }

    try {
      await addToMailchimp({ email, listName: 'signups' });
    } catch (error) {
      console.error('Mailchimp error:', error);
    }

    return _.pick(newUser, this.publicFields());
  }

  public static async signInOrSignUpByPasswordless({ uid, email }) {
    const user = await this.findOne({ email })
      .select(this.publicFields().join(' '))
      .setOptions({ lean: true });

    if (user) {
      throw Error('User already exists');
    }

    const slug = await generateSlug(this, email);

    const newUser = await this.create({
      _id: uid,
      createdAt: new Date(),
      email,
      slug,
    });

    const emailTemplate = await getEmailTemplate('welcome', { userName: email });

    if (!emailTemplate) {
      throw new Error('Email template "welcome" not found in database.');
    }

    try {
      await sendEmail({
        from: `Kelly from saas-app.async-await.com <${process.env.EMAIL_SUPPORT_FROM_ADDRESS}>`,
        to: [email],
        subject: emailTemplate.subject,
        body: emailTemplate.message,
      });
    } catch (err) {
      console.error('Email sending error:', err);
    }

    try {
      await addToMailchimp({ email, listName: 'signups' });
    } catch (error) {
      console.error('Mailchimp error:', error);
    }

    return _.pick(newUser, this.publicFields());
  }
}

mongoSchema.loadClass(UserClass);

const User = mongoose.model<UserDocument, UserModel>('User', mongoSchema);

export default User;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\api\server\utils\slugify.ts -----

import * as _ from 'lodash';

const slugify = (text) => _.kebabCase(text);

async function createUniqueSlug(Model, slug, count, filter) {
  const obj = await Model.findOne({ slug: `${slug}-${count}`, ...filter })
    .select('_id')
    .setOptions({ lean: true });

  if (!obj) {
    return `${slug}-${count}`;
  }

  return createUniqueSlug(Model, slug, count + 1, filter);
}

async function generateSlug(Model, name, filter = {}) {
  const origSlug = slugify(name);

  const obj = await Model.findOne({ slug: origSlug, ...filter })
    .select('_id')
    .setOptions({ lean: true });

  if (!obj) {
    return origSlug;
  }

  return createUniqueSlug(Model, origSlug, 1, filter);
}

export { generateSlug };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\api\server\utils\sum.ts -----

function sum(a, b) {
  return a + b;
}

export { sum };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\api\server\aws-s3.ts -----

import * as url from 'url';
import * as aws from 'aws-sdk';

async function signRequestForUpload({ fileName, fileType, prefix, bucket }) {
  const randomStringForPrefix =
    Math.random().toString(36).substring(2, 12) + Math.random().toString(36).substring(2, 12);

  const key = `${prefix}/${randomStringForPrefix}/${fileName}`;

  const acl = 'public-read';

  const params = {
    Bucket: bucket,
    Key: key,
    Expires: 60,
    ContentType: fileType,
    ACL: acl,
  };

  console.log(prefix);

  const s3 = new aws.S3({
    apiVersion: 'latest',
    region: process.env.AWS_REGION,
    accessKeyId: process.env.AWS_ACCESSKEYID,
    secretAccessKey: process.env.AWS_SECRETACCESSKEY,
  });

  return new Promise((resolve, reject) => {
    s3.getSignedUrl('putObject', params, (err, data) => {
      const parsedUrl = url.parse(data);

      const returnData = {
        signedRequest: data,
        url: `${parsedUrl.protocol}//${parsedUrl.hostname}${parsedUrl.pathname}`,
      };

      if (err) {
        console.error(err);
        reject(err);
      } else {
        resolve(returnData);
      }
    });
  });
}

export { signRequestForUpload };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\api\server\aws-ses.ts -----

import * as aws from 'aws-sdk';

export default function sendEmail(options) {
  const ses = new aws.SES({
    apiVersion: 'latest',
    region: process.env.AWS_REGION,
    accessKeyId: process.env.AWS_ACCESSKEYID,
    secretAccessKey: process.env.AWS_SECRETACCESSKEY,
  });

  return new Promise((resolve, reject) => {
    ses.sendEmail(
      {
        Source: options.from,
        Destination: {
          CcAddresses: options.cc,
          ToAddresses: options.to,
        },
        Message: {
          Subject: {
            Data: options.subject,
          },
          Body: {
            Html: {
              Data: options.body,
            },
          },
        },
        ReplyToAddresses: options.replyTo,
      },
      (err, info) => {
        if (err) {
          reject(err);
        } else {
          resolve(info);
        }
      },
    );
  });
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\api\server\google-auth.ts -----

import * as passport from 'passport';
import { OAuth2Strategy as Strategy } from 'passport-google-oauth';

import User, { UserDocument } from './models/User';

function setupGoogle({ server }) {
  if (!process.env.GOOGLE_CLIENTID) {
    return;
  }

  const verify = async (accessToken, refreshToken, profile, done) => {
    let email;
    let avatarUrl;

    if (profile.emails) {
      email = profile.emails[0].value;
    }

    if (profile.photos && profile.photos.length > 0) {
      avatarUrl = profile.photos[0].value.replace('sz=50', 'sz=128');
    }

    try {
      const user = await User.signInOrSignUpViaGoogle({
        googleId: profile.id,
        email,
        googleToken: { accessToken, refreshToken },
        displayName: profile.displayName,
        avatarUrl,
      });

      done(null, user);
    } catch (err) {
      done(err);
      console.error(err);
    }
  };

  passport.use(
    new Strategy(
      {
        clientID: process.env.GOOGLE_CLIENTID,
        clientSecret: process.env.GOOGLE_CLIENTSECRET,
        callbackURL: `${process.env.URL_API}/oauth2callback`,
      },
      verify,
    ),
  );

  passport.serializeUser((user: UserDocument, done) => {
    done(null, user._id);
  });

  passport.deserializeUser((id, done) => {
    User.findById(id, User.publicFields())
      .then((user) => {
        done(null, user);
      })
      .catch((error) => {
        done(error, null);
      });
  });

  server.use(passport.initialize());
  server.use(passport.session());

  server.get('/auth/google', (req, res, next) => {
    const options = {
      scope: ['profile', 'email'],
      prompt: 'select_account',
    };

    passport.authenticate('google', options)(req, res, next);

    console.log('/auth/google');
  });

  server.get(
    '/oauth2callback',
    passport.authenticate('google', {
      failureRedirect: '/login',
    }),
    (_, res) => {
      console.log('/oauth2callback');
      res.redirect(`${process.env.URL_APP}/your-settings`);
    },
  );

  // server.get('/logout', (req, res, next) => {
  //  req.logout((err) => {
  //    if (err) {
  //      next(err);
  //    }
  //    res.redirect(`${process.env.URL_APP}/login`);
  //  });
  //});
}

export { setupGoogle };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\api\server\mailchimp.ts -----

import fetch, { Response } from 'node-fetch';

// eslint-disable-next-line
require('dotenv').config();

const LIST_IDS = {
  signups: process.env.MAILCHIMP_SAAS_ALL_LIST_ID,
};

function callAPI({ path, method, data }): Promise<Response> {
  const ROOT_URI = `https://${process.env.MAILCHIMP_REGION}.api.mailchimp.com/3.0`;

  return fetch(`${ROOT_URI}${path}`, {
    method,
    headers: {
      Accept: 'application/json',
      Authorization: `Basic ${Buffer.from(`apikey:${process.env.MAILCHIMP_API_KEY}`).toString(
        'base64',
      )}`,
    },
    body: JSON.stringify(data),
  });
}

async function addToMailchimp({ email, listName }) {
  const data = {
    // eslint-disable-next-line
    email_address: email,
    status: 'subscribed',
  };

  const path = `/lists/${LIST_IDS[listName]}/members/`;

  await callAPI({ path, method: 'POST', data });
}

export { addToMailchimp };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\api\server\passwordless-auth.ts -----

import * as passwordless from 'passwordless';

import sendEmail from './aws-ses';
import getEmailTemplate from './models/EmailTemplate';
import User from './models/User';
import PasswordlessMongoStore from './passwordless-token-mongostore';

function setupPasswordless({ server }) {
  const mongoStore = new PasswordlessMongoStore();

  passwordless.addDelivery(async (tokenToSend, uidToSend, recipient, callback) => {
    try {
      const template = await getEmailTemplate('login', {
        loginURL: `${
          process.env.URL_API
        }/auth/logged_in?token=${tokenToSend}&uid=${encodeURIComponent(uidToSend)}`,
      });

      await sendEmail({
        from: `Kelly from saas-app.async-await.com <${process.env.EMAIL_SUPPORT_FROM_ADDRESS}>`,
        to: [recipient],
        subject: template.subject,
        body: template.message,
      });

      callback();
    } catch (err) {
      console.error('Email sending error:', err);
      callback(err);
    }
  });

  passwordless.init(mongoStore);
  server.use(passwordless.sessionSupport());

  server.use((req, __, next) => {
    if (req.user && typeof req.user === 'string') {
      User.findById(req.user, User.publicFields())
        .then((user) => {
          req.user = user;
          console.log('passwordless middleware');
          next();
        })
        .catch((err) => {
          next(err);
        });
    } else {
      next();
    }
  });

  server.post(
    '/auth/email-login-link',
    passwordless.requestToken(async (email, __, callback) => {
      try {
        const user = await User.findOne({ email }).select('_id').setOptions({ lean: true });

        if (user) {
          callback(null, user._id);
        } else {
          const id = await mongoStore.storeOrUpdateByEmail(email);
          callback(null, id);
        }
      } catch (error) {
        callback(error, null);
      }
    }),
    (_, res) => {
      res.json({ done: 1 });
    },
  );

  server.get(
    '/auth/logged_in',
    passwordless.acceptToken(),
    (req, __, next) => {
      if (req.user && typeof req.user === 'string') {
        User.findById(req.user, User.publicFields())
          .then((user) => {
            req.user = user;
            next();
          })
          .catch((err) => {
            next(err);
          });
      } else {
        next();
      }
    },
    (_, res) => {
      res.redirect(`${process.env.URL_APP}/your-settings`);
    },
  );

  server.get('/logout', (req, res, next) => {
    req.logout((err) => {
      if (err) {
        next(err);
      }
      res.redirect(`${process.env.URL_APP}/login`);
    });
  });
}

export { setupPasswordless };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\api\server\passwordless-token-mongostore.ts -----

import * as bcrypt from 'bcrypt';
import * as mongoose from 'mongoose';
import * as TokenStore from 'passwordless-tokenstore';
import * as util from 'util';

import User from './models/User';

interface TokenDocument extends mongoose.Document {
  hashedToken: string;
  uid: string;
  ttl: Date;
  originUrl: string;
  email: string;
}

const mongoSchema = new mongoose.Schema({
  hashedToken: {
    type: String,
    required: true,
  },
  uid: {
    type: String,
    required: true,
    unique: true,
  },
  ttl: {
    type: Date,
    required: true,
    expires: 0,
  },
  originUrl: String,
  email: String,
});

const PasswordlessToken = mongoose.model<TokenDocument>(
  'PasswordlessToken',
  mongoSchema,
  'passwordless-token',
);

function MongoStore(options = {}) {
  TokenStore.call(this);

  this._options = options || {};
}

util.inherits(MongoStore, TokenStore);

MongoStore.prototype.authenticate = async function (token, uid, callback) {
  if (!token || !uid || !callback) {
    throw new Error('TokenStore:authenticate called with invalid parameters');
  }

  try {
    const tokenDoc = await PasswordlessToken.findOne({ uid, ttl: { $gt: new Date() } }).setOptions({
      lean: true,
    });

    if (tokenDoc) {
      const isMatch = await bcrypt.compare(token, tokenDoc.hashedToken);
      if (isMatch) {
        if (tokenDoc.email) {
          await User.signInOrSignUpByPasswordless({ uid, email: tokenDoc.email });
        }

        callback(null, true, tokenDoc.originUrl);
      } else {
        callback(null, false, null);
      }
    } else {
      callback(null, false, null);
    }
  } catch (error) {
    callback(error, false, null);
  }
};

MongoStore.prototype.storeOrUpdate = async function (token, uid, msToLive, originUrl, callback) {
  if (!token || !uid || !msToLive || !callback) {
    throw new Error('TokenStore:storeOrUpdate called with invalid parameters');
  }

  const saltRounds = 10;

  try {
    const hashedToken = await bcrypt.hash(token, saltRounds);
    const newRecord = { hashedToken, uid, ttl: new Date(Date.now() + msToLive), originUrl };

    await PasswordlessToken.updateOne(
      { uid },
      { $set: newRecord },
      { upsert: true, runValidators: true },
    );
    callback();
  } catch (error) {
    callback(error);
  }
};

MongoStore.prototype.invalidateUser = async function (uid, callback) {
  if (!uid || !callback) {
    throw new Error('TokenStore:invalidateUser called with invalid parameters');
  }

  try {
    await PasswordlessToken.deleteOne({ uid });
    callback();
  } catch (error) {
    callback(error);
  }
};

MongoStore.prototype.clear = async function (callback) {
  if (!callback) {
    throw new Error('TokenStore:clear called with invalid parameters');
  }

  try {
    await PasswordlessToken.deleteMany({});
    callback();
  } catch (error) {
    callback(error);
  }
};

MongoStore.prototype.length = function (callback) {
  PasswordlessToken.countDocuments(callback);
};

MongoStore.prototype.storeOrUpdateByEmail = async function addEmail(email: string) {
  if (!email) {
    throw new Error('TokenStore:addEmail called with invalid parameters');
  }

  const obj = await PasswordlessToken.findOne({ email }).select('uid').setOptions({ lean: true });

  if (obj) {
    return obj.uid;
  }

  const uid = new mongoose.Types.ObjectId().toHexString();
  await PasswordlessToken.updateOne({ uid }, { email }, { upsert: true });

  return uid;
};

export default MongoStore;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\api\server\server.ts -----

// eslint-disable-next-line @typescript-eslint/no-var-requires
const MongoStore = require('connect-mongo');

import * as cors from 'cors';
import * as express from 'express';
import * as session from 'express-session';
import * as mongoose from 'mongoose';

import api from './api';
import { setupGoogle } from './google-auth';
import { setupPasswordless } from './passwordless-auth';

// eslint-disable-next-line
require('dotenv').config();

mongoose.connect(process.env.MONGO_URL_TEST);

const server = express();

server.use(
  cors({
    origin: process.env.URL_APP,
    methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',
    credentials: true,
  }),
);

server.use(express.json());

const sessionOptions = {
  name: process.env.SESSION_NAME,
  secret: process.env.SESSION_SECRET,
  resave: false,
  saveUninitialized: false,
  store: MongoStore.create({
    mongoUrl: process.env.MONGO_URL_TEST,
    ttl: 14 * 24 * 60 * 60, // save session 14 days
    autoRemove: 'interval',
    autoRemoveInterval: 1440, // clears every day
  }),
  cookie: {
    httpOnly: true,
    maxAge: 14 * 24 * 60 * 60 * 1000, // expires in 14 days
    secure: false,
  },
};

const sessionMiddleware = session(sessionOptions);
server.use(sessionMiddleware);

setupGoogle({ server });
setupPasswordless({ server });

api(server);

server.get('*', (_, res) => {
  res.sendStatus(403);
});

server.listen(process.env.PORT_API, () => {
  console.log(`> Ready on ${process.env.URL_API}`);
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\api\test\server\utils\slugify.test.ts -----

import * as mongoose from 'mongoose';
import User from '../../../server/models/User';
import { generateSlug } from '../../../server/utils/slugify';

// eslint-disable-next-line
require('dotenv').config();

describe('slugify', () => {
  beforeAll(async () => {
    await mongoose.connect(process.env.MONGO_URL_TEST);

    const mockUsers = [
      {
        slug: 'john',
        email: 'john@example.com',
        createdAt: new Date(),
        displayName: 'abc',
        avatarUrl: 'def',
      },
      {
        slug: 'john-johnson',
        email: 'john-johnson@example.com',
        createdAt: new Date(),
        displayName: 'abc',
        avatarUrl: 'def',
      },
      {
        slug: 'john-johnson-1',
        email: 'john-johnson-1@example.com',
        createdAt: new Date(),
        displayName: 'abc',
        avatarUrl: 'def',
      },
    ];

    await User.insertMany(mockUsers);
  });

  test('not duplicated', async () => {
    expect.assertions(1);

    await expect(generateSlug(User, 'John J Johnson@#$')).resolves.toEqual('john-j-johnson');
  });

  test('one time duplicated', async () => {
    expect.assertions(1);

    await expect(generateSlug(User, ' John@#$')).resolves.toEqual('john-1');
  });

  test('multiple duplicated', async () => {
    expect.assertions(1);

    await expect(generateSlug(User, 'John & Johnson@#$')).resolves.toEqual('john-johnson-2');
  });

  afterAll(async () => {
    await User.deleteMany({ slug: { $in: ['john', 'john-johnson', 'john-johnson-1'] } });
    await mongoose.disconnect();
  });
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\api\test\server\utils\sum.test.ts -----

import { sum } from '../../../server/utils/sum';

console.log(sum(1, 2));

describe.skip('testing sum function', () => {
  test('adds 1 + 2 to equal 3', () => {
    expect(sum(1, 2)).toBe(3);
  });
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\api\.eslintrc.js -----

module.exports = {
  parser: "@typescript-eslint/parser",
  extends: ["plugin:@typescript-eslint/recommended", "prettier"],
  env: {
    "es6": true,
    "node": true,
  },
  plugins: ["prettier"],
  rules: {
    'prettier/prettier': [
      'error',
      {
        singleQuote: true,
        trailingComma: 'all',
        arrowParens: 'always',
        printWidth: 100,
        semi: true,
      },
    ],
    '@typescript-eslint/no-unused-vars': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/no-explicit-any': 'off',
    'prefer-arrow-callback': 'error',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
 },
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\api\nodemon.json -----

{
  "watch": ["server"],
  "exec": "ts-node --project tsconfig.server.json",
  "ext": "ts"
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\api\package.json -----

{
  "name": "7-begin-api",
  "version": "1",
  "license": "MIT",
  "scripts": {
    "dev": "nodemon server/server.ts",
    "lint": "eslint . --ext .ts,.tsx",
    "test": "jest"
  },
  "jest": {
    "preset": "ts-jest",
    "testPathIgnorePatterns": [
      "production-server"
    ],
    "testEnvironment": "node"
  },
  "dependencies": {
    "aws-sdk": "^2.1692.0",
    "bcrypt": "^5.1.1",
    "connect-mongo": "^5.1.0",
    "cors": "^2.8.5",
    "dotenv": "^16.4.7",
    "express": "^4.21.2",
    "express-session": "^1.18.1",
    "lodash": "^4.17.21",
    "mongoose": "^8.12.1",
    "node-fetch": "2",
    "passport": "^0.7.0",
    "passport-google-oauth": "^2.0.0",
    "passwordless": "^1.1.3",
    "passwordless-tokenstore": "^0.0.10",
    "typescript": "^5.8.2"
  },
  "devDependencies": {
    "@types/connect-mongo": "^3.1.6",
    "@types/dotenv": "^8.2.3",
    "@types/express": "^5.0.1",
    "@types/express-session": "^1.18.1",
    "@types/jest": "^29.5.14",
    "@types/lodash": "^4.17.16",
    "@types/mongoose": "^5.11.97",
    "@types/node": "^22.13.10",
    "@types/node-fetch": "^2.6.12",
    "@types/passport": "^1.0.17",
    "@typescript-eslint/eslint-plugin": "^8.27.0",
    "@typescript-eslint/parser": "^8.27.0",
    "eslint": "^9.22.0",
    "eslint-config-prettier": "^10.1.1",
    "eslint-plugin-prettier": "^5.2.3",
    "jest": "^29.7.0",
    "nodemon": "^3.1.9",
    "prettier": "^3.5.3",
    "ts-jest": "^29.2.6",
    "ts-node": "^10.9.2"
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\api\tsconfig.json -----

{
  "compileOnSave": false,
  "compilerOptions": {
    "jsx": "preserve",
    "allowJs": true,
    "alwaysStrict": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "removeComments": false,
    "preserveConstEnums": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "sourceMap": true,
    "skipLibCheck": true,
    "baseUrl": ".",
    "experimentalDecorators": true,
    "typeRoots": ["./node_modules/@types"],
    "lib": ["es2015", "es2016"]
  },
  "exclude": ["production-server", "node_modules"]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\api\tsconfig.server.json -----

{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "module": "commonjs",
    "outDir": "production-server/"
  },
  "include": ["./server/**/*.ts"],
  "exclude": ["./server/**/*.test.ts"]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\components\common\Confirmer.tsx -----

import Button from "@mui/material/Button";
import Dialog from "@mui/material/Dialog";
import DialogActions from "@mui/material/DialogActions";
import DialogContent from "@mui/material/DialogContent";
import DialogContentText from "@mui/material/DialogContentText";
import DialogTitle from "@mui/material/DialogTitle";
import React from "react";

export let openConfirmDialogExternal;

type State = {
  open: boolean;
  title: string;
  message: string;
  onAnswer: (answer) => void;
};

class Confirmer extends React.Component<any, State> {
  constructor(props) {
    super(props);

    this.state = {
      open: false,
      title: "Are you sure?",
      message: "",
      onAnswer: null,
    };

    openConfirmDialogExternal = this.openConfirmDialog;
  }

  public render() {
    return (
      <Dialog
        open={this.state.open}
        onClose={this.handleClose}
        aria-labelledby="alert-dialog-title"
        aria-describedby="alert-dialog-description"
      >
        <DialogTitle id="alert-dialog-title">{this.state.title}</DialogTitle>
        <DialogContent>
          <DialogContentText id="alert-dialog-description">{this.state.message}</DialogContentText>
        </DialogContent>
        <DialogActions style={{ padding: "10px" }}>
          <Button onClick={this.handleClose} variant="contained" color="primary" autoFocus>
            Cancel
          </Button>
          <Button onClick={this.handleYes} variant="contained" color="secondary">
            OK
          </Button>
        </DialogActions>
      </Dialog>
    );
  }

  public handleClose = () => {
    this.setState({ open: false });
    this.state.onAnswer(false);
  };

  public handleYes = () => {
    this.setState({ open: false });
    this.state.onAnswer(true);
  };

  public openConfirmDialog = ({ title, message, onAnswer }) => {
    this.setState({ open: true, title, message, onAnswer });
  };
}

export default Confirmer;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\components\common\LoginButton.tsx -----

import Button from "@mui/material/Button";
import TextField from "@mui/material/TextField";
import React from "react";

import { emailLoginLinkApiMethod } from "../../lib/api/public";
import notify from "../../lib/notify";

type State = { email: string };

class LoginButton extends React.PureComponent<any, State> {
  constructor(props) {
    super(props);

    this.state = { email: "" };
  }

  public render() {
    const url = `${process.env.NEXT_PUBLIC_URL_API}/auth/google`;

    console.log(url);

    return (
      <React.Fragment>
        <Button variant="contained" color="secondary" href={url}>
          <img src="https://storage.googleapis.com/async-await-all/G.svg" alt="Log in with Google" />
          &nbsp;&nbsp;&nbsp; Log in with Google
        </Button>
        <p />
        <br />
        <hr style={{ width: "60px" }} /> <h4>OR</h4> <hr style={{ width: "60px" }} />
        <p />
        <br />
        <div>
          <form autoComplete="off" onSubmit={this.onSubmit}>
            <TextField
              required
              type="email"
              label="Email address"
              value={this.state.email}
              onChange={(event) => {
                this.setState({ email: event.target.value });
              }}
              style={{ width: "300px" }}
            />
            <p />
            <Button variant="contained" color="primary" type="submit">
              Log in with email
            </Button>
          </form>
          <p />
          <br />
        </div>
      </React.Fragment>
    );
  }

  private onSubmit = async (event) => {
    event.preventDefault();
    const { email } = this.state;

    if (!email) {
      notify("Email is required");
    }

    try {
      await emailLoginLinkApiMethod({ email });
      this.setState({ email: "" });
      notify("SaaS boilerplate emailed you a login link.");
    } catch (error) {
      notify(error);
    }
  };
}

export default LoginButton;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\components\common\MenuWithLinks.tsx -----

import Menu from "@mui/material/Menu";
import MenuItem from "@mui/material/MenuItem";
import Link from "next/link";
import { NextRouter, withRouter } from "next/router";
import React from "react";

type Props = {
  options: {
    href: string;
    as: string;
    highlighterSlug: string;
    text: string;
    externalServer: boolean;
    separator: boolean;
  }[];
  router: NextRouter;
  children: any;
};

type State = {
  anchorEl: Element | ((element: Element) => Element);
};

class MenuWithLinks extends React.PureComponent<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      anchorEl: null,
    };
  }

  public render() {
    const { options, children, router } = this.props;
    const { anchorEl } = this.state;

    return (
      <div style={{ textAlign: "center" }}>
        <div
          aria-controls={anchorEl ? "simple-menu" : null}
          aria-haspopup="true"
          onClick={this.handleClick}
          onKeyPress={this.handleClick}
        >
          {children}
        </div>
        <Menu id="simple-menu" anchorEl={anchorEl} open={Boolean(anchorEl)} onClose={this.handleClose} keepMounted>
          {options.map((option, i) =>
            option.separator ? (
              <hr style={{ width: "95%", margin: "10px auto" }} key={`separated-${i}`} />
            ) : option.externalServer ? (
              <MenuItem
                onClick={(event) => {
                  event.preventDefault();
                  window.location.href = option.href;
                  this.handleClose();
                }}
                key={option.href || option.text}
              >
                {option.text}
              </MenuItem>
            ) : (
              <Link key={option.href} href={option.href} as={option.as} passHref>
                <MenuItem
                  key={option.href}
                  style={{
                    fontWeight: router.asPath.includes(option.highlighterSlug) ? 600 : 300,
                    fontSize: "14px",
                  }}
                >
                  {option.text}
                </MenuItem>
              </Link>
            )
          )}
        </Menu>
      </div>
    );
  }

  public handleClick = (event) => {
    this.setState({ anchorEl: event.currentTarget });
  };

  public handleClose = () => {
    this.setState({ anchorEl: null });
  };
}

export default withRouter(MenuWithLinks);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\components\common\Notifier.tsx -----

import Snackbar from "@mui/material/Snackbar";
import React from "react";

export let openSnackbarExternal;

type State = {
  open: boolean;
  message: string;
};

class Notifier extends React.PureComponent<any, State> {
  constructor(props) {
    super(props);
    openSnackbarExternal = this.openSnackbar;

    this.state = {
      open: false,
      message: "",
    };
  }

  public render() {
    const message = <span id="snackbar-message-id" dangerouslySetInnerHTML={{ __html: this.state.message }} />;

    return (
      <Snackbar
        anchorOrigin={{ vertical: "top", horizontal: "right" }}
        message={message}
        autoHideDuration={5000}
        onClose={this.handleSnackbarClose}
        open={this.state.open}
        ContentProps={{
          "aria-describedby": "snackbar-message-id",
        }}
      />
    );
  }

  public handleSnackbarClose = () => {
    this.setState({
      open: false,
      message: "",
    });
  };

  public openSnackbar = ({ message }) => {
    this.setState({ open: true, message });
  };
}

export default Notifier;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\components\layout\index.tsx -----

import Avatar from "@mui/material/Avatar";
import Grid from "@mui/material/Grid";
import React from "react";
import MenuWithLinks from "../common/MenuWithLinks";
import Confirmer from "../common/Confirmer";
import Notifier from "../common/Notifier";

const styleGrid = {
  width: "100%",
  height: "100vh",
  maxWidth: "100%",
  padding: "0px 10px",
  display: "flex",
  overflow: "hidden",
};

const styleGridIsMobile = {
  width: "100%",
  height: "100vh",
  maxWidth: "100%",
  padding: "0px 0px 0px 10px",
  display: "flex",
  overflow: "hidden",
};

type Props = {
  children: React.ReactNode;
  firstGridItem?: boolean;
  isMobile?: boolean;
};

class Layout extends React.Component<Props> {
  public render() {
    const { children, firstGridItem, isMobile } = this.props;

    const isThemeDark = false;

    // console.log(isMobile);

    return (
      <Grid
        container
        direction="row"
        justify="flex-start"
        alignItems="stretch"
        style={isMobile ? styleGridIsMobile : styleGrid}
      >
        {firstGridItem ? (
          <Grid
            item
            sm={2}
            xs={12}
            style={{
              borderRight: "1px #707070 solid",
              justifyContent: "center",
              overflow: "hidden",
            }}
          >
            <div style={{ display: "flex", justifyContent: "space-between" }}>
              <svg
                xmlns="http://www.w3.org/2000/svg"
                width="124"
                height="40"
                viewBox="0 0 124 40"
                style={{
                  marginTop: "20px",
                  display: "inline-flex",
                  height: "40px",
                }}
              >
                <g id="async-logo">
                  <g id="async-logo-40">
                    <circle id="Ellipse 2" cx="20" cy="20" r="20" fill="black" />
                    <path
                      id="path-async-logo"
                      d="M7.07825 -0.0960007V16H4.51825V13.088C4.04892 14.0907 3.33425 14.8693 2.37425 15.424C1.43558 15.9573 0.336917 16.224 -0.92175 16.224C-2.35108 16.224 -3.60975 15.8827 -4.69775 15.2C-5.76442 14.5173 -6.59642 13.5573 -7.19375 12.32C-7.76975 11.0613 -8.05775 9.6 -8.05775 7.936C-8.05775 6.272 -7.75908 4.81067 -7.16175 3.552C-6.56442 2.272 -5.73242 1.28 -4.66575 0.576C-3.57775 -0.128 -2.32975 -0.48 -0.92175 -0.48C0.336917 -0.48 1.43558 -0.202666 2.37425 0.352C3.31292 0.906667 4.02758 1.68533 4.51825 2.688V-0.0960007H7.07825ZM-0.40975 14.08C1.16892 14.08 2.38492 13.5467 3.23825 12.48C4.09158 11.392 4.51825 9.856 4.51825 7.872C4.51825 5.888 4.09158 4.36267 3.23825 3.296C2.38492 2.22933 1.16892 1.696 -0.40975 1.696C-1.98842 1.696 -3.22575 2.25067 -4.12175 3.36C-4.99642 4.448 -5.43375 5.97333 -5.43375 7.936C-5.43375 9.89867 -4.99642 11.4133 -4.12175 12.48C-3.24708 13.5467 -2.00975 14.08 -0.40975 14.08Z"
                      transform="translate(19.5938 12)"
                      fill="white"
                    />
                  </g>
                  <path
                    id="path-async-text"
                    d="M22.6251 11.928V24H20.7051V21.816C20.3531 22.568 19.8171 23.152 19.0971 23.568C18.3931 23.968 17.5691 24.168 16.6251 24.168C15.5531 24.168 14.6091 23.912 13.7931 23.4C12.9931 22.888 12.3691 22.168 11.9211 21.24C11.4891 20.296 11.2731 19.2 11.2731 17.952C11.2731 16.704 11.4971 15.608 11.9451 14.664C12.3931 13.704 13.0171 12.96 13.8171 12.432C14.6331 11.904 15.5691 11.64 16.6251 11.64C17.5691 11.64 18.3931 11.848 19.0971 12.264C19.8011 12.68 20.3371 13.264 20.7051 14.016V11.928H22.6251ZM17.0091 22.56C18.1931 22.56 19.1051 22.16 19.7451 21.36C20.3851 20.544 20.7051 19.392 20.7051 17.904C20.7051 16.416 20.3851 15.272 19.7451 14.472C19.1051 13.672 18.1931 13.272 17.0091 13.272C15.8251 13.272 14.8971 13.688 14.2251 14.52C13.5691 15.336 13.2411 16.48 13.2411 17.952C13.2411 19.424 13.5691 20.56 14.2251 21.36C14.8811 22.16 15.8091 22.56 17.0091 22.56ZM30.4637 24.168C28.4317 24.168 26.8237 23.648 25.6397 22.608L26.2877 21.168C26.9437 21.68 27.6077 22.048 28.2797 22.272C28.9517 22.496 29.7037 22.608 30.5357 22.608C31.4477 22.608 32.1357 22.456 32.5997 22.152C33.0797 21.832 33.3197 21.376 33.3197 20.784C33.3197 20.304 33.1597 19.92 32.8397 19.632C32.5197 19.344 31.9917 19.12 31.2557 18.96L29.2157 18.48C28.2077 18.256 27.4237 17.856 26.8637 17.28C26.3197 16.704 26.0477 16.016 26.0477 15.216C26.0477 14.16 26.4717 13.304 27.3197 12.648C28.1677 11.976 29.2877 11.64 30.6797 11.64C31.5277 11.64 32.3277 11.776 33.0797 12.048C33.8317 12.32 34.4637 12.712 34.9757 13.224L34.3277 14.64C33.1917 13.696 31.9757 13.224 30.6797 13.224C29.8157 13.224 29.1437 13.392 28.6637 13.728C28.1997 14.048 27.9677 14.504 27.9677 15.096C27.9677 15.592 28.1117 15.984 28.3997 16.272C28.7037 16.56 29.1837 16.784 29.8397 16.944L31.8797 17.448C32.9997 17.704 33.8317 18.104 34.3757 18.648C34.9197 19.176 35.1917 19.872 35.1917 20.736C35.1917 21.776 34.7677 22.608 33.9197 23.232C33.0717 23.856 31.9197 24.168 30.4637 24.168ZM48.687 11.928L43.047 25.104C42.455 26.48 41.711 27.488 40.815 28.128C39.919 28.768 38.815 29.208 37.503 29.448L37.095 27.936C38.231 27.68 39.087 27.336 39.663 26.904C40.255 26.488 40.743 25.84 41.127 24.96L41.607 23.88L36.495 11.928H38.535L42.615 21.888L46.743 11.928H48.687ZM56.853 11.64C59.749 11.64 61.197 13.232 61.197 16.416V24H59.253V16.512C59.253 15.392 59.029 14.576 58.581 14.064C58.133 13.536 57.429 13.272 56.469 13.272C55.349 13.272 54.453 13.616 53.781 14.304C53.109 14.992 52.773 15.92 52.773 17.088V24H50.829V15.312C50.829 14.064 50.765 12.936 50.637 11.928H52.485L52.677 14.088C53.045 13.304 53.597 12.704 54.333 12.288C55.069 11.856 55.909 11.64 56.853 11.64ZM69.9321 24.168C68.7641 24.168 67.7401 23.912 66.8601 23.4C65.9961 22.888 65.3241 22.168 64.8441 21.24C64.3801 20.296 64.1481 19.2 64.1481 17.952C64.1481 16.704 64.3881 15.608 64.8681 14.664C65.3481 13.704 66.0281 12.96 66.9081 12.432C67.8041 11.904 68.8441 11.64 70.0281 11.64C70.8441 11.64 71.6281 11.784 72.3801 12.072C73.1481 12.344 73.7801 12.728 74.2761 13.224L73.6281 14.664C73.0201 14.184 72.4281 13.832 71.8521 13.608C71.2921 13.384 70.7161 13.272 70.1241 13.272C68.8921 13.272 67.9241 13.688 67.2201 14.52C66.5161 15.336 66.1641 16.48 66.1641 17.952C66.1641 19.408 66.5081 20.544 67.1961 21.36C67.9001 22.16 68.8761 22.56 70.1241 22.56C70.7161 22.56 71.2921 22.448 71.8521 22.224C72.4281 22 73.0201 21.648 73.6281 21.168L74.2761 22.608C73.7641 23.088 73.1161 23.472 72.3321 23.76C71.5641 24.032 70.7641 24.168 69.9321 24.168Z"
                    transform="translate(39 4)"
                    fill={isThemeDark ? "white" : "black"}
                  />
                </g>
              </svg>
              <MenuWithLinks
                options={[
                  {
                    text: "Index page",
                    href: "/",
                    highlighterSlug: "/",
                  },
                  {
                    text: "Your Settings",
                    href: "/your-settings",
                    highlighterSlug: "/your-settings",
                  },
                  {
                    separator: true,
                  },
                  {
                    text: "Log out",
                    href: `${process.env.NEXT_PUBLIC_URL_API}/logout`,
                    as: `${process.env.NEXT_PUBLIC_URL_API}/logout`,
                    externalServer: true,
                  },
                ]}
              >
                <Avatar
                  src={"https://storage.googleapis.com/async-await/default-user.png"}
                  alt="Add username here later in the book"
                  style={{
                    margin: "20px auto",
                    cursor: "pointer",
                    display: "inline-flex",
                    width: "40px",
                    height: "40px",
                  }}
                />

                <i className="material-icons" color="action" style={{ verticalAlign: "super" }}>
                  arrow_drop_down
                </i>
              </MenuWithLinks>
            </div>
            <hr />
            <p />
            <p />
          </Grid>
        ) : null}
        <Grid item sm={firstGridItem ? 10 : 12} xs={12}>
          {isMobile ? <hr /> : null}
          {children}
        </Grid>
        <Notifier />
        <Confirmer />
      </Grid>
    );
  }
}

export default Layout;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\lib\api\public.ts -----

import sendRequestAndGetResponse from './sendRequestAndGetResponse';

const BASE_PATH = '/api/v1/public';

export const getUserApiMethod = (request) =>
  sendRequestAndGetResponse(`${BASE_PATH}/get-user`, {
    request,
    method: 'GET',
  });

export const getUserBySlugApiMethod = (slug) =>
  sendRequestAndGetResponse(`${BASE_PATH}/get-user-by-slug`, {
    body: JSON.stringify({ slug }),
  });

export const updateProfileApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/user/update-profile`, {
    body: JSON.stringify(data),
  });

export const emailLoginLinkApiMethod = ({ email }: { email: string }) =>
  sendRequestAndGetResponse('/auth/email-login-link', {
    body: JSON.stringify({ user: email }),
  });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\lib\api\sendRequestAndGetResponse.ts -----

import 'isomorphic-unfetch';

export default async function sendRequestAndGetResponse(path, opts: any = {}) {
  const headers = Object.assign(
    {},
    opts.headers || {},
    opts.externalServer
      ? {}
      : {
          'Content-type': 'application/json; charset=UTF-8',
        },
  );

  const { request } = opts;

  if (request && request.headers && request.headers.cookie) {
    headers.cookie = request.headers.cookie;
  }

  const qs = opts.qs || '';

  // console.log(`before: ${process.env.NEXT_PUBLIC_URL_API}${path}${qs}`);

  const response = await fetch(
    opts.externalServer ? `${path}${qs}` : `${process.env.NEXT_PUBLIC_URL_API}${path}${qs}`,
    Object.assign({ method: 'POST', credentials: 'include' }, opts, { headers }),
  );

  // console.log(`after: ${process.env.NEXT_PUBLIC_URL_API}${path}${qs}`);

  // console.log(response.status);
  // console.log(response.statusText);

  const text = await response.text();

  if (response.status >= 400) {
    console.error(text);
    throw new Error(response.status.toString());
  }

  try {
    const data = JSON.parse(text);

    return data;
  } catch (err) {
    if (err instanceof SyntaxError) {
      return text;
    }

    throw err;
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\lib\api\team-member.ts -----

import sendRequestAndGetResponse from './sendRequestAndGetResponse';

const BASE_PATH = '/api/v1/team-member';

export const getSignedRequestForUploadApiMethod = ({ fileName, fileType, prefix, bucket }) =>
  sendRequestAndGetResponse(`${BASE_PATH}/aws/get-signed-request-for-upload-to-s3`, {
    body: JSON.stringify({ fileName, fileType, prefix, bucket }),
  });

export const uploadFileUsingSignedPutRequestApiMethod = (file, signedRequest, headers = {}) =>
  sendRequestAndGetResponse(signedRequest, {
    externalServer: true,
    method: 'PUT',
    body: file,
    headers,
  });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\lib\confirm.ts -----

import { openConfirmDialogExternal } from '../components/common/Confirmer';

export default function confirm({
  title,
  message,
  onAnswer,
}: {
  title: string;
  message: string;
  onAnswer: (answer) => void;
}) {
  openConfirmDialogExternal({ title, message, onAnswer });
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\lib\isMobile.ts -----

const mobileRE = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i;

export function isMobile(opts) {
  if (!opts) {
    opts = {};
  }

  let ua = opts.ua;

  if (!ua && typeof navigator !== 'undefined') {
    ua = navigator.userAgent;
  }

  if (!ua && opts.req && opts.req.headers && typeof opts.req.headers['user-agent'] === 'string') {
    ua = opts.req.headers['user-agent'];
    // console.log(ua);
  }

  if (typeof ua !== 'string') {
    return false;
  }

  return mobileRE.test(ua);
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\lib\notify.ts -----

import { openSnackbarExternal } from '../components/common/Notifier';

export default function notify(obj) {
  openSnackbarExternal({ message: obj.message || obj.toString() });
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\lib\resizeImage.ts -----

function resizeImage(file: File, MAX_WIDTH, MAX_HEIGHT) {
  const image = document.createElement('img');

  const resize = (resolve) => () => {
    let isResizeNeeded = false;
    let width = image.width;
    let height = image.height;

    if (width > height) {
      if (width > MAX_WIDTH) {
        isResizeNeeded = true;
        height *= MAX_WIDTH / width;
        width = MAX_WIDTH;
      }
    } else {
      if (height > MAX_HEIGHT) {
        isResizeNeeded = true;
        width *= MAX_HEIGHT / height;
        height = MAX_HEIGHT;
      }
    }

    if (isResizeNeeded) {
      const canvas = document.createElement('canvas');

      canvas.width = width;
      canvas.height = height;

      console.log(width, height);

      const ctx = canvas.getContext('2d');
      ctx.drawImage(image, 0, 0, width, height);

      canvas.toBlob((blob) => {
        resolve(blob);
      }, file.type);
    } else {
      resolve(file);
    }
  };

  return new Promise((resolve) => {
    const reader = new FileReader();

    console.log(`before ${image.src}`);

    reader.readAsDataURL(file);

    reader.onload = (e) => {
      image.src = e.target.result.toString();

      image.onload = resize(resolve);

      console.log(`after ${image.src}`);
    };
  });
}

export { resizeImage };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\lib\sharedStyles.ts -----

const styleBigAvatar = {
  width: '80px',
  height: '80px',
  margin: '0px auto 15px',
};

const styleRaisedButton = {
  margin: '15px',
  font: '14px Roboto',
};

const styleToolbar = {
  background: '#FFF',
  height: '64px',
  paddingRight: '20px',
};

const styleTextField = {
  font: '15px Roboto',
  color: '#222',
  fontWeight: '300',
};

const styleForm = {
  margin: '7% auto',
  width: '360px',
};

export { styleBigAvatar, styleRaisedButton, styleToolbar, styleTextField, styleForm };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\lib\theme.ts -----

import { createMuiTheme } from "@mui/material/styles";

const themeDark = createMuiTheme({
  palette: {
    primary: { main: "#238636" },
    secondary: { main: "#b62324" },
    type: "dark",
    background: { default: "#0d1117" },
    text: {
      primary: "#c9d1d9",
    },
  },
  typography: {
    button: {
      textTransform: "none",
    },
  },
});

const themeLight = createMuiTheme({
  palette: {
    primary: { main: "#238636" },
    secondary: { main: "#b62324" },
    type: "light",
    background: { default: "#fff" },
    text: {
      primary: "#222",
    },
  },
  typography: {
    button: {
      textTransform: "none",
    },
  },
});

export { themeDark, themeLight };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\lib\withAuth.tsx -----

import Router from 'next/router';
import React from 'react';

import * as NProgress from 'nprogress';

import { getUserApiMethod } from '../lib/api/public';

Router.events.on('routeChangeStart', () => {
  NProgress.start();
});

Router.events.on('routeChangeComplete', () => {
  NProgress.done();
});

Router.events.on('routeChangeError', () => NProgress.done());

type Props = {
  user: { email: string; displayName: string; slug: string; avatarUrl: string };
};

export default function withAuth(Component, { loginRequired = true, logoutRequired = false } = {}) {
  class WithAuth extends React.Component<Props> {
    public static async getInitialProps(ctx) {
      const { req, res } = ctx;

      let pageComponentProps = {};

      if (Component.getInitialProps) {
        pageComponentProps = await Component.getInitialProps(ctx);
      }

      const { user } = await getUserApiMethod(req);

      console.log(user);

      if (loginRequired && !logoutRequired && !user) {
        if (res) {
          res.redirect('/login');
        } else {
          Router.push('/login');
        }
        return;
      }

      let redirectUrl = '/login';
      let asUrl = '/login';

      if (user) {
        redirectUrl = `/your-settings`;
        asUrl = `/your-settings`;
      }

      if (logoutRequired && user) {
        if (res) {
          res.redirect(`${redirectUrl}`);
        } else {
          Router.push(redirectUrl, asUrl);
        }
      }

      return {
        ...pageComponentProps,
        user,
      };
    }

    public render() {
      const { user } = this.props;

      if (loginRequired && !logoutRequired && !user) {
        return null;
      }

      if (logoutRequired && user) {
        return null;
      }

      return <Component {...this.props} />;
    }
  }

  return WithAuth;
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\pages\csr-page.tsx -----

import Button from "@mui/material/Button";
import React from "react";
import Head from "next/head";

const CSRPage = () => (
  <div>
    <Head>
      <title>CSR page</title>
      <meta name="description" content="This is a description of the CSR page" />
    </Head>
    <div style={{ padding: "0px 30px", fontSize: "15px", height: "100%" }}>
      <p>Content on CSR page</p>
      <Button variant="outlined">Some button</Button>
    </div>
  </div>
);

console.log(process.env.NEXT_PUBLIC_URL_APP);

export default CSRPage;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\pages\index.tsx -----

import Button from "@mui/material/Button";
import React from "react";
import Head from "next/head";
import Link from "next/link";

import Layout from "../components/layout";
import NProgress from "nprogress";

import confirm from "../lib/confirm";
import notify from "../lib/notify";
import { getUserBySlugApiMethod } from "../lib/api/public";

type Props = { user: { email: string; displayName: string } };

class Index extends React.Component<Props> {
  public static async getInitialProps() {
    const slug = "team-builder-book";

    const user = await getUserBySlugApiMethod(slug);

    console.log(user);

    return { ...user };
  }

  public render() {
    return (
      <Layout {...this.props}>
        <Head>
          <title>Index page</title>
          <meta name="description" content="This is a description of the Index page" />
        </Head>
        <div style={{ padding: "0px 30px", fontSize: "15px", height: "100%" }}>
          <p>Content on Index page</p>
          <Link href="/your-settings" as="/your-settings">
            Go to Your Settings page
          </Link>
          <p />
          <Button
            variant="contained"
            onClick={() =>
              confirm({
                title: "Are you sure?",
                message: "explanatory message",
                onAnswer: async (answer) => {
                  // console.log(answer);
                  if (!answer) {
                    return;
                  }

                  NProgress.start();

                  try {
                    notify("You successfully confirmed.");
                  } catch (error) {
                    console.error(error);
                    notify(error);
                  } finally {
                    NProgress.done();
                  }
                },
              })
            }
          >
            Test Confirmer and Notifier
          </Button>
          <p>Your email: {this.props.user.email}</p>
          <p>Your username: {this.props.user.displayName}</p>
        </div>
      </Layout>
    );
  }
}

export default Index;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\pages\login.tsx -----

import Head from 'next/head';
import React from 'react';
import LoginButton from '../components/common/LoginButton';
import Layout from '../components/layout';
import withAuth from '../lib/withAuth';

class Login extends React.Component {
  public render() {
    return (
      <Layout {...this.props}>
        <div style={{ textAlign: 'center', margin: '0 20px' }}>
          <Head>
            <title>Log in to SaaS boilerplate by Async</title>
            <meta
              name="description"
              content="Login and signup page for SaaS boilerplate demo by Async"
            />
          </Head>
          <br />
          <p style={{ margin: '45px auto', fontSize: '44px', fontWeight: 400 }}>Log in</p>
          <p>Youll be logged in for 14 days unless you log out manually.</p>
          <br />

          <LoginButton />
        </div>
      </Layout>
    );
  }
}

export default withAuth(Login, { logoutRequired: true });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\pages\your-settings.tsx -----

import Avatar from "@mui/material/Avatar";
import Button from "@mui/material/Button";
import TextField from "@mui/material/TextField";
import Head from "next/head";
import NProgress from "nprogress";
import * as React from "react";

import Layout from "../components/layout";

import { updateProfileApiMethod } from "../lib/api/public";
import { getSignedRequestForUploadApiMethod, uploadFileUsingSignedPutRequestApiMethod } from "../lib/api/team-member";

import { resizeImage } from "../lib/resizeImage";

import notify from "../lib/notify";

import withAuth from "../lib/withAuth";

type Props = {
  isMobile: boolean;
  user: { email: string; displayName: string; slug: string; avatarUrl: string };
};

type State = { newName: string; newAvatarUrl: string; disabled: boolean };

class YourSettings extends React.Component<Props, State> {
  // public static async getInitialProps(ctx) {
  //   const user = await getUserApiMethod(ctx.req);

  //   console.log(user);

  //   return { ...user };
  // }

  // public static async getInitialProps() {
  //   const slug = 'team-builder-book';

  //   const user = await getUserBySlugApiMethod(slug);

  //   console.log(user);

  //   return { ...user };
  // }

  constructor(props) {
    super(props);

    this.state = {
      newName: this.props.user.displayName,
      newAvatarUrl: this.props.user.avatarUrl,
      disabled: false,
    };
  }

  public render() {
    const { user } = this.props;
    const { newName, newAvatarUrl } = this.state;

    return (
      <Layout {...this.props}>
        <Head>
          <title>Your Settings at Async</title>
          <meta name="description" content="description" />
        </Head>
        <div
          style={{
            padding: this.props.isMobile ? "0px" : "0px 30px",
            fontSize: "15px",
            height: "100%",
          }}
        >
          <h3>Your Settings</h3>
          <h4 style={{ marginTop: "40px" }}>Your account</h4>
          <ul>
            <li>
              Your email: <b>{user.email}</b>
            </li>
            <li>
              Your username: <b>{user.displayName}</b>
            </li>
          </ul>
          <form onSubmit={this.onSubmit} autoComplete="off">
            <h4>Your username</h4>
            <TextField
              autoComplete="off"
              value={newName}
              helperText="Your username as seen by your team members"
              onChange={(event) => {
                this.setState({ newName: event.target.value });
              }}
            />
            <br />
            <br />
            <Button variant="contained" color="primary" type="submit" disabled={this.state.disabled}>
              Update username
            </Button>
          </form>

          <br />
          <h4>Your photo</h4>
          <Avatar
            src={newAvatarUrl}
            style={{
              display: "inline-flex",
              verticalAlign: "middle",
              marginRight: 20,
              width: 60,
              height: 60,
            }}
          />
          <label htmlFor="upload-file-user-avatar">
            <Button variant="outlined" color="primary" component="span" disabled={this.state.disabled}>
              Update avatar
            </Button>
          </label>
          <input
            accept="image/*"
            name="upload-file-user-avatar"
            id="upload-file-user-avatar"
            type="file"
            style={{ display: "none" }}
            onChange={this.uploadFile}
          />
          <p />
          <br />
        </div>
      </Layout>
    );
  }

  private onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();

    const { newName, newAvatarUrl } = this.state;

    console.log(newName);

    if (!newName) {
      notify("Name is required");
      return;
    }

    NProgress.start();
    this.setState({ disabled: true });

    try {
      await updateProfileApiMethod({
        name: newName,
        avatarUrl: newAvatarUrl,
      });

      notify("You successfully updated your profile.");
    } catch (error) {
      notify(error);
    } finally {
      this.setState({ disabled: false });
      NProgress.done();
    }
  };

  private uploadFile = async () => {
    const fileElement = document.getElementById("upload-file-user-avatar") as HTMLFormElement;
    const file = fileElement.files[0];

    if (file == null) {
      notify("No file selected for upload.");
      return;
    }

    const fileName = file.name;
    const fileType = file.type;

    NProgress.start();
    this.setState({ disabled: true });

    const bucket = process.env.NEXT_PUBLIC_BUCKET_FOR_AVATARS;

    const prefix = "team-builder-book";

    try {
      const responseFromApiServerForUpload = await getSignedRequestForUploadApiMethod({
        fileName,
        fileType,
        prefix,
        bucket,
      });

      const resizedFile = await resizeImage(file, 128, 128);

      console.log(file);
      console.log(resizedFile);

      await uploadFileUsingSignedPutRequestApiMethod(resizedFile, responseFromApiServerForUpload.signedRequest, {
        "Cache-Control": "max-age=2592000",
      });

      this.setState({
        newAvatarUrl: responseFromApiServerForUpload.url,
      });

      await updateProfileApiMethod({
        name: this.state.newName,
        avatarUrl: this.state.newAvatarUrl,
      });

      notify("You successfully uploaded new avatar.");
    } catch (error) {
      notify(error);
    } finally {
      fileElement.value = "";
      this.setState({ disabled: false });
      NProgress.done();
    }
  };
}

export default withAuth(YourSettings);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\pages\_app.tsx -----

import CssBaseline from "@mui/material/CssBaseline";
import { ThemeProvider } from "@mui/material";
import App from "next/app";
import Head from "next/head";
import React from "react";
import { isMobile } from "../lib/isMobile";
import { themeDark, themeLight } from "../lib/theme";

class MyApp extends App {
  public static async getInitialProps({ Component, ctx }) {
    let firstGridItem = true;

    if (ctx.pathname.includes("/login")) {
      firstGridItem = false;
    }

    const pageProps = { isMobile: isMobile({ req: ctx.req }), firstGridItem };

    if (Component.getInitialProps) {
      Object.assign(pageProps, await Component.getInitialProps(ctx));
    }

    return { pageProps };
  }

  public componentDidMount() {
    // Remove the server-side injected CSS.
    const jssStyles = document.querySelector("#jss-server-side");
    if (jssStyles && jssStyles.parentNode) {
      jssStyles.parentNode.removeChild(jssStyles);
    }
  }
  public render() {
    const { Component, pageProps } = this.props;

    return (
      <ThemeProvider theme={false ? themeDark : themeLight}>
        <Head>
          <meta name="viewport" content="width=device-width, initial-scale=1.0" />
          <link rel="stylesheet" href="https://storage.googleapis.com/async-await/nprogress-dark.min.css?v=1" />
        </Head>
        <CssBaseline />
        <Component {...pageProps} />
      </ThemeProvider>
    );
  }
}

export default MyApp;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\pages\_document.tsx -----

import Document, { Head, Html, Main, NextScript } from "next/document";
import React from "react";

class MyDocument extends Document {
  public static getInitialProps = async (ctx) => {
    const initialProps = await Document.getInitialProps(ctx);

    return {
      ...initialProps,
    };
  };

  public render() {
    // console.log('rendered on the server');

    return (
      <Html lang="en">
        <Head>
          <meta charSet="utf-8" />
          <meta name="google" content="notranslate" />
          <meta name="theme-color" content="#303030" />

          <link rel="shortcut icon" href="https://storage.googleapis.com/async-await/async-favicon32.png" />

          <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons" />
          <link rel="stylesheet" href="https://storage.googleapis.com/async-await/vs2015.min.css" />

          <style>
            {`
              #__next {
                width: 100%;
                height: 100%;
              }
              a {
                font-weight: 400;
                color: #58a6ff;
                text-decoration: none;
                outline: none;
              }
              hr {
                border: 0.5px #707070 solid;
                color: #000;
              }
              blockquote {
                padding: 0 0.5em;
                margin: 20px 1em;
                border-left: 0.25em solid #dfe2e5;
                color: #000;
              }
              pre {
                display: block;
                overflow-x: auto;
                padding: 0.5em;
                background: #d0d0d0;
                border: 1px solid #ddd;
                font-size: 14px;
                color: #000;
              }
              pre code {
                font-size: 13px;
                background: #d0d0d0;
                padding: 0px;
                color: #000;
              }
              code {
                font-size: 13px;
                background: #d0d0d0;
                padding: 3px 5px;
                color: #000;
              }
              mark {
                background-color: #ffff0060;
              }
              summary:focus {
                outline: none;
              }
              table {
                border-collapse: collapse;
                margin: 15px 0px;
              }
              table, th, td {
                border: 1px solid #a1a1a1;
              }
              th, td {
                line-height: 1.5em;
                padding: 10px;
              }
            `}
          </style>
        </Head>
        <body>
          <Main />
          <NextScript />
        </body>
      </Html>
    );
  }
}

export default MyDocument;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\server\server.ts -----

import express from 'express';
import next from 'next';

const NODE_ENV = process.env.NODE_ENV || 'development';
const IS_DEV = NODE_ENV !== 'production';

const app = next({ dev: IS_DEV });
const handle = app.getRequestHandler();

app.prepare().then(() => {
  const server = express();

  // give all Nextjs's request to Nextjs before anything else
  server.get('/_next/*', (req, res) => {
    // console.log('next server, page');
    handle(req, res);
  });

  server.use(express.json());

  // server.get('/api/v1/public/get-user', (_, res) => {
  //   res.json({ user: { email: 'team@builderbook.org' } });
  // });

  server.all('*', (req, res) => {
    handle(req, res);
  });

  server.listen(process.env.NEXT_PUBLIC_PORT_APP, () => {
    console.log(`> Ready on ${process.env.NEXT_PUBLIC_URL_APP}`);
  });
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\.eslintrc.js -----

module.exports = {
  settings: {
    react: { version: 'detect' },
  },
  parser: '@typescript-eslint/parser',
  extends: ['plugin:react/recommended', 'plugin:@typescript-eslint/recommended', 'prettier'],
  env: {
    es6: true,
    node: true,
  },
  plugins: ['prettier', 'react'],
  rules: {
    'prettier/prettier': [
      'error',
      {
        singleQuote: true,
        trailingComma: 'all',
        arrowParens: 'always',
        printWidth: 100,
        semi: true,
      },
    ],
    '@typescript-eslint/camelcase': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    'react/no-unescaped-entities': 'off',
    'react/jsx-filename-extension': ['error', { extensions: ['.tsx'] }],
    '@typescript-eslint/no-explicit-any': 'off',
    'prefer-arrow-callback': 'error',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
  },
};

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\next-env.d.ts -----

/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/pages/api-reference/config/typescript for more information.

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\next.config.js -----

module.exports = {
  poweredByHeader: false,
  webpack5: true,
  typescript: {
    ignoreBuildErrors: true,
  },
};

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\nodemon.json -----

{
  "watch": ["server"],
  "exec": "ts-node --project tsconfig.server.json",
  "ext": "ts"
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\package.json -----

{
  "name": "7-begin-app",
  "version": "1",
  "license": "MIT",
  "scripts": {
    "dev": "nodemon server/server.ts",
    "build": "next build",
    "lint": "eslint . --ext .ts,.tsx"
  },
  "dependencies": {
    "@emotion/react": "^11.14.0",
    "@emotion/styled": "^11.14.0",
    "@material-ui/core": "^4.12.4",
    "@material-ui/styles": "^4.11.5",
    "@mui/material": "^6.4.8",
    "@mui/system": "^6.4.8",
    "dotenv": "^16.4.7",
    "express": "^4.21.2",
    "isomorphic-unfetch": "^4.0.2",
    "next": "^15.2.3",
    "nprogress": "^0.2.0",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "typescript": "^5.8.2"
  },
  "devDependencies": {
    "@types/express": "^5.0.1",
    "@types/node": "^22.13.10",
    "@types/react": "^19.0.12",
    "@types/react-dom": "^19.0.4",
    "@typescript-eslint/eslint-plugin": "^8.27.0",
    "@typescript-eslint/parser": "^8.27.0",
    "eslint": "^9.22.0",
    "eslint-config-prettier": "^10.1.1",
    "eslint-plugin-prettier": "^5.2.3",
    "eslint-plugin-react": "^7.37.4",
    "nodemon": "^3.1.9",
    "prettier": "^3.5.3",
    "ts-node": "^10.9.2"
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\tsconfig.json -----

{
  "compileOnSave": false,
  "compilerOptions": {
    "target": "esnext",
    "module": "esnext",
    "jsx": "preserve",
    "allowJs": true,
    "alwaysStrict": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "removeComments": true,
    "preserveConstEnums": true,
    "sourceMap": false,
    "skipLibCheck": true,
    "baseUrl": ".",
    "typeRoots": [
      "./node_modules/@types"
    ],
    "lib": [
      "dom",
      "es2017"
    ],
    "strict": false,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "incremental": true
  },
  "include": [
    "next-env.d.ts",
    "./**/*.tsx",
    "./**/*.ts"
  ],
  "exclude": [
    "dist",
    "production-server",
    ".next",
    "out",
    "next.config.js",
    "node_modules"
  ]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-begin\app\tsconfig.server.json -----

{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "module": "commonjs",
    "outDir": "production-server/",
    "target": "es2017",
    "isolatedModules": false,
    "noEmit": false
  },
  "exclude": ["./server/types.d.ts"],
  "include": ["./server/**/*.ts"],
  "typeRoots": ["./node_modules/@types", "./server/types.d.ts"]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\api\server\api\index.ts -----

import * as express from 'express';

import publicExpressRoutes from './public';
import teamMemberExpressRoutes from './team-member';
import teamLeaderApi from './team-leader';

function handleError(err, _, res, __) {
  console.error(err.stack);

  res.json({ error: err.message || err.toString() });
}

export default function api(server: express.Express) {
  server.use('/api/v1/public', publicExpressRoutes, handleError);
  server.use('/api/v1/team-member', teamMemberExpressRoutes, handleError);
  server.use('/api/v1/team-leader', teamLeaderApi, handleError);
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\api\server\api\public.ts -----

import * as express from 'express';

import User from '../models/User';
import Invitation from '../models/Invitation';

const router = express.Router();

router.get('/get-user', (req, res) => {
  console.log(req.user);
  res.json({ user: req.user || null });
});

router.post('/get-user-by-slug', async (req, res, next) => {
  console.log('Express route: /get-user-by-slug');

  // req.session.foo = 'bar';

  try {
    const { slug } = req.body;

    const user = await User.getUserBySlug({ slug });

    res.json({ user });
  } catch (err) {
    next(err);
  }
});

router.get('/invitations/get-team-by-token', async (req, res, next) => {
  const token = req.query.token as string;

  try {
    const team = await Invitation.getTeamByToken({ token });

    res.json({ team });
  } catch (err) {
    next(err);
  }
});

export default router;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\api\server\api\team-leader.ts -----

import * as express from 'express';

import Invitation from '../models/Invitation';
import Team from '../models/Team';

const router = express.Router();

router.use((req, res, next) => {
  console.log('team leader API', req.path);

  if (!req.user) {
    res.status(401).json({ error: 'Unauthorized' });
    return;
  }

  next();
});

router.post('/teams/add', async (req: any, res, next) => {
  try {
    const { name, avatarUrl } = req.body;

    console.log(`Express route: ${name}, ${avatarUrl}`);

    const team = await Team.addTeam({ userId: req.user.id, name, avatarUrl });

    res.json(team);
  } catch (err) {
    next(err);
  }
});

router.post('/teams/update', async (req: any, res, next) => {
  try {
    const { teamId, name, avatarUrl } = req.body;

    // console.log(req.user.id, typeof req.user.id);
    // console.log(req.user._id, typeof req.user._id);

    const team = await Team.updateTeam({
      userId: req.user.id,
      teamId,
      name,
      avatarUrl,
    });

    res.json(team);
  } catch (err) {
    next(err);
  }
});

router.get('/teams/get-invitations-for-team', async (req: any, res, next) => {
  try {
    const invitations = await Invitation.getTeamInvitations({
      userId: req.user.id,
      teamId: req.query.teamId as string,
    });

    res.json({ invitations });
  } catch (err) {
    next(err);
  }
});

router.post('/teams/invite-member', async (req: any, res, next) => {
  try {
    const { teamId, email } = req.body;

    const newInvitation = await Invitation.add({ userId: req.user.id, teamId, email });

    res.json({ newInvitation });
  } catch (err) {
    next(err);
  }
});

router.post('/teams/remove-member', async (req: any, res, next) => {
  try {
    const { teamId, userId } = req.body;

    await Team.removeMember({ teamLeaderId: req.user.id, teamId, userId });

    res.json({ done: 1 });
  } catch (err) {
    next(err);
  }
});

export default router;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\api\server\api\team-member.ts -----

import * as express from 'express';

import { signRequestForUpload } from '../aws-s3';

import User from '../models/User';
import Team from '../models/Team';
import Invitation from '../models/Invitation';

const router = express.Router();

router.use((req, res, next) => {
  console.log('team member API', req.path);
  if (!req.user) {
    res.status(401).json({ error: 'Unauthorized' });
    return;
  }

  next();
});

// Get signed request from AWS S3 server
router.post('/aws/get-signed-request-for-upload-to-s3', async (req, res, next) => {
  try {
    const { fileName, fileType, prefix, bucket } = req.body;

    const returnData = await signRequestForUpload({
      fileName,
      fileType,
      prefix,
      bucket,
    });

    console.log(bucket);

    res.json(returnData);
  } catch (err) {
    next(err);
  }
});

router.post('/user/update-profile', async (req: any, res, next) => {
  try {
    const { name, avatarUrl } = req.body;

    const updatedUser = await User.updateProfile({
      userId: req.user.id,
      name,
      avatarUrl,
    });

    res.json({ updatedUser });
  } catch (err) {
    next(err);
  }
});

router.post('/user/toggle-theme', async (req: any, res, next) => {
  try {
    const { darkTheme } = req.body;

    await User.toggleTheme({ userId: req.user.id, darkTheme });

    res.json({ done: 1 });
  } catch (err) {
    next(err);
  }
});

async function loadTeamData(team, userId) {
  const initialMembers = await User.getMembersForTeam({
    userId,
    teamId: team._id,
  });

  let initialInvitations = [];
  if (userId === team.teamLeaderId) {
    initialInvitations = await Invitation.getTeamInvitations({
      userId,
      teamId: team._id,
    });
  }

  const data: any = { initialMembers, initialInvitations };

  return data;
}

router.post('/get-initial-data', async (req: any, res, next) => {
  try {
    const teams = await Team.getAllTeamsForUser(req.user.id);

    let selectedTeamSlug = req.body.teamSlug;
    if (!selectedTeamSlug && teams && teams.length > 0) {
      selectedTeamSlug = teams[0].slug;
    }

    for (const team of teams) {
      if (team.slug === selectedTeamSlug) {
        Object.assign(team, await loadTeamData(team, req.user.id));
        break;
      }
    }

    res.json({ teams });
  } catch (err) {
    next(err);
  }
});

router.get('/teams', async (req: any, res, next) => {
  try {
    const teams = await Team.getAllTeamsForUser(req.user.id);

    console.log(teams);

    res.json({ teams });
  } catch (err) {
    next(err);
  }
});

router.get('/teams/get-members', async (req: any, res, next) => {
  try {
    const users = await User.getMembersForTeam({
      userId: req.user.id,
      teamId: req.query.teamId as string,
    });

    res.json({ users });
  } catch (err) {
    next(err);
  }
});

export default router;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\api\server\models\EmailTemplate.ts -----

import * as _ from 'lodash';
import * as mongoose from 'mongoose';

interface EmailTemplateDocument extends mongoose.Document {
  name: string;
  subject: string;
  message: string;
}

const EmailTemplate = mongoose.model<EmailTemplateDocument>(
  'EmailTemplate',
  new mongoose.Schema({
    name: {
      type: String,
      required: true,
      unique: true,
    },
    subject: {
      type: String,
      required: true,
    },
    message: {
      type: String,
      required: true,
    },
  }),
);

export async function insertTemplates() {
  const templates = [
    {
      name: 'welcome',
      subject: 'Welcome to SaaS boilerplate by Async',
      message: `Welcome <%= userName %>,
        <p>
          Thanks for signing up on our <a href="https://github.com/async-labs/saas" target="blank">SaaS boilerplate</a>!
        </p>
        <p>
          If you are learning how to build a SaaS web app, check out our 2 books:
           <a href="https://builderbook.org" target="blank">Builder Book</a>
           and
           <a href="https://builderbook.org/book" target="blank">SaaS Boilerplate</a>.
        </p>
        <p>
          Also check out
          <a href="https://async-await.com" target="blank"> Async</a>
          , our communication tool for small teams of software developers.
        </p>
        Kelly & Timur, Team Async
      `,
    },
    {
      name: 'login',
      subject: 'Login link for saas-app.async-await.com',
      message: `
        <p>Log into your account by clicking on this link: <a href="<%= loginURL %>"><%= loginURL %></a>.</p>`,
    },
    {
      name: 'invitation',
      subject: 'You are invited to join a team at saas-app.async-await.com',
      message: `You've been invited to join <b><%= teamName%></b>.
        <br/>Click here to accept the invitation: <%= invitationURL%>
      `,
    },
    // {
    //   name: 'newPost',
    //   subject: 'New Post was created in Discussion: <%= discussionName %>',
    //   message: `<p>New Post in Discussion: "<%= discussionName%>" by <%= authorName%></p>
    //     New Post: "<%= postContent %>"
    //     <p>---</p>
    //     <p>View it at <a href="<%= discussionLink %>"><%= discussionLink %></a>.</p>
    //   `,
    // },
  ];

  for (const t of templates) {
    const et = await EmailTemplate.findOne({ name: t.name }).setOptions({ lean: true });
    const message = t.message.replace(/\n/g, '').replace(/[ ]+/g, ' ').trim();

    if (!et) {
      EmailTemplate.create(Object.assign({}, t, { message }));
    } else if (et.subject !== t.subject || et.message !== message) {
      EmailTemplate.updateOne({ _id: et._id }, { $set: { message, subject: t.subject } }).exec();
    }
  }
}

export default async function getEmailTemplate(name: string, params: any) {
  await insertTemplates();

  const et = await EmailTemplate.findOne({ name }).setOptions({ lean: true });

  if (!et) {
    throw new Error('Email Template is not found in database.');
  }

  return {
    message: _.template(et.message)(params),
    subject: _.template(et.subject)(params),
  };
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\api\server\models\Invitation.ts -----

import * as mongoose from 'mongoose';

import sendEmail from '../aws-ses';
import getEmailTemplate from './EmailTemplate';
import Team from './Team';
import User, { UserDocument } from './User';

const mongoSchema = new mongoose.Schema({
  teamId: {
    type: String,
    required: true,
  },
  email: {
    type: String,
    required: true,
  },
  createdAt: {
    type: Date,
    required: true,
    default: Date.now,
    expires: 60 * 60 * 24, // delete doc after 24 hours
  },
  token: {
    type: String,
    required: true,
    unique: true,
  },
});

mongoSchema.index({ teamId: 1, email: 1 }, { unique: true });

interface InvitationDocument extends mongoose.Document {
  teamId: string;
  email: string;
  createdAt: Date;
  token: string;
}

interface InvitationModel extends mongoose.Model<InvitationDocument> {
  add({
    userId,
    teamId,
    email,
  }: {
    userId: string;
    teamId: string;
    email: string;
  }): InvitationDocument;

  getTeamInvitations({ userId, teamId }: { userId: string; teamId: string });
  getTeamByToken({ token }: { token: string });
  addUserToTeam({ token, user }: { token: string; user: UserDocument });
}

function generateToken() {
  const gen = () =>
    Math.random().toString(36).substring(2, 12) + Math.random().toString(36).substring(2, 12);

  return `${gen()}`;
}

class InvitationClass extends mongoose.Model {
  public static async add({ userId, teamId, email }) {
    if (!teamId || !email) {
      throw new Error('Bad data');
    }

    const team = await Team.findById(teamId).setOptions({ lean: true });
    if (!team || team.teamLeaderId !== userId) {
      throw new Error('Team does not exist or you have no permission');
    }

    const registeredUser = await User.findOne({ email }).setOptions({ lean: true });

    if (registeredUser && team.memberIds.includes(registeredUser._id.toString())) {
      throw new Error('This user is already Team Member.');
    }

    let token;
    const invitation = await this.findOne({ teamId, email })
      .select('token')
      .setOptions({ lean: true });

    if (invitation) {
      token = invitation.token;
    } else {
      token = generateToken();
      while ((await this.countDocuments({ token })) > 0) {
        token = generateToken();
      }

      await this.create({
        teamId,
        email,
        token,
      });
    }

    const emailTemplate = await getEmailTemplate('invitation', {
      teamName: team.name,
      invitationURL: `${process.env.URL_APP}/invitation?token=${token}`,
    });

    if (!emailTemplate) {
      throw new Error('Invitation email template not found');
    }

    try {
      await sendEmail({
        from: `Kelly from saas-app.async-await.com <${process.env.EMAIL_SUPPORT_FROM_ADDRESS}>`,
        to: [email],
        subject: emailTemplate.subject,
        body: emailTemplate.message,
      });
    } catch (err) {
      console.log('Email sending error:', err);
    }

    return await this.findOne({ teamId, email }).setOptions({ lean: true });
  }

  public static async getTeamInvitations({ userId, teamId }) {
    const team = await Team.findOne({ _id: teamId })
      .select('teamLeaderId')
      .setOptions({ lean: true });

    if (userId !== team.teamLeaderId) {
      throw new Error('You have no permission.');
    }

    return this.find({ teamId }).select('email').setOptions({ lean: true });
  }

  public static async getTeamByToken({ token }) {
    if (!token) {
      throw new Error('Bad data');
    }

    const invitation = await this.findOne({ token }).setOptions({ lean: true });

    if (!invitation) {
      throw new Error('Invitation not found');
    }

    const team = await Team.findById(invitation.teamId)
      .select('name slug avatarUrl memberIds')
      .setOptions({ lean: true });

    if (!team) {
      throw new Error('Team does not exist');
    }

    return team;
  }

  public static async addUserToTeam({ token, user }) {
    if (!token || !user) {
      throw new Error('Bad data');
    }

    const invitation = await this.findOne({ token }).setOptions({ lean: true });

    if (!invitation || invitation.email !== user.email) {
      throw new Error('Invitation not found');
    }

    await this.deleteOne({ token });

    const team = await Team.findById(invitation.teamId)
      .select('memberIds slug teamLeaderId')
      .setOptions({ lean: true });

    if (!team) {
      throw new Error('Team does not exist');
    }

    if (team && !team.memberIds.includes(user._id)) {
      await Team.updateOne({ _id: team._id }, { $addToSet: { memberIds: user._id } });

      if (user._id !== team.teamLeaderId) {
        await User.findByIdAndUpdate(user._id, { $set: { defaultTeamSlug: team.slug } });
      }
    }

    return team.slug;
  }
}

mongoSchema.loadClass(InvitationClass);

const Invitation = mongoose.model<InvitationDocument, InvitationModel>('Invitation', mongoSchema);

export default Invitation;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\api\server\models\Team.ts -----

import * as mongoose from 'mongoose';

import { generateNumberSlug } from '../utils/slugify';
import User from './User';

const mongoSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
  },
  slug: {
    type: String,
    required: true,
    unique: true,
  },
  avatarUrl: String,
  createdAt: {
    type: Date,
    required: true,
  },
  teamLeaderId: {
    type: String,
    required: true,
  },
  memberIds: [
    {
      type: String,
      required: true,
    },
  ],
  defaultTeam: {
    type: Boolean,
    default: false,
  },
});

export interface TeamDocument extends mongoose.Document {
  name: string;
  slug: string;
  avatarUrl: string;
  createdAt: Date;

  teamLeaderId: string;
  memberIds: string[];
  defaultTeam: boolean;
}

interface TeamModel extends mongoose.Model<TeamDocument> {
  addTeam({
    name,
    userId,
  }: {
    userId: string;
    name: string;
    avatarUrl: string;
  }): Promise<TeamDocument>;

  updateTeam({
    userId,
    teamId,
    name,
    avatarUrl,
  }: {
    userId: string;
    teamId: string;
    name: string;
    avatarUrl: string;
  }): Promise<TeamDocument>;

  getAllTeamsForUser(userId: string): Promise<TeamDocument[]>;

  removeMember({
    teamId,
    teamLeaderId,
    userId,
  }: {
    teamId: string;
    teamLeaderId: string;
    userId: string;
  }): Promise<void>;
}

class TeamClass extends mongoose.Model {
  public static async addTeam({ userId, name, avatarUrl }) {
    console.log(`Static method: ${name}, ${avatarUrl}`);

    if (!userId || !name || !avatarUrl) {
      throw new Error('Bad data');
    }

    const slug = await generateNumberSlug(this);

    let defaultTeam = false;
    if ((await this.countDocuments({ teamLeaderId: userId })) === 0) {
      await User.findByIdAndUpdate(userId, { $set: { defaultTeamSlug: slug } });
      defaultTeam = true;
    }

    const team = await this.create({
      teamLeaderId: userId,
      name,
      slug,
      avatarUrl,
      memberIds: [userId],
      createdAt: new Date(),
      defaultTeam,
    });

    return team;
  }

  public static async updateTeam({ userId, teamId, name, avatarUrl }) {
    const team = await this.findById(teamId, 'name teamLeaderId');

    if (!team) {
      throw new Error('Team not found');
    }

    if (team.teamLeaderId !== userId) {
      throw new Error('Permission denied');
    }

    const modifier = { name: team.name, avatarUrl };

    if (name !== team.name) {
      modifier.name = name;
    }

    await this.updateOne({ _id: teamId }, { $set: modifier }, { runValidators: true });

    return this.findById(teamId, 'name avatarUrl slug defaultTeam').setOptions({ lean: true });
  }

  public static getAllTeamsForUser(userId: string) {
    console.log(`userId:${userId}`);
    return this.find({ memberIds: userId }).setOptions({ lean: true });
  }

  public static async removeMember({ teamId, teamLeaderId, userId }) {
    const team = await this.findById(teamId).select('memberIds teamLeaderId');

    if (!team) {
      throw new Error('Team does not exist');
    }

    if (team.teamLeaderId !== teamLeaderId || teamLeaderId === userId) {
      throw new Error('Permission denied');
    }

    await this.findByIdAndUpdate(teamId, { $pull: { memberIds: userId } });
  }
}

mongoSchema.loadClass(TeamClass);

const Team = mongoose.model<TeamDocument, TeamModel>('Team', mongoSchema);

export default Team;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\api\server\models\User.ts -----

import * as _ from 'lodash';
import * as mongoose from 'mongoose';

import sendEmail from '../aws-ses';
import { addToMailchimp } from '../mailchimp';
import { generateSlug } from '../utils/slugify';
import getEmailTemplate from './EmailTemplate';
import Team, { TeamDocument } from './Team';

const mongoSchema = new mongoose.Schema({
  slug: {
    type: String,
    required: true,
    unique: true,
  },
  createdAt: {
    type: Date,
    required: true,
  },
  email: {
    type: String,
    required: true,
    unique: true,
  },
  displayName: String,
  avatarUrl: String,
  googleId: {
    type: String,
    unique: true,
    sparse: true,
  },
  googleToken: {
    accessToken: String,
    refreshToken: String,
  },
  isSignedupViaGoogle: {
    type: Boolean,
    required: true,
    default: false,
  },
  darkTheme: Boolean,
  defaultTeamSlug: {
    type: String,
    default: '',
  },
});

export interface UserDocument extends mongoose.Document {
  slug: string;
  createdAt: Date;
  email: string;
  displayName: string;
  avatarUrl: string;
  googleId: string;
  googleToken: { accessToken: string; refreshToken: string };
  isSignedupViaGoogle: boolean;
  darkTheme: boolean;
  defaultTeamSlug: string;
}

interface UserModel extends mongoose.Model<UserDocument> {
  getUserBySlug({ slug }: { slug: string }): Promise<UserDocument>;

  updateProfile({
    userId,
    name,
    avatarUrl,
  }: {
    userId: string;
    name: string;
    avatarUrl: string;
  }): Promise<UserDocument[]>;

  publicFields(): string[];

  signInOrSignUpViaGoogle({
    googleId,
    email,
    displayName,
    avatarUrl,
    googleToken,
  }: {
    googleId: string;
    email: string;
    displayName: string;
    avatarUrl: string;
    googleToken: { accessToken?: string; refreshToken?: string };
  }): Promise<UserDocument>;

  signInOrSignUpByPasswordless({
    uid,
    email,
  }: {
    uid: string;
    email: string;
  }): Promise<UserDocument>;

  toggleTheme({ userId, darkTheme }: { userId: string; darkTheme: boolean }): Promise<void>;

  getMembersForTeam({
    userId,
    teamId,
  }: {
    userId: string;
    teamId: string;
  }): Promise<UserDocument[]>;

  checkPermissionAndGetTeam({
    userId,
    teamId,
  }: {
    userId: string;
    teamId: string;
  }): Promise<TeamDocument[]>;
}

class UserClass extends mongoose.Model {
  public static async getUserBySlug({ slug }) {
    console.log('Static method: getUserBySlug');

    return this.findOne({ slug }, 'email displayName avatarUrl').setOptions({ lean: true });
  }

  public static async updateProfile({ userId, name, avatarUrl }) {
    console.log('Static method: updateProfile');

    const user = await this.findById(userId, 'slug displayName');

    const modifier = { displayName: user.displayName, avatarUrl, slug: user.slug };

    console.log(user.slug);

    if (name !== user.displayName) {
      modifier.displayName = name;
      modifier.slug = await generateSlug(this, name);
    }

    return this.findByIdAndUpdate(userId, { $set: modifier }, { new: true, runValidators: true })
      .select('displayName avatarUrl slug')
      .setOptions({ lean: true });
  }

  public static publicFields(): string[] {
    return [
      '_id',
      'id',
      'displayName',
      'email',
      'avatarUrl',
      'slug',
      'isSignedupViaGoogle',
      'darkTheme',
      'defaultTeamSlug',
    ];
  }

  public static async signInOrSignUpViaGoogle({
    googleId,
    email,
    displayName,
    avatarUrl,
    googleToken,
  }) {
    const user = await this.findOne({ email })
      .select([...this.publicFields(), 'googleId'].join(' '))
      .setOptions({ lean: true });

    if (user) {
      if (_.isEmpty(googleToken) && user.googleId) {
        return user;
      }

      const modifier = { googleId };
      if (googleToken.accessToken) {
        modifier['googleToken.accessToken'] = googleToken.accessToken;
      }

      if (googleToken.refreshToken) {
        modifier['googleToken.refreshToken'] = googleToken.refreshToken;
      }

      await this.updateOne({ email }, { $set: modifier });

      return user;
    }

    const slug = await generateSlug(this, displayName);

    const newUser = await this.create({
      createdAt: new Date(),
      googleId,
      email,
      googleToken,
      displayName,
      avatarUrl,
      slug,
      isSignedupViaGoogle: true,
      defaultTeamSlug: '',
      darkTheme: false,
    });

    const emailTemplate = await getEmailTemplate('welcome', { userName: displayName });

    if (!emailTemplate) {
      throw new Error('Welcome email template not found');
    }

    try {
      await sendEmail({
        from: `Kelly from saas-app.async-await.com <${process.env.EMAIL_SUPPORT_FROM_ADDRESS}>`,
        to: [email],
        subject: emailTemplate.subject,
        body: emailTemplate.message,
      });
    } catch (err) {
      console.error('Email sending error:', err);
    }

    try {
      await addToMailchimp({ email, listName: 'signups' });
    } catch (error) {
      console.error('Mailchimp error:', error);
    }

    return _.pick(newUser, this.publicFields());
  }

  public static async signInOrSignUpByPasswordless({ uid, email }) {
    const user = await this.findOne({ email })
      .select(this.publicFields().join(' '))
      .setOptions({ lean: true });

    if (user) {
      throw Error('User already exists');
    }

    const slug = await generateSlug(this, email);

    const newUser = await this.create({
      _id: uid,
      createdAt: new Date(),
      email,
      slug,
      defaultTeamSlug: '',
    });

    const emailTemplate = await getEmailTemplate('welcome', { userName: email });

    if (!emailTemplate) {
      throw new Error('Email template "welcome" not found in database.');
    }

    try {
      await sendEmail({
        from: `Kelly from saas-app.async-await.com <${process.env.EMAIL_SUPPORT_FROM_ADDRESS}>`,
        to: [email],
        subject: emailTemplate.subject,
        body: emailTemplate.message,
      });
    } catch (err) {
      console.error('Email sending error:', err);
    }

    try {
      await addToMailchimp({ email, listName: 'signups' });
    } catch (error) {
      console.error('Mailchimp error:', error);
    }

    return _.pick(newUser, this.publicFields());
  }

  public static toggleTheme({ userId, darkTheme }) {
    return this.updateOne({ _id: userId }, { darkTheme: !!darkTheme });
  }

  public static async getMembersForTeam({ userId, teamId }) {
    const team = await this.checkPermissionAndGetTeam({ userId, teamId });

    return this.find({ _id: { $in: team.memberIds } })
      .select(this.publicFields().join(' '))
      .setOptions({ lean: true });
  }

  private static async checkPermissionAndGetTeam({ userId, teamId }) {
    console.log(userId, teamId);

    if (!userId || !teamId) {
      throw new Error('Bad data');
    }

    const team = await Team.findById(teamId).select('memberIds').setOptions({ lean: true });

    if (!team || team.memberIds.indexOf(userId) === -1) {
      throw new Error('Team not found');
    }

    return team;
  }
}

mongoSchema.loadClass(UserClass);

const User = mongoose.model<UserDocument, UserModel>('User', mongoSchema);

export default User;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\api\server\utils\slugify.ts -----

import * as _ from 'lodash';

const slugify = (text) => _.kebabCase(text);

async function createUniqueSlug(Model, slug, count, filter) {
  const obj = await Model.findOne({ slug: `${slug}-${count}`, ...filter })
    .select('_id')
    .setOptions({ lean: true });

  if (!obj) {
    return `${slug}-${count}`;
  }

  return createUniqueSlug(Model, slug, count + 1, filter);
}

async function generateSlug(Model, name, filter = {}) {
  const origSlug = slugify(name);

  const obj = await Model.findOne({ slug: origSlug, ...filter })
    .select('_id')
    .setOptions({ lean: true });

  if (!obj) {
    return origSlug;
  }

  return createUniqueSlug(Model, origSlug, 1, filter);
}

async function generateNumberSlug(Model, filter = {}, n = 1) {
  const obj = await Model.findOne({ slug: n, ...filter })
    .select('_id')
    .setOptions({ lean: true });

  if (!obj) {
    return `${n}`;
  }

  return generateNumberSlug(Model, filter, ++n);
}

export { generateSlug, generateNumberSlug };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\api\server\utils\sum.ts -----

function sum(a, b) {
  return a + b;
}

export { sum };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\api\server\aws-s3.ts -----

import * as url from 'url';
import * as aws from 'aws-sdk';

async function signRequestForUpload({ fileName, fileType, prefix, bucket }) {
  const randomStringForPrefix =
    Math.random().toString(36).substring(2, 12) + Math.random().toString(36).substring(2, 12);

  const key = `${prefix}/${randomStringForPrefix}/${fileName}`;

  const acl = 'public-read';

  const params = {
    Bucket: bucket,
    Key: key,
    Expires: 60,
    ContentType: fileType,
    ACL: acl,
  };

  console.log(key, bucket);

  const s3 = new aws.S3({
    apiVersion: 'latest',
    region: process.env.AWS_REGION,
    accessKeyId: process.env.AWS_ACCESSKEYID,
    secretAccessKey: process.env.AWS_SECRETACCESSKEY,
  });

  return new Promise((resolve, reject) => {
    s3.getSignedUrl('putObject', params, (err, data) => {
      const parsedUrl = url.parse(data);

      const returnData = {
        signedRequest: data,
        url: `${parsedUrl.protocol}//${parsedUrl.hostname}${parsedUrl.pathname}`,
      };

      console.log(returnData);

      if (err) {
        console.error(err);
        reject(err);
      } else {
        resolve(returnData);
      }
    });
  });
}

export { signRequestForUpload };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\api\server\aws-ses.ts -----

import * as aws from 'aws-sdk';

export default function sendEmail(options) {
  const ses = new aws.SES({
    apiVersion: 'latest',
    region: process.env.AWS_REGION,
    accessKeyId: process.env.AWS_ACCESSKEYID,
    secretAccessKey: process.env.AWS_SECRETACCESSKEY,
  });

  return new Promise((resolve, reject) => {
    ses.sendEmail(
      {
        Source: options.from,
        Destination: {
          CcAddresses: options.cc,
          ToAddresses: options.to,
        },
        Message: {
          Subject: {
            Data: options.subject,
          },
          Body: {
            Html: {
              Data: options.body,
            },
          },
        },
        ReplyToAddresses: options.replyTo,
      },
      (err, info) => {
        if (err) {
          reject(err);
        } else {
          resolve(info);
        }
      },
    );
  });
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\api\server\google-auth.ts -----

import * as passport from 'passport';
import { OAuth2Strategy as Strategy } from 'passport-google-oauth';

import User, { UserDocument } from './models/User';
import Invitation from './models/Invitation';

function setupGoogle({ server }) {
  if (!process.env.GOOGLE_CLIENTID) {
    return;
  }

  const verify = async (req, accessToken, refreshToken, profile, done) => {
    let email;
    let avatarUrl;

    if (profile.emails) {
      email = profile.emails[0].value;
    }

    if (profile.photos && profile.photos.length > 0) {
      avatarUrl = profile.photos[0].value.replace('sz=50', 'sz=128');
    }

    try {
      const user = await User.signInOrSignUpViaGoogle({
        googleId: profile.id,
        email,
        googleToken: { accessToken, refreshToken },
        displayName: profile.displayName,
        avatarUrl,
      });

      let teamSlugOfInvitedTeam;
      if (user && req.session.invitationToken) {
        teamSlugOfInvitedTeam = await Invitation.addUserToTeam({
          token: req.session.invitationToken,
          user,
        }).catch((err) => console.error(err));
      }

      user.defaultTeamSlug = teamSlugOfInvitedTeam ? teamSlugOfInvitedTeam : user.defaultTeamSlug;

      done(null, user);
    } catch (err) {
      done(err);
      console.error(err);
    }
  };

  passport.use(
    new Strategy(
      {
        clientID: process.env.GOOGLE_CLIENTID,
        clientSecret: process.env.GOOGLE_CLIENTSECRET,
        callbackURL: `${process.env.URL_API}/oauth2callback`,
        passReqToCallback: true,
      },
      verify,
    ),
  );

  passport.serializeUser((user: UserDocument, done) => {
    done(null, user._id);
  });

  passport.deserializeUser((id, done) => {
    User.findById(id, User.publicFields())
      .then((user) => {
        done(null, user);
      })
      .catch((error) => {
        done(error, null);
      });
  });

  server.use(passport.initialize());
  server.use(passport.session());

  server.get('/auth/google', (req, res, next) => {
    const options = {
      scope: ['profile', 'email'],
      prompt: 'select_account',
    };

    if (req.query && req.query.invitationToken) {
      req.session.invitationToken = req.query.invitationToken;
    } else {
      req.session.invitationToken = null;
    }

    passport.authenticate('google', options)(req, res, next);
  });

  server.get(
    '/oauth2callback',
    passport.authenticate('google', {
      failureRedirect: '/login',
    }),
    async (req, res) => {
      let teamSlugOfInvitedTeam;

      if (req.user && req.session.invitationToken) {
        teamSlugOfInvitedTeam = await Invitation.addUserToTeam({
          token: req.session.invitationToken,
          user: req.user,
        }).catch((err) => console.error(err));

        req.session.invitationToken = null;
      }

      let redirectUrlAfterLogin;
      const defaultTeamSlug = req.user && req.user.defaultTeamSlug;

      if (teamSlugOfInvitedTeam || defaultTeamSlug) {
        redirectUrlAfterLogin = `/your-settings`;
      } else {
        redirectUrlAfterLogin = `/create-team`;
      }

      res.redirect(`${process.env.URL_APP}${redirectUrlAfterLogin}`);
    },
  );
}

export { setupGoogle };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\api\server\mailchimp.ts -----

import fetch, { Response } from 'node-fetch';

// eslint-disable-next-line
require('dotenv').config();

const LIST_IDS = {
  signups: process.env.MAILCHIMP_SAAS_ALL_LIST_ID,
};

function callAPI({ path, method, data }): Promise<Response> {
  const ROOT_URI = `https://${process.env.MAILCHIMP_REGION}.api.mailchimp.com/3.0`;

  return fetch(`${ROOT_URI}${path}`, {
    method,
    headers: {
      Accept: 'application/json',
      Authorization: `Basic ${Buffer.from(`apikey:${process.env.MAILCHIMP_API_KEY}`).toString(
        'base64',
      )}`,
    },
    body: JSON.stringify(data),
  });
}

async function addToMailchimp({ email, listName }) {
  const data = {
    // eslint-disable-next-line
    email_address: email,
    status: 'subscribed',
  };

  const path = `/lists/${LIST_IDS[listName]}/members/`;

  await callAPI({ path, method: 'POST', data });
}

export { addToMailchimp };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\api\server\passwordless-auth.ts -----

import * as passwordless from 'passwordless';

import sendEmail from './aws-ses';
import getEmailTemplate from './models/EmailTemplate';
import User from './models/User';
import PasswordlessMongoStore from './passwordless-token-mongostore';
import Invitation from './models/Invitation';

function setupPasswordless({ server }) {
  const mongoStore = new PasswordlessMongoStore();

  passwordless.addDelivery(async (tokenToSend, uidToSend, recipient, callback) => {
    try {
      const template = await getEmailTemplate('login', {
        loginURL: `${
          process.env.URL_API
        }/auth/logged_in?token=${tokenToSend}&uid=${encodeURIComponent(uidToSend)}`,
      });

      await sendEmail({
        from: `Kelly from saas-app.async-await.com <${process.env.EMAIL_SUPPORT_FROM_ADDRESS}>`,
        to: [recipient],
        subject: template.subject,
        body: template.message,
      });

      callback();
    } catch (err) {
      console.error('Email sending error:', err);
      callback(err);
    }
  });

  passwordless.init(mongoStore);
  server.use(passwordless.sessionSupport());

  server.use((req, __, next) => {
    if (req.user && typeof req.user === 'string') {
      User.findById(req.user, User.publicFields())
        .then((user) => {
          req.user = user;
          console.log('passwordless middleware');
          next();
        })
        .catch((err) => {
          next(err);
        });
    } else {
      next();
    }
  });

  server.post(
    '/auth/email-login-link',
    passwordless.requestToken(async (email, __, callback) => {
      try {
        const user = await User.findOne({ email }).select('_id').setOptions({ lean: true });

        if (user) {
          callback(null, user._id);
        } else {
          const id = await mongoStore.storeOrUpdateByEmail(email);
          callback(null, id);
        }
      } catch (error) {
        callback(error, null);
      }
    }),
    (req, res) => {
      if (req.query && req.query.invitationToken) {
        req.session.invitationToken = req.query.invitationToken;
      } else {
        req.session.invitationToken = null;
      }

      res.json({ done: 1 });
    },
  );

  server.get(
    '/auth/logged_in',
    passwordless.acceptToken(),
    (req, __, next) => {
      if (req.user && typeof req.user === 'string') {
        User.findById(req.user, User.publicFields())
          .then((user) => {
            req.user = user;
            next();
          })
          .catch((err) => {
            next(err);
          });
      } else {
        next();
      }
    },
    async (req, res) => {
      let teamSlugOfInvitedTeam;

      if (req.user && req.session.invitationToken) {
        teamSlugOfInvitedTeam = await Invitation.addUserToTeam({
          token: req.session.invitationToken,
          user: req.user,
        }).catch((err) => console.error(err));

        req.session.invitationToken = null;
      }

      let redirectUrlAfterLogin;
      const defaultTeamSlug = req.user && req.user.defaultTeamSlug;

      if (teamSlugOfInvitedTeam || defaultTeamSlug) {
        redirectUrlAfterLogin = `/your-settings`;
      } else {
        redirectUrlAfterLogin = `/create-team`;
      }

      res.redirect(`${process.env.URL_APP}${redirectUrlAfterLogin}`);
    },
  );

  server.get('/logout', (req, res, next) => {
    req.logout((err) => {
      if (err) {
        next(err);
      }

      if (req.query && req.query.invitationToken) {
        res.redirect(`${process.env.URL_APP}/invitation?token=${req.query.invitationToken}`);
      } else {
        res.redirect(`${process.env.URL_APP}/login`);
      }
    });
  });
}

export { setupPasswordless };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\api\server\passwordless-token-mongostore.ts -----

import * as bcrypt from 'bcrypt';
import * as mongoose from 'mongoose';
import * as TokenStore from 'passwordless-tokenstore';
import * as util from 'util';

import User from './models/User';

interface TokenDocument extends mongoose.Document {
  hashedToken: string;
  uid: string;
  ttl: Date;
  originUrl: string;
  email: string;
}

const mongoSchema = new mongoose.Schema({
  hashedToken: {
    type: String,
    required: true,
  },
  uid: {
    type: String,
    required: true,
    unique: true,
  },
  ttl: {
    type: Date,
    required: true,
    expires: 0,
  },
  originUrl: String,
  email: String,
});

const PasswordlessToken = mongoose.model<TokenDocument>(
  'PasswordlessToken',
  mongoSchema,
  'passwordless-token',
);

function MongoStore(options = {}) {
  TokenStore.call(this);

  this._options = options || {};
}

util.inherits(MongoStore, TokenStore);

MongoStore.prototype.authenticate = async function (token, uid, callback) {
  if (!token || !uid || !callback) {
    throw new Error('TokenStore:authenticate called with invalid parameters');
  }

  try {
    const tokenDoc = await PasswordlessToken.findOne({ uid, ttl: { $gt: new Date() } }).setOptions({
      lean: true,
    });

    if (tokenDoc) {
      const isMatch = await bcrypt.compare(token, tokenDoc.hashedToken);
      if (isMatch) {
        if (tokenDoc.email) {
          await User.signInOrSignUpByPasswordless({ uid, email: tokenDoc.email });
        }

        callback(null, true, tokenDoc.originUrl);
      } else {
        callback(null, false, null);
      }
    } else {
      callback(null, false, null);
    }
  } catch (error) {
    callback(error, false, null);
  }
};

MongoStore.prototype.storeOrUpdate = async function (token, uid, msToLive, originUrl, callback) {
  if (!token || !uid || !msToLive || !callback) {
    throw new Error('TokenStore:storeOrUpdate called with invalid parameters');
  }

  const saltRounds = 10;

  try {
    const hashedToken = await bcrypt.hash(token, saltRounds);
    const newRecord = { hashedToken, uid, ttl: new Date(Date.now() + msToLive), originUrl };

    await PasswordlessToken.updateOne(
      { uid },
      { $set: newRecord },
      { upsert: true, runValidators: true },
    );
    callback();
  } catch (error) {
    callback(error);
  }
};

MongoStore.prototype.invalidateUser = async function (uid, callback) {
  if (!uid || !callback) {
    throw new Error('TokenStore:invalidateUser called with invalid parameters');
  }

  try {
    await PasswordlessToken.deleteOne({ uid });
    callback();
  } catch (error) {
    callback(error);
  }
};

MongoStore.prototype.clear = async function (callback) {
  if (!callback) {
    throw new Error('TokenStore:clear called with invalid parameters');
  }

  try {
    await PasswordlessToken.deleteMany({});
    callback();
  } catch (error) {
    callback(error);
  }
};

MongoStore.prototype.length = function (callback) {
  PasswordlessToken.countDocuments(callback);
};

MongoStore.prototype.storeOrUpdateByEmail = async function addEmail(email: string) {
  if (!email) {
    throw new Error('TokenStore:addEmail called with invalid parameters');
  }

  const obj = await PasswordlessToken.findOne({ email }).select('uid').setOptions({ lean: true });

  if (obj) {
    return obj.uid;
  }

  const uid = new mongoose.Types.ObjectId().toHexString();
  await PasswordlessToken.updateOne({ uid }, { email }, { upsert: true });

  return uid;
};

export default MongoStore;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\api\server\server.ts -----

// eslint-disable-next-line @typescript-eslint/no-var-requires
const MongoStore = require('connect-mongo');

import * as cors from 'cors';
import * as express from 'express';
import * as session from 'express-session';
import * as mongoose from 'mongoose';

import api from './api';
import { setupGoogle } from './google-auth';
import { setupPasswordless } from './passwordless-auth';

// eslint-disable-next-line
require('dotenv').config();

mongoose.connect(process.env.MONGO_URL_TEST);

const server = express();

server.use(
  cors({
    origin: process.env.URL_APP,
    methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',
    credentials: true,
  }),
);

server.use(express.json());

const sessionOptions = {
  name: process.env.SESSION_NAME,
  secret: process.env.SESSION_SECRET,
  resave: false,
  saveUninitialized: false,
  store: MongoStore.create({
    mongoUrl: process.env.MONGO_URL_TEST,
    ttl: 14 * 24 * 60 * 60, // save session 14 days
    autoRemove: 'interval',
    autoRemoveInterval: 1440, // clears every day
  }),
  cookie: {
    httpOnly: true,
    maxAge: 14 * 24 * 60 * 60 * 1000, // expires in 14 days
    secure: false,
  },
};

const sessionMiddleware = session(sessionOptions);
server.use(sessionMiddleware);

setupGoogle({ server });
setupPasswordless({ server });

api(server);

server.get('*', (_, res) => {
  res.sendStatus(403);
});

server.listen(process.env.PORT_API, () => {
  console.log(`> Ready on ${process.env.URL_API}`);
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\api\test\server\utils\slugify.test.ts -----

import * as mongoose from 'mongoose';
import User from '../../../server/models/User';
import { generateSlug } from '../../../server/utils/slugify';

// eslint-disable-next-line
require('dotenv').config();

describe('slugify', () => {
  beforeAll(async () => {
    await mongoose.connect(process.env.MONGO_URL_TEST);

    const mockUsers = [
      {
        slug: 'john',
        email: 'john@example.com',
        createdAt: new Date(),
        displayName: 'abc',
        avatarUrl: 'def',
      },
      {
        slug: 'john-johnson',
        email: 'john-johnson@example.com',
        createdAt: new Date(),
        displayName: 'abc',
        avatarUrl: 'def',
      },
      {
        slug: 'john-johnson-1',
        email: 'john-johnson-1@example.com',
        createdAt: new Date(),
        displayName: 'abc',
        avatarUrl: 'def',
      },
    ];

    await User.insertMany(mockUsers);
  });

  test('not duplicated', async () => {
    expect.assertions(1);

    await expect(generateSlug(User, 'John J Johnson@#$')).resolves.toEqual('john-j-johnson');
  });

  test('one time duplicated', async () => {
    expect.assertions(1);

    await expect(generateSlug(User, ' John@#$')).resolves.toEqual('john-1');
  });

  test('multiple duplicated', async () => {
    expect.assertions(1);

    await expect(generateSlug(User, 'John & Johnson@#$')).resolves.toEqual('john-johnson-2');
  });

  afterAll(async () => {
    await User.deleteMany({ slug: { $in: ['john', 'john-johnson', 'john-johnson-1'] } });
    await mongoose.disconnect();
  });
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\api\test\server\utils\sum.test.ts -----

import { sum } from '../../../server/utils/sum';

console.log(sum(1, 2));

describe.skip('testing sum function', () => {
  test('adds 1 + 2 to equal 3', () => {
    expect(sum(1, 2)).toBe(3);
  });
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\api\.eslintrc.js -----

module.exports = {
  parser: "@typescript-eslint/parser",
  extends: ["plugin:@typescript-eslint/recommended", "prettier"],
  env: {
    "es6": true,
    "node": true,
  },
  plugins: ["prettier"],
  rules: {
    'prettier/prettier': [
      'error',
      {
        singleQuote: true,
        trailingComma: 'all',
        arrowParens: 'always',
        printWidth: 100,
        semi: true,
      },
    ],
    '@typescript-eslint/no-unused-vars': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/no-explicit-any': 'off',
    'prefer-arrow-callback': 'error',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
 },
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\api\nodemon.json -----

{
  "watch": ["server"],
  "exec": "ts-node --project tsconfig.server.json",
  "ext": "ts"
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\api\package.json -----

{
  "name": "7-end-api",
  "version": "1",
  "license": "MIT",
  "scripts": {
    "dev": "nodemon server/server.ts",
    "lint": "eslint . --ext .ts,.tsx",
    "test": "jest"
  },
  "jest": {
    "preset": "ts-jest",
    "testPathIgnorePatterns": [
      "production-server"
    ],
    "testEnvironment": "node"
  },
  "dependencies": {
    "aws-sdk": "^2.1692.0",
    "bcrypt": "^5.1.1",
    "connect-mongo": "^5.1.0",
    "cors": "^2.8.5",
    "dotenv": "^16.4.7",
    "express": "^4.21.2",
    "express-session": "^1.18.1",
    "lodash": "^4.17.21",
    "mongoose": "^8.12.1",
    "node-fetch": "2",
    "passport": "^0.7.0",
    "passport-google-oauth": "^2.0.0",
    "passwordless": "^1.1.3",
    "passwordless-tokenstore": "^0.0.10",
    "typescript": "^5.8.2"
  },
  "devDependencies": {
    "@types/connect-mongo": "^3.1.6",
    "@types/dotenv": "^8.2.3",
    "@types/express": "^5.0.1",
    "@types/express-session": "^1.18.1",
    "@types/jest": "^29.5.14",
    "@types/lodash": "^4.17.16",
    "@types/mongoose": "^5.11.97",
    "@types/node": "^22.13.10",
    "@types/node-fetch": "^2.6.12",
    "@types/passport": "^1.0.17",
    "@typescript-eslint/eslint-plugin": "^8.27.0",
    "@typescript-eslint/parser": "^8.27.0",
    "eslint": "^9.22.0",
    "eslint-config-prettier": "^10.1.1",
    "eslint-plugin-prettier": "^5.2.3",
    "jest": "^29.7.0",
    "nodemon": "^3.1.9",
    "prettier": "^3.5.3",
    "ts-jest": "^29.2.6",
    "ts-node": "^10.9.2"
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\api\tsconfig.json -----

{
  "compileOnSave": false,
  "compilerOptions": {
    "jsx": "preserve",
    "allowJs": true,
    "alwaysStrict": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "removeComments": false,
    "preserveConstEnums": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "sourceMap": true,
    "skipLibCheck": true,
    "baseUrl": ".",
    "experimentalDecorators": true,
    "typeRoots": ["./node_modules/@types"],
    "lib": ["es2015", "es2016"]
  },
  "exclude": ["production-server", "node_modules"]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\api\tsconfig.server.json -----

{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "module": "commonjs",
    "outDir": "production-server/"
  },
  "include": ["./server/**/*.ts"],
  "exclude": ["./server/**/*.test.ts"]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\components\common\Confirmer.tsx -----

import Button from "@mui/material/Button";
import Dialog from "@mui/material/Dialog";
import DialogActions from "@mui/material/DialogActions";
import DialogContent from "@mui/material/DialogContent";
import DialogContentText from "@mui/material/DialogContentText";
import DialogTitle from "@mui/material/DialogTitle";
import React from "react";

export let openConfirmDialogExternal;

type State = {
  open: boolean;
  title: string;
  message: string;
  onAnswer: (answer) => void;
};

class Confirmer extends React.Component<any, State> {
  constructor(props) {
    super(props);

    this.state = {
      open: false,
      title: "Are you sure?",
      message: "",
      onAnswer: null,
    };

    openConfirmDialogExternal = this.openConfirmDialog;
  }

  public render() {
    return (
      <Dialog
        open={this.state.open}
        onClose={this.handleClose}
        aria-labelledby="alert-dialog-title"
        aria-describedby="alert-dialog-description"
      >
        <DialogTitle id="alert-dialog-title">{this.state.title}</DialogTitle>
        <DialogContent>
          <DialogContentText id="alert-dialog-description">{this.state.message}</DialogContentText>
        </DialogContent>
        <DialogActions style={{ padding: "10px" }}>
          <Button onClick={this.handleClose} variant="contained" color="primary" autoFocus>
            Cancel
          </Button>
          <Button onClick={this.handleYes} variant="contained" color="secondary">
            OK
          </Button>
        </DialogActions>
      </Dialog>
    );
  }

  public handleClose = () => {
    this.setState({ open: false });
    this.state.onAnswer(false);
  };

  public handleYes = () => {
    this.setState({ open: false });
    this.state.onAnswer(true);
  };

  public openConfirmDialog = ({ title, message, onAnswer }) => {
    this.setState({ open: true, title, message, onAnswer });
  };
}

export default Confirmer;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\components\common\Loading.tsx -----

import React from 'react';

const Loading = ({ text }: { text: string }) => {
  const IS_DEV = process.env.NODE_ENV !== 'production';

  if (IS_DEV) {
    return <p style={{ height: '1.0em' }} />;
  }

  return <p style={{ height: '1.0em' }}>{text}</p>;
};

export default Loading;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\components\common\LoginButton.tsx -----

import Button from "@mui/material/Button";
import TextField from "@mui/material/TextField";
import React from "react";

import { emailLoginLinkApiMethod } from "../../lib/api/public";
import notify from "../../lib/notify";
import { makeQueryString } from "../../lib/api/makeQueryString";

type Props = { invitationToken?: string };
type State = { email: string };

class LoginButton extends React.PureComponent<Props, State> {
  constructor(props) {
    super(props);

    this.state = { email: "" };
  }

  public render() {
    const { invitationToken } = this.props;

    let url = `${process.env.NEXT_PUBLIC_URL_API}/auth/google`;
    const qs = makeQueryString({ invitationToken });

    if (qs) {
      url += `?${qs}`;
    }

    // console.log(url);

    return (
      <React.Fragment>
        <Button variant="contained" color="secondary" href={url}>
          <img src="https://storage.googleapis.com/async-await-all/G.svg" alt="Log in with Google" />
          &nbsp;&nbsp;&nbsp; Log in with Google
        </Button>
        <p />
        <br />
        <hr style={{ width: "60px" }} /> <h4>OR</h4> <hr style={{ width: "60px" }} />
        <p />
        <br />
        <div>
          <form autoComplete="off" onSubmit={this.onSubmit}>
            <TextField
              required
              type="email"
              label="Email address"
              value={this.state.email}
              onChange={(event) => {
                this.setState({ email: event.target.value });
              }}
              style={{ width: "300px" }}
            />
            <p />
            <Button variant="contained" color="primary" type="submit">
              Log in with email
            </Button>
          </form>
          <p />
          <br />
        </div>
      </React.Fragment>
    );
  }

  private onSubmit = async (event) => {
    event.preventDefault();
    const { email } = this.state;
    const { invitationToken } = this.props;

    if (!email) {
      notify("Email is required");
    }

    try {
      await emailLoginLinkApiMethod({ email, invitationToken });
      this.setState({ email: "" });
      notify("SaaS boilerplate emailed you a login link.");
    } catch (error) {
      notify(error);
    }
  };
}

export default LoginButton;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\components\common\MenuWithLinks.tsx -----

import Menu from "@mui/material/Menu";
import MenuItem from "@mui/material/MenuItem";
import Link from "next/link";
import { NextRouter, withRouter } from "next/router";
import React from "react";

type Props = {
  options: {
    href: string;
    as: string;
    highlighterSlug: string;
    text: string;
    externalServer: boolean;
    separator: boolean;
  }[];
  router: NextRouter;
  children: any;
};

type State = {
  anchorEl: Element | ((element: Element) => Element);
};

class MenuWithLinks extends React.PureComponent<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      anchorEl: null,
    };
  }

  public render() {
    const { options, children, router } = this.props;
    const { anchorEl } = this.state;

    return (
      <div style={{ textAlign: "center" }}>
        <div
          aria-controls={anchorEl ? "simple-menu" : null}
          aria-haspopup="true"
          onClick={this.handleClick}
          onKeyPress={this.handleClick}
        >
          {children}
        </div>
        <Menu id="simple-menu" anchorEl={anchorEl} open={Boolean(anchorEl)} onClose={this.handleClose} keepMounted>
          {options.map((option, i) =>
            option.separator ? (
              <hr style={{ width: "95%", margin: "10px auto" }} key={`separated-${i}`} />
            ) : option.externalServer ? (
              <MenuItem
                onClick={(event) => {
                  event.preventDefault();
                  window.location.href = option.href;
                  this.handleClose();
                }}
                key={option.href || option.text}
              >
                {option.text}
              </MenuItem>
            ) : (
              <Link key={option.href} href={option.href} as={option.as} passHref>
                <MenuItem
                  key={option.href}
                  style={{
                    fontWeight: router.asPath.includes(option.highlighterSlug) ? 600 : 300,
                    fontSize: "14px",
                  }}
                >
                  {option.text}
                </MenuItem>
              </Link>
            )
          )}
        </Menu>
      </div>
    );
  }

  public handleClick = (event) => {
    this.setState({ anchorEl: event.currentTarget });
  };

  public handleClose = () => {
    this.setState({ anchorEl: null });
  };
}

export default withRouter(MenuWithLinks);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\components\common\Notifier.tsx -----

import Snackbar from "@mui/material/Snackbar";
import React from "react";

export let openSnackbarExternal;

type State = {
  open: boolean;
  message: string;
};

class Notifier extends React.PureComponent<any, State> {
  constructor(props) {
    super(props);
    openSnackbarExternal = this.openSnackbar;

    this.state = {
      open: false,
      message: "",
    };
  }

  public render() {
    const message = <span id="snackbar-message-id" dangerouslySetInnerHTML={{ __html: this.state.message }} />;

    return (
      <Snackbar
        anchorOrigin={{ vertical: "top", horizontal: "right" }}
        message={message}
        autoHideDuration={5000}
        onClose={this.handleSnackbarClose}
        open={this.state.open}
        ContentProps={{
          "aria-describedby": "snackbar-message-id",
        }}
      />
    );
  }

  public handleSnackbarClose = () => {
    this.setState({
      open: false,
      message: "",
    });
  };

  public openSnackbar = ({ message }) => {
    this.setState({ open: true, message });
  };
}

export default Notifier;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\components\layout\index.tsx -----

import Avatar from "@mui/material/Avatar";
import Button from "@mui/material/Button";
import Grid from "@mui/material/Grid";

import Link from "next/link";
import React from "react";

import MenuWithLinks from "../common/MenuWithLinks";
import Confirmer from "../common/Confirmer";
import Notifier from "../common/Notifier";

import { Store } from "../../lib/store";

const styleGrid = {
  width: "100%",
  height: "100vh",
  maxWidth: "100%",
  padding: "0px 10px",
  display: "flex",
  overflow: "hidden",
};

const styleGridIsMobile = {
  width: "100%",
  height: "100vh",
  maxWidth: "100%",
  padding: "0px 0px 0px 10px",
  display: "flex",
  overflow: "hidden",
};

function LayoutWrapper({
  children,
  isMobile,
  firstGridItem,
  store,
}: {
  children: React.ReactNode;
  isMobile: boolean;
  firstGridItem: boolean;
  store: Store;
}) {
  const isThemeDark = store.currentUser ? store.currentUser.darkTheme : true;

  return (
    <React.Fragment>
      <Grid
        container
        direction="row"
        justify="flex-start"
        alignItems="stretch"
        style={isMobile ? styleGridIsMobile : styleGrid}
      >
        {firstGridItem ? (
          <Grid
            item
            sm={2}
            xs={12}
            style={{
              borderRight: "1px #707070 solid",
              justifyContent: "center",
              overflow: "hidden",
            }}
          >
            <div style={{ display: "flex", justifyContent: "space-between" }}>
              <svg
                xmlns="http://www.w3.org/2000/svg"
                width="124"
                height="40"
                viewBox="0 0 124 40"
                style={{
                  marginTop: "20px",
                  display: "inline-flex",
                  height: "40px",
                }}
              >
                <g id="async-logo">
                  <g id="async-logo-40">
                    <circle id="Ellipse 2" cx="20" cy="20" r="20" fill="black" />
                    <path
                      id="path-async-logo"
                      d="M7.07825 -0.0960007V16H4.51825V13.088C4.04892 14.0907 3.33425 14.8693 2.37425 15.424C1.43558 15.9573 0.336917 16.224 -0.92175 16.224C-2.35108 16.224 -3.60975 15.8827 -4.69775 15.2C-5.76442 14.5173 -6.59642 13.5573 -7.19375 12.32C-7.76975 11.0613 -8.05775 9.6 -8.05775 7.936C-8.05775 6.272 -7.75908 4.81067 -7.16175 3.552C-6.56442 2.272 -5.73242 1.28 -4.66575 0.576C-3.57775 -0.128 -2.32975 -0.48 -0.92175 -0.48C0.336917 -0.48 1.43558 -0.202666 2.37425 0.352C3.31292 0.906667 4.02758 1.68533 4.51825 2.688V-0.0960007H7.07825ZM-0.40975 14.08C1.16892 14.08 2.38492 13.5467 3.23825 12.48C4.09158 11.392 4.51825 9.856 4.51825 7.872C4.51825 5.888 4.09158 4.36267 3.23825 3.296C2.38492 2.22933 1.16892 1.696 -0.40975 1.696C-1.98842 1.696 -3.22575 2.25067 -4.12175 3.36C-4.99642 4.448 -5.43375 5.97333 -5.43375 7.936C-5.43375 9.89867 -4.99642 11.4133 -4.12175 12.48C-3.24708 13.5467 -2.00975 14.08 -0.40975 14.08Z"
                      transform="translate(19.5938 12)"
                      fill="white"
                    />
                  </g>
                  <path
                    id="path-async-text"
                    d="M22.6251 11.928V24H20.7051V21.816C20.3531 22.568 19.8171 23.152 19.0971 23.568C18.3931 23.968 17.5691 24.168 16.6251 24.168C15.5531 24.168 14.6091 23.912 13.7931 23.4C12.9931 22.888 12.3691 22.168 11.9211 21.24C11.4891 20.296 11.2731 19.2 11.2731 17.952C11.2731 16.704 11.4971 15.608 11.9451 14.664C12.3931 13.704 13.0171 12.96 13.8171 12.432C14.6331 11.904 15.5691 11.64 16.6251 11.64C17.5691 11.64 18.3931 11.848 19.0971 12.264C19.8011 12.68 20.3371 13.264 20.7051 14.016V11.928H22.6251ZM17.0091 22.56C18.1931 22.56 19.1051 22.16 19.7451 21.36C20.3851 20.544 20.7051 19.392 20.7051 17.904C20.7051 16.416 20.3851 15.272 19.7451 14.472C19.1051 13.672 18.1931 13.272 17.0091 13.272C15.8251 13.272 14.8971 13.688 14.2251 14.52C13.5691 15.336 13.2411 16.48 13.2411 17.952C13.2411 19.424 13.5691 20.56 14.2251 21.36C14.8811 22.16 15.8091 22.56 17.0091 22.56ZM30.4637 24.168C28.4317 24.168 26.8237 23.648 25.6397 22.608L26.2877 21.168C26.9437 21.68 27.6077 22.048 28.2797 22.272C28.9517 22.496 29.7037 22.608 30.5357 22.608C31.4477 22.608 32.1357 22.456 32.5997 22.152C33.0797 21.832 33.3197 21.376 33.3197 20.784C33.3197 20.304 33.1597 19.92 32.8397 19.632C32.5197 19.344 31.9917 19.12 31.2557 18.96L29.2157 18.48C28.2077 18.256 27.4237 17.856 26.8637 17.28C26.3197 16.704 26.0477 16.016 26.0477 15.216C26.0477 14.16 26.4717 13.304 27.3197 12.648C28.1677 11.976 29.2877 11.64 30.6797 11.64C31.5277 11.64 32.3277 11.776 33.0797 12.048C33.8317 12.32 34.4637 12.712 34.9757 13.224L34.3277 14.64C33.1917 13.696 31.9757 13.224 30.6797 13.224C29.8157 13.224 29.1437 13.392 28.6637 13.728C28.1997 14.048 27.9677 14.504 27.9677 15.096C27.9677 15.592 28.1117 15.984 28.3997 16.272C28.7037 16.56 29.1837 16.784 29.8397 16.944L31.8797 17.448C32.9997 17.704 33.8317 18.104 34.3757 18.648C34.9197 19.176 35.1917 19.872 35.1917 20.736C35.1917 21.776 34.7677 22.608 33.9197 23.232C33.0717 23.856 31.9197 24.168 30.4637 24.168ZM48.687 11.928L43.047 25.104C42.455 26.48 41.711 27.488 40.815 28.128C39.919 28.768 38.815 29.208 37.503 29.448L37.095 27.936C38.231 27.68 39.087 27.336 39.663 26.904C40.255 26.488 40.743 25.84 41.127 24.96L41.607 23.88L36.495 11.928H38.535L42.615 21.888L46.743 11.928H48.687ZM56.853 11.64C59.749 11.64 61.197 13.232 61.197 16.416V24H59.253V16.512C59.253 15.392 59.029 14.576 58.581 14.064C58.133 13.536 57.429 13.272 56.469 13.272C55.349 13.272 54.453 13.616 53.781 14.304C53.109 14.992 52.773 15.92 52.773 17.088V24H50.829V15.312C50.829 14.064 50.765 12.936 50.637 11.928H52.485L52.677 14.088C53.045 13.304 53.597 12.704 54.333 12.288C55.069 11.856 55.909 11.64 56.853 11.64ZM69.9321 24.168C68.7641 24.168 67.7401 23.912 66.8601 23.4C65.9961 22.888 65.3241 22.168 64.8441 21.24C64.3801 20.296 64.1481 19.2 64.1481 17.952C64.1481 16.704 64.3881 15.608 64.8681 14.664C65.3481 13.704 66.0281 12.96 66.9081 12.432C67.8041 11.904 68.8441 11.64 70.0281 11.64C70.8441 11.64 71.6281 11.784 72.3801 12.072C73.1481 12.344 73.7801 12.728 74.2761 13.224L73.6281 14.664C73.0201 14.184 72.4281 13.832 71.8521 13.608C71.2921 13.384 70.7161 13.272 70.1241 13.272C68.8921 13.272 67.9241 13.688 67.2201 14.52C66.5161 15.336 66.1641 16.48 66.1641 17.952C66.1641 19.408 66.5081 20.544 67.1961 21.36C67.9001 22.16 68.8761 22.56 70.1241 22.56C70.7161 22.56 71.2921 22.448 71.8521 22.224C72.4281 22 73.0201 21.648 73.6281 21.168L74.2761 22.608C73.7641 23.088 73.1161 23.472 72.3321 23.76C71.5641 24.032 70.7641 24.168 69.9321 24.168Z"
                    transform="translate(39 4)"
                    fill={isThemeDark ? "white" : "black"}
                  />
                </g>
              </svg>
              <MenuWithLinks
                options={[
                  {
                    text: "Team Settings",
                    href: `/team-settings?teamSlug=${store.currentTeam.slug}`,
                    as: `/team/${store.currentTeam.slug}/team-settings`,
                    simple: true,
                  },
                  {
                    text: "Billing",
                    href: `/billing?teamSlug=${store.currentTeam.slug}`,
                    as: `/team/${store.currentTeam.slug}/billing`,
                    simple: true,
                  },
                  {
                    text: "Your Settings",
                    href: "/your-settings",
                    highlighterSlug: "/your-settings",
                  },
                  {
                    separator: true,
                  },
                  {
                    text: "Log out",
                    href: `${process.env.NEXT_PUBLIC_URL_API}/logout`,
                    as: `${process.env.NEXT_PUBLIC_URL_API}/logout`,
                    externalServer: true,
                  },
                ]}
              >
                <Avatar
                  src={store.currentUser.avatarUrl}
                  alt="Add username here later in the book"
                  style={{
                    margin: "20px auto",
                    cursor: "pointer",
                    display: "inline-flex",
                    width: "40px",
                    height: "40px",
                  }}
                />

                <i className="material-icons" color="action" style={{ verticalAlign: "super" }}>
                  arrow_drop_down
                </i>
              </MenuWithLinks>
            </div>
            <hr />
            <p />
            <p />
          </Grid>
        ) : null}

        {children}
      </Grid>
      <Notifier />
      <Confirmer />
    </React.Fragment>
  );
}

type Props = {
  children: React.ReactNode;
  isMobile?: boolean;
  firstGridItem?: boolean;
  store?: Store;
  teamRequired?: boolean;
};

class Layout extends React.Component<Props> {
  public render() {
    const { children, isMobile, firstGridItem, store, teamRequired } = this.props;

    const { currentUser, currentTeam } = store;

    // console.log(this.props.store.currentUser.darkTheme);

    // const isThemeDark = false;

    // console.log(isMobile);

    // console.log(currentTeam);

    if (!currentUser) {
      return (
        <LayoutWrapper firstGridItem={firstGridItem} isMobile={isMobile} store={store}>
          <Grid item sm={12} xs={12}>
            {children}
          </Grid>
        </LayoutWrapper>
      );
    }

    if (!currentTeam) {
      if (teamRequired) {
        return (
          <LayoutWrapper firstGridItem={firstGridItem} isMobile={isMobile} store={store}>
            <Grid item sm={10} xs={12} style={{ padding: "0px 35px", overflow: "auto", height: "auto" }}>
              <div style={{ padding: "20px" }}>
                Select existing team or create a new team.
                <p />
                <Link href="/create-team" as="/create-team">
                  <Button variant="outlined" color="primary">
                    Create new team
                  </Button>
                </Link>
              </div>
            </Grid>
          </LayoutWrapper>
        );
      } else {
        console.log("team not required");
        return (
          <LayoutWrapper firstGridItem={firstGridItem} isMobile={isMobile} store={store}>
            <Grid item sm={10} xs={12} style={{ padding: "0px 35px", overflow: "auto", height: "auto" }}>
              {children}
            </Grid>
          </LayoutWrapper>
        );
      }
    }

    return (
      <LayoutWrapper firstGridItem={firstGridItem} isMobile={isMobile} store={store}>
        <Grid
          item
          sm={firstGridItem ? 10 : 12}
          xs={12}
          style={{ padding: "0px 35px", overflowY: "auto", height: "inherit" }}
        >
          <div>
            {isMobile || store.currentUrl.includes("create-team") ? null : (
              <React.Fragment>
                <i
                  style={{
                    float: "left",
                    margin: "15px 0px 10px 25px",
                    opacity: 0.8,
                    fontSize: "18px",
                    cursor: "pointer",
                    verticalAlign: "top",
                  }}
                  className="material-icons"
                  onClick={async () => {
                    await store.currentUser.toggleTheme(!store.currentUser.darkTheme);
                  }}
                >
                  lens
                </i>
              </React.Fragment>
            )}
            <div style={{ clear: "both" }} />
          </div>
          {children}
        </Grid>
      </LayoutWrapper>
    );
  }
}

export default Layout;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\components\teams\InviteMember.tsx -----

import Button from "@mui/material/Button";
import Dialog from "@mui/material/Dialog";
import DialogContent from "@mui/material/DialogContent";
import DialogTitle from "@mui/material/DialogTitle";
import TextField from "@mui/material/TextField";
import { inject, observer } from "mobx-react";
import NProgress from "nprogress";
import React from "react";

import notify from "../../lib/notify";
import { Store } from "../../lib/store";

type Props = {
  store: Store;
  onClose: () => void;
  open: boolean;
};

type State = {
  email: string;
  disabled: boolean;
};

class InviteMember extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      email: "",
      disabled: false,
    };
  }

  public render() {
    const { open } = this.props;

    return (
      <Dialog onClose={this.handleClose} aria-labelledby="invite-member-dialog-title" open={open}>
        <DialogTitle id="invite-member-dialog-title">Invite member</DialogTitle>
        <DialogContent>
          <form onSubmit={this.onSubmit} style={{ padding: "20px" }}>
            <TextField
              autoComplete="off"
              value={this.state.email}
              placeholder="Email"
              onChange={(event) => {
                this.setState({ email: event.target.value });
              }}
            />
            <p />
            <br />
            <Button variant="outlined" onClick={this.handleClose} disabled={this.state.disabled}>
              Cancel
            </Button>{" "}
            <Button type="submit" variant="contained" color="primary" disabled={this.state.disabled}>
              Invite
            </Button>
          </form>
        </DialogContent>
      </Dialog>
    );
  }

  private handleClose = () => {
    this.setState({ email: "", disabled: false });
    this.props.onClose();
  };

  private onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();

    const { store } = this.props;

    if (!store.currentTeam) {
      notify("Team have not selected");
      return;
    }

    const { email } = this.state;

    if (!email) {
      notify("Email is required");
      return;
    }

    NProgress.start();
    try {
      this.setState({ disabled: true });
      await store.currentTeam.inviteMember(email);

      this.setState({ email: "" });
      notify("You successfully sent invitation.");
      NProgress.done();
    } catch (error) {
      console.log(error);
      notify(error);
    } finally {
      this.props.onClose();
      this.setState({ disabled: false });
      NProgress.done();
    }
  };
}

export default inject("store")(observer(InviteMember));

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\lib\api\makeQueryString.ts -----

function makeQueryString(params) {
  const query = Object.keys(params)
    .filter((k) => !!params[k])
    .map((k) => `${encodeURIComponent(k)}=${encodeURIComponent(params[k])}`)
    .join('&');

  return query;
}

export { makeQueryString };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\lib\api\public.ts -----

import sendRequestAndGetResponse from './sendRequestAndGetResponse';

const BASE_PATH = '/api/v1/public';

export const getUserApiMethod = (request) =>
  sendRequestAndGetResponse(`${BASE_PATH}/get-user`, {
    request,
    method: 'GET',
  });

export const getUserBySlugApiMethod = (slug) =>
  sendRequestAndGetResponse(`${BASE_PATH}/get-user-by-slug`, {
    body: JSON.stringify({ slug }),
  });

export const emailLoginLinkApiMethod = ({
  email,
  invitationToken,
}: {
  email: string;
  invitationToken?: string;
}) =>
  sendRequestAndGetResponse('/auth/email-login-link', {
    qs: { invitationToken },
    body: JSON.stringify({ user: email }),
  });

export const getTeamByTokenApiMethod = (token: string, request) =>
  sendRequestAndGetResponse(`${BASE_PATH}/invitations/get-team-by-token`, {
    request,
    method: 'GET',
    qs: { token },
  });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\lib\api\sendRequestAndGetResponse.ts -----

import 'isomorphic-unfetch';

import { makeQueryString } from './makeQueryString';

export default async function sendRequestAndGetResponse(path, opts: any = {}) {
  const headers = Object.assign(
    {},
    opts.headers || {},
    opts.externalServer
      ? {}
      : {
          'Content-type': 'application/json; charset=UTF-8',
        },
  );

  const { request } = opts;

  if (request && request.headers && request.headers.cookie) {
    headers.cookie = request.headers.cookie;
  }

  // const qs = opts.qs || '';

  const qs = (opts.qs && `?${makeQueryString(opts.qs)}`) || '';

  // console.log(`before: ${process.env.NEXT_PUBLIC_URL_API}${path}${qs}`);

  const response = await fetch(
    opts.externalServer ? `${path}${qs}` : `${process.env.NEXT_PUBLIC_URL_API}${path}${qs}`,
    Object.assign({ method: 'POST', credentials: 'include' }, opts, { headers }),
  );

  // console.log(`after: ${process.env.NEXT_PUBLIC_URL_API}${path}${qs}`);

  // console.log(response.status);
  // console.log(response.statusText);

  const text = await response.text();

  if (response.status >= 400) {
    console.error(text);
    throw new Error(response.status.toString());
  }

  try {
    const data = JSON.parse(text);

    return data;
  } catch (err) {
    if (err instanceof SyntaxError) {
      return text;
    }

    throw err;
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\lib\api\team-leader.ts -----

import sendRequestAndGetResponse from './sendRequestAndGetResponse';

const BASE_PATH = '/api/v1/team-leader';

export const addTeamApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams/add`, {
    body: JSON.stringify(data),
  });

export const updateTeamApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams/update`, {
    body: JSON.stringify(data),
  });

export const getTeamInvitationsApiMethod = (teamId: string) =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams/get-invitations-for-team`, {
    method: 'GET',
    qs: { teamId },
  });

export const inviteMemberApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams/invite-member`, {
    body: JSON.stringify(data),
  });

export const removeMemberApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams/remove-member`, {
    body: JSON.stringify(data),
  });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\lib\api\team-member.ts -----

import sendRequestAndGetResponse from './sendRequestAndGetResponse';

const BASE_PATH = '/api/v1/team-member';

export const getSignedRequestForUploadApiMethod = ({ fileName, fileType, prefix, bucket }) =>
  sendRequestAndGetResponse(`${BASE_PATH}/aws/get-signed-request-for-upload-to-s3`, {
    body: JSON.stringify({ fileName, fileType, prefix, bucket }),
  });

export const uploadFileUsingSignedPutRequestApiMethod = (file, signedRequest, headers = {}) =>
  sendRequestAndGetResponse(signedRequest, {
    externalServer: true,
    method: 'PUT',
    body: file,
    headers,
  });

export const updateProfileApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/user/update-profile`, {
    body: JSON.stringify(data),
  });

export const toggleThemeApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/user/toggle-theme`, {
    body: JSON.stringify(data),
  });

export const getInitialDataApiMethod = (options: any = {}) =>
  sendRequestAndGetResponse(
    `${BASE_PATH}/get-initial-data`,
    Object.assign(
      {
        body: JSON.stringify(options.data || {}),
      },
      options,
    ),
  );

export const getTeamListApiMethod = () =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams`, {
    method: 'GET',
  });

export const getTeamMembersApiMethod = (teamId: string) =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams/get-members`, {
    method: 'GET',
    qs: { teamId },
  });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\lib\store\index.ts -----

import * as mobx from 'mobx';
import { action, decorate, observable } from 'mobx';
import { useStaticRendering } from 'mobx-react';

import { addTeamApiMethod, getTeamInvitationsApiMethod } from '../api/team-leader';
import { getTeamListApiMethod, getTeamMembersApiMethod } from '../api/team-member';

import { User } from './user';
import { Team } from './team';

useStaticRendering(typeof window === 'undefined');

mobx.configure({ enforceActions: 'observed' });

class Store {
  public isServer: boolean;

  public currentUser?: User = null;
  public currentUrl = '';

  public currentTeam?: Team;

  constructor({ initialState = {}, isServer }: { initialState?: any; isServer: boolean }) {
    this.isServer = !!isServer;

    this.setCurrentUser(initialState.user);

    this.currentUrl = initialState.currentUrl || '';

    // console.log(initialState.user);

    if (initialState.teamSlug || (initialState.user && initialState.user.defaultTeamSlug)) {
      this.setCurrentTeam(
        initialState.teamSlug || initialState.user.defaultTeamSlug,
        initialState.teams,
      );
    }
  }

  public changeCurrentUrl(url: string) {
    this.currentUrl = url;
  }

  public async setCurrentUser(user) {
    if (user) {
      this.currentUser = new User({ store: this, ...user });
    } else {
      this.currentUser = null;
    }
  }

  public async addTeam({ name, avatarUrl }: { name: string; avatarUrl: string }): Promise<Team> {
    const data = await addTeamApiMethod({ name, avatarUrl });
    const team = new Team({ store: this, ...data });

    return team;
  }

  public async setCurrentTeam(slug: string, initialTeams: any[]) {
    if (this.currentTeam) {
      if (this.currentTeam.slug === slug) {
        return;
      }
    }

    let found = false;

    const teams = initialTeams || (await getTeamListApiMethod()).teams;

    for (const team of teams) {
      if (team.slug === slug) {
        found = true;
        this.currentTeam = new Team({ ...team, store: this });

        const users =
          team.initialMembers || (await getTeamMembersApiMethod(this.currentTeam._id)).users;

        const invitations =
          team.initialInvitations ||
          (await getTeamInvitationsApiMethod(this.currentTeam._id)).invitations;

        this.currentTeam.setInitialMembersAndInvitations(users, invitations);

        break;
      }
    }

    if (!found) {
      this.currentTeam = null;
    }
  }
}

decorate(Store, {
  currentUser: observable,
  currentUrl: observable,
  currentTeam: observable,

  changeCurrentUrl: action,
  setCurrentUser: action,
  setCurrentTeam: action,
});

let store: Store = null;

function initializeStore(initialState = {}) {
  const isServer = typeof window === 'undefined';

  const _store =
    store !== null && store !== undefined ? store : new Store({ initialState, isServer });

  // For SSG and SSR always create a new store
  if (typeof window === 'undefined') {
    return _store;
  }
  // Create the store once in the client
  if (!store) {
    store = _store;
  }

  // console.log(_store);

  return _store;
}

function getStore() {
  return store;
}

export { Store, initializeStore, getStore };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\lib\store\invitation.ts -----

class Invitation {
  public _id: string;
  public teamId: string;
  public email: string;
  public createdAt: Date;

  constructor(params) {
    Object.assign(this, params);
  }
}

export { Invitation };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\lib\store\team.ts -----

import { action, decorate, IObservableArray, observable, runInAction } from 'mobx';
import {
  inviteMemberApiMethod,
  removeMemberApiMethod,
  updateTeamApiMethod,
} from '../api/team-leader';
import { Store } from './index';
import { User } from './user';
import { Invitation } from './invitation';

class Team {
  public store: Store;

  public _id: string;
  public teamLeaderId: string;

  public name: string;
  public slug: string;
  public avatarUrl: string;
  public memberIds: IObservableArray<string> = observable([]);
  public members: Map<string, User> = new Map();
  public invitations: Map<string, Invitation> = new Map();

  // public initialDiscussionSlug = '';

  constructor(params) {
    this._id = params._id;
    this.teamLeaderId = params.teamLeaderId;
    this.slug = params.slug;
    this.name = params.name;
    this.avatarUrl = params.avatarUrl;
    this.memberIds.replace(params.memberIds || []);

    this.store = params.store;

    if (params.initialMembers) {
      this.setInitialMembersAndInvitations(params.initialMembers, params.initialInvitations);
    }
  }

  public setInitialMembersAndInvitations(users, invitations) {
    this.members.clear();
    this.invitations.clear();

    for (const user of users) {
      if (this.store.currentUser && this.store.currentUser._id === user._id) {
        this.members.set(user._id, this.store.currentUser);
      } else {
        this.members.set(user._id, new User(user));
      }
    }

    for (const invitation of invitations) {
      this.invitations.set(invitation._id, new Invitation(invitation));
    }
  }

  public async updateTheme({ name, avatarUrl }: { name: string; avatarUrl: string }) {
    try {
      const { slug } = await updateTeamApiMethod({
        teamId: this._id,
        name,
        avatarUrl,
      });

      runInAction(() => {
        this.name = name;
        this.avatarUrl = avatarUrl;
        this.slug = slug;
      });
    } catch (error) {
      console.error(error);
      throw error;
    }
  }

  public async inviteMember(email: string) {
    try {
      const { newInvitation } = await inviteMemberApiMethod({ teamId: this._id, email });

      runInAction(() => {
        this.invitations.set(newInvitation._id, new Invitation(newInvitation));
      });
    } catch (error) {
      console.error(error);
      throw error;
    }
  }

  public async removeMember(userId: string) {
    try {
      await removeMemberApiMethod({ teamId: this._id, userId });

      runInAction(() => {
        this.members.delete(userId);
        this.memberIds.remove(userId);
      });
    } catch (error) {
      console.error(error);
      throw error;
    }
  }
}

decorate(Team, {
  name: observable,
  slug: observable,
  avatarUrl: observable,
  memberIds: observable,
  members: observable,
  invitations: observable,

  setInitialMembersAndInvitations: action,
  updateTheme: action,
  inviteMember: action,
  removeMember: action,
});

export { Team };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\lib\store\user.ts -----

import { action, decorate, observable, runInAction } from 'mobx';

import * as NProgress from 'nprogress';

import { toggleThemeApiMethod, updateProfileApiMethod } from '../api/team-member';
import { Store } from './index';

class User {
  public store: Store;

  public _id: string;
  public slug: string;
  public email: string | null;
  public displayName: string | null;
  public avatarUrl: string | null;
  public isSignedupViaGoogle: boolean;

  public darkTheme = false;
  public defaultTeamSlug: string;

  constructor(params) {
    this.store = params.store;
    this._id = params._id;
    this.slug = params.slug;
    this.email = params.email;
    this.displayName = params.displayName;
    this.avatarUrl = params.avatarUrl;
    this.isSignedupViaGoogle = !!params.isSignedupViaGoogle;
    this.darkTheme = !!params.darkTheme;
    this.defaultTeamSlug = params.defaultTeamSlug;
  }

  public async updateProfile({ name, avatarUrl }: { name: string; avatarUrl: string }) {
    const { updatedUser } = await updateProfileApiMethod({
      name,
      avatarUrl,
    });

    runInAction(() => {
      this.displayName = updatedUser.displayName;
      this.avatarUrl = updatedUser.avatarUrl;
      this.slug = updatedUser.slug;
    });
  }

  public async toggleTheme(darkTheme: boolean) {
    await toggleThemeApiMethod({ darkTheme });
    runInAction(() => {
      this.darkTheme = darkTheme;
    });
    NProgress.start();
    NProgress.set(0.5);
    window.location.reload();
  }
}

decorate(User, {
  slug: observable,
  email: observable,
  displayName: observable,
  avatarUrl: observable,
  // darkTheme: observable,
  defaultTeamSlug: observable,

  updateProfile: action,
  toggleTheme: action,
});

export { User };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\lib\confirm.ts -----

import { openConfirmDialogExternal } from '../components/common/Confirmer';

export default function confirm({
  title,
  message,
  onAnswer,
}: {
  title: string;
  message: string;
  onAnswer: (answer) => void;
}) {
  openConfirmDialogExternal({ title, message, onAnswer });
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\lib\isMobile.ts -----

const mobileRE = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i;

export function isMobile(opts) {
  if (!opts) {
    opts = {};
  }

  let ua = opts.ua;

  if (!ua && typeof navigator !== 'undefined') {
    ua = navigator.userAgent;
  }

  if (!ua && opts.req && opts.req.headers && typeof opts.req.headers['user-agent'] === 'string') {
    ua = opts.req.headers['user-agent'];
    // console.log(ua);
  }

  if (typeof ua !== 'string') {
    return false;
  }

  return mobileRE.test(ua);
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\lib\notify.ts -----

import { openSnackbarExternal } from '../components/common/Notifier';

export default function notify(obj) {
  openSnackbarExternal({ message: obj.message || obj.toString() });
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\lib\resizeImage.ts -----

function resizeImage(file: File, MAX_WIDTH, MAX_HEIGHT) {
  const image = document.createElement('img');

  const resize = (resolve) => () => {
    let isResizeNeeded = false;
    let width = image.width;
    let height = image.height;

    if (width > height) {
      if (width > MAX_WIDTH) {
        isResizeNeeded = true;
        height *= MAX_WIDTH / width;
        width = MAX_WIDTH;
      }
    } else {
      if (height > MAX_HEIGHT) {
        isResizeNeeded = true;
        width *= MAX_HEIGHT / height;
        height = MAX_HEIGHT;
      }
    }

    if (isResizeNeeded) {
      const canvas = document.createElement('canvas');

      canvas.width = width;
      canvas.height = height;

      console.log(width, height);

      const ctx = canvas.getContext('2d');
      ctx.drawImage(image, 0, 0, width, height);

      canvas.toBlob((blob) => {
        resolve(blob);
      }, file.type);
    } else {
      resolve(file);
    }
  };

  return new Promise((resolve) => {
    const reader = new FileReader();

    console.log(`before ${image.src}`);

    reader.readAsDataURL(file);

    reader.onload = (e) => {
      image.src = e.target.result.toString();

      image.onload = resize(resolve);

      console.log(`after ${image.src}`);
    };
  });
}

export { resizeImage };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\lib\sharedStyles.ts -----

const styleBigAvatar = {
  width: '80px',
  height: '80px',
  margin: '0px auto 15px',
};

const styleRaisedButton = {
  margin: '15px',
  font: '14px Roboto',
};

const styleToolbar = {
  background: '#FFF',
  height: '64px',
  paddingRight: '20px',
};

const styleTextField = {
  font: '15px Roboto',
  color: '#222',
  fontWeight: '300',
};

const styleForm = {
  margin: '7% auto',
  width: '360px',
};

export { styleBigAvatar, styleRaisedButton, styleToolbar, styleTextField, styleForm };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\lib\theme.ts -----

import { createTheme } from "@mui/material/styles";

const themeDark = createTheme({
  palette: {
    primary: { main: "#238636" },
    secondary: { main: "#b62324" },
    type: "dark",
    background: { default: "#0d1117" },
    text: {
      primary: "#c9d1d9",
    },
  },
  typography: {
    button: {
      textTransform: "none",
    },
  },
});

const themeLight = createTheme({
  palette: {
    primary: { main: "#238636" },
    secondary: { main: "#b62324" },
    type: "light",
    background: { default: "#fff" },
    text: {
      primary: "#222",
    },
  },
  typography: {
    button: {
      textTransform: "none",
    },
  },
});

export { themeDark, themeLight };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\lib\withAuth.tsx -----

import { observer } from 'mobx-react';
import Router from 'next/router';
import React from 'react';

import * as NProgress from 'nprogress';

import { Store } from './store';

Router.events.on('routeChangeStart', () => {
  NProgress.start();
});

Router.events.on('routeChangeComplete', () => {
  NProgress.done();
});

Router.events.on('routeChangeError', () => NProgress.done());

export default function withAuth(Component, { loginRequired = true, logoutRequired = false } = {}) {
  class WithAuth extends React.Component<{ store: Store }> {
    public static async getInitialProps(ctx) {
      console.log('WithAuth.getInitialProps');

      const { req } = ctx;

      let pageComponentProps = {};

      if (Component.getInitialProps) {
        pageComponentProps = await Component.getInitialProps(ctx);
      }

      return {
        ...pageComponentProps,
        isServer: !!req,
      };
    }

    public componentDidMount() {
      console.log('WithAuth.componentDidMount');

      const { store } = this.props;
      const user = store.currentUser;

      if (loginRequired && !logoutRequired && !user) {
        Router.push('/login');
        return;
      }

      let redirectUrl = '/login';
      let asUrl = '/login';
      if (user) {
        if (!user.defaultTeamSlug) {
          redirectUrl = '/create-team';
          asUrl = '/create-team';
        } else {
          redirectUrl = `/your-settings`;
          asUrl = `/your-settings`;
        }
      }

      if (logoutRequired && user) {
        Router.push(redirectUrl, asUrl);
      }
    }

    public render() {
      const { store } = this.props;
      const user = store.currentUser;

      if (loginRequired && !logoutRequired && !user) {
        return null;
      }

      if (logoutRequired && user) {
        return null;
      }

      return <Component {...this.props} />;
    }
  }

  return observer(WithAuth);
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\pages\create-team.tsx -----

import { inject, observer } from "mobx-react";
import * as React from "react";

import Avatar from "@mui/material/Avatar";
import Button from "@mui/material/Button";
import Grid from "@mui/material/Grid";
import TextField from "@mui/material/TextField";
import Head from "next/head";
import Router from "next/router";

import { getSignedRequestForUploadApiMethod, uploadFileUsingSignedPutRequestApiMethod } from "../lib/api/team-member";
import notify from "../lib/notify";
import { resizeImage } from "../lib/resizeImage";
import { Store } from "../lib/store";
import withAuth from "../lib/withAuth";

import Layout from "../components/layout";

const styleGrid = {
  height: "100%",
};

type Props = { store: Store; isMobile: boolean; teamRequired: boolean };

type State = { newName: string; newAvatarUrl: string; disabled: boolean };

class CreateTeam extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      newName: "",
      newAvatarUrl: "https://storage.googleapis.com/async-await/default-user.png?v=1",
      disabled: false,
    };
  }

  public render() {
    const { newAvatarUrl } = this.state;

    console.log(this.props.store);

    return (
      <Layout {...this.props}>
        <Head>
          <title>Create Team</title>
          <meta name="description" content="Create a new Team at SaaS Boilerplate" />
        </Head>
        <div style={{ padding: "0px", fontSize: "14px", height: "100%" }}>
          <Grid container style={styleGrid}>
            <Grid item sm={12} xs={12} style={{ padding: this.props.isMobile ? "0px" : "0px 30px" }}>
              <h3>Create team</h3>
              <p />
              <form onSubmit={this.onSubmit}>
                <h4>Team name</h4>
                <TextField
                  value={this.state.newName}
                  label="Type your team's name."
                  helperText="Team name as seen by your team members."
                  onChange={(event) => {
                    this.setState({ newName: event.target.value });
                  }}
                />
                <p />
                <h4 style={{ marginTop: "40px" }}>Team logo (optional)</h4>
                <Avatar
                  src={newAvatarUrl}
                  style={{
                    display: "inline-flex",
                    verticalAlign: "middle",
                    marginRight: 20,
                    width: 60,
                    height: 60,
                  }}
                />
                <label htmlFor="upload-file">
                  <Button variant="outlined" color="primary" component="span">
                    Select team logo
                  </Button>
                </label>
                <input
                  accept="image/*"
                  name="upload-file"
                  id="upload-file"
                  type="file"
                  style={{ display: "none" }}
                  onChange={this.previewTeamLogo}
                />
                <p />
                <br />
                <br />
                <Button variant="contained" color="primary" type="submit" disabled={this.state.disabled}>
                  Create new team
                </Button>
              </form>
            </Grid>
          </Grid>
          <br />
        </div>
      </Layout>
    );
  }

  private onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();

    const { newName } = this.state;

    const { store } = this.props;

    if (!newName) {
      notify("Team name is required.");
      return;
    }

    const file = (document.getElementById("upload-file") as HTMLFormElement).files[0];

    try {
      this.setState({ disabled: true });

      const defaultAvatarUrl = "https://storage.googleapis.com/async-await/default-user.png?v=1";
      const team = await store.addTeam({
        name: newName,
        avatarUrl: defaultAvatarUrl,
      });

      console.log(`Returned to client: ${team._id}, ${team.name}, ${team.slug}`);

      if (file == null) {
        Router.push(`/team/${team.slug}/team-settings`);
        notify("You successfully created Team.<p />Redirecting...");
        return;
      }

      const fileName = file.name;
      const fileType = file.type;
      const bucket = process.env.NEXT_PUBLIC_BUCKET_FOR_TEAM_LOGOS;
      const prefix = team.slug;

      const responseFromApiServerForUpload = await getSignedRequestForUploadApiMethod({
        fileName,
        fileType,
        prefix,
        bucket,
      });

      const resizedFile = await resizeImage(file, 128, 128);

      await uploadFileUsingSignedPutRequestApiMethod(resizedFile, responseFromApiServerForUpload.signedRequest, {
        "Cache-Control": "max-age=2592000",
      });

      const uploadedAvatarUrl = responseFromApiServerForUpload.url;

      await team.updateTheme({ name: team.name, avatarUrl: uploadedAvatarUrl });

      this.setState({
        newName: "",
        newAvatarUrl: "https://storage.googleapis.com/async-await/default-user.png?v=1",
      });

      (document.getElementById("upload-file") as HTMLFormElement).value = "";

      Router.push(`/team/${team.slug}/team-settings`);

      notify("You successfully created Team. Redirecting ...");
    } catch (error) {
      console.log(error);
      notify(error);
    } finally {
      this.setState({ disabled: false });
    }
  };

  private previewTeamLogo = () => {
    const file = (document.getElementById("upload-file") as HTMLFormElement).files[0];
    if (!file) {
      return;
    }

    const reader = new FileReader();

    reader.readAsDataURL(file);

    reader.onload = (e) => {
      this.setState({ newAvatarUrl: e.target.result as string });
    };
  };
}

export default withAuth(inject("store")(observer(CreateTeam)));

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\pages\invitation.tsx -----

import Avatar from "@mui/material/Avatar";
import { observer } from "mobx-react";
import Error from "next/error";
import Head from "next/head";
import Router from "next/router";
// import { NextPageContext } from 'next';
import React from "react";

import LoginButton from "../components/common/LoginButton";
import Layout from "../components/layout";
import { getTeamByTokenApiMethod } from "../lib/api/public";
import { Team } from "../lib/store/team";
import { Store } from "../lib/store";
import withAuth from "../lib/withAuth";

class InvitationPageComp extends React.Component<{ store: Store; team: Team; token: string }> {
  public static async getInitialProps(ctx) {
    const { token } = ctx.query;
    if (!token) {
      return {};
    }

    try {
      const { team } = await getTeamByTokenApiMethod(token, ctx.req);

      return { team, token };
    } catch (error) {
      console.log(error);
      return {};
    }
  }

  public render() {
    const { team, token, store } = this.props;

    if (!team) {
      return <Error statusCode={404} />;
    }

    const user = store.currentUser;

    if (user) {
      return null;
    }

    return (
      <Layout {...this.props}>
        <Head>
          <title>Invitation to {team.name}</title>
          <meta name="description" content={`Invitation to join ${team.name}`} />
        </Head>
        <div style={{ textAlign: "center", margin: "0 20px" }}>
          <br />
          <Avatar
            src={`${team.avatarUrl || "https://storage.googleapis.com/async-await/default-user.png?v=1"}`}
            alt="Team logo"
            style={{
              verticalAlign: "middle",
              display: "inline-flex",
            }}
          />{" "}
          <h2>{team.name}</h2>
          <p>
            Join <b>{team.name}</b> by logging in or signing up.
          </p>
          <br />
          <LoginButton invitationToken={token} />
        </div>
      </Layout>
    );
  }

  public async componentDidMount() {
    const { store, team, token } = this.props;

    const user = store.currentUser;

    if (user && team) {
      Router.push(
        `${process.env.NEXT_PUBLIC_URL_API}/logout?invitationToken=${token}`,
        `${process.env.NEXT_PUBLIC_URL_API}/logout`
      );
    }
  }
}

// export async function getServerSideProps(context: NextPageContext) {
//   const { token } = context.query;

//   try {
//     const { team } = await getTeamByTokenApiMethod(token as string, context.req);

//     if (team && token) {
//       return { props: { team, token } };
//     } else {
//       return { props: {} };
//     }
//   } catch (error) {
//     console.log(error);
//     return { props: {} };
//   }
// }

// see our explanation for not using getServerSideProps at this time: https://github.com/async-labs/saas/issues/193

export default withAuth(observer(InvitationPageComp), { loginRequired: false });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\pages\login.tsx -----

import Head from 'next/head';
import React from 'react';
import LoginButton from '../components/common/LoginButton';
import Layout from '../components/layout';
import withAuth from '../lib/withAuth';

class Login extends React.Component {
  public render() {
    return (
      <Layout {...this.props}>
        <div style={{ textAlign: 'center', margin: '0 20px' }}>
          <Head>
            <title>Log in to SaaS boilerplate by Async</title>
            <meta
              name="description"
              content="Login and signup page for SaaS boilerplate demo by Async"
            />
          </Head>
          <br />
          <p style={{ margin: '45px auto', fontSize: '44px', fontWeight: 400 }}>Log in</p>
          <p>Youll be logged in for 14 days unless you log out manually.</p>
          <br />

          <LoginButton />
        </div>
      </Layout>
    );
  }
}

export default withAuth(Login, { logoutRequired: true });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\pages\team-settings.tsx -----

import Avatar from "@mui/material/Avatar";
import Button from "@mui/material/Button";
import Hidden from "@mui/material/Hidden";
import TextField from "@mui/material/TextField";
import { inject, observer } from "mobx-react";
import Head from "next/head";
import NProgress from "nprogress";
import * as React from "react";
import Table from "@mui/material/Table";
import TableBody from "@mui/material/TableBody";
import TableCell from "@mui/material/TableCell";
import TableContainer from "@mui/material/TableContainer";
import TableHead from "@mui/material/TableHead";
import TableRow from "@mui/material/TableRow";

import Layout from "../components/layout";
import InviteMember from "../components/teams/InviteMember";
import { getSignedRequestForUploadApiMethod, uploadFileUsingSignedPutRequestApiMethod } from "../lib/api/team-member";
import confirm from "../lib/confirm";
import notify from "../lib/notify";
import { resizeImage } from "../lib/resizeImage";
import { Store } from "../lib/store";
import withAuth from "../lib/withAuth";

type Props = { isMobile: boolean; store: Store; teamSlug: string };

type State = {
  newName: string;
  newAvatarUrl: string;
  disabled: boolean;
  inviteMemberOpen: boolean;
};

class TeamSettings extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      newName: this.props.store.currentTeam.name,
      newAvatarUrl: this.props.store.currentTeam.avatarUrl,
      disabled: false,
      inviteMemberOpen: false,
    };
  }

  public render() {
    const { store, isMobile } = this.props;
    const { currentTeam, currentUser } = store;
    const { newName, newAvatarUrl } = this.state;
    const isTeamLeader = currentTeam && currentUser && currentUser._id === currentTeam.teamLeaderId;

    // console.log(this.props.firstGridItem);

    if (!currentTeam || currentTeam.slug !== this.props.teamSlug) {
      return (
        <Layout {...this.props}>
          <div style={{ padding: isMobile ? "0px" : "0px 30px" }}>
            <p>You did not select any team.</p>
            <p>To access this page, please select existing team or create new team if you have no teams.</p>
          </div>
        </Layout>
      );
    }

    if (!isTeamLeader) {
      return (
        <Layout {...this.props}>
          <div style={{ padding: isMobile ? "0px" : "0px 30px" }}>
            <p>Only the Team Leader can access this page.</p>
            <p>Create your own team to become a Team Leader.</p>
          </div>
        </Layout>
      );
    }

    console.log(Array.from(currentTeam.members.values()).filter((user) => user._id !== currentUser._id));

    return (
      <Layout {...this.props}>
        <Head>
          <title>Team Settings</title>
          <meta name="description" content={`Edit team settings. Add or edit members for Team ${currentTeam.name}`} />
        </Head>
        <div style={{ padding: isMobile ? "0px" : "0px 30px", fontSize: "15px", height: "100%" }}>
          <h3>Team Settings</h3>
          <p />
          <br />
          <form onSubmit={this.onSubmit}>
            <h4>Team name</h4>
            <TextField
              value={newName}
              helperText="Team name as seen by your team members"
              onChange={(event) => {
                this.setState({ newName: event.target.value });
              }}
            />
            <br />
            <br />
            <Button variant="contained" color="primary" type="submit" disabled={this.state.disabled}>
              Update username
            </Button>
          </form>
          <p />
          <br />
          <h4>Team logo</h4>
          <Avatar
            src={newAvatarUrl}
            style={{
              display: "inline-flex",
              verticalAlign: "middle",
              marginRight: 20,
              width: 60,
              height: 60,
            }}
          />
          <label htmlFor="upload-file-team-logo">
            <Button variant="contained" color="primary" component="span" disabled={this.state.disabled}>
              Update logo
            </Button>
          </label>
          <input
            accept="image/*"
            name="upload-file-team-logo"
            id="upload-file-team-logo"
            type="file"
            style={{ display: "none" }}
            onChange={this.uploadFile}
          />
          <p />
          <br />
          <br />
          <h4 style={{ marginRight: 20, display: "inline" }}>
            Team Members ( {Array.from(currentTeam.members.values()).length} / 20 )
          </h4>
          <Button
            onClick={this.openInviteMember}
            variant="contained"
            color="primary"
            style={{ float: "right", marginTop: "-20px" }}
            disabled={this.state.disabled}
          >
            Invite member
          </Button>
          <p />
          <TableContainer>
            <Table>
              <TableHead>
                <TableRow>
                  <TableCell>Person</TableCell>
                  <TableCell>Role</TableCell>
                  <TableCell>Action</TableCell>
                </TableRow>
              </TableHead>

              <TableBody>
                {currentTeam.memberIds
                  .map((userId) => currentTeam.members.get(userId))
                  .map((m) => (
                    <TableRow key={m._id}>
                      <TableCell style={{ width: "300px" }}>
                        <Hidden smDown>
                          <Avatar
                            role="presentation"
                            src={m.avatarUrl}
                            alt={(m.displayName || m.email)[0]}
                            key={m._id}
                            style={{
                              margin: "0px 5px",
                              display: "inline-flex",
                              width: "30px",
                              height: "30px",
                              verticalAlign: "middle",
                            }}
                          />
                        </Hidden>
                        {m.email}
                      </TableCell>
                      <TableCell>{isTeamLeader && m._id !== currentUser._id ? "Team Member" : "Team Leader"}</TableCell>
                      <TableCell>
                        {isTeamLeader && m._id !== currentUser._id ? (
                          <i
                            color="action"
                            data-id={m._id}
                            onClick={this.removeMember}
                            style={{
                              marginLeft: "20px",
                              fontSize: "16px",
                              opacity: 0.6,
                              cursor: "pointer",
                              verticalAlign: "middle",
                            }}
                            className="material-icons"
                          >
                            delete
                          </i>
                        ) : null}
                      </TableCell>
                    </TableRow>
                  ))}
              </TableBody>
            </Table>
          </TableContainer>

          <p />
          <br />

          {Array.from(currentTeam.invitations.values()).length > 0 ? (
            <React.Fragment>
              <h4>Invited users</h4>
              <p />
              <TableContainer>
                <Table>
                  <TableHead>
                    <TableRow>
                      <TableCell>Email</TableCell>
                      <TableCell>Status</TableCell>
                    </TableRow>
                  </TableHead>

                  <TableBody>
                    {Array.from(currentTeam.invitations.values()).map((i) => (
                      <TableRow key={i._id}>
                        <TableCell style={{ width: "300px" }}>{i.email}</TableCell>
                        <TableCell>Sent</TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              </TableContainer>
            </React.Fragment>
          ) : null}
          <p />
          <br />
          <InviteMember
            open={this.state.inviteMemberOpen}
            onClose={this.handleInviteMemberClose}
            store={this.props.store}
          />
          <br />
        </div>
      </Layout>
    );
  }

  private onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    const { newName, newAvatarUrl } = this.state;
    const { currentTeam } = this.props.store;

    if (!newName) {
      notify("Team name is required");
      return;
    }

    NProgress.start();

    try {
      this.setState({ disabled: true });

      await currentTeam.updateTheme({ name: newName, avatarUrl: newAvatarUrl });

      notify("You successfully updated Team name.");
    } catch (error) {
      notify(error);
    } finally {
      this.setState({ disabled: false });
      NProgress.done();
    }
  };

  private uploadFile = async () => {
    const { store } = this.props;
    const { currentTeam } = store;

    const fileElement = document.getElementById("upload-file-team-logo") as HTMLFormElement;
    const file = fileElement.files[0];

    if (file == null) {
      notify("No file selected for upload.");
      return;
    }

    const fileName = file.name;
    const fileType = file.type;

    NProgress.start();
    this.setState({ disabled: true });

    const bucket = process.env.NEXT_PUBLIC_BUCKET_FOR_TEAM_LOGOS;
    const prefix = `${currentTeam.slug}`;

    console.log(bucket);

    try {
      const responseFromApiServerForUpload = await getSignedRequestForUploadApiMethod({
        fileName,
        fileType,
        prefix,
        bucket,
      });

      const resizedFile = await resizeImage(file, 128, 128);

      await uploadFileUsingSignedPutRequestApiMethod(resizedFile, responseFromApiServerForUpload.signedRequest, {
        "Cache-Control": "max-age=2592000",
      });

      this.setState({
        newAvatarUrl: responseFromApiServerForUpload.url,
      });

      await currentTeam.updateTheme({
        name: this.state.newName,
        avatarUrl: this.state.newAvatarUrl,
      });

      notify("You successfully uploaded new Team logo.");
    } catch (error) {
      notify(error);
    } finally {
      this.setState({ disabled: false });
      NProgress.done();
    }
  };

  private openInviteMember = async () => {
    const { currentTeam } = this.props.store;
    if (!currentTeam) {
      notify("You have not selected a Team.");
      return;
    }

    this.setState({ inviteMemberOpen: true });
  };

  private handleInviteMemberClose = () => {
    this.setState({ inviteMemberOpen: false });
  };

  private removeMember = (event) => {
    const { currentTeam } = this.props.store;
    if (!currentTeam) {
      notify("You have not selected a Team.");
      return;
    }

    const userId = event.currentTarget.dataset.id;
    if (!userId) {
      notify("Select user.");
      return;
    }

    confirm({
      title: "Are you sure?",
      message: "",
      onAnswer: async (answer) => {
        if (answer) {
          try {
            await currentTeam.removeMember(userId);
          } catch (error) {
            notify(error);
          }
        }
      },
    });
  };
}

export default withAuth(inject("store")(observer(TeamSettings)));

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\pages\your-settings.tsx -----

import Avatar from "@mui/material/Avatar";
import Button from "@mui/material/Button";
import TextField from "@mui/material/TextField";
import { inject, observer } from "mobx-react";
import Head from "next/head";
import NProgress from "nprogress";
import * as React from "react";

import Layout from "../components/layout";

import { getSignedRequestForUploadApiMethod, uploadFileUsingSignedPutRequestApiMethod } from "../lib/api/team-member";

import notify from "../lib/notify";
import { resizeImage } from "../lib/resizeImage";
import { Store } from "../lib/store";
import withAuth from "../lib/withAuth";

type Props = { isMobile: boolean; store: Store };

type State = { newName: string; newAvatarUrl: string; disabled: boolean };

class YourSettings extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      newName: this.props.store.currentUser.displayName,
      newAvatarUrl: this.props.store.currentUser.avatarUrl,
      disabled: false,
    };
  }

  public render() {
    const { currentUser } = this.props.store;
    const { newName, newAvatarUrl } = this.state;

    return (
      <Layout {...this.props}>
        <Head>
          <title>Your Settings at Async</title>
          <meta name="description" content="description" />
        </Head>
        <div
          style={{
            padding: this.props.isMobile ? "0px" : "0px 30px",
            fontSize: "15px",
            height: "100%",
          }}
        >
          <h3>Your Settings</h3>
          <h4 style={{ marginTop: "40px" }}>Your account</h4>
          <div>
            <i className="material-icons" color="action" style={{ verticalAlign: "text-bottom" }}>
              done
            </i>{" "}
            {currentUser.isSignedupViaGoogle
              ? "You signed up on Async using your Google account."
              : "You signed up on Async using your email."}
            <p />
            <li>
              Your email: <b>{currentUser.email}</b>
            </li>
            <li>
              Your username: <b>{currentUser.displayName}</b>
            </li>
          </div>
          <form onSubmit={this.onSubmit} autoComplete="off">
            <h4>Your username</h4>
            <TextField
              autoComplete="off"
              value={newName}
              helperText="Your username as seen by your team members"
              onChange={(event) => {
                this.setState({ newName: event.target.value });
              }}
            />
            <br />
            <br />
            <Button variant="contained" color="primary" type="submit" disabled={this.state.disabled}>
              Update username
            </Button>
          </form>

          <br />
          <h4>Your photo</h4>
          <Avatar
            src={newAvatarUrl}
            style={{
              display: "inline-flex",
              verticalAlign: "middle",
              marginRight: 20,
              width: 60,
              height: 60,
            }}
          />
          <label htmlFor="upload-file-user-avatar">
            <Button variant="outlined" color="primary" component="span" disabled={this.state.disabled}>
              Update avatar
            </Button>
          </label>
          <input
            accept="image/*"
            name="upload-file-user-avatar"
            id="upload-file-user-avatar"
            type="file"
            style={{ display: "none" }}
            onChange={this.uploadFile}
          />
          <p />
          <br />
        </div>
      </Layout>
    );
  }

  private onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();

    const { currentUser } = this.props.store;

    const { newName, newAvatarUrl } = this.state;

    console.log(newName);

    if (!newName) {
      notify("Name is required");
      return;
    }

    NProgress.start();
    this.setState({ disabled: true });

    try {
      await currentUser.updateProfile({ name: newName, avatarUrl: newAvatarUrl });

      notify("You successfully updated your profile.");
    } catch (error) {
      notify(error);
    } finally {
      this.setState({ disabled: false });
      NProgress.done();
    }
  };

  private uploadFile = async () => {
    const fileElement = document.getElementById("upload-file-user-avatar") as HTMLFormElement;
    const file = fileElement.files[0];

    const { currentUser } = this.props.store;

    if (file == null) {
      notify("No file selected for upload.");
      return;
    }

    const fileName = file.name;
    const fileType = file.type;

    NProgress.start();
    this.setState({ disabled: true });

    const bucket = process.env.NEXT_PUBLIC_BUCKET_FOR_AVATARS;

    const prefix = `${currentUser.slug}`;

    try {
      const responseFromApiServerForUpload = await getSignedRequestForUploadApiMethod({
        fileName,
        fileType,
        prefix,
        bucket,
      });

      const resizedFile = await resizeImage(file, 128, 128);

      console.log(file);
      console.log(resizedFile);

      await uploadFileUsingSignedPutRequestApiMethod(resizedFile, responseFromApiServerForUpload.signedRequest, {
        "Cache-Control": "max-age=2592000",
      });

      this.setState({
        newAvatarUrl: responseFromApiServerForUpload.url,
      });

      await currentUser.updateProfile({
        name: this.state.newName,
        avatarUrl: this.state.newAvatarUrl,
      });

      notify("You successfully uploaded new avatar.");
    } catch (error) {
      notify(error);
    } finally {
      fileElement.value = "";
      this.setState({ disabled: false });
      NProgress.done();
    }
  };
}

export default withAuth(inject("store")(observer(YourSettings)));

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\pages\_app.tsx -----

import CssBaseline from "@mui/material/CssBaseline";
import { ThemeProvider } from "@mui/material/styles";
import { Provider } from "mobx-react";
import App from "next/app";
import Head from "next/head";
import React from "react";

import { themeDark, themeLight } from "../lib/theme";
import { getUserApiMethod } from "../lib/api/public";
import { getInitialDataApiMethod } from "../lib/api/team-member";
import { isMobile } from "../lib/isMobile";
import { getStore, initializeStore, Store } from "../lib/store";

class MyApp extends App {
  public static async getInitialProps({ Component, ctx }) {
    let firstGridItem = true;
    let teamRequired = false;

    if (
      ctx.pathname.includes("/login") ||
      ctx.pathname.includes("/create-team") ||
      ctx.pathname.includes("/invitation")
    ) {
      firstGridItem = false;
    }

    if (
      ctx.pathname.includes("/team-settings") ||
      ctx.pathname.includes("/discussion") ||
      ctx.pathname.includes("/billing")
    ) {
      teamRequired = true;
    }

    const { teamSlug } = ctx.query;

    // console.log(`ctx.query.teamSlug:${teamSlug}`);

    const pageProps = {
      isMobile: isMobile({ req: ctx.req }),
      firstGridItem,
      teamRequired,
      teamSlug,
    };

    if (Component.getInitialProps) {
      Object.assign(pageProps, await Component.getInitialProps(ctx));
    }

    const appProps = { pageProps };

    const store = getStore();
    if (store) {
      return appProps;
    }

    let userObj = null;
    try {
      const { user } = await getUserApiMethod(ctx.req);
      userObj = user;
    } catch (error) {
      console.log(error);
    }

    let initialData = {};

    if (userObj) {
      try {
        initialData = await getInitialDataApiMethod({
          request: ctx.req,
          data: { teamSlug },
        });
      } catch (error) {
        console.error(error);
      }
    }

    // console.log(initialData);

    // console.log(teamSlug);

    return {
      ...appProps,
      initialState: { user: userObj, currentUrl: ctx.asPath, teamSlug, ...initialData },
    };
  }

  public componentDidMount() {
    // Remove the server-side injected CSS.
    const jssStyles = document.querySelector("#jss-server-side");
    if (jssStyles && jssStyles.parentNode) {
      jssStyles.parentNode.removeChild(jssStyles);
    }
  }

  private store: Store;

  constructor(props) {
    super(props);

    console.log("MyApp.constructor");

    this.store = initializeStore(props.initialState);
  }

  public render() {
    const { Component, pageProps } = this.props;
    const store = this.store;

    const isThemeDark = store.currentUser ? store.currentUser.darkTheme : true;

    return (
      <ThemeProvider theme={isThemeDark ? themeDark : themeLight}>
        <Head>
          <meta name="viewport" content="width=device-width, initial-scale=1.0" />
          <link rel="stylesheet" href="https://storage.googleapis.com/async-await/nprogress-dark.min.css?v=1" />
        </Head>
        <CssBaseline />
        <Provider store={store}>
          <Component {...pageProps} store={store} />
        </Provider>
      </ThemeProvider>
    );
  }
}

export default MyApp;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\pages\_document.tsx -----

import Document, { Head, Html, Main, NextScript } from "next/document";
import React from "react";

class MyDocument extends Document {
  public static getInitialProps = async (ctx) => {
    const initialProps = await Document.getInitialProps(ctx);

    return {
      ...initialProps,
    };
  };

  public render() {
    // console.log('rendered on the server');

    return (
      <Html lang="en">
        <Head>
          <meta charSet="utf-8" />
          <meta name="google" content="notranslate" />
          <meta name="theme-color" content="#303030" />

          <link rel="shortcut icon" href="https://storage.googleapis.com/async-await/async-favicon32.png" />

          <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons" />
          <link rel="stylesheet" href="https://storage.googleapis.com/async-await/vs2015.min.css" />

          <style>
            {`
              #__next {
                width: 100%;
                height: 100%;
              }
              a {
                font-weight: 400;
                color: #58a6ff;
                text-decoration: none;
                outline: none;
              }
              hr {
                border: 0.5px #707070 solid;
                color: #000;
              }
              blockquote {
                padding: 0 0.5em;
                margin: 20px 1em;
                border-left: 0.25em solid #dfe2e5;
                color: #000;
              }
              pre {
                display: block;
                overflow-x: auto;
                padding: 0.5em;
                background: #d0d0d0;
                border: 1px solid #ddd;
                font-size: 14px;
                color: #000;
              }
              pre code {
                font-size: 13px;
                background: #d0d0d0;
                padding: 0px;
                color: #000;
              }
              code {
                font-size: 13px;
                background: #d0d0d0;
                padding: 3px 5px;
                color: #000;
              }
              mark {
                background-color: #ffff0060;
              }
              summary:focus {
                outline: none;
              }
              table {
                border-collapse: collapse;
                margin: 15px 0px;
              }
              table, th, td {
                border: 1px solid #a1a1a1;
              }
              th, td {
                line-height: 1.5em;
                padding: 10px;
              }
            `}
          </style>
        </Head>
        <body>
          <Main />
          <NextScript />
        </body>
      </Html>
    );
  }
}

export default MyDocument;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\server\server.ts -----

import express from 'express';
import next from 'next';

const NODE_ENV = process.env.NODE_ENV || 'development';
const IS_DEV = NODE_ENV !== 'production';

const app = next({ dev: IS_DEV });
const handle = app.getRequestHandler();

app.prepare().then(() => {
  const server = express();

  // give all Nextjs's request to Nextjs before anything else
  server.get('/_next/*', (req, res) => {
    // console.log('next server, page');
    handle(req, res);
  });

  server.use(express.json());

  // server.get('/api/v1/public/get-user', (_, res) => {
  //   res.json({ user: { email: 'team@builderbook.org' } });
  // });

  server.get('/team/:teamSlug/team-settings', (req, res) => {
    const { teamSlug } = req.params;
    app.render(req, res, '/team-settings', { teamSlug });
  });

  server.get('/invitation', (req, res) => {
    app.render(req, res, '/invitation', { token: req.query.token as string });
  });

  server.all('*', (req, res) => {
    handle(req, res);
  });

  server.listen(process.env.NEXT_PUBLIC_PORT_APP, () => {
    console.log(`> Ready on ${process.env.NEXT_PUBLIC_URL_APP}`);
  });
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\.eslintrc.js -----

module.exports = {
  settings: {
    react: { version: 'detect' },
  },
  parser: '@typescript-eslint/parser',
  extends: ['plugin:react/recommended', 'plugin:@typescript-eslint/recommended', 'prettier'],
  env: {
    es6: true,
    node: true,
  },
  plugins: ['prettier', 'react'],
  rules: {
    'prettier/prettier': [
      'error',
      {
        singleQuote: true,
        trailingComma: 'all',
        arrowParens: 'always',
        printWidth: 100,
        semi: true,
      },
    ],
    '@typescript-eslint/camelcase': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    'react/no-unescaped-entities': 'off',
    'react/jsx-filename-extension': ['error', { extensions: ['.tsx'] }],
    '@typescript-eslint/no-explicit-any': 'off',
    'prefer-arrow-callback': 'error',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
  },
};

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\next-env.d.ts -----

/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/pages/api-reference/config/typescript for more information.

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\next.config.js -----

module.exports = {
  poweredByHeader: false,
  webpack5: true,
  typescript: {
    ignoreBuildErrors: true,
  },
};

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\nodemon.json -----

{
  "watch": ["server"],
  "exec": "ts-node --project tsconfig.server.json",
  "ext": "ts"
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\package.json -----

{
  "name": "7-end-app",
  "version": "1",
  "license": "MIT",
  "scripts": {
    "dev": "nodemon server/server.ts",
    "build": "next build",
    "lint": "eslint . --ext .ts,.tsx"
  },
  "dependencies": {
    "@emotion/react": "^11.14.0",
    "@emotion/styled": "^11.14.0",
    "@mui/material": "^6.4.8",
    "@mui/system": "^6.4.8",
    "dotenv": "^16.4.7",
    "express": "^4.21.2",
    "isomorphic-unfetch": "^4.0.2",
    "mobx": "5.15.7",
    "mobx-react": "6.3.1",
    "next": "^15.2.3",
    "nprogress": "^0.2.0",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "typescript": "^5.8.2"
  },
  "devDependencies": {
    "@types/express": "^5.0.1",
    "@types/node": "^22.13.11",
    "@types/react": "^19.0.12",
    "@types/react-dom": "^19.0.4",
    "@typescript-eslint/eslint-plugin": "^8.27.0",
    "@typescript-eslint/parser": "^8.27.0",
    "eslint": "^9.22.0",
    "eslint-config-prettier": "^10.1.1",
    "eslint-plugin-prettier": "^5.2.3",
    "eslint-plugin-react": "^7.37.4",
    "nodemon": "^3.1.9",
    "prettier": "^3.5.3",
    "ts-node": "^10.9.2"
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\tsconfig.json -----

{
  "compileOnSave": false,
  "compilerOptions": {
    "target": "esnext",
    "module": "esnext",
    "jsx": "preserve",
    "allowJs": true,
    "alwaysStrict": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "removeComments": true,
    "preserveConstEnums": true,
    "sourceMap": false,
    "skipLibCheck": true,
    "baseUrl": ".",
    "typeRoots": [
      "./node_modules/@types"
    ],
    "lib": [
      "dom",
      "es2017"
    ],
    "strict": false,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "incremental": true
  },
  "include": [
    "next-env.d.ts",
    "./**/*.tsx",
    "./**/*.ts"
  ],
  "exclude": [
    "dist",
    "production-server",
    ".next",
    "out",
    "next.config.js",
    "node_modules"
  ]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\7-end\app\tsconfig.server.json -----

{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "module": "commonjs",
    "outDir": "production-server/",
    "target": "es2017",
    "isolatedModules": false,
    "noEmit": false
  },
  "exclude": ["./server/types.d.ts"],
  "include": ["./server/**/*.ts"],
  "typeRoots": ["./node_modules/@types", "./server/types.d.ts"]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\api\server\api\index.ts -----

import * as express from 'express';

import publicExpressRoutes from './public';
import teamMemberExpressRoutes from './team-member';
import teamLeaderApi from './team-leader';

function handleError(err, _, res, __) {
  console.error(err.stack);

  res.json({ error: err.message || err.toString() });
}

export default function api(server: express.Express) {
  server.use('/api/v1/public', publicExpressRoutes, handleError);
  server.use('/api/v1/team-member', teamMemberExpressRoutes, handleError);
  server.use('/api/v1/team-leader', teamLeaderApi, handleError);
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\api\server\api\public.ts -----

import * as express from 'express';

import User from '../models/User';
import Invitation from '../models/Invitation';

const router = express.Router();

router.get('/get-user', (req, res) => {
  console.log(req.user);
  res.json({ user: req.user || null });
});

router.post('/get-user-by-slug', async (req, res, next) => {
  console.log('Express route: /get-user-by-slug');

  // req.session.foo = 'bar';

  try {
    const { slug } = req.body;

    const user = await User.getUserBySlug({ slug });

    res.json({ user });
  } catch (err) {
    next(err);
  }
});

router.get('/invitations/get-team-by-token', async (req, res, next) => {
  const token = req.query.token as string;

  try {
    const team = await Invitation.getTeamByToken({ token });

    res.json({ team });
  } catch (err) {
    next(err);
  }
});

export default router;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\api\server\api\team-leader.ts -----

import * as express from 'express';

import Invitation from '../models/Invitation';
import Team from '../models/Team';

const router = express.Router();

router.use((req, res, next) => {
  console.log('team leader API', req.path);

  if (!req.user) {
    res.status(401).json({ error: 'Unauthorized' });
    return;
  }

  next();
});

router.post('/teams/add', async (req: any, res, next) => {
  try {
    const { name, avatarUrl } = req.body;

    console.log(`Express route: ${name}, ${avatarUrl}`);

    const team = await Team.addTeam({ userId: req.user.id, name, avatarUrl });

    res.json(team);
  } catch (err) {
    next(err);
  }
});

router.post('/teams/update', async (req: any, res, next) => {
  try {
    const { teamId, name, avatarUrl } = req.body;

    // console.log(req.user.id, typeof req.user.id);
    // console.log(req.user._id, typeof req.user._id);

    const team = await Team.updateTeam({
      userId: req.user.id,
      teamId,
      name,
      avatarUrl,
    });

    res.json(team);
  } catch (err) {
    next(err);
  }
});

router.get('/teams/get-invitations-for-team', async (req: any, res, next) => {
  try {
    const invitations = await Invitation.getTeamInvitations({
      userId: req.user.id,
      teamId: req.query.teamId as string,
    });

    res.json({ invitations });
  } catch (err) {
    next(err);
  }
});

router.post('/teams/invite-member', async (req: any, res, next) => {
  try {
    const { teamId, email } = req.body;

    const newInvitation = await Invitation.add({ userId: req.user.id, teamId, email });

    res.json({ newInvitation });
  } catch (err) {
    next(err);
  }
});

router.post('/teams/remove-member', async (req: any, res, next) => {
  try {
    const { teamId, userId } = req.body;

    await Team.removeMember({ teamLeaderId: req.user.id, teamId, userId });

    res.json({ done: 1 });
  } catch (err) {
    next(err);
  }
});

export default router;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\api\server\api\team-member.ts -----

import * as express from 'express';

import { signRequestForUpload } from '../aws-s3';

import User from '../models/User';
import Team from '../models/Team';
import Invitation from '../models/Invitation';

const router = express.Router();

router.use((req, res, next) => {
  console.log('team member API', req.path);
  if (!req.user) {
    res.status(401).json({ error: 'Unauthorized' });
    return;
  }

  next();
});

// Get signed request from AWS S3 server
router.post('/aws/get-signed-request-for-upload-to-s3', async (req, res, next) => {
  try {
    const { fileName, fileType, prefix, bucket } = req.body;

    const returnData = await signRequestForUpload({
      fileName,
      fileType,
      prefix,
      bucket,
    });

    console.log(bucket);

    res.json(returnData);
  } catch (err) {
    next(err);
  }
});

router.post('/user/update-profile', async (req: any, res, next) => {
  try {
    const { name, avatarUrl } = req.body;

    const updatedUser = await User.updateProfile({
      userId: req.user.id,
      name,
      avatarUrl,
    });

    res.json({ updatedUser });
  } catch (err) {
    next(err);
  }
});

router.post('/user/toggle-theme', async (req: any, res, next) => {
  try {
    const { darkTheme } = req.body;

    await User.toggleTheme({ userId: req.user.id, darkTheme });

    res.json({ done: 1 });
  } catch (err) {
    next(err);
  }
});

async function loadTeamData(team, userId) {
  const initialMembers = await User.getMembersForTeam({
    userId,
    teamId: team._id,
  });

  let initialInvitations = [];
  if (userId === team.teamLeaderId) {
    initialInvitations = await Invitation.getTeamInvitations({
      userId,
      teamId: team._id,
    });
  }

  const data: any = { initialMembers, initialInvitations };

  return data;
}

router.post('/get-initial-data', async (req: any, res, next) => {
  try {
    const teams = await Team.getAllTeamsForUser(req.user.id);

    let selectedTeamSlug = req.body.teamSlug;
    if (!selectedTeamSlug && teams && teams.length > 0) {
      selectedTeamSlug = teams[0].slug;
    }

    for (const team of teams) {
      if (team.slug === selectedTeamSlug) {
        Object.assign(team, await loadTeamData(team, req.user.id));
        break;
      }
    }

    res.json({ teams });
  } catch (err) {
    next(err);
  }
});

router.get('/teams', async (req: any, res, next) => {
  try {
    const teams = await Team.getAllTeamsForUser(req.user.id);

    console.log(teams);

    res.json({ teams });
  } catch (err) {
    next(err);
  }
});

router.get('/teams/get-members', async (req: any, res, next) => {
  try {
    const users = await User.getMembersForTeam({
      userId: req.user.id,
      teamId: req.query.teamId as string,
    });

    res.json({ users });
  } catch (err) {
    next(err);
  }
});

export default router;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\api\server\models\EmailTemplate.ts -----

import * as _ from 'lodash';
import * as mongoose from 'mongoose';

interface EmailTemplateDocument extends mongoose.Document {
  name: string;
  subject: string;
  message: string;
}

const EmailTemplate = mongoose.model<EmailTemplateDocument>(
  'EmailTemplate',
  new mongoose.Schema({
    name: {
      type: String,
      required: true,
      unique: true,
    },
    subject: {
      type: String,
      required: true,
    },
    message: {
      type: String,
      required: true,
    },
  }),
);

export async function insertTemplates() {
  const templates = [
    {
      name: 'welcome',
      subject: 'Welcome to SaaS boilerplate by Async',
      message: `Welcome <%= userName %>,
        <p>
          Thanks for signing up on our <a href="https://github.com/async-labs/saas" target="blank">SaaS boilerplate</a>!
        </p>
        <p>
          If you are learning how to build a SaaS web app, check out our 2 books:
           <a href="https://builderbook.org" target="blank">Builder Book</a>
           and
           <a href="https://builderbook.org/book" target="blank">SaaS Boilerplate</a>.
        </p>
        <p>
          Also check out
          <a href="https://async-await.com" target="blank"> Async</a>
          , our communication tool for small teams of software developers.
        </p>
        Kelly & Timur, Team Async
      `,
    },
    {
      name: 'login',
      subject: 'Login link for saas-app.async-await.com',
      message: `
        <p>Log into your account by clicking on this link: <a href="<%= loginURL %>"><%= loginURL %></a>.</p>`,
    },
    {
      name: 'invitation',
      subject: 'You are invited to join a team at saas-app.async-await.com',
      message: `You've been invited to join <b><%= teamName%></b>.
        <br/>Click here to accept the invitation: <%= invitationURL%>
      `,
    },
    // {
    //   name: 'newPost',
    //   subject: 'New Post was created in Discussion: <%= discussionName %>',
    //   message: `<p>New Post in Discussion: "<%= discussionName%>" by <%= authorName%></p>
    //     New Post: "<%= postContent %>"
    //     <p>---</p>
    //     <p>View it at <a href="<%= discussionLink %>"><%= discussionLink %></a>.</p>
    //   `,
    // },
  ];

  for (const t of templates) {
    const et = await EmailTemplate.findOne({ name: t.name }).setOptions({ lean: true });
    const message = t.message.replace(/\n/g, '').replace(/[ ]+/g, ' ').trim();

    if (!et) {
      EmailTemplate.create(Object.assign({}, t, { message }));
    } else if (et.subject !== t.subject || et.message !== message) {
      EmailTemplate.updateOne({ _id: et._id }, { $set: { message, subject: t.subject } }).exec();
    }
  }
}

export default async function getEmailTemplate(name: string, params: any) {
  await insertTemplates();

  const et = await EmailTemplate.findOne({ name }).setOptions({ lean: true });

  if (!et) {
    throw new Error('Email Template is not found in database.');
  }

  return {
    message: _.template(et.message)(params),
    subject: _.template(et.subject)(params),
  };
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\api\server\models\Invitation.ts -----

import * as mongoose from 'mongoose';

import sendEmail from '../aws-ses';
import getEmailTemplate from './EmailTemplate';
import Team from './Team';
import User, { UserDocument } from './User';

const mongoSchema = new mongoose.Schema({
  teamId: {
    type: String,
    required: true,
  },
  email: {
    type: String,
    required: true,
  },
  createdAt: {
    type: Date,
    required: true,
    default: Date.now,
    expires: 60 * 60 * 24, // delete doc after 24 hours
  },
  token: {
    type: String,
    required: true,
    unique: true,
  },
});

mongoSchema.index({ teamId: 1, email: 1 }, { unique: true });

interface InvitationDocument extends mongoose.Document {
  teamId: string;
  email: string;
  createdAt: Date;
  token: string;
}

interface InvitationModel extends mongoose.Model<InvitationDocument> {
  add({
    userId,
    teamId,
    email,
  }: {
    userId: string;
    teamId: string;
    email: string;
  }): InvitationDocument;

  getTeamInvitations({ userId, teamId }: { userId: string; teamId: string });
  getTeamByToken({ token }: { token: string });
  addUserToTeam({ token, user }: { token: string; user: UserDocument });
}

function generateToken() {
  const gen = () =>
    Math.random().toString(36).substring(2, 12) + Math.random().toString(36).substring(2, 12);

  return `${gen()}`;
}

class InvitationClass extends mongoose.Model {
  public static async add({ userId, teamId, email }) {
    if (!teamId || !email) {
      throw new Error('Bad data');
    }

    const team = await Team.findById(teamId).setOptions({ lean: true });
    if (!team || team.teamLeaderId !== userId) {
      throw new Error('Team does not exist or you have no permission');
    }

    const registeredUser = await User.findOne({ email }).setOptions({ lean: true });

    if (registeredUser && team.memberIds.includes(registeredUser._id.toString())) {
      throw new Error('This user is already Team Member.');
    }

    let token;
    const invitation = await this.findOne({ teamId, email })
      .select('token')
      .setOptions({ lean: true });

    if (invitation) {
      token = invitation.token;
    } else {
      token = generateToken();
      while ((await this.countDocuments({ token })) > 0) {
        token = generateToken();
      }

      await this.create({
        teamId,
        email,
        token,
      });
    }

    const emailTemplate = await getEmailTemplate('invitation', {
      teamName: team.name,
      invitationURL: `${process.env.URL_APP}/invitation?token=${token}`,
    });

    if (!emailTemplate) {
      throw new Error('Invitation email template not found');
    }

    try {
      await sendEmail({
        from: `Kelly from saas-app.async-await.com <${process.env.EMAIL_SUPPORT_FROM_ADDRESS}>`,
        to: [email],
        subject: emailTemplate.subject,
        body: emailTemplate.message,
      });
    } catch (err) {
      console.log('Email sending error:', err);
    }

    return await this.findOne({ teamId, email }).setOptions({ lean: true });
  }

  public static async getTeamInvitations({ userId, teamId }) {
    const team = await Team.findOne({ _id: teamId })
      .select('teamLeaderId')
      .setOptions({ lean: true });

    if (userId !== team.teamLeaderId) {
      throw new Error('You have no permission.');
    }

    return this.find({ teamId }).select('email').setOptions({ lean: true });
  }

  public static async getTeamByToken({ token }) {
    if (!token) {
      throw new Error('Bad data');
    }

    const invitation = await this.findOne({ token }).setOptions({ lean: true });

    if (!invitation) {
      throw new Error('Invitation not found');
    }

    const team = await Team.findById(invitation.teamId)
      .select('name slug avatarUrl memberIds')
      .setOptions({ lean: true });

    if (!team) {
      throw new Error('Team does not exist');
    }

    return team;
  }

  public static async addUserToTeam({ token, user }) {
    if (!token || !user) {
      throw new Error('Bad data');
    }

    const invitation = await this.findOne({ token }).setOptions({ lean: true });

    if (!invitation || invitation.email !== user.email) {
      throw new Error('Invitation not found');
    }

    await this.deleteOne({ token });

    const team = await Team.findById(invitation.teamId)
      .select('memberIds slug teamLeaderId')
      .setOptions({ lean: true });

    if (!team) {
      throw new Error('Team does not exist');
    }

    if (team && !team.memberIds.includes(user._id)) {
      await Team.updateOne({ _id: team._id }, { $addToSet: { memberIds: user._id } });

      if (user._id !== team.teamLeaderId) {
        await User.findByIdAndUpdate(user._id, { $set: { defaultTeamSlug: team.slug } });
      }
    }

    return team.slug;
  }
}

mongoSchema.loadClass(InvitationClass);

const Invitation = mongoose.model<InvitationDocument, InvitationModel>('Invitation', mongoSchema);

export default Invitation;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\api\server\models\Team.ts -----

import * as mongoose from 'mongoose';

import { generateNumberSlug } from '../utils/slugify';
import User from './User';

const mongoSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
  },
  slug: {
    type: String,
    required: true,
    unique: true,
  },
  avatarUrl: String,
  createdAt: {
    type: Date,
    required: true,
  },
  teamLeaderId: {
    type: String,
    required: true,
  },
  memberIds: [
    {
      type: String,
      required: true,
    },
  ],
  defaultTeam: {
    type: Boolean,
    default: false,
  },
});

export interface TeamDocument extends mongoose.Document {
  name: string;
  slug: string;
  avatarUrl: string;
  createdAt: Date;

  teamLeaderId: string;
  memberIds: string[];
  defaultTeam: boolean;
}

interface TeamModel extends mongoose.Model<TeamDocument> {
  addTeam({
    name,
    userId,
  }: {
    userId: string;
    name: string;
    avatarUrl: string;
  }): Promise<TeamDocument>;

  updateTeam({
    userId,
    teamId,
    name,
    avatarUrl,
  }: {
    userId: string;
    teamId: string;
    name: string;
    avatarUrl: string;
  }): Promise<TeamDocument>;

  getAllTeamsForUser(userId: string): Promise<TeamDocument[]>;

  removeMember({
    teamId,
    teamLeaderId,
    userId,
  }: {
    teamId: string;
    teamLeaderId: string;
    userId: string;
  }): Promise<void>;
}

class TeamClass extends mongoose.Model {
  public static async addTeam({ userId, name, avatarUrl }) {
    console.log(`Static method: ${name}, ${avatarUrl}`);

    if (!userId || !name || !avatarUrl) {
      throw new Error('Bad data');
    }

    const slug = await generateNumberSlug(this);

    let defaultTeam = false;
    if ((await this.countDocuments({ teamLeaderId: userId })) === 0) {
      await User.findByIdAndUpdate(userId, { $set: { defaultTeamSlug: slug } });
      defaultTeam = true;
    }

    const team = await this.create({
      teamLeaderId: userId,
      name,
      slug,
      avatarUrl,
      memberIds: [userId],
      createdAt: new Date(),
      defaultTeam,
    });

    return team;
  }

  public static async updateTeam({ userId, teamId, name, avatarUrl }) {
    const team = await this.findById(teamId, 'name teamLeaderId');

    if (!team) {
      throw new Error('Team not found');
    }

    if (team.teamLeaderId !== userId) {
      throw new Error('Permission denied');
    }

    const modifier = { name: team.name, avatarUrl };

    if (name !== team.name) {
      modifier.name = name;
    }

    await this.updateOne({ _id: teamId }, { $set: modifier }, { runValidators: true });

    return this.findById(teamId, 'name avatarUrl slug defaultTeam').setOptions({ lean: true });
  }

  public static getAllTeamsForUser(userId: string) {
    console.log(`userId:${userId}`);
    return this.find({ memberIds: userId }).setOptions({ lean: true });
  }

  public static async removeMember({ teamId, teamLeaderId, userId }) {
    const team = await this.findById(teamId).select('memberIds teamLeaderId');

    if (!team) {
      throw new Error('Team does not exist');
    }

    if (team.teamLeaderId !== teamLeaderId || teamLeaderId === userId) {
      throw new Error('Permission denied');
    }

    await this.findByIdAndUpdate(teamId, { $pull: { memberIds: userId } });
  }
}

mongoSchema.loadClass(TeamClass);

const Team = mongoose.model<TeamDocument, TeamModel>('Team', mongoSchema);

export default Team;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\api\server\models\User.ts -----

import * as _ from 'lodash';
import * as mongoose from 'mongoose';

import sendEmail from '../aws-ses';
import { addToMailchimp } from '../mailchimp';
import { generateSlug } from '../utils/slugify';
import getEmailTemplate from './EmailTemplate';
import Team, { TeamDocument } from './Team';

const mongoSchema = new mongoose.Schema({
  slug: {
    type: String,
    required: true,
    unique: true,
  },
  createdAt: {
    type: Date,
    required: true,
  },
  email: {
    type: String,
    required: true,
    unique: true,
  },
  displayName: String,
  avatarUrl: String,
  googleId: {
    type: String,
    unique: true,
    sparse: true,
  },
  googleToken: {
    accessToken: String,
    refreshToken: String,
  },
  isSignedupViaGoogle: {
    type: Boolean,
    required: true,
    default: false,
  },
  darkTheme: Boolean,
  defaultTeamSlug: {
    type: String,
    default: '',
  },
});

export interface UserDocument extends mongoose.Document {
  slug: string;
  createdAt: Date;
  email: string;
  displayName: string;
  avatarUrl: string;
  googleId: string;
  googleToken: { accessToken: string; refreshToken: string };
  isSignedupViaGoogle: boolean;
  darkTheme: boolean;
  defaultTeamSlug: string;
}

interface UserModel extends mongoose.Model<UserDocument> {
  getUserBySlug({ slug }: { slug: string }): Promise<UserDocument>;

  updateProfile({
    userId,
    name,
    avatarUrl,
  }: {
    userId: string;
    name: string;
    avatarUrl: string;
  }): Promise<UserDocument[]>;

  publicFields(): string[];

  signInOrSignUpViaGoogle({
    googleId,
    email,
    displayName,
    avatarUrl,
    googleToken,
  }: {
    googleId: string;
    email: string;
    displayName: string;
    avatarUrl: string;
    googleToken: { accessToken?: string; refreshToken?: string };
  }): Promise<UserDocument>;

  signInOrSignUpByPasswordless({
    uid,
    email,
  }: {
    uid: string;
    email: string;
  }): Promise<UserDocument>;

  toggleTheme({ userId, darkTheme }: { userId: string; darkTheme: boolean }): Promise<void>;

  getMembersForTeam({
    userId,
    teamId,
  }: {
    userId: string;
    teamId: string;
  }): Promise<UserDocument[]>;

  checkPermissionAndGetTeam({
    userId,
    teamId,
  }: {
    userId: string;
    teamId: string;
  }): Promise<TeamDocument[]>;
}

class UserClass extends mongoose.Model {
  public static async getUserBySlug({ slug }) {
    console.log('Static method: getUserBySlug');

    return this.findOne({ slug }, 'email displayName avatarUrl').setOptions({ lean: true });
  }

  public static async updateProfile({ userId, name, avatarUrl }) {
    console.log('Static method: updateProfile');

    const user = await this.findById(userId, 'slug displayName');

    const modifier = { displayName: user.displayName, avatarUrl, slug: user.slug };

    console.log(user.slug);

    if (name !== user.displayName) {
      modifier.displayName = name;
      modifier.slug = await generateSlug(this, name);
    }

    return this.findByIdAndUpdate(userId, { $set: modifier }, { new: true, runValidators: true })
      .select('displayName avatarUrl slug')
      .setOptions({ lean: true });
  }

  public static publicFields(): string[] {
    return [
      '_id',
      'id',
      'displayName',
      'email',
      'avatarUrl',
      'slug',
      'isSignedupViaGoogle',
      'darkTheme',
      'defaultTeamSlug',
    ];
  }

  public static async signInOrSignUpViaGoogle({
    googleId,
    email,
    displayName,
    avatarUrl,
    googleToken,
  }) {
    const user = await this.findOne({ email })
      .select([...this.publicFields(), 'googleId'].join(' '))
      .setOptions({ lean: true });

    if (user) {
      if (_.isEmpty(googleToken) && user.googleId) {
        return user;
      }

      const modifier = { googleId };
      if (googleToken.accessToken) {
        modifier['googleToken.accessToken'] = googleToken.accessToken;
      }

      if (googleToken.refreshToken) {
        modifier['googleToken.refreshToken'] = googleToken.refreshToken;
      }

      await this.updateOne({ email }, { $set: modifier });

      return user;
    }

    const slug = await generateSlug(this, displayName);

    const newUser = await this.create({
      createdAt: new Date(),
      googleId,
      email,
      googleToken,
      displayName,
      avatarUrl,
      slug,
      isSignedupViaGoogle: true,
      defaultTeamSlug: '',
      darkTheme: false,
    });

    const emailTemplate = await getEmailTemplate('welcome', { userName: displayName });

    if (!emailTemplate) {
      throw new Error('Welcome email template not found');
    }

    try {
      await sendEmail({
        from: `Kelly from saas-app.async-await.com <${process.env.EMAIL_SUPPORT_FROM_ADDRESS}>`,
        to: [email],
        subject: emailTemplate.subject,
        body: emailTemplate.message,
      });
    } catch (err) {
      console.error('Email sending error:', err);
    }

    try {
      await addToMailchimp({ email, listName: 'signups' });
    } catch (error) {
      console.error('Mailchimp error:', error);
    }

    return _.pick(newUser, this.publicFields());
  }

  public static async signInOrSignUpByPasswordless({ uid, email }) {
    const user = await this.findOne({ email })
      .select(this.publicFields().join(' '))
      .setOptions({ lean: true });

    if (user) {
      throw Error('User already exists');
    }

    const slug = await generateSlug(this, email);

    const newUser = await this.create({
      _id: uid,
      createdAt: new Date(),
      email,
      slug,
      defaultTeamSlug: '',
    });

    const emailTemplate = await getEmailTemplate('welcome', { userName: email });

    if (!emailTemplate) {
      throw new Error('Email template "welcome" not found in database.');
    }

    try {
      await sendEmail({
        from: `Kelly from saas-app.async-await.com <${process.env.EMAIL_SUPPORT_FROM_ADDRESS}>`,
        to: [email],
        subject: emailTemplate.subject,
        body: emailTemplate.message,
      });
    } catch (err) {
      console.error('Email sending error:', err);
    }

    try {
      await addToMailchimp({ email, listName: 'signups' });
    } catch (error) {
      console.error('Mailchimp error:', error);
    }

    return _.pick(newUser, this.publicFields());
  }

  public static toggleTheme({ userId, darkTheme }) {
    return this.updateOne({ _id: userId }, { darkTheme: !!darkTheme });
  }

  public static async getMembersForTeam({ userId, teamId }) {
    const team = await this.checkPermissionAndGetTeam({ userId, teamId });

    return this.find({ _id: { $in: team.memberIds } })
      .select(this.publicFields().join(' '))
      .setOptions({ lean: true });
  }

  private static async checkPermissionAndGetTeam({ userId, teamId }) {
    console.log(userId, teamId);

    if (!userId || !teamId) {
      throw new Error('Bad data');
    }

    const team = await Team.findById(teamId).select('memberIds').setOptions({ lean: true });

    if (!team || team.memberIds.indexOf(userId) === -1) {
      throw new Error('Team not found');
    }

    return team;
  }
}

mongoSchema.loadClass(UserClass);

const User = mongoose.model<UserDocument, UserModel>('User', mongoSchema);

export default User;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\api\server\utils\slugify.ts -----

import * as _ from 'lodash';

const slugify = (text) => _.kebabCase(text);

async function createUniqueSlug(Model, slug, count, filter) {
  const obj = await Model.findOne({ slug: `${slug}-${count}`, ...filter })
    .select('_id')
    .setOptions({ lean: true });

  if (!obj) {
    return `${slug}-${count}`;
  }

  return createUniqueSlug(Model, slug, count + 1, filter);
}

async function generateSlug(Model, name, filter = {}) {
  const origSlug = slugify(name);

  const obj = await Model.findOne({ slug: origSlug, ...filter })
    .select('_id')
    .setOptions({ lean: true });

  if (!obj) {
    return origSlug;
  }

  return createUniqueSlug(Model, origSlug, 1, filter);
}

async function generateNumberSlug(Model, filter = {}, n = 1) {
  const obj = await Model.findOne({ slug: n, ...filter })
    .select('_id')
    .setOptions({ lean: true });

  if (!obj) {
    return `${n}`;
  }

  return generateNumberSlug(Model, filter, ++n);
}

export { generateSlug, generateNumberSlug };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\api\server\utils\sum.ts -----

function sum(a, b) {
  return a + b;
}

export { sum };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\api\server\aws-s3.ts -----

import * as url from 'url';
import * as aws from 'aws-sdk';

async function signRequestForUpload({ fileName, fileType, prefix, bucket }) {
  const randomStringForPrefix =
    Math.random().toString(36).substring(2, 12) + Math.random().toString(36).substring(2, 12);

  const key = `${prefix}/${randomStringForPrefix}/${fileName}`;

  const acl = 'public-read';

  const params = {
    Bucket: bucket,
    Key: key,
    Expires: 60,
    ContentType: fileType,
    ACL: acl,
  };

  console.log(key, bucket);

  const s3 = new aws.S3({
    apiVersion: 'latest',
    region: process.env.AWS_REGION,
    accessKeyId: process.env.AWS_ACCESSKEYID,
    secretAccessKey: process.env.AWS_SECRETACCESSKEY,
  });

  return new Promise((resolve, reject) => {
    s3.getSignedUrl('putObject', params, (err, data) => {
      const parsedUrl = url.parse(data);

      const returnData = {
        signedRequest: data,
        url: `${parsedUrl.protocol}//${parsedUrl.hostname}${parsedUrl.pathname}`,
      };

      console.log(returnData);

      if (err) {
        console.error(err);
        reject(err);
      } else {
        resolve(returnData);
      }
    });
  });
}

export { signRequestForUpload };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\api\server\aws-ses.ts -----

import * as aws from 'aws-sdk';

export default function sendEmail(options) {
  const ses = new aws.SES({
    apiVersion: 'latest',
    region: process.env.AWS_REGION,
    accessKeyId: process.env.AWS_ACCESSKEYID,
    secretAccessKey: process.env.AWS_SECRETACCESSKEY,
  });

  return new Promise((resolve, reject) => {
    ses.sendEmail(
      {
        Source: options.from,
        Destination: {
          CcAddresses: options.cc,
          ToAddresses: options.to,
        },
        Message: {
          Subject: {
            Data: options.subject,
          },
          Body: {
            Html: {
              Data: options.body,
            },
          },
        },
        ReplyToAddresses: options.replyTo,
      },
      (err, info) => {
        if (err) {
          reject(err);
        } else {
          resolve(info);
        }
      },
    );
  });
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\api\server\google-auth.ts -----

import * as passport from 'passport';
import { OAuth2Strategy as Strategy } from 'passport-google-oauth';

import User, { UserDocument } from './models/User';
import Invitation from './models/Invitation';

function setupGoogle({ server }) {
  if (!process.env.GOOGLE_CLIENTID) {
    return;
  }

  const verify = async (req, accessToken, refreshToken, profile, done) => {
    let email;
    let avatarUrl;

    if (profile.emails) {
      email = profile.emails[0].value;
    }

    if (profile.photos && profile.photos.length > 0) {
      avatarUrl = profile.photos[0].value.replace('sz=50', 'sz=128');
    }

    try {
      const user = await User.signInOrSignUpViaGoogle({
        googleId: profile.id,
        email,
        googleToken: { accessToken, refreshToken },
        displayName: profile.displayName,
        avatarUrl,
      });

      let teamSlugOfInvitedTeam;
      if (user && req.session.invitationToken) {
        teamSlugOfInvitedTeam = await Invitation.addUserToTeam({
          token: req.session.invitationToken,
          user,
        }).catch((err) => console.error(err));
      }

      user.defaultTeamSlug = teamSlugOfInvitedTeam ? teamSlugOfInvitedTeam : user.defaultTeamSlug;

      done(null, user);
    } catch (err) {
      done(err);
      console.error(err);
    }
  };

  passport.use(
    new Strategy(
      {
        clientID: process.env.GOOGLE_CLIENTID,
        clientSecret: process.env.GOOGLE_CLIENTSECRET,
        callbackURL: `${process.env.URL_API}/oauth2callback`,
        passReqToCallback: true,
      },
      verify,
    ),
  );

  passport.serializeUser((user: UserDocument, done) => {
    done(null, user._id);
  });

  passport.deserializeUser((id, done) => {
    User.findById(id, User.publicFields())
      .then((user) => {
        done(null, user);
      })
      .catch((error) => {
        done(error, null);
      });
  });

  server.use(passport.initialize());
  server.use(passport.session());

  server.get('/auth/google', (req, res, next) => {
    const options = {
      scope: ['profile', 'email'],
      prompt: 'select_account',
    };

    if (req.query && req.query.invitationToken) {
      req.session.invitationToken = req.query.invitationToken;
    } else {
      req.session.invitationToken = null;
    }

    passport.authenticate('google', options)(req, res, next);
  });

  server.get(
    '/oauth2callback',
    passport.authenticate('google', {
      failureRedirect: '/login',
    }),
    async (req, res) => {
      let teamSlugOfInvitedTeam;

      if (req.user && req.session.invitationToken) {
        teamSlugOfInvitedTeam = await Invitation.addUserToTeam({
          token: req.session.invitationToken,
          user: req.user,
        }).catch((err) => console.error(err));

        req.session.invitationToken = null;
      }

      let redirectUrlAfterLogin;
      const defaultTeamSlug = req.user && req.user.defaultTeamSlug;

      if (teamSlugOfInvitedTeam || defaultTeamSlug) {
        redirectUrlAfterLogin = `/your-settings`;
      } else {
        redirectUrlAfterLogin = `/create-team`;
      }

      res.redirect(`${process.env.URL_APP}${redirectUrlAfterLogin}`);
    },
  );
}

export { setupGoogle };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\api\server\mailchimp.ts -----

import fetch, { Response } from 'node-fetch';

// eslint-disable-next-line
require('dotenv').config();

const LIST_IDS = {
  signups: process.env.MAILCHIMP_SAAS_ALL_LIST_ID,
};

function callAPI({ path, method, data }): Promise<Response> {
  const ROOT_URI = `https://${process.env.MAILCHIMP_REGION}.api.mailchimp.com/3.0`;

  return fetch(`${ROOT_URI}${path}`, {
    method,
    headers: {
      Accept: 'application/json',
      Authorization: `Basic ${Buffer.from(`apikey:${process.env.MAILCHIMP_API_KEY}`).toString(
        'base64',
      )}`,
    },
    body: JSON.stringify(data),
  });
}

async function addToMailchimp({ email, listName }) {
  const data = {
    // eslint-disable-next-line
    email_address: email,
    status: 'subscribed',
  };

  const path = `/lists/${LIST_IDS[listName]}/members/`;

  await callAPI({ path, method: 'POST', data });
}

export { addToMailchimp };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\api\server\passwordless-auth.ts -----

import * as passwordless from 'passwordless';

import sendEmail from './aws-ses';
import getEmailTemplate from './models/EmailTemplate';
import User from './models/User';
import PasswordlessMongoStore from './passwordless-token-mongostore';
import Invitation from './models/Invitation';

function setupPasswordless({ server }) {
  const mongoStore = new PasswordlessMongoStore();

  passwordless.addDelivery(async (tokenToSend, uidToSend, recipient, callback) => {
    try {
      const template = await getEmailTemplate('login', {
        loginURL: `${
          process.env.URL_API
        }/auth/logged_in?token=${tokenToSend}&uid=${encodeURIComponent(uidToSend)}`,
      });

      await sendEmail({
        from: `Kelly from saas-app.async-await.com <${process.env.EMAIL_SUPPORT_FROM_ADDRESS}>`,
        to: [recipient],
        subject: template.subject,
        body: template.message,
      });

      callback();
    } catch (err) {
      console.error('Email sending error:', err);
      callback(err);
    }
  });

  passwordless.init(mongoStore);
  server.use(passwordless.sessionSupport());

  server.use((req, __, next) => {
    if (req.user && typeof req.user === 'string') {
      User.findById(req.user, User.publicFields())
        .then((user) => {
          req.user = user;
          console.log('passwordless middleware');
          next();
        })
        .catch((err) => {
          next(err);
        });
    } else {
      next();
    }
  });

  server.post(
    '/auth/email-login-link',
    passwordless.requestToken(async (email, __, callback) => {
      try {
        const user = await User.findOne({ email }).select('_id').setOptions({ lean: true });

        if (user) {
          callback(null, user._id);
        } else {
          const id = await mongoStore.storeOrUpdateByEmail(email);
          callback(null, id);
        }
      } catch (error) {
        callback(error, null);
      }
    }),
    (req, res) => {
      if (req.query && req.query.invitationToken) {
        req.session.invitationToken = req.query.invitationToken;
      } else {
        req.session.invitationToken = null;
      }

      res.json({ done: 1 });
    },
  );

  server.get(
    '/auth/logged_in',
    passwordless.acceptToken(),
    (req, __, next) => {
      if (req.user && typeof req.user === 'string') {
        User.findById(req.user, User.publicFields())
          .then((user) => {
            req.user = user;
            next();
          })
          .catch((err) => {
            next(err);
          });
      } else {
        next();
      }
    },
    async (req, res) => {
      let teamSlugOfInvitedTeam;

      if (req.user && req.session.invitationToken) {
        teamSlugOfInvitedTeam = await Invitation.addUserToTeam({
          token: req.session.invitationToken,
          user: req.user,
        }).catch((err) => console.error(err));

        req.session.invitationToken = null;
      }

      let redirectUrlAfterLogin;
      const defaultTeamSlug = req.user && req.user.defaultTeamSlug;

      if (teamSlugOfInvitedTeam || defaultTeamSlug) {
        redirectUrlAfterLogin = `/your-settings`;
      } else {
        redirectUrlAfterLogin = `/create-team`;
      }

      res.redirect(`${process.env.URL_APP}${redirectUrlAfterLogin}`);
    },
  );

  server.get('/logout', (req, res, next) => {
    req.logout((err) => {
      if (err) {
        next(err);
      }

      if (req.query && req.query.invitationToken) {
        res.redirect(`${process.env.URL_APP}/invitation?token=${req.query.invitationToken}`);
      } else {
        res.redirect(`${process.env.URL_APP}/login`);
      }
    });
  });
}

export { setupPasswordless };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\api\server\passwordless-token-mongostore.ts -----

import * as bcrypt from 'bcrypt';
import * as mongoose from 'mongoose';
import * as TokenStore from 'passwordless-tokenstore';
import * as util from 'util';

import User from './models/User';

interface TokenDocument extends mongoose.Document {
  hashedToken: string;
  uid: string;
  ttl: Date;
  originUrl: string;
  email: string;
}

const mongoSchema = new mongoose.Schema({
  hashedToken: {
    type: String,
    required: true,
  },
  uid: {
    type: String,
    required: true,
    unique: true,
  },
  ttl: {
    type: Date,
    required: true,
    expires: 0,
  },
  originUrl: String,
  email: String,
});

const PasswordlessToken = mongoose.model<TokenDocument>(
  'PasswordlessToken',
  mongoSchema,
  'passwordless-token',
);

function MongoStore(options = {}) {
  TokenStore.call(this);

  this._options = options || {};
}

util.inherits(MongoStore, TokenStore);

MongoStore.prototype.authenticate = async function (token, uid, callback) {
  if (!token || !uid || !callback) {
    throw new Error('TokenStore:authenticate called with invalid parameters');
  }

  try {
    const tokenDoc = await PasswordlessToken.findOne({ uid, ttl: { $gt: new Date() } }).setOptions({
      lean: true,
    });

    if (tokenDoc) {
      const isMatch = await bcrypt.compare(token, tokenDoc.hashedToken);
      if (isMatch) {
        if (tokenDoc.email) {
          await User.signInOrSignUpByPasswordless({ uid, email: tokenDoc.email });
        }

        callback(null, true, tokenDoc.originUrl);
      } else {
        callback(null, false, null);
      }
    } else {
      callback(null, false, null);
    }
  } catch (error) {
    callback(error, false, null);
  }
};

MongoStore.prototype.storeOrUpdate = async function (token, uid, msToLive, originUrl, callback) {
  if (!token || !uid || !msToLive || !callback) {
    throw new Error('TokenStore:storeOrUpdate called with invalid parameters');
  }

  const saltRounds = 10;

  try {
    const hashedToken = await bcrypt.hash(token, saltRounds);
    const newRecord = { hashedToken, uid, ttl: new Date(Date.now() + msToLive), originUrl };

    await PasswordlessToken.updateOne(
      { uid },
      { $set: newRecord },
      { upsert: true, runValidators: true },
    );
    callback();
  } catch (error) {
    callback(error);
  }
};

MongoStore.prototype.invalidateUser = async function (uid, callback) {
  if (!uid || !callback) {
    throw new Error('TokenStore:invalidateUser called with invalid parameters');
  }

  try {
    await PasswordlessToken.deleteOne({ uid });
    callback();
  } catch (error) {
    callback(error);
  }
};

MongoStore.prototype.clear = async function (callback) {
  if (!callback) {
    throw new Error('TokenStore:clear called with invalid parameters');
  }

  try {
    await PasswordlessToken.deleteMany({});
    callback();
  } catch (error) {
    callback(error);
  }
};

MongoStore.prototype.length = function (callback) {
  PasswordlessToken.countDocuments(callback);
};

MongoStore.prototype.storeOrUpdateByEmail = async function addEmail(email: string) {
  if (!email) {
    throw new Error('TokenStore:addEmail called with invalid parameters');
  }

  const obj = await PasswordlessToken.findOne({ email }).select('uid').setOptions({ lean: true });

  if (obj) {
    return obj.uid;
  }

  const uid = new mongoose.Types.ObjectId().toHexString();
  await PasswordlessToken.updateOne({ uid }, { email }, { upsert: true });

  return uid;
};

export default MongoStore;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\api\server\server.ts -----

// eslint-disable-next-line @typescript-eslint/no-var-requires
const MongoStore = require('connect-mongo');

import * as cors from 'cors';
import * as express from 'express';
import * as session from 'express-session';
import * as mongoose from 'mongoose';

import api from './api';
import { setupGoogle } from './google-auth';
import { setupPasswordless } from './passwordless-auth';

// eslint-disable-next-line
require('dotenv').config();

mongoose.connect(process.env.MONGO_URL_TEST);

const server = express();

server.use(
  cors({
    origin: process.env.URL_APP,
    methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',
    credentials: true,
  }),
);

server.use(express.json());

const sessionOptions = {
  name: process.env.SESSION_NAME,
  secret: process.env.SESSION_SECRET,
  resave: false,
  saveUninitialized: false,
  store: MongoStore.create({
    mongoUrl: process.env.MONGO_URL_TEST,
    ttl: 14 * 24 * 60 * 60, // save session 14 days
    autoRemove: 'interval',
    autoRemoveInterval: 1440, // clears every day
  }),
  cookie: {
    httpOnly: true,
    maxAge: 14 * 24 * 60 * 60 * 1000, // expires in 14 days
    secure: false,
  },
};

const sessionMiddleware = session(sessionOptions);
server.use(sessionMiddleware);

setupGoogle({ server });
setupPasswordless({ server });

api(server);

server.get('*', (_, res) => {
  res.sendStatus(403);
});

server.listen(process.env.PORT_API, () => {
  console.log(`> Ready on ${process.env.URL_API}`);
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\api\test\server\utils\slugify.test.ts -----

import * as mongoose from 'mongoose';
import User from '../../../server/models/User';
import { generateSlug } from '../../../server/utils/slugify';

// eslint-disable-next-line
require('dotenv').config();

describe('slugify', () => {
  beforeAll(async () => {
    await mongoose.connect(process.env.MONGO_URL_TEST);

    const mockUsers = [
      {
        slug: 'john',
        email: 'john@example.com',
        createdAt: new Date(),
        displayName: 'abc',
        avatarUrl: 'def',
      },
      {
        slug: 'john-johnson',
        email: 'john-johnson@example.com',
        createdAt: new Date(),
        displayName: 'abc',
        avatarUrl: 'def',
      },
      {
        slug: 'john-johnson-1',
        email: 'john-johnson-1@example.com',
        createdAt: new Date(),
        displayName: 'abc',
        avatarUrl: 'def',
      },
    ];

    await User.insertMany(mockUsers);
  });

  test('not duplicated', async () => {
    expect.assertions(1);

    await expect(generateSlug(User, 'John J Johnson@#$')).resolves.toEqual('john-j-johnson');
  });

  test('one time duplicated', async () => {
    expect.assertions(1);

    await expect(generateSlug(User, ' John@#$')).resolves.toEqual('john-1');
  });

  test('multiple duplicated', async () => {
    expect.assertions(1);

    await expect(generateSlug(User, 'John & Johnson@#$')).resolves.toEqual('john-johnson-2');
  });

  afterAll(async () => {
    await User.deleteMany({ slug: { $in: ['john', 'john-johnson', 'john-johnson-1'] } });
    await mongoose.disconnect();
  });
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\api\test\server\utils\sum.test.ts -----

import { sum } from '../../../server/utils/sum';

console.log(sum(1, 2));

describe.skip('testing sum function', () => {
  test('adds 1 + 2 to equal 3', () => {
    expect(sum(1, 2)).toBe(3);
  });
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\api\.eslintrc.js -----

module.exports = {
  parser: "@typescript-eslint/parser",
  extends: ["plugin:@typescript-eslint/recommended", "prettier"],
  env: {
    "es6": true,
    "node": true,
  },
  plugins: ["prettier"],
  rules: {
    'prettier/prettier': [
      'error',
      {
        singleQuote: true,
        trailingComma: 'all',
        arrowParens: 'always',
        printWidth: 100,
        semi: true,
      },
    ],
    '@typescript-eslint/no-unused-vars': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/no-explicit-any': 'off',
    'prefer-arrow-callback': 'error',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
 },
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\api\nodemon.json -----

{
  "watch": ["server"],
  "exec": "ts-node --project tsconfig.server.json",
  "ext": "ts"
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\api\package.json -----

{
  "name": "8-begin-api",
  "version": "1",
  "license": "MIT",
  "scripts": {
    "dev": "nodemon server/server.ts",
    "lint": "eslint . --ext .ts,.tsx",
    "test": "jest"
  },
  "jest": {
    "preset": "ts-jest",
    "testPathIgnorePatterns": [
      "production-server"
    ],
    "testEnvironment": "node"
  },
  "dependencies": {
    "aws-sdk": "^2.1692.0",
    "bcrypt": "^5.1.1",
    "connect-mongo": "^5.1.0",
    "cors": "^2.8.5",
    "dotenv": "^16.4.7",
    "express": "^4.21.2",
    "express-session": "^1.18.1",
    "lodash": "^4.17.21",
    "mongoose": "^8.12.1",
    "node-fetch": "2",
    "passport": "^0.7.0",
    "passport-google-oauth": "^2.0.0",
    "passwordless": "^1.1.3",
    "passwordless-tokenstore": "^0.0.10",
    "typescript": "^5.8.2"
  },
  "devDependencies": {
    "@types/connect-mongo": "^3.1.6",
    "@types/dotenv": "^8.2.3",
    "@types/express": "^5.0.1",
    "@types/express-session": "^1.18.1",
    "@types/jest": "^29.5.14",
    "@types/lodash": "^4.17.16",
    "@types/mongoose": "^5.11.97",
    "@types/node": "^22.13.10",
    "@types/node-fetch": "^2.6.12",
    "@types/passport": "^1.0.17",
    "@typescript-eslint/eslint-plugin": "^8.27.0",
    "@typescript-eslint/parser": "^8.27.0",
    "eslint": "^9.22.0",
    "eslint-config-prettier": "^10.1.1",
    "eslint-plugin-prettier": "^5.2.3",
    "jest": "^29.7.0",
    "nodemon": "^3.1.9",
    "prettier": "^3.5.3",
    "ts-jest": "^29.2.6",
    "ts-node": "^10.9.2"
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\api\tsconfig.json -----

{
  "compileOnSave": false,
  "compilerOptions": {
    "jsx": "preserve",
    "allowJs": true,
    "alwaysStrict": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "removeComments": false,
    "preserveConstEnums": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "sourceMap": true,
    "skipLibCheck": true,
    "baseUrl": ".",
    "experimentalDecorators": true,
    "typeRoots": ["./node_modules/@types"],
    "lib": ["es2015", "es2016"]
  },
  "exclude": ["production-server", "node_modules"]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\api\tsconfig.server.json -----

{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "module": "commonjs",
    "outDir": "production-server/"
  },
  "include": ["./server/**/*.ts"],
  "exclude": ["./server/**/*.test.ts"]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\components\common\Confirmer.tsx -----

import Button from "@mui/material/Button";
import Dialog from "@mui/material/Dialog";
import DialogActions from "@mui/material/DialogActions";
import DialogContent from "@mui/material/DialogContent";
import DialogContentText from "@mui/material/DialogContentText";
import DialogTitle from "@mui/material/DialogTitle";
import React from "react";

export let openConfirmDialogExternal;

type State = {
  open: boolean;
  title: string;
  message: string;
  onAnswer: (answer) => void;
};

class Confirmer extends React.Component<any, State> {
  constructor(props) {
    super(props);

    this.state = {
      open: false,
      title: "Are you sure?",
      message: "",
      onAnswer: null,
    };

    openConfirmDialogExternal = this.openConfirmDialog;
  }

  public render() {
    return (
      <Dialog
        open={this.state.open}
        onClose={this.handleClose}
        aria-labelledby="alert-dialog-title"
        aria-describedby="alert-dialog-description"
      >
        <DialogTitle id="alert-dialog-title">{this.state.title}</DialogTitle>
        <DialogContent>
          <DialogContentText id="alert-dialog-description">{this.state.message}</DialogContentText>
        </DialogContent>
        <DialogActions style={{ padding: "10px" }}>
          <Button onClick={this.handleClose} variant="contained" color="primary" autoFocus>
            Cancel
          </Button>
          <Button onClick={this.handleYes} variant="contained" color="secondary">
            OK
          </Button>
        </DialogActions>
      </Dialog>
    );
  }

  public handleClose = () => {
    this.setState({ open: false });
    this.state.onAnswer(false);
  };

  public handleYes = () => {
    this.setState({ open: false });
    this.state.onAnswer(true);
  };

  public openConfirmDialog = ({ title, message, onAnswer }) => {
    this.setState({ open: true, title, message, onAnswer });
  };
}

export default Confirmer;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\components\common\Loading.tsx -----

import React from 'react';

const Loading = ({ text }: { text: string }) => {
  const IS_DEV = process.env.NODE_ENV !== 'production';

  if (IS_DEV) {
    return <p style={{ height: '1.0em' }} />;
  }

  return <p style={{ height: '1.0em' }}>{text}</p>;
};

export default Loading;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\components\common\LoginButton.tsx -----

import Button from "@mui/material/Button";
import TextField from "@mui/material/TextField";
import React from "react";

import { emailLoginLinkApiMethod } from "../../lib/api/public";
import notify from "../../lib/notify";
import { makeQueryString } from "../../lib/api/makeQueryString";

type Props = { invitationToken?: string };
type State = { email: string };

class LoginButton extends React.PureComponent<Props, State> {
  constructor(props) {
    super(props);

    this.state = { email: "" };
  }

  public render() {
    const { invitationToken } = this.props;

    let url = `${process.env.NEXT_PUBLIC_URL_API}/auth/google`;
    const qs = makeQueryString({ invitationToken });

    if (qs) {
      url += `?${qs}`;
    }

    // console.log(url);

    return (
      <React.Fragment>
        <Button variant="contained" color="secondary" href={url}>
          <img src="https://storage.googleapis.com/async-await-all/G.svg" alt="Log in with Google" />
          &nbsp;&nbsp;&nbsp; Log in with Google
        </Button>
        <p />
        <br />
        <hr style={{ width: "60px" }} /> <h4>OR</h4> <hr style={{ width: "60px" }} />
        <p />
        <br />
        <div>
          <form autoComplete="off" onSubmit={this.onSubmit}>
            <TextField
              required
              type="email"
              label="Email address"
              value={this.state.email}
              onChange={(event) => {
                this.setState({ email: event.target.value });
              }}
              style={{ width: "300px" }}
            />
            <p />
            <Button variant="contained" color="primary" type="submit">
              Log in with email
            </Button>
          </form>
          <p />
          <br />
        </div>
      </React.Fragment>
    );
  }

  private onSubmit = async (event) => {
    event.preventDefault();
    const { email } = this.state;
    const { invitationToken } = this.props;

    if (!email) {
      notify("Email is required");
    }

    try {
      await emailLoginLinkApiMethod({ email, invitationToken });
      this.setState({ email: "" });
      notify("SaaS boilerplate emailed you a login link.");
    } catch (error) {
      notify(error);
    }
  };
}

export default LoginButton;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\components\common\MenuWithLinks.tsx -----

import Menu from "@mui/material/Menu";
import MenuItem from "@mui/material/MenuItem";
import Link from "next/link";
import { NextRouter, withRouter } from "next/router";
import React from "react";

type Props = {
  options: {
    href: string;
    as: string;
    highlighterSlug: string;
    text: string;
    externalServer: boolean;
    separator: boolean;
  }[];
  router: NextRouter;
  children: any;
};

type State = {
  anchorEl: Element | ((element: Element) => Element);
};

class MenuWithLinks extends React.PureComponent<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      anchorEl: null,
    };
  }

  public render() {
    const { options, children, router } = this.props;
    const { anchorEl } = this.state;

    return (
      <div style={{ textAlign: "center" }}>
        <div
          aria-controls={anchorEl ? "simple-menu" : null}
          aria-haspopup="true"
          onClick={this.handleClick}
          onKeyPress={this.handleClick}
        >
          {children}
        </div>
        <Menu id="simple-menu" anchorEl={anchorEl} open={Boolean(anchorEl)} onClose={this.handleClose} keepMounted>
          {options.map((option, i) =>
            option.separator ? (
              <hr style={{ width: "95%", margin: "10px auto" }} key={`separated-${i}`} />
            ) : option.externalServer ? (
              <MenuItem
                onClick={(event) => {
                  event.preventDefault();
                  window.location.href = option.href;
                  this.handleClose();
                }}
                key={option.href || option.text}
              >
                {option.text}
              </MenuItem>
            ) : (
              <Link key={option.href} href={option.href} as={option.as} passHref>
                <MenuItem
                  key={option.href}
                  style={{
                    fontWeight: router.asPath.includes(option.highlighterSlug) ? 600 : 300,
                    fontSize: "14px",
                  }}
                >
                  {option.text}
                </MenuItem>
              </Link>
            )
          )}
        </Menu>
      </div>
    );
  }

  public handleClick = (event) => {
    this.setState({ anchorEl: event.currentTarget });
  };

  public handleClose = () => {
    this.setState({ anchorEl: null });
  };
}

export default withRouter(MenuWithLinks);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\components\common\Notifier.tsx -----

import Snackbar from "@mui/material/Snackbar";
import React from "react";

export let openSnackbarExternal;

type State = {
  open: boolean;
  message: string;
};

class Notifier extends React.PureComponent<any, State> {
  constructor(props) {
    super(props);
    openSnackbarExternal = this.openSnackbar;

    this.state = {
      open: false,
      message: "",
    };
  }

  public render() {
    const message = <span id="snackbar-message-id" dangerouslySetInnerHTML={{ __html: this.state.message }} />;

    return (
      <Snackbar
        anchorOrigin={{ vertical: "top", horizontal: "right" }}
        message={message}
        autoHideDuration={5000}
        onClose={this.handleSnackbarClose}
        open={this.state.open}
        ContentProps={{
          "aria-describedby": "snackbar-message-id",
        }}
      />
    );
  }

  public handleSnackbarClose = () => {
    this.setState({
      open: false,
      message: "",
    });
  };

  public openSnackbar = ({ message }) => {
    this.setState({ open: true, message });
  };
}

export default Notifier;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\components\layout\index.tsx -----

import Avatar from "@mui/material/Avatar";
import Button from "@mui/material/Button";
import Grid from "@mui/material/Grid";

import Link from "next/link";
import React from "react";

import MenuWithLinks from "../common/MenuWithLinks";
import Confirmer from "../common/Confirmer";
import Notifier from "../common/Notifier";

import { Store } from "../../lib/store";

const styleGrid = {
  width: "100%",
  height: "100vh",
  maxWidth: "100%",
  padding: "0px 10px",
  display: "flex",
  overflow: "hidden",
};

const styleGridIsMobile = {
  width: "100%",
  height: "100vh",
  maxWidth: "100%",
  padding: "0px 0px 0px 10px",
  display: "flex",
  overflow: "hidden",
};

function LayoutWrapper({
  children,
  isMobile,
  firstGridItem,
  store,
}: {
  children: React.ReactNode;
  isMobile: boolean;
  firstGridItem: boolean;
  store: Store;
}) {
  const isThemeDark = store.currentUser ? store.currentUser.darkTheme : true;

  return (
    <React.Fragment>
      <Grid
        container
        direction="row"
        justify="flex-start"
        alignItems="stretch"
        style={isMobile ? styleGridIsMobile : styleGrid}
      >
        {firstGridItem ? (
          <Grid
            item
            sm={2}
            xs={12}
            style={{
              borderRight: "1px #707070 solid",
              justifyContent: "center",
              overflow: "hidden",
            }}
          >
            <div style={{ display: "flex", justifyContent: "space-between" }}>
              <svg
                xmlns="http://www.w3.org/2000/svg"
                width="124"
                height="40"
                viewBox="0 0 124 40"
                style={{
                  marginTop: "20px",
                  display: "inline-flex",
                  height: "40px",
                }}
              >
                <g id="async-logo">
                  <g id="async-logo-40">
                    <circle id="Ellipse 2" cx="20" cy="20" r="20" fill="black" />
                    <path
                      id="path-async-logo"
                      d="M7.07825 -0.0960007V16H4.51825V13.088C4.04892 14.0907 3.33425 14.8693 2.37425 15.424C1.43558 15.9573 0.336917 16.224 -0.92175 16.224C-2.35108 16.224 -3.60975 15.8827 -4.69775 15.2C-5.76442 14.5173 -6.59642 13.5573 -7.19375 12.32C-7.76975 11.0613 -8.05775 9.6 -8.05775 7.936C-8.05775 6.272 -7.75908 4.81067 -7.16175 3.552C-6.56442 2.272 -5.73242 1.28 -4.66575 0.576C-3.57775 -0.128 -2.32975 -0.48 -0.92175 -0.48C0.336917 -0.48 1.43558 -0.202666 2.37425 0.352C3.31292 0.906667 4.02758 1.68533 4.51825 2.688V-0.0960007H7.07825ZM-0.40975 14.08C1.16892 14.08 2.38492 13.5467 3.23825 12.48C4.09158 11.392 4.51825 9.856 4.51825 7.872C4.51825 5.888 4.09158 4.36267 3.23825 3.296C2.38492 2.22933 1.16892 1.696 -0.40975 1.696C-1.98842 1.696 -3.22575 2.25067 -4.12175 3.36C-4.99642 4.448 -5.43375 5.97333 -5.43375 7.936C-5.43375 9.89867 -4.99642 11.4133 -4.12175 12.48C-3.24708 13.5467 -2.00975 14.08 -0.40975 14.08Z"
                      transform="translate(19.5938 12)"
                      fill="white"
                    />
                  </g>
                  <path
                    id="path-async-text"
                    d="M22.6251 11.928V24H20.7051V21.816C20.3531 22.568 19.8171 23.152 19.0971 23.568C18.3931 23.968 17.5691 24.168 16.6251 24.168C15.5531 24.168 14.6091 23.912 13.7931 23.4C12.9931 22.888 12.3691 22.168 11.9211 21.24C11.4891 20.296 11.2731 19.2 11.2731 17.952C11.2731 16.704 11.4971 15.608 11.9451 14.664C12.3931 13.704 13.0171 12.96 13.8171 12.432C14.6331 11.904 15.5691 11.64 16.6251 11.64C17.5691 11.64 18.3931 11.848 19.0971 12.264C19.8011 12.68 20.3371 13.264 20.7051 14.016V11.928H22.6251ZM17.0091 22.56C18.1931 22.56 19.1051 22.16 19.7451 21.36C20.3851 20.544 20.7051 19.392 20.7051 17.904C20.7051 16.416 20.3851 15.272 19.7451 14.472C19.1051 13.672 18.1931 13.272 17.0091 13.272C15.8251 13.272 14.8971 13.688 14.2251 14.52C13.5691 15.336 13.2411 16.48 13.2411 17.952C13.2411 19.424 13.5691 20.56 14.2251 21.36C14.8811 22.16 15.8091 22.56 17.0091 22.56ZM30.4637 24.168C28.4317 24.168 26.8237 23.648 25.6397 22.608L26.2877 21.168C26.9437 21.68 27.6077 22.048 28.2797 22.272C28.9517 22.496 29.7037 22.608 30.5357 22.608C31.4477 22.608 32.1357 22.456 32.5997 22.152C33.0797 21.832 33.3197 21.376 33.3197 20.784C33.3197 20.304 33.1597 19.92 32.8397 19.632C32.5197 19.344 31.9917 19.12 31.2557 18.96L29.2157 18.48C28.2077 18.256 27.4237 17.856 26.8637 17.28C26.3197 16.704 26.0477 16.016 26.0477 15.216C26.0477 14.16 26.4717 13.304 27.3197 12.648C28.1677 11.976 29.2877 11.64 30.6797 11.64C31.5277 11.64 32.3277 11.776 33.0797 12.048C33.8317 12.32 34.4637 12.712 34.9757 13.224L34.3277 14.64C33.1917 13.696 31.9757 13.224 30.6797 13.224C29.8157 13.224 29.1437 13.392 28.6637 13.728C28.1997 14.048 27.9677 14.504 27.9677 15.096C27.9677 15.592 28.1117 15.984 28.3997 16.272C28.7037 16.56 29.1837 16.784 29.8397 16.944L31.8797 17.448C32.9997 17.704 33.8317 18.104 34.3757 18.648C34.9197 19.176 35.1917 19.872 35.1917 20.736C35.1917 21.776 34.7677 22.608 33.9197 23.232C33.0717 23.856 31.9197 24.168 30.4637 24.168ZM48.687 11.928L43.047 25.104C42.455 26.48 41.711 27.488 40.815 28.128C39.919 28.768 38.815 29.208 37.503 29.448L37.095 27.936C38.231 27.68 39.087 27.336 39.663 26.904C40.255 26.488 40.743 25.84 41.127 24.96L41.607 23.88L36.495 11.928H38.535L42.615 21.888L46.743 11.928H48.687ZM56.853 11.64C59.749 11.64 61.197 13.232 61.197 16.416V24H59.253V16.512C59.253 15.392 59.029 14.576 58.581 14.064C58.133 13.536 57.429 13.272 56.469 13.272C55.349 13.272 54.453 13.616 53.781 14.304C53.109 14.992 52.773 15.92 52.773 17.088V24H50.829V15.312C50.829 14.064 50.765 12.936 50.637 11.928H52.485L52.677 14.088C53.045 13.304 53.597 12.704 54.333 12.288C55.069 11.856 55.909 11.64 56.853 11.64ZM69.9321 24.168C68.7641 24.168 67.7401 23.912 66.8601 23.4C65.9961 22.888 65.3241 22.168 64.8441 21.24C64.3801 20.296 64.1481 19.2 64.1481 17.952C64.1481 16.704 64.3881 15.608 64.8681 14.664C65.3481 13.704 66.0281 12.96 66.9081 12.432C67.8041 11.904 68.8441 11.64 70.0281 11.64C70.8441 11.64 71.6281 11.784 72.3801 12.072C73.1481 12.344 73.7801 12.728 74.2761 13.224L73.6281 14.664C73.0201 14.184 72.4281 13.832 71.8521 13.608C71.2921 13.384 70.7161 13.272 70.1241 13.272C68.8921 13.272 67.9241 13.688 67.2201 14.52C66.5161 15.336 66.1641 16.48 66.1641 17.952C66.1641 19.408 66.5081 20.544 67.1961 21.36C67.9001 22.16 68.8761 22.56 70.1241 22.56C70.7161 22.56 71.2921 22.448 71.8521 22.224C72.4281 22 73.0201 21.648 73.6281 21.168L74.2761 22.608C73.7641 23.088 73.1161 23.472 72.3321 23.76C71.5641 24.032 70.7641 24.168 69.9321 24.168Z"
                    transform="translate(39 4)"
                    fill={isThemeDark ? "white" : "black"}
                  />
                </g>
              </svg>
              <MenuWithLinks
                options={[
                  {
                    text: "Team Settings",
                    href: `/team-settings?teamSlug=${store.currentTeam.slug}`,
                    as: `/team/${store.currentTeam.slug}/team-settings`,
                    simple: true,
                  },
                  {
                    text: "Billing",
                    href: `/billing?teamSlug=${store.currentTeam.slug}`,
                    as: `/team/${store.currentTeam.slug}/billing`,
                    simple: true,
                  },
                  {
                    text: "Your Settings",
                    href: "/your-settings",
                    highlighterSlug: "/your-settings",
                  },
                  {
                    separator: true,
                  },
                  {
                    text: "Log out",
                    href: `${process.env.NEXT_PUBLIC_URL_API}/logout`,
                    as: `${process.env.NEXT_PUBLIC_URL_API}/logout`,
                    externalServer: true,
                  },
                ]}
              >
                <Avatar
                  src={store.currentUser.avatarUrl}
                  alt="Add username here later in the book"
                  style={{
                    margin: "20px auto",
                    cursor: "pointer",
                    display: "inline-flex",
                    width: "40px",
                    height: "40px",
                  }}
                />

                <i className="material-icons" color="action" style={{ verticalAlign: "super" }}>
                  arrow_drop_down
                </i>
              </MenuWithLinks>
            </div>
            <hr />
            <p />
            <p />
          </Grid>
        ) : null}

        {children}
      </Grid>
      <Notifier />
      <Confirmer />
    </React.Fragment>
  );
}

type Props = {
  children: React.ReactNode;
  isMobile?: boolean;
  firstGridItem?: boolean;
  store?: Store;
  teamRequired?: boolean;
};

class Layout extends React.Component<Props> {
  public render() {
    const { children, isMobile, firstGridItem, store, teamRequired } = this.props;

    const { currentUser, currentTeam } = store;

    // console.log(this.props.store.currentUser.darkTheme);

    // const isThemeDark = false;

    // console.log(isMobile);

    // console.log(currentTeam);

    if (!currentUser) {
      return (
        <LayoutWrapper firstGridItem={firstGridItem} isMobile={isMobile} store={store}>
          <Grid item sm={12} xs={12}>
            {children}
          </Grid>
        </LayoutWrapper>
      );
    }

    if (!currentTeam) {
      if (teamRequired) {
        return (
          <LayoutWrapper firstGridItem={firstGridItem} isMobile={isMobile} store={store}>
            <Grid item sm={10} xs={12} style={{ padding: "0px 35px", overflow: "auto", height: "auto" }}>
              <div style={{ padding: "20px" }}>
                Select existing team or create a new team.
                <p />
                <Link href="/create-team" as="/create-team">
                  <Button variant="outlined" color="primary">
                    Create new team
                  </Button>
                </Link>
              </div>
            </Grid>
          </LayoutWrapper>
        );
      } else {
        console.log("team not required");
        return (
          <LayoutWrapper firstGridItem={firstGridItem} isMobile={isMobile} store={store}>
            <Grid item sm={10} xs={12} style={{ padding: "0px 35px", overflow: "auto", height: "auto" }}>
              {children}
            </Grid>
          </LayoutWrapper>
        );
      }
    }

    return (
      <LayoutWrapper firstGridItem={firstGridItem} isMobile={isMobile} store={store}>
        <Grid
          item
          sm={firstGridItem ? 10 : 12}
          xs={12}
          style={{ padding: "0px 35px", overflowY: "auto", height: "inherit" }}
        >
          <div>
            {isMobile || store.currentUrl.includes("create-team") ? null : (
              <React.Fragment>
                <i
                  style={{
                    float: "left",
                    margin: "15px 0px 10px 25px",
                    opacity: 0.8,
                    fontSize: "18px",
                    cursor: "pointer",
                    verticalAlign: "top",
                  }}
                  className="material-icons"
                  onClick={async () => {
                    await store.currentUser.toggleTheme(!store.currentUser.darkTheme);
                  }}
                >
                  lens
                </i>
              </React.Fragment>
            )}
            <div style={{ clear: "both" }} />
          </div>
          {children}
        </Grid>
      </LayoutWrapper>
    );
  }
}

export default Layout;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\components\teams\InviteMember.tsx -----

import Button from "@mui/material/Button";
import Dialog from "@mui/material/Dialog";
import DialogContent from "@mui/material/DialogContent";
import DialogTitle from "@mui/material/DialogTitle";
import TextField from "@mui/material/TextField";
import { inject, observer } from "mobx-react";
import NProgress from "nprogress";
import React from "react";

import notify from "../../lib/notify";
import { Store } from "../../lib/store";

type Props = {
  store: Store;
  onClose: () => void;
  open: boolean;
};

type State = {
  email: string;
  disabled: boolean;
};

class InviteMember extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      email: "",
      disabled: false,
    };
  }

  public render() {
    const { open } = this.props;

    return (
      <Dialog onClose={this.handleClose} aria-labelledby="invite-member-dialog-title" open={open}>
        <DialogTitle id="invite-member-dialog-title">Invite member</DialogTitle>
        <DialogContent>
          <form onSubmit={this.onSubmit} style={{ padding: "20px" }}>
            <TextField
              autoComplete="off"
              value={this.state.email}
              placeholder="Email"
              onChange={(event) => {
                this.setState({ email: event.target.value });
              }}
            />
            <p />
            <br />
            <Button variant="outlined" onClick={this.handleClose} disabled={this.state.disabled}>
              Cancel
            </Button>{" "}
            <Button type="submit" variant="contained" color="primary" disabled={this.state.disabled}>
              Invite
            </Button>
          </form>
        </DialogContent>
      </Dialog>
    );
  }

  private handleClose = () => {
    this.setState({ email: "", disabled: false });
    this.props.onClose();
  };

  private onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();

    const { store } = this.props;

    if (!store.currentTeam) {
      notify("Team have not selected");
      return;
    }

    const { email } = this.state;

    if (!email) {
      notify("Email is required");
      return;
    }

    NProgress.start();
    try {
      this.setState({ disabled: true });
      await store.currentTeam.inviteMember(email);

      this.setState({ email: "" });
      notify("You successfully sent invitation.");
      NProgress.done();
    } catch (error) {
      console.log(error);
      notify(error);
    } finally {
      this.props.onClose();
      this.setState({ disabled: false });
      NProgress.done();
    }
  };
}

export default inject("store")(observer(InviteMember));

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\lib\api\makeQueryString.ts -----

function makeQueryString(params) {
  const query = Object.keys(params)
    .filter((k) => !!params[k])
    .map((k) => `${encodeURIComponent(k)}=${encodeURIComponent(params[k])}`)
    .join('&');

  return query;
}

export { makeQueryString };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\lib\api\public.ts -----

import sendRequestAndGetResponse from './sendRequestAndGetResponse';

const BASE_PATH = '/api/v1/public';

export const getUserApiMethod = (request) =>
  sendRequestAndGetResponse(`${BASE_PATH}/get-user`, {
    request,
    method: 'GET',
  });

export const getUserBySlugApiMethod = (slug) =>
  sendRequestAndGetResponse(`${BASE_PATH}/get-user-by-slug`, {
    body: JSON.stringify({ slug }),
  });

export const emailLoginLinkApiMethod = ({
  email,
  invitationToken,
}: {
  email: string;
  invitationToken?: string;
}) =>
  sendRequestAndGetResponse('/auth/email-login-link', {
    qs: { invitationToken },
    body: JSON.stringify({ user: email }),
  });

export const getTeamByTokenApiMethod = (token: string, request) =>
  sendRequestAndGetResponse(`${BASE_PATH}/invitations/get-team-by-token`, {
    request,
    method: 'GET',
    qs: { token },
  });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\lib\api\sendRequestAndGetResponse.ts -----

import 'isomorphic-unfetch';

import { makeQueryString } from './makeQueryString';

export default async function sendRequestAndGetResponse(path, opts: any = {}) {
  const headers = Object.assign(
    {},
    opts.headers || {},
    opts.externalServer
      ? {}
      : {
          'Content-type': 'application/json; charset=UTF-8',
        },
  );

  const { request } = opts;

  if (request && request.headers && request.headers.cookie) {
    headers.cookie = request.headers.cookie;
  }

  // const qs = opts.qs || '';

  const qs = (opts.qs && `?${makeQueryString(opts.qs)}`) || '';

  // console.log(`before: ${process.env.NEXT_PUBLIC_URL_API}${path}${qs}`);

  const response = await fetch(
    opts.externalServer ? `${path}${qs}` : `${process.env.NEXT_PUBLIC_URL_API}${path}${qs}`,
    Object.assign({ method: 'POST', credentials: 'include' }, opts, { headers }),
  );

  // console.log(`after: ${process.env.NEXT_PUBLIC_URL_API}${path}${qs}`);

  // console.log(response.status);
  // console.log(response.statusText);

  const text = await response.text();

  if (response.status >= 400) {
    console.error(text);
    throw new Error(response.status.toString());
  }

  try {
    const data = JSON.parse(text);

    return data;
  } catch (err) {
    if (err instanceof SyntaxError) {
      return text;
    }

    throw err;
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\lib\api\team-leader.ts -----

import sendRequestAndGetResponse from './sendRequestAndGetResponse';

const BASE_PATH = '/api/v1/team-leader';

export const addTeamApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams/add`, {
    body: JSON.stringify(data),
  });

export const updateTeamApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams/update`, {
    body: JSON.stringify(data),
  });

export const getTeamInvitationsApiMethod = (teamId: string) =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams/get-invitations-for-team`, {
    method: 'GET',
    qs: { teamId },
  });

export const inviteMemberApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams/invite-member`, {
    body: JSON.stringify(data),
  });

export const removeMemberApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams/remove-member`, {
    body: JSON.stringify(data),
  });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\lib\api\team-member.ts -----

import sendRequestAndGetResponse from './sendRequestAndGetResponse';

const BASE_PATH = '/api/v1/team-member';

export const getSignedRequestForUploadApiMethod = ({ fileName, fileType, prefix, bucket }) =>
  sendRequestAndGetResponse(`${BASE_PATH}/aws/get-signed-request-for-upload-to-s3`, {
    body: JSON.stringify({ fileName, fileType, prefix, bucket }),
  });

export const uploadFileUsingSignedPutRequestApiMethod = (file, signedRequest, headers = {}) =>
  sendRequestAndGetResponse(signedRequest, {
    externalServer: true,
    method: 'PUT',
    body: file,
    headers,
  });

export const updateProfileApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/user/update-profile`, {
    body: JSON.stringify(data),
  });

export const toggleThemeApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/user/toggle-theme`, {
    body: JSON.stringify(data),
  });

export const getInitialDataApiMethod = (options: any = {}) =>
  sendRequestAndGetResponse(
    `${BASE_PATH}/get-initial-data`,
    Object.assign(
      {
        body: JSON.stringify(options.data || {}),
      },
      options,
    ),
  );

export const getTeamListApiMethod = () =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams`, {
    method: 'GET',
  });

export const getTeamMembersApiMethod = (teamId: string) =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams/get-members`, {
    method: 'GET',
    qs: { teamId },
  });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\lib\store\index.ts -----

import * as mobx from 'mobx';
import { action, decorate, observable } from 'mobx';
import { useStaticRendering } from 'mobx-react';

import { addTeamApiMethod, getTeamInvitationsApiMethod } from '../api/team-leader';
import { getTeamListApiMethod, getTeamMembersApiMethod } from '../api/team-member';

import { User } from './user';
import { Team } from './team';

useStaticRendering(typeof window === 'undefined');

mobx.configure({ enforceActions: 'observed' });

class Store {
  public isServer: boolean;

  public currentUser?: User = null;
  public currentUrl = '';

  public currentTeam?: Team;

  constructor({ initialState = {}, isServer }: { initialState?: any; isServer: boolean }) {
    this.isServer = !!isServer;

    this.setCurrentUser(initialState.user);

    this.currentUrl = initialState.currentUrl || '';

    // console.log(initialState.user);

    if (initialState.teamSlug || (initialState.user && initialState.user.defaultTeamSlug)) {
      this.setCurrentTeam(
        initialState.teamSlug || initialState.user.defaultTeamSlug,
        initialState.teams,
      );
    }
  }

  public changeCurrentUrl(url: string) {
    this.currentUrl = url;
  }

  public async setCurrentUser(user) {
    if (user) {
      this.currentUser = new User({ store: this, ...user });
    } else {
      this.currentUser = null;
    }
  }

  public async addTeam({ name, avatarUrl }: { name: string; avatarUrl: string }): Promise<Team> {
    const data = await addTeamApiMethod({ name, avatarUrl });
    const team = new Team({ store: this, ...data });

    return team;
  }

  public async setCurrentTeam(slug: string, initialTeams: any[]) {
    if (this.currentTeam) {
      if (this.currentTeam.slug === slug) {
        return;
      }
    }

    let found = false;

    const teams = initialTeams || (await getTeamListApiMethod()).teams;

    for (const team of teams) {
      if (team.slug === slug) {
        found = true;
        this.currentTeam = new Team({ ...team, store: this });

        const users =
          team.initialMembers || (await getTeamMembersApiMethod(this.currentTeam._id)).users;

        const invitations =
          team.initialInvitations ||
          (await getTeamInvitationsApiMethod(this.currentTeam._id)).invitations;

        this.currentTeam.setInitialMembersAndInvitations(users, invitations);

        break;
      }
    }

    if (!found) {
      this.currentTeam = null;
    }
  }
}

decorate(Store, {
  currentUser: observable,
  currentUrl: observable,
  currentTeam: observable,

  changeCurrentUrl: action,
  setCurrentUser: action,
  setCurrentTeam: action,
});

let store: Store = null;

function initializeStore(initialState = {}) {
  const isServer = typeof window === 'undefined';

  const _store =
    store !== null && store !== undefined ? store : new Store({ initialState, isServer });

  // For SSG and SSR always create a new store
  if (typeof window === 'undefined') {
    return _store;
  }
  // Create the store once in the client
  if (!store) {
    store = _store;
  }

  // console.log(_store);

  return _store;
}

function getStore() {
  return store;
}

export { Store, initializeStore, getStore };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\lib\store\invitation.ts -----

class Invitation {
  public _id: string;
  public teamId: string;
  public email: string;
  public createdAt: Date;

  constructor(params) {
    Object.assign(this, params);
  }
}

export { Invitation };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\lib\store\team.ts -----

import { action, decorate, IObservableArray, observable, runInAction } from 'mobx';
import {
  inviteMemberApiMethod,
  removeMemberApiMethod,
  updateTeamApiMethod,
} from '../api/team-leader';
import { Store } from './index';
import { User } from './user';
import { Invitation } from './invitation';

class Team {
  public store: Store;

  public _id: string;
  public teamLeaderId: string;

  public name: string;
  public slug: string;
  public avatarUrl: string;
  public memberIds: IObservableArray<string> = observable([]);
  public members: Map<string, User> = new Map();
  public invitations: Map<string, Invitation> = new Map();

  // public initialDiscussionSlug = '';

  constructor(params) {
    this._id = params._id;
    this.teamLeaderId = params.teamLeaderId;
    this.slug = params.slug;
    this.name = params.name;
    this.avatarUrl = params.avatarUrl;
    this.memberIds.replace(params.memberIds || []);

    this.store = params.store;

    if (params.initialMembers) {
      this.setInitialMembersAndInvitations(params.initialMembers, params.initialInvitations);
    }
  }

  public setInitialMembersAndInvitations(users, invitations) {
    this.members.clear();
    this.invitations.clear();

    for (const user of users) {
      if (this.store.currentUser && this.store.currentUser._id === user._id) {
        this.members.set(user._id, this.store.currentUser);
      } else {
        this.members.set(user._id, new User(user));
      }
    }

    for (const invitation of invitations) {
      this.invitations.set(invitation._id, new Invitation(invitation));
    }
  }

  public async updateTheme({ name, avatarUrl }: { name: string; avatarUrl: string }) {
    try {
      const { slug } = await updateTeamApiMethod({
        teamId: this._id,
        name,
        avatarUrl,
      });

      runInAction(() => {
        this.name = name;
        this.avatarUrl = avatarUrl;
        this.slug = slug;
      });
    } catch (error) {
      console.error(error);
      throw error;
    }
  }

  public async inviteMember(email: string) {
    try {
      const { newInvitation } = await inviteMemberApiMethod({ teamId: this._id, email });

      runInAction(() => {
        this.invitations.set(newInvitation._id, new Invitation(newInvitation));
      });
    } catch (error) {
      console.error(error);
      throw error;
    }
  }

  public async removeMember(userId: string) {
    try {
      await removeMemberApiMethod({ teamId: this._id, userId });

      runInAction(() => {
        this.members.delete(userId);
        this.memberIds.remove(userId);
      });
    } catch (error) {
      console.error(error);
      throw error;
    }
  }
}

decorate(Team, {
  name: observable,
  slug: observable,
  avatarUrl: observable,
  memberIds: observable,
  members: observable,
  invitations: observable,

  setInitialMembersAndInvitations: action,
  updateTheme: action,
  inviteMember: action,
  removeMember: action,
});

export { Team };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\lib\store\user.ts -----

import { action, decorate, observable, runInAction } from 'mobx';

import * as NProgress from 'nprogress';

import { toggleThemeApiMethod, updateProfileApiMethod } from '../api/team-member';
import { Store } from './index';

class User {
  public store: Store;

  public _id: string;
  public slug: string;
  public email: string | null;
  public displayName: string | null;
  public avatarUrl: string | null;
  public isSignedupViaGoogle: boolean;

  public darkTheme = false;
  public defaultTeamSlug: string;

  constructor(params) {
    this.store = params.store;
    this._id = params._id;
    this.slug = params.slug;
    this.email = params.email;
    this.displayName = params.displayName;
    this.avatarUrl = params.avatarUrl;
    this.isSignedupViaGoogle = !!params.isSignedupViaGoogle;
    this.darkTheme = !!params.darkTheme;
    this.defaultTeamSlug = params.defaultTeamSlug;
  }

  public async updateProfile({ name, avatarUrl }: { name: string; avatarUrl: string }) {
    const { updatedUser } = await updateProfileApiMethod({
      name,
      avatarUrl,
    });

    runInAction(() => {
      this.displayName = updatedUser.displayName;
      this.avatarUrl = updatedUser.avatarUrl;
      this.slug = updatedUser.slug;
    });
  }

  public async toggleTheme(darkTheme: boolean) {
    await toggleThemeApiMethod({ darkTheme });
    runInAction(() => {
      this.darkTheme = darkTheme;
    });
    NProgress.start();
    NProgress.set(0.5);
    window.location.reload();
  }
}

decorate(User, {
  slug: observable,
  email: observable,
  displayName: observable,
  avatarUrl: observable,
  // darkTheme: observable,
  defaultTeamSlug: observable,

  updateProfile: action,
  toggleTheme: action,
});

export { User };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\lib\confirm.ts -----

import { openConfirmDialogExternal } from '../components/common/Confirmer';

export default function confirm({
  title,
  message,
  onAnswer,
}: {
  title: string;
  message: string;
  onAnswer: (answer) => void;
}) {
  openConfirmDialogExternal({ title, message, onAnswer });
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\lib\isMobile.ts -----

const mobileRE = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i;

export function isMobile(opts) {
  if (!opts) {
    opts = {};
  }

  let ua = opts.ua;

  if (!ua && typeof navigator !== 'undefined') {
    ua = navigator.userAgent;
  }

  if (!ua && opts.req && opts.req.headers && typeof opts.req.headers['user-agent'] === 'string') {
    ua = opts.req.headers['user-agent'];
    // console.log(ua);
  }

  if (typeof ua !== 'string') {
    return false;
  }

  return mobileRE.test(ua);
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\lib\notify.ts -----

import { openSnackbarExternal } from '../components/common/Notifier';

export default function notify(obj) {
  openSnackbarExternal({ message: obj.message || obj.toString() });
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\lib\resizeImage.ts -----

function resizeImage(file: File, MAX_WIDTH, MAX_HEIGHT) {
  const image = document.createElement('img');

  const resize = (resolve) => () => {
    let isResizeNeeded = false;
    let width = image.width;
    let height = image.height;

    if (width > height) {
      if (width > MAX_WIDTH) {
        isResizeNeeded = true;
        height *= MAX_WIDTH / width;
        width = MAX_WIDTH;
      }
    } else {
      if (height > MAX_HEIGHT) {
        isResizeNeeded = true;
        width *= MAX_HEIGHT / height;
        height = MAX_HEIGHT;
      }
    }

    if (isResizeNeeded) {
      const canvas = document.createElement('canvas');

      canvas.width = width;
      canvas.height = height;

      console.log(width, height);

      const ctx = canvas.getContext('2d');
      ctx.drawImage(image, 0, 0, width, height);

      canvas.toBlob((blob) => {
        resolve(blob);
      }, file.type);
    } else {
      resolve(file);
    }
  };

  return new Promise((resolve) => {
    const reader = new FileReader();

    console.log(`before ${image.src}`);

    reader.readAsDataURL(file);

    reader.onload = (e) => {
      image.src = e.target.result.toString();

      image.onload = resize(resolve);

      console.log(`after ${image.src}`);
    };
  });
}

export { resizeImage };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\lib\sharedStyles.ts -----

const styleBigAvatar = {
  width: '80px',
  height: '80px',
  margin: '0px auto 15px',
};

const styleRaisedButton = {
  margin: '15px',
  font: '14px Roboto',
};

const styleToolbar = {
  background: '#FFF',
  height: '64px',
  paddingRight: '20px',
};

const styleTextField = {
  font: '15px Roboto',
  color: '#222',
  fontWeight: '300',
};

const styleForm = {
  margin: '7% auto',
  width: '360px',
};

export { styleBigAvatar, styleRaisedButton, styleToolbar, styleTextField, styleForm };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\lib\theme.ts -----

import { createTheme } from "@mui/material/styles";

const themeDark = createTheme({
  palette: {
    primary: { main: "#238636" },
    secondary: { main: "#b62324" },
    type: "dark",
    background: { default: "#0d1117" },
    text: {
      primary: "#c9d1d9",
    },
  },
  typography: {
    button: {
      textTransform: "none",
    },
  },
});

const themeLight = createTheme({
  palette: {
    primary: { main: "#238636" },
    secondary: { main: "#b62324" },
    type: "light",
    background: { default: "#fff" },
    text: {
      primary: "#222",
    },
  },
  typography: {
    button: {
      textTransform: "none",
    },
  },
});

export { themeDark, themeLight };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\lib\withAuth.tsx -----

import { observer } from 'mobx-react';
import Router from 'next/router';
import React from 'react';

import * as NProgress from 'nprogress';

import { Store } from './store';

Router.events.on('routeChangeStart', () => {
  NProgress.start();
});

Router.events.on('routeChangeComplete', () => {
  NProgress.done();
});

Router.events.on('routeChangeError', () => NProgress.done());

export default function withAuth(Component, { loginRequired = true, logoutRequired = false } = {}) {
  class WithAuth extends React.Component<{ store: Store }> {
    public static async getInitialProps(ctx) {
      console.log('WithAuth.getInitialProps');

      const { req } = ctx;

      let pageComponentProps = {};

      if (Component.getInitialProps) {
        pageComponentProps = await Component.getInitialProps(ctx);
      }

      return {
        ...pageComponentProps,
        isServer: !!req,
      };
    }

    public componentDidMount() {
      console.log('WithAuth.componentDidMount');

      const { store } = this.props;
      const user = store.currentUser;

      if (loginRequired && !logoutRequired && !user) {
        Router.push('/login');
        return;
      }

      let redirectUrl = '/login';
      let asUrl = '/login';
      if (user) {
        if (!user.defaultTeamSlug) {
          redirectUrl = '/create-team';
          asUrl = '/create-team';
        } else {
          redirectUrl = `/your-settings`;
          asUrl = `/your-settings`;
        }
      }

      if (logoutRequired && user) {
        Router.push(redirectUrl, asUrl);
      }
    }

    public render() {
      const { store } = this.props;
      const user = store.currentUser;

      if (loginRequired && !logoutRequired && !user) {
        return null;
      }

      if (logoutRequired && user) {
        return null;
      }

      return <Component {...this.props} />;
    }
  }

  return observer(WithAuth);
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\pages\create-team.tsx -----

import { inject, observer } from "mobx-react";
import * as React from "react";

import Avatar from "@mui/material/Avatar";
import Button from "@mui/material/Button";
import Grid from "@mui/material/Grid";
import TextField from "@mui/material/TextField";
import Head from "next/head";
import Router from "next/router";

import { getSignedRequestForUploadApiMethod, uploadFileUsingSignedPutRequestApiMethod } from "../lib/api/team-member";
import notify from "../lib/notify";
import { resizeImage } from "../lib/resizeImage";
import { Store } from "../lib/store";
import withAuth from "../lib/withAuth";

import Layout from "../components/layout";

const styleGrid = {
  height: "100%",
};

type Props = { store: Store; isMobile: boolean; teamRequired: boolean };

type State = { newName: string; newAvatarUrl: string; disabled: boolean };

class CreateTeam extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      newName: "",
      newAvatarUrl: "https://storage.googleapis.com/async-await/default-user.png?v=1",
      disabled: false,
    };
  }

  public render() {
    const { newAvatarUrl } = this.state;

    console.log(this.props.store);

    return (
      <Layout {...this.props}>
        <Head>
          <title>Create Team</title>
          <meta name="description" content="Create a new Team at SaaS Boilerplate" />
        </Head>
        <div style={{ padding: "0px", fontSize: "14px", height: "100%" }}>
          <Grid container style={styleGrid}>
            <Grid item sm={12} xs={12} style={{ padding: this.props.isMobile ? "0px" : "0px 30px" }}>
              <h3>Create team</h3>
              <p />
              <form onSubmit={this.onSubmit}>
                <h4>Team name</h4>
                <TextField
                  value={this.state.newName}
                  label="Type your team's name."
                  helperText="Team name as seen by your team members."
                  onChange={(event) => {
                    this.setState({ newName: event.target.value });
                  }}
                />
                <p />
                <h4 style={{ marginTop: "40px" }}>Team logo (optional)</h4>
                <Avatar
                  src={newAvatarUrl}
                  style={{
                    display: "inline-flex",
                    verticalAlign: "middle",
                    marginRight: 20,
                    width: 60,
                    height: 60,
                  }}
                />
                <label htmlFor="upload-file">
                  <Button variant="outlined" color="primary" component="span">
                    Select team logo
                  </Button>
                </label>
                <input
                  accept="image/*"
                  name="upload-file"
                  id="upload-file"
                  type="file"
                  style={{ display: "none" }}
                  onChange={this.previewTeamLogo}
                />
                <p />
                <br />
                <br />
                <Button variant="contained" color="primary" type="submit" disabled={this.state.disabled}>
                  Create new team
                </Button>
              </form>
            </Grid>
          </Grid>
          <br />
        </div>
      </Layout>
    );
  }

  private onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();

    const { newName } = this.state;

    const { store } = this.props;

    if (!newName) {
      notify("Team name is required.");
      return;
    }

    const file = (document.getElementById("upload-file") as HTMLFormElement).files[0];

    try {
      this.setState({ disabled: true });

      const defaultAvatarUrl = "https://storage.googleapis.com/async-await/default-user.png?v=1";
      const team = await store.addTeam({
        name: newName,
        avatarUrl: defaultAvatarUrl,
      });

      console.log(`Returned to client: ${team._id}, ${team.name}, ${team.slug}`);

      if (file == null) {
        Router.push(`/team/${team.slug}/team-settings`);
        notify("You successfully created Team.<p />Redirecting...");
        return;
      }

      const fileName = file.name;
      const fileType = file.type;
      const bucket = process.env.NEXT_PUBLIC_BUCKET_FOR_TEAM_LOGOS;
      const prefix = team.slug;

      const responseFromApiServerForUpload = await getSignedRequestForUploadApiMethod({
        fileName,
        fileType,
        prefix,
        bucket,
      });

      const resizedFile = await resizeImage(file, 128, 128);

      await uploadFileUsingSignedPutRequestApiMethod(resizedFile, responseFromApiServerForUpload.signedRequest, {
        "Cache-Control": "max-age=2592000",
      });

      const uploadedAvatarUrl = responseFromApiServerForUpload.url;

      await team.updateTheme({ name: team.name, avatarUrl: uploadedAvatarUrl });

      this.setState({
        newName: "",
        newAvatarUrl: "https://storage.googleapis.com/async-await/default-user.png?v=1",
      });

      (document.getElementById("upload-file") as HTMLFormElement).value = "";

      Router.push(`/team/${team.slug}/team-settings`);

      notify("You successfully created Team. Redirecting ...");
    } catch (error) {
      console.log(error);
      notify(error);
    } finally {
      this.setState({ disabled: false });
    }
  };

  private previewTeamLogo = () => {
    const file = (document.getElementById("upload-file") as HTMLFormElement).files[0];
    if (!file) {
      return;
    }

    const reader = new FileReader();

    reader.readAsDataURL(file);

    reader.onload = (e) => {
      this.setState({ newAvatarUrl: e.target.result as string });
    };
  };
}

export default withAuth(inject("store")(observer(CreateTeam)));

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\pages\invitation.tsx -----

import Avatar from "@mui/material/Avatar";
import { observer } from "mobx-react";
import Error from "next/error";
import Head from "next/head";
import Router from "next/router";
// import { NextPageContext } from 'next';
import React from "react";

import LoginButton from "../components/common/LoginButton";
import Layout from "../components/layout";
import { getTeamByTokenApiMethod } from "../lib/api/public";
import { Team } from "../lib/store/team";
import { Store } from "../lib/store";
import withAuth from "../lib/withAuth";

class InvitationPageComp extends React.Component<{ store: Store; team: Team; token: string }> {
  public static async getInitialProps(ctx) {
    const { token } = ctx.query;
    if (!token) {
      return {};
    }

    try {
      const { team } = await getTeamByTokenApiMethod(token, ctx.req);

      return { team, token };
    } catch (error) {
      console.log(error);
      return {};
    }
  }

  public render() {
    const { team, token, store } = this.props;

    if (!team) {
      return <Error statusCode={404} />;
    }

    const user = store.currentUser;

    if (user) {
      return null;
    }

    return (
      <Layout {...this.props}>
        <Head>
          <title>Invitation to {team.name}</title>
          <meta name="description" content={`Invitation to join ${team.name}`} />
        </Head>
        <div style={{ textAlign: "center", margin: "0 20px" }}>
          <br />
          <Avatar
            src={`${team.avatarUrl || "https://storage.googleapis.com/async-await/default-user.png?v=1"}`}
            alt="Team logo"
            style={{
              verticalAlign: "middle",
              display: "inline-flex",
            }}
          />{" "}
          <h2>{team.name}</h2>
          <p>
            Join <b>{team.name}</b> by logging in or signing up.
          </p>
          <br />
          <LoginButton invitationToken={token} />
        </div>
      </Layout>
    );
  }

  public async componentDidMount() {
    const { store, team, token } = this.props;

    const user = store.currentUser;

    if (user && team) {
      Router.push(
        `${process.env.NEXT_PUBLIC_URL_API}/logout?invitationToken=${token}`,
        `${process.env.NEXT_PUBLIC_URL_API}/logout`
      );
    }
  }
}

// export async function getServerSideProps(context: NextPageContext) {
//   const { token } = context.query;

//   try {
//     const { team } = await getTeamByTokenApiMethod(token as string, context.req);

//     if (team && token) {
//       return { props: { team, token } };
//     } else {
//       return { props: {} };
//     }
//   } catch (error) {
//     console.log(error);
//     return { props: {} };
//   }
// }

// see our explanation for not using getServerSideProps at this time: https://github.com/async-labs/saas/issues/193

export default withAuth(observer(InvitationPageComp), { loginRequired: false });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\pages\login.tsx -----

import Head from 'next/head';
import React from 'react';
import LoginButton from '../components/common/LoginButton';
import Layout from '../components/layout';
import withAuth from '../lib/withAuth';

class Login extends React.Component {
  public render() {
    return (
      <Layout {...this.props}>
        <div style={{ textAlign: 'center', margin: '0 20px' }}>
          <Head>
            <title>Log in to SaaS boilerplate by Async</title>
            <meta
              name="description"
              content="Login and signup page for SaaS boilerplate demo by Async"
            />
          </Head>
          <br />
          <p style={{ margin: '45px auto', fontSize: '44px', fontWeight: 400 }}>Log in</p>
          <p>Youll be logged in for 14 days unless you log out manually.</p>
          <br />

          <LoginButton />
        </div>
      </Layout>
    );
  }
}

export default withAuth(Login, { logoutRequired: true });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\pages\team-settings.tsx -----

import Avatar from "@mui/material/Avatar";
import Button from "@mui/material/Button";
import Hidden from "@mui/material/Hidden";
import TextField from "@mui/material/TextField";
import { inject, observer } from "mobx-react";
import Head from "next/head";
import NProgress from "nprogress";
import * as React from "react";
import Table from "@mui/material/Table";
import TableBody from "@mui/material/TableBody";
import TableCell from "@mui/material/TableCell";
import TableContainer from "@mui/material/TableContainer";
import TableHead from "@mui/material/TableHead";
import TableRow from "@mui/material/TableRow";

import Layout from "../components/layout";
import InviteMember from "../components/teams/InviteMember";
import { getSignedRequestForUploadApiMethod, uploadFileUsingSignedPutRequestApiMethod } from "../lib/api/team-member";
import confirm from "../lib/confirm";
import notify from "../lib/notify";
import { resizeImage } from "../lib/resizeImage";
import { Store } from "../lib/store";
import withAuth from "../lib/withAuth";

type Props = { isMobile: boolean; store: Store; teamSlug: string };

type State = {
  newName: string;
  newAvatarUrl: string;
  disabled: boolean;
  inviteMemberOpen: boolean;
};

class TeamSettings extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      newName: this.props.store.currentTeam.name,
      newAvatarUrl: this.props.store.currentTeam.avatarUrl,
      disabled: false,
      inviteMemberOpen: false,
    };
  }

  public render() {
    const { store, isMobile } = this.props;
    const { currentTeam, currentUser } = store;
    const { newName, newAvatarUrl } = this.state;
    const isTeamLeader = currentTeam && currentUser && currentUser._id === currentTeam.teamLeaderId;

    // console.log(this.props.firstGridItem);

    if (!currentTeam || currentTeam.slug !== this.props.teamSlug) {
      return (
        <Layout {...this.props}>
          <div style={{ padding: isMobile ? "0px" : "0px 30px" }}>
            <p>You did not select any team.</p>
            <p>To access this page, please select existing team or create new team if you have no teams.</p>
          </div>
        </Layout>
      );
    }

    if (!isTeamLeader) {
      return (
        <Layout {...this.props}>
          <div style={{ padding: isMobile ? "0px" : "0px 30px" }}>
            <p>Only the Team Leader can access this page.</p>
            <p>Create your own team to become a Team Leader.</p>
          </div>
        </Layout>
      );
    }

    console.log(Array.from(currentTeam.members.values()).filter((user) => user._id !== currentUser._id));

    return (
      <Layout {...this.props}>
        <Head>
          <title>Team Settings</title>
          <meta name="description" content={`Edit team settings. Add or edit members for Team ${currentTeam.name}`} />
        </Head>
        <div style={{ padding: isMobile ? "0px" : "0px 30px", fontSize: "15px", height: "100%" }}>
          <h3>Team Settings</h3>
          <p />
          <br />
          <form onSubmit={this.onSubmit}>
            <h4>Team name</h4>
            <TextField
              value={newName}
              helperText="Team name as seen by your team members"
              onChange={(event) => {
                this.setState({ newName: event.target.value });
              }}
            />
            <br />
            <br />
            <Button variant="contained" color="primary" type="submit" disabled={this.state.disabled}>
              Update username
            </Button>
          </form>
          <p />
          <br />
          <h4>Team logo</h4>
          <Avatar
            src={newAvatarUrl}
            style={{
              display: "inline-flex",
              verticalAlign: "middle",
              marginRight: 20,
              width: 60,
              height: 60,
            }}
          />
          <label htmlFor="upload-file-team-logo">
            <Button variant="contained" color="primary" component="span" disabled={this.state.disabled}>
              Update logo
            </Button>
          </label>
          <input
            accept="image/*"
            name="upload-file-team-logo"
            id="upload-file-team-logo"
            type="file"
            style={{ display: "none" }}
            onChange={this.uploadFile}
          />
          <p />
          <br />
          <br />
          <h4 style={{ marginRight: 20, display: "inline" }}>
            Team Members ( {Array.from(currentTeam.members.values()).length} / 20 )
          </h4>
          <Button
            onClick={this.openInviteMember}
            variant="contained"
            color="primary"
            style={{ float: "right", marginTop: "-20px" }}
            disabled={this.state.disabled}
          >
            Invite member
          </Button>
          <p />
          <TableContainer>
            <Table>
              <TableHead>
                <TableRow>
                  <TableCell>Person</TableCell>
                  <TableCell>Role</TableCell>
                  <TableCell>Action</TableCell>
                </TableRow>
              </TableHead>

              <TableBody>
                {currentTeam.memberIds
                  .map((userId) => currentTeam.members.get(userId))
                  .map((m) => (
                    <TableRow key={m._id}>
                      <TableCell style={{ width: "300px" }}>
                        <Hidden smDown>
                          <Avatar
                            role="presentation"
                            src={m.avatarUrl}
                            alt={(m.displayName || m.email)[0]}
                            key={m._id}
                            style={{
                              margin: "0px 5px",
                              display: "inline-flex",
                              width: "30px",
                              height: "30px",
                              verticalAlign: "middle",
                            }}
                          />
                        </Hidden>
                        {m.email}
                      </TableCell>
                      <TableCell>{isTeamLeader && m._id !== currentUser._id ? "Team Member" : "Team Leader"}</TableCell>
                      <TableCell>
                        {isTeamLeader && m._id !== currentUser._id ? (
                          <i
                            color="action"
                            data-id={m._id}
                            onClick={this.removeMember}
                            style={{
                              marginLeft: "20px",
                              fontSize: "16px",
                              opacity: 0.6,
                              cursor: "pointer",
                              verticalAlign: "middle",
                            }}
                            className="material-icons"
                          >
                            delete
                          </i>
                        ) : null}
                      </TableCell>
                    </TableRow>
                  ))}
              </TableBody>
            </Table>
          </TableContainer>

          <p />
          <br />

          {Array.from(currentTeam.invitations.values()).length > 0 ? (
            <React.Fragment>
              <h4>Invited users</h4>
              <p />
              <TableContainer>
                <Table>
                  <TableHead>
                    <TableRow>
                      <TableCell>Email</TableCell>
                      <TableCell>Status</TableCell>
                    </TableRow>
                  </TableHead>

                  <TableBody>
                    {Array.from(currentTeam.invitations.values()).map((i) => (
                      <TableRow key={i._id}>
                        <TableCell style={{ width: "300px" }}>{i.email}</TableCell>
                        <TableCell>Sent</TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              </TableContainer>
            </React.Fragment>
          ) : null}
          <p />
          <br />
          <InviteMember
            open={this.state.inviteMemberOpen}
            onClose={this.handleInviteMemberClose}
            store={this.props.store}
          />
          <br />
        </div>
      </Layout>
    );
  }

  private onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    const { newName, newAvatarUrl } = this.state;
    const { currentTeam } = this.props.store;

    if (!newName) {
      notify("Team name is required");
      return;
    }

    NProgress.start();

    try {
      this.setState({ disabled: true });

      await currentTeam.updateTheme({ name: newName, avatarUrl: newAvatarUrl });

      notify("You successfully updated Team name.");
    } catch (error) {
      notify(error);
    } finally {
      this.setState({ disabled: false });
      NProgress.done();
    }
  };

  private uploadFile = async () => {
    const { store } = this.props;
    const { currentTeam } = store;

    const fileElement = document.getElementById("upload-file-team-logo") as HTMLFormElement;
    const file = fileElement.files[0];

    if (file == null) {
      notify("No file selected for upload.");
      return;
    }

    const fileName = file.name;
    const fileType = file.type;

    NProgress.start();
    this.setState({ disabled: true });

    const bucket = process.env.NEXT_PUBLIC_BUCKET_FOR_TEAM_LOGOS;
    const prefix = `${currentTeam.slug}`;

    console.log(bucket);

    try {
      const responseFromApiServerForUpload = await getSignedRequestForUploadApiMethod({
        fileName,
        fileType,
        prefix,
        bucket,
      });

      const resizedFile = await resizeImage(file, 128, 128);

      await uploadFileUsingSignedPutRequestApiMethod(resizedFile, responseFromApiServerForUpload.signedRequest, {
        "Cache-Control": "max-age=2592000",
      });

      this.setState({
        newAvatarUrl: responseFromApiServerForUpload.url,
      });

      await currentTeam.updateTheme({
        name: this.state.newName,
        avatarUrl: this.state.newAvatarUrl,
      });

      notify("You successfully uploaded new Team logo.");
    } catch (error) {
      notify(error);
    } finally {
      this.setState({ disabled: false });
      NProgress.done();
    }
  };

  private openInviteMember = async () => {
    const { currentTeam } = this.props.store;
    if (!currentTeam) {
      notify("You have not selected a Team.");
      return;
    }

    this.setState({ inviteMemberOpen: true });
  };

  private handleInviteMemberClose = () => {
    this.setState({ inviteMemberOpen: false });
  };

  private removeMember = (event) => {
    const { currentTeam } = this.props.store;
    if (!currentTeam) {
      notify("You have not selected a Team.");
      return;
    }

    const userId = event.currentTarget.dataset.id;
    if (!userId) {
      notify("Select user.");
      return;
    }

    confirm({
      title: "Are you sure?",
      message: "",
      onAnswer: async (answer) => {
        if (answer) {
          try {
            await currentTeam.removeMember(userId);
          } catch (error) {
            notify(error);
          }
        }
      },
    });
  };
}

export default withAuth(inject("store")(observer(TeamSettings)));

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\pages\your-settings.tsx -----

import Avatar from "@mui/material/Avatar";
import Button from "@mui/material/Button";
import TextField from "@mui/material/TextField";
import { inject, observer } from "mobx-react";
import Head from "next/head";
import NProgress from "nprogress";
import * as React from "react";

import Layout from "../components/layout";

import { getSignedRequestForUploadApiMethod, uploadFileUsingSignedPutRequestApiMethod } from "../lib/api/team-member";

import notify from "../lib/notify";
import { resizeImage } from "../lib/resizeImage";
import { Store } from "../lib/store";
import withAuth from "../lib/withAuth";

type Props = { isMobile: boolean; store: Store };

type State = { newName: string; newAvatarUrl: string; disabled: boolean };

class YourSettings extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      newName: this.props.store.currentUser.displayName,
      newAvatarUrl: this.props.store.currentUser.avatarUrl,
      disabled: false,
    };
  }

  public render() {
    const { currentUser } = this.props.store;
    const { newName, newAvatarUrl } = this.state;

    return (
      <Layout {...this.props}>
        <Head>
          <title>Your Settings at Async</title>
          <meta name="description" content="description" />
        </Head>
        <div
          style={{
            padding: this.props.isMobile ? "0px" : "0px 30px",
            fontSize: "15px",
            height: "100%",
          }}
        >
          <h3>Your Settings</h3>
          <h4 style={{ marginTop: "40px" }}>Your account</h4>
          <div>
            <i className="material-icons" color="action" style={{ verticalAlign: "text-bottom" }}>
              done
            </i>{" "}
            {currentUser.isSignedupViaGoogle
              ? "You signed up on Async using your Google account."
              : "You signed up on Async using your email."}
            <p />
            <li>
              Your email: <b>{currentUser.email}</b>
            </li>
            <li>
              Your username: <b>{currentUser.displayName}</b>
            </li>
          </div>
          <form onSubmit={this.onSubmit} autoComplete="off">
            <h4>Your username</h4>
            <TextField
              autoComplete="off"
              value={newName}
              helperText="Your username as seen by your team members"
              onChange={(event) => {
                this.setState({ newName: event.target.value });
              }}
            />
            <br />
            <br />
            <Button variant="contained" color="primary" type="submit" disabled={this.state.disabled}>
              Update username
            </Button>
          </form>

          <br />
          <h4>Your photo</h4>
          <Avatar
            src={newAvatarUrl}
            style={{
              display: "inline-flex",
              verticalAlign: "middle",
              marginRight: 20,
              width: 60,
              height: 60,
            }}
          />
          <label htmlFor="upload-file-user-avatar">
            <Button variant="outlined" color="primary" component="span" disabled={this.state.disabled}>
              Update avatar
            </Button>
          </label>
          <input
            accept="image/*"
            name="upload-file-user-avatar"
            id="upload-file-user-avatar"
            type="file"
            style={{ display: "none" }}
            onChange={this.uploadFile}
          />
          <p />
          <br />
        </div>
      </Layout>
    );
  }

  private onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();

    const { currentUser } = this.props.store;

    const { newName, newAvatarUrl } = this.state;

    console.log(newName);

    if (!newName) {
      notify("Name is required");
      return;
    }

    NProgress.start();
    this.setState({ disabled: true });

    try {
      await currentUser.updateProfile({ name: newName, avatarUrl: newAvatarUrl });

      notify("You successfully updated your profile.");
    } catch (error) {
      notify(error);
    } finally {
      this.setState({ disabled: false });
      NProgress.done();
    }
  };

  private uploadFile = async () => {
    const fileElement = document.getElementById("upload-file-user-avatar") as HTMLFormElement;
    const file = fileElement.files[0];

    const { currentUser } = this.props.store;

    if (file == null) {
      notify("No file selected for upload.");
      return;
    }

    const fileName = file.name;
    const fileType = file.type;

    NProgress.start();
    this.setState({ disabled: true });

    const bucket = process.env.NEXT_PUBLIC_BUCKET_FOR_AVATARS;

    const prefix = `${currentUser.slug}`;

    try {
      const responseFromApiServerForUpload = await getSignedRequestForUploadApiMethod({
        fileName,
        fileType,
        prefix,
        bucket,
      });

      const resizedFile = await resizeImage(file, 128, 128);

      console.log(file);
      console.log(resizedFile);

      await uploadFileUsingSignedPutRequestApiMethod(resizedFile, responseFromApiServerForUpload.signedRequest, {
        "Cache-Control": "max-age=2592000",
      });

      this.setState({
        newAvatarUrl: responseFromApiServerForUpload.url,
      });

      await currentUser.updateProfile({
        name: this.state.newName,
        avatarUrl: this.state.newAvatarUrl,
      });

      notify("You successfully uploaded new avatar.");
    } catch (error) {
      notify(error);
    } finally {
      fileElement.value = "";
      this.setState({ disabled: false });
      NProgress.done();
    }
  };
}

export default withAuth(inject("store")(observer(YourSettings)));

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\pages\_app.tsx -----

import CssBaseline from "@mui/material/CssBaseline";
import { ThemeProvider } from "@mui/material/styles";
import { Provider } from "mobx-react";
import App from "next/app";
import Head from "next/head";
import React from "react";

import { themeDark, themeLight } from "../lib/theme";
import { getUserApiMethod } from "../lib/api/public";
import { getInitialDataApiMethod } from "../lib/api/team-member";
import { isMobile } from "../lib/isMobile";
import { getStore, initializeStore, Store } from "../lib/store";

class MyApp extends App {
  public static async getInitialProps({ Component, ctx }) {
    let firstGridItem = true;
    let teamRequired = false;

    if (
      ctx.pathname.includes("/login") ||
      ctx.pathname.includes("/create-team") ||
      ctx.pathname.includes("/invitation")
    ) {
      firstGridItem = false;
    }

    if (
      ctx.pathname.includes("/team-settings") ||
      ctx.pathname.includes("/discussion") ||
      ctx.pathname.includes("/billing")
    ) {
      teamRequired = true;
    }

    const { teamSlug } = ctx.query;

    // console.log(`ctx.query.teamSlug:${teamSlug}`);

    const pageProps = {
      isMobile: isMobile({ req: ctx.req }),
      firstGridItem,
      teamRequired,
      teamSlug,
    };

    if (Component.getInitialProps) {
      Object.assign(pageProps, await Component.getInitialProps(ctx));
    }

    const appProps = { pageProps };

    const store = getStore();
    if (store) {
      return appProps;
    }

    let userObj = null;
    try {
      const { user } = await getUserApiMethod(ctx.req);
      userObj = user;
    } catch (error) {
      console.log(error);
    }

    let initialData = {};

    if (userObj) {
      try {
        initialData = await getInitialDataApiMethod({
          request: ctx.req,
          data: { teamSlug },
        });
      } catch (error) {
        console.error(error);
      }
    }

    // console.log(initialData);

    // console.log(teamSlug);

    return {
      ...appProps,
      initialState: { user: userObj, currentUrl: ctx.asPath, teamSlug, ...initialData },
    };
  }

  public componentDidMount() {
    // Remove the server-side injected CSS.
    const jssStyles = document.querySelector("#jss-server-side");
    if (jssStyles && jssStyles.parentNode) {
      jssStyles.parentNode.removeChild(jssStyles);
    }
  }

  private store: Store;

  constructor(props) {
    super(props);

    console.log("MyApp.constructor");

    this.store = initializeStore(props.initialState);
  }

  public render() {
    const { Component, pageProps } = this.props;
    const store = this.store;

    const isThemeDark = store.currentUser ? store.currentUser.darkTheme : true;

    return (
      <ThemeProvider theme={isThemeDark ? themeDark : themeLight}>
        <Head>
          <meta name="viewport" content="width=device-width, initial-scale=1.0" />
          <link rel="stylesheet" href="https://storage.googleapis.com/async-await/nprogress-dark.min.css?v=1" />
        </Head>
        <CssBaseline />
        <Provider store={store}>
          <Component {...pageProps} store={store} />
        </Provider>
      </ThemeProvider>
    );
  }
}

export default MyApp;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\pages\_document.tsx -----

import Document, { Head, Html, Main, NextScript } from "next/document";
import React from "react";

class MyDocument extends Document {
  public static getInitialProps = async (ctx) => {
    const initialProps = await Document.getInitialProps(ctx);

    return {
      ...initialProps,
    };
  };

  public render() {
    // console.log('rendered on the server');

    return (
      <Html lang="en">
        <Head>
          <meta charSet="utf-8" />
          <meta name="google" content="notranslate" />
          <meta name="theme-color" content="#303030" />

          <link rel="shortcut icon" href="https://storage.googleapis.com/async-await/async-favicon32.png" />

          <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons" />
          <link rel="stylesheet" href="https://storage.googleapis.com/async-await/vs2015.min.css" />

          <style>
            {`
              #__next {
                width: 100%;
                height: 100%;
              }
              a {
                font-weight: 400;
                color: #58a6ff;
                text-decoration: none;
                outline: none;
              }
              hr {
                border: 0.5px #707070 solid;
                color: #000;
              }
              blockquote {
                padding: 0 0.5em;
                margin: 20px 1em;
                border-left: 0.25em solid #dfe2e5;
                color: #000;
              }
              pre {
                display: block;
                overflow-x: auto;
                padding: 0.5em;
                background: #d0d0d0;
                border: 1px solid #ddd;
                font-size: 14px;
                color: #000;
              }
              pre code {
                font-size: 13px;
                background: #d0d0d0;
                padding: 0px;
                color: #000;
              }
              code {
                font-size: 13px;
                background: #d0d0d0;
                padding: 3px 5px;
                color: #000;
              }
              mark {
                background-color: #ffff0060;
              }
              summary:focus {
                outline: none;
              }
              table {
                border-collapse: collapse;
                margin: 15px 0px;
              }
              table, th, td {
                border: 1px solid #a1a1a1;
              }
              th, td {
                line-height: 1.5em;
                padding: 10px;
              }
            `}
          </style>
        </Head>
        <body>
          <Main />
          <NextScript />
        </body>
      </Html>
    );
  }
}

export default MyDocument;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\server\server.ts -----

import express from 'express';
import next from 'next';

const NODE_ENV = process.env.NODE_ENV || 'development';
const IS_DEV = NODE_ENV !== 'production';

const app = next({ dev: IS_DEV });
const handle = app.getRequestHandler();

app.prepare().then(() => {
  const server = express();

  // give all Nextjs's request to Nextjs before anything else
  server.get('/_next/*', (req, res) => {
    // console.log('next server, page');
    handle(req, res);
  });

  server.use(express.json());

  // server.get('/api/v1/public/get-user', (_, res) => {
  //   res.json({ user: { email: 'team@builderbook.org' } });
  // });

  server.get('/team/:teamSlug/team-settings', (req, res) => {
    const { teamSlug } = req.params;
    app.render(req, res, '/team-settings', { teamSlug });
  });

  server.get('/invitation', (req, res) => {
    app.render(req, res, '/invitation', { token: req.query.token as string });
  });

  server.all('*', (req, res) => {
    handle(req, res);
  });

  server.listen(process.env.NEXT_PUBLIC_PORT_APP, () => {
    console.log(`> Ready on ${process.env.NEXT_PUBLIC_URL_APP}`);
  });
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\.eslintrc.js -----

module.exports = {
  settings: {
    react: { version: 'detect' },
  },
  parser: '@typescript-eslint/parser',
  extends: ['plugin:react/recommended', 'plugin:@typescript-eslint/recommended', 'prettier'],
  env: {
    es6: true,
    node: true,
  },
  plugins: ['prettier', 'react'],
  rules: {
    'prettier/prettier': [
      'error',
      {
        singleQuote: true,
        trailingComma: 'all',
        arrowParens: 'always',
        printWidth: 100,
        semi: true,
      },
    ],
    '@typescript-eslint/camelcase': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    'react/no-unescaped-entities': 'off',
    'react/jsx-filename-extension': ['error', { extensions: ['.tsx'] }],
    '@typescript-eslint/no-explicit-any': 'off',
    'prefer-arrow-callback': 'error',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
  },
};

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\next-env.d.ts -----

/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/pages/api-reference/config/typescript for more information.

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\next.config.js -----

module.exports = {
  poweredByHeader: false,
  webpack5: true,
  typescript: {
    ignoreBuildErrors: true,
  },
};

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\nodemon.json -----

{
  "watch": ["server"],
  "exec": "ts-node --project tsconfig.server.json",
  "ext": "ts"
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\package.json -----

{
  "name": "8-begin-app",
  "version": "1",
  "license": "MIT",
  "scripts": {
    "dev": "nodemon server/server.ts",
    "build": "next build",
    "lint": "eslint . --ext .ts,.tsx"
  },
  "dependencies": {
    "@emotion/react": "^11.14.0",
    "@emotion/styled": "^11.14.0",
    "@mui/material": "^6.4.8",
    "@mui/system": "^6.4.8",
    "dotenv": "^16.4.7",
    "express": "^4.21.2",
    "isomorphic-unfetch": "^4.0.2",
    "mobx": "5.15.7",
    "mobx-react": "6.3.1",
    "next": "^15.2.3",
    "nprogress": "^0.2.0",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "typescript": "^5.8.2"
  },
  "devDependencies": {
    "@types/express": "^5.0.1",
    "@types/node": "^22.13.11",
    "@types/react": "^19.0.12",
    "@types/react-dom": "^19.0.4",
    "@typescript-eslint/eslint-plugin": "^8.27.0",
    "@typescript-eslint/parser": "^8.27.0",
    "eslint": "^9.22.0",
    "eslint-config-prettier": "^10.1.1",
    "eslint-plugin-prettier": "^5.2.3",
    "eslint-plugin-react": "^7.37.4",
    "nodemon": "^3.1.9",
    "prettier": "^3.5.3",
    "ts-node": "^10.9.2"
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\tsconfig.json -----

{
  "compileOnSave": false,
  "compilerOptions": {
    "target": "esnext",
    "module": "esnext",
    "jsx": "preserve",
    "allowJs": true,
    "alwaysStrict": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "removeComments": true,
    "preserveConstEnums": true,
    "sourceMap": false,
    "skipLibCheck": true,
    "baseUrl": ".",
    "typeRoots": [
      "./node_modules/@types"
    ],
    "lib": [
      "dom",
      "es2017"
    ],
    "strict": false,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "incremental": true
  },
  "include": [
    "next-env.d.ts",
    "./**/*.tsx",
    "./**/*.ts"
  ],
  "exclude": [
    "dist",
    "production-server",
    ".next",
    "out",
    "next.config.js",
    "node_modules"
  ]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-begin\app\tsconfig.server.json -----

{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "module": "commonjs",
    "outDir": "production-server/",
    "target": "es2017",
    "isolatedModules": false,
    "noEmit": false
  },
  "exclude": ["./server/types.d.ts"],
  "include": ["./server/**/*.ts"],
  "typeRoots": ["./node_modules/@types", "./server/types.d.ts"]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\server\api\index.ts -----

import * as express from 'express';

import publicExpressRoutes from './public';
import teamMemberExpressRoutes from './team-member';
import teamLeaderApi from './team-leader';

function handleError(err, _, res, __) {
  console.error(err.stack);

  res.json({ error: err.message || err.toString() });
}

export default function api(server: express.Express) {
  server.use('/api/v1/public', publicExpressRoutes, handleError);
  server.use('/api/v1/team-member', teamMemberExpressRoutes, handleError);
  server.use('/api/v1/team-leader', teamLeaderApi, handleError);
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\server\api\public.ts -----

import * as express from 'express';

import User from '../models/User';
import Invitation from '../models/Invitation';

const router = express.Router();

router.get('/get-user', (req, res) => {
  console.log(req.user);
  res.json({ user: req.user || null });
});

router.post('/get-user-by-slug', async (req, res, next) => {
  console.log('Express route: /get-user-by-slug');

  // req.session.foo = 'bar';

  try {
    const { slug } = req.body;

    const user = await User.getUserBySlug({ slug });

    res.json({ user });
  } catch (err) {
    next(err);
  }
});

router.get('/invitations/get-team-by-token', async (req, res, next) => {
  const token = req.query.token as string;

  try {
    const team = await Invitation.getTeamByToken({ token });

    res.json({ team });
  } catch (err) {
    next(err);
  }
});

export default router;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\server\api\team-leader.ts -----

import * as express from 'express';

import Invitation from '../models/Invitation';
import Team from '../models/Team';

const router = express.Router();

router.use((req, res, next) => {
  console.log('team leader API', req.path);

  if (!req.user) {
    res.status(401).json({ error: 'Unauthorized' });
    return;
  }

  next();
});

router.post('/teams/add', async (req: any, res, next) => {
  try {
    const { name, avatarUrl } = req.body;

    console.log(`Express route: ${name}, ${avatarUrl}`);

    const team = await Team.addTeam({ userId: req.user.id, name, avatarUrl });

    res.json(team);
  } catch (err) {
    next(err);
  }
});

router.post('/teams/update', async (req: any, res, next) => {
  try {
    const { teamId, name, avatarUrl } = req.body;

    // console.log(req.user.id, typeof req.user.id);
    // console.log(req.user._id, typeof req.user._id);

    const team = await Team.updateTeam({
      userId: req.user.id,
      teamId,
      name,
      avatarUrl,
    });

    res.json(team);
  } catch (err) {
    next(err);
  }
});

router.get('/teams/get-invitations-for-team', async (req: any, res, next) => {
  try {
    const invitations = await Invitation.getTeamInvitations({
      userId: req.user.id,
      teamId: req.query.teamId as string,
    });

    res.json({ invitations });
  } catch (err) {
    next(err);
  }
});

router.post('/teams/invite-member', async (req: any, res, next) => {
  try {
    const { teamId, email } = req.body;

    const newInvitation = await Invitation.add({ userId: req.user.id, teamId, email });

    res.json({ newInvitation });
  } catch (err) {
    next(err);
  }
});

router.post('/teams/remove-member', async (req: any, res, next) => {
  try {
    const { teamId, userId } = req.body;

    await Team.removeMember({ teamLeaderId: req.user.id, teamId, userId });

    res.json({ done: 1 });
  } catch (err) {
    next(err);
  }
});

export default router;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\server\api\team-member.ts -----

import * as express from "express";

import { signRequestForUpload } from "../aws-s3";

import User from "../models/User";
import Team from "../models/Team";
import Invitation from "../models/Invitation";
import Discussion from "../models/Discussion";
import Post from "../models/Post";

import { discussionAdded, discussionDeleted, discussionEdited, postAdded, postDeleted, postEdited } from "../sockets";

const router = express.Router();

router.use((req, res, next) => {
  console.log("team member API", req.path);
  if (!req.user) {
    res.status(401).json({ error: "Unauthorized" });
    return;
  }

  next();
});

// Get signed request from AWS S3 server
router.post("/aws/get-signed-request-for-upload-to-s3", async (req, res, next) => {
  try {
    const { fileName, fileType, prefix, bucket } = req.body;

    const returnData = await signRequestForUpload({
      fileName,
      fileType,
      prefix,
      bucket,
    });

    console.log(bucket);

    res.json(returnData);
  } catch (err) {
    next(err);
  }
});

router.post("/user/update-profile", async (req: any, res, next) => {
  try {
    const { name, avatarUrl } = req.body;

    const updatedUser = await User.updateProfile({
      userId: req.user.id,
      name,
      avatarUrl,
    });

    res.json({ updatedUser });
  } catch (err) {
    next(err);
  }
});

router.post("/user/toggle-theme", async (req: any, res, next) => {
  try {
    const { darkTheme } = req.body;

    await User.toggleTheme({ userId: req.user.id, darkTheme });

    res.json({ done: 1 });
  } catch (err) {
    next(err);
  }
});

async function loadDiscussionsData(team, userId, body) {
  const { discussionSlug } = body;

  if (!discussionSlug) {
    return [];
  }

  const { discussions } = await Discussion.getList({
    userId,
    teamId: team._id,
  });

  for (const discussion of discussions) {
    if (discussion.slug === discussionSlug) {
      Object.assign(discussion, {
        initialPosts: await Post.getList({
          userId,
          discussionId: discussion._id.toString(),
        }),
      });

      break;
    }
  }

  return discussions;
}

async function loadTeamData(team, userId, body) {
  const initialMembers = await User.getMembersForTeam({
    userId,
    teamId: team._id,
  });

  let initialInvitations = [];
  if (userId === team.teamLeaderId) {
    initialInvitations = await Invitation.getTeamInvitations({
      userId,
      teamId: team._id,
    });
  }

  console.log(`initialMembers:${initialMembers}`);

  const initialDiscussions = await loadDiscussionsData(team, userId, body);

  const data: any = { initialMembers, initialInvitations, initialDiscussions };

  // console.log(`Express route:${data.initialPosts}`);

  return data;
}

router.post("/get-initial-data", async (req: any, res, next) => {
  try {
    const teams = await Team.getAllTeamsForUser(req.user.id);

    let selectedTeamSlug = req.body.teamSlug;
    if (!selectedTeamSlug && teams && teams.length > 0) {
      selectedTeamSlug = teams[0].slug;
    }

    for (const team of teams) {
      if (team.slug === selectedTeamSlug) {
        Object.assign(team, await loadTeamData(team, req.user.id, req.body));
        break;
      }
    }

    res.json({ teams });
  } catch (err) {
    next(err);
  }
});

router.get("/teams", async (req: any, res, next) => {
  try {
    const teams = await Team.getAllTeamsForUser(req.user.id);

    console.log(teams);

    res.json({ teams });
  } catch (err) {
    next(err);
  }
});

router.get("/teams/get-members", async (req: any, res, next) => {
  try {
    const users = await User.getMembersForTeam({
      userId: req.user.id,
      teamId: req.query.teamId as string,
    });

    res.json({ users });
  } catch (err) {
    next(err);
  }
});

router.post("/discussions/add", async (req: any, res, next) => {
  try {
    const { name, teamId, memberIds = [], socketId } = req.body;

    const discussion = await Discussion.add({
      userId: req.user.id,
      name,
      teamId,
      memberIds,
    });

    discussionAdded({ socketId, discussion });

    res.json({ discussion });
  } catch (err) {
    next(err);
  }
});

router.post("/discussions/edit", async (req: any, res, next) => {
  try {
    const { name, id, memberIds = [], socketId } = req.body;

    const updatedDiscussion = await Discussion.edit({
      userId: req.user.id,
      name,
      id,
      memberIds,
    });

    discussionEdited({ socketId, discussion: updatedDiscussion });

    res.json({ done: 1 });
  } catch (err) {
    next(err);
  }
});

router.post("/discussions/delete", async (req: any, res, next) => {
  try {
    const { id, socketId } = req.body;

    const { teamId } = await Discussion.delete({ userId: req.user.id, id });

    discussionDeleted({ socketId, teamId, id });

    res.json({ done: 1 });
  } catch (err) {
    next(err);
  }
});

router.get("/discussions/list", async (req: any, res, next) => {
  try {
    const { discussions } = await Discussion.getList({
      userId: req.user.id,
      teamId: req.query.teamId as string,
    });

    res.json({ discussions });
  } catch (err) {
    next(err);
  }
});

router.get("/posts/list", async (req: any, res, next) => {
  try {
    const posts = await Post.getList({
      userId: req.user.id,
      discussionId: req.query.discussionId as string,
    });

    res.json({ posts });
  } catch (err) {
    next(err);
  }
});

router.post("/posts/add", async (req: any, res, next) => {
  try {
    const { content, discussionId, socketId } = req.body;

    const post = await Post.add({ userId: req.user.id, content, discussionId });

    postAdded({ socketId, post });

    res.json({ post });
  } catch (err) {
    next(err);
  }
});

router.post("/posts/edit", async (req: any, res, next) => {
  try {
    const { content, id, socketId } = req.body;

    const updatedPost = await Post.edit({ userId: req.user.id, content, id });

    postEdited({ socketId, post: updatedPost });

    res.json({ done: 1 });
  } catch (err) {
    next(err);
  }
});

router.post("/posts/delete", async (req: any, res, next) => {
  try {
    const { id, discussionId, socketId } = req.body;

    await Post.delete({ userId: req.user.id, id });

    postDeleted({ socketId, id, discussionId });

    res.json({ done: 1 });
  } catch (err) {
    next(err);
  }
});

export default router;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\server\models\Discussion.ts -----

import { uniq } from 'lodash';
import * as mongoose from 'mongoose';

import { generateNumberSlug } from '../utils/slugify';
import Team, { TeamDocument } from './Team';
import Post from './Post';

const mongoSchema = new mongoose.Schema({
  createdUserId: {
    type: String,
    required: true,
  },
  teamId: {
    type: String,
    required: true,
  },
  name: {
    type: String,
    required: true,
  },
  slug: {
    type: String,
    required: true,
  },
  memberIds: [
    {
      type: String,
    },
  ],
  createdAt: {
    type: Date,
    required: true,
    default: Date.now,
  },
});

export interface DiscussionDocument extends mongoose.Document {
  createdUserId: string;
  teamId: string;
  name: string;
  slug: string;
  memberIds: string[];
  createdAt: Date;
}

interface DiscussionModel extends mongoose.Model<DiscussionDocument> {
  getList({
    userId,
    teamId,
  }: {
    userId: string;
    teamId: string;
  }): Promise<{ discussions: DiscussionDocument[] }>;

  add({
    name,
    userId,
    teamId,
    memberIds,
  }: {
    name: string;
    userId: string;
    teamId: string;
    memberIds: string[];
  }): Promise<DiscussionDocument>;

  edit({
    userId,
    id,
    name,
    memberIds,
  }: {
    userId: string;
    id: string;
    name: string;
    memberIds: string[];
  }): Promise<DiscussionDocument>;

  delete({ userId, id }: { userId: string; id: string }): Promise<{ teamId: string }>;

  checkPermissionAndGetTeam({
    userId,
    teamId,
    memberIds,
  }: {
    userId: string;
    teamId: string;
    memberIds: string[];
  }): Promise<TeamDocument>;
}

class DiscussionClass extends mongoose.Model {
  public static async getList({ userId, teamId }) {
    await this.checkPermissionAndGetTeam({ userId, teamId });

    const filter: any = { teamId, memberIds: userId };

    const discussions: any[] = await this.find(filter).setOptions({ lean: true });

    return { discussions };
  }

  public static async add({ name, userId, teamId, memberIds = [] }) {
    if (!name) {
      throw new Error('Bad data');
    }

    await this.checkPermissionAndGetTeam({ userId, teamId, memberIds });

    const slug = await generateNumberSlug(this, { teamId });

    return this.create({
      createdUserId: userId,
      teamId,
      name,
      slug,
      memberIds: uniq([userId, ...memberIds]),
      createdAt: new Date(),
    });
  }

  public static async edit({ userId, id, name, memberIds = [] }) {
    if (!id) {
      throw new Error('Bad data');
    }

    const discussion = await this.findById(id)
      .select('teamId createdUserId')
      .setOptions({ lean: true });

    const team = await this.checkPermissionAndGetTeam({
      userId,
      teamId: discussion.teamId,
      memberIds,
    });

    if (discussion.createdUserId !== userId && team.teamLeaderId !== userId) {
      throw new Error('Permission denied. Only author or team leader can edit Discussion.');
    }

    const updatedObj = await this.findOneAndUpdate(
      { _id: id },
      {
        name,
        memberIds: uniq([userId, ...memberIds]),
      },
      { runValidators: true, new: true },
    );

    return updatedObj;
  }

  public static async delete({ userId, id }) {
    if (!id) {
      throw new Error('Bad data');
    }

    const discussion = await this.findById(id).select('teamId').setOptions({ lean: true });

    await this.checkPermissionAndGetTeam({ userId, teamId: discussion.teamId });

    await Post.deleteMany({ discussionId: id });

    await this.deleteOne({ _id: id });

    return { teamId: discussion.teamId };
  }

  private static async checkPermissionAndGetTeam({ userId, teamId, memberIds = [] }) {
    if (!userId || !teamId) {
      throw new Error('Bad data');
    }

    const team = await Team.findById(teamId)
      .select('memberIds teamLeaderId')
      .setOptions({ lean: true });

    if (!team || team.memberIds.indexOf(userId) === -1) {
      throw new Error('Team not found');
    }

    for (const id of memberIds) {
      if (team.memberIds.indexOf(id) === -1) {
        throw new Error('Permission denied');
      }
    }

    return team;
  }
}

mongoSchema.loadClass(DiscussionClass);

const Discussion = mongoose.model<DiscussionDocument, DiscussionModel>('Discussion', mongoSchema);

export default Discussion;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\server\models\EmailTemplate.ts -----

import * as _ from 'lodash';
import * as mongoose from 'mongoose';

interface EmailTemplateDocument extends mongoose.Document {
  name: string;
  subject: string;
  message: string;
}

const EmailTemplate = mongoose.model<EmailTemplateDocument>(
  'EmailTemplate',
  new mongoose.Schema({
    name: {
      type: String,
      required: true,
      unique: true,
    },
    subject: {
      type: String,
      required: true,
    },
    message: {
      type: String,
      required: true,
    },
  }),
);

export async function insertTemplates() {
  const templates = [
    {
      name: 'welcome',
      subject: 'Welcome to SaaS boilerplate by Async',
      message: `Welcome <%= userName %>,
        <p>
          Thanks for signing up on our <a href="https://github.com/async-labs/saas" target="blank">SaaS boilerplate</a>!
        </p>
        <p>
          If you are learning how to build a SaaS web app, check out our 2 books:
           <a href="https://builderbook.org" target="blank">Builder Book</a>
           and
           <a href="https://builderbook.org/book" target="blank">SaaS Boilerplate</a>.
        </p>
        <p>
          Also check out
          <a href="https://async-await.com" target="blank"> Async</a>
          , our communication tool for small teams of software developers.
        </p>
        Kelly & Timur, Team Async
      `,
    },
    {
      name: 'login',
      subject: 'Login link for saas-app.async-await.com',
      message: `
        <p>Log into your account by clicking on this link: <a href="<%= loginURL %>"><%= loginURL %></a>.</p>`,
    },
    {
      name: 'invitation',
      subject: 'You are invited to join a team at saas-app.async-await.com',
      message: `You've been invited to join <b><%= teamName%></b>.
        <br/>Click here to accept the invitation: <%= invitationURL%>
      `,
    },
    // {
    //   name: 'newPost',
    //   subject: 'New Post was created in Discussion: <%= discussionName %>',
    //   message: `<p>New Post in Discussion: "<%= discussionName%>" by <%= authorName%></p>
    //     New Post: "<%= postContent %>"
    //     <p>---</p>
    //     <p>View it at <a href="<%= discussionLink %>"><%= discussionLink %></a>.</p>
    //   `,
    // },
  ];

  for (const t of templates) {
    const et = await EmailTemplate.findOne({ name: t.name }).setOptions({ lean: true });
    const message = t.message.replace(/\n/g, '').replace(/[ ]+/g, ' ').trim();

    if (!et) {
      EmailTemplate.create(Object.assign({}, t, { message }));
    } else if (et.subject !== t.subject || et.message !== message) {
      EmailTemplate.updateOne({ _id: et._id }, { $set: { message, subject: t.subject } }).exec();
    }
  }
}

export default async function getEmailTemplate(name: string, params: any) {
  await insertTemplates();

  const et = await EmailTemplate.findOne({ name }).setOptions({ lean: true });

  if (!et) {
    throw new Error('Email Template is not found in database.');
  }

  return {
    message: _.template(et.message)(params),
    subject: _.template(et.subject)(params),
  };
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\server\models\Invitation.ts -----

import * as mongoose from 'mongoose';

import sendEmail from '../aws-ses';
import getEmailTemplate from './EmailTemplate';
import Team from './Team';
import User, { UserDocument } from './User';

const mongoSchema = new mongoose.Schema({
  teamId: {
    type: String,
    required: true,
  },
  email: {
    type: String,
    required: true,
  },
  createdAt: {
    type: Date,
    required: true,
    default: Date.now,
    expires: 60 * 60 * 24, // delete doc after 24 hours
  },
  token: {
    type: String,
    required: true,
    unique: true,
  },
});

mongoSchema.index({ teamId: 1, email: 1 }, { unique: true });

interface InvitationDocument extends mongoose.Document {
  teamId: string;
  email: string;
  createdAt: Date;
  token: string;
}

interface InvitationModel extends mongoose.Model<InvitationDocument> {
  add({
    userId,
    teamId,
    email,
  }: {
    userId: string;
    teamId: string;
    email: string;
  }): InvitationDocument;

  getTeamInvitations({ userId, teamId }: { userId: string; teamId: string });
  getTeamByToken({ token }: { token: string });
  addUserToTeam({ token, user }: { token: string; user: UserDocument });
}

function generateToken() {
  const gen = () =>
    Math.random().toString(36).substring(2, 12) + Math.random().toString(36).substring(2, 12);

  return `${gen()}`;
}

class InvitationClass extends mongoose.Model {
  public static async add({ userId, teamId, email }) {
    if (!teamId || !email) {
      throw new Error('Bad data');
    }

    const team = await Team.findById(teamId).setOptions({ lean: true });
    if (!team || team.teamLeaderId !== userId) {
      throw new Error('Team does not exist or you have no permission');
    }

    const registeredUser = await User.findOne({ email }).setOptions({ lean: true });

    if (registeredUser && team.memberIds.includes(registeredUser._id.toString())) {
      throw new Error('This user is already Team Member.');
    }

    let token;
    const invitation = await this.findOne({ teamId, email })
      .select('token')
      .setOptions({ lean: true });

    if (invitation) {
      token = invitation.token;
    } else {
      token = generateToken();
      while ((await this.countDocuments({ token })) > 0) {
        token = generateToken();
      }

      await this.create({
        teamId,
        email,
        token,
      });
    }

    const emailTemplate = await getEmailTemplate('invitation', {
      teamName: team.name,
      invitationURL: `${process.env.URL_APP}/invitation?token=${token}`,
    });

    if (!emailTemplate) {
      throw new Error('Invitation email template not found');
    }

    try {
      await sendEmail({
        from: `Kelly from saas-app.async-await.com <${process.env.EMAIL_SUPPORT_FROM_ADDRESS}>`,
        to: [email],
        subject: emailTemplate.subject,
        body: emailTemplate.message,
      });
    } catch (err) {
      console.log('Email sending error:', err);
    }

    return await this.findOne({ teamId, email }).setOptions({ lean: true });
  }

  public static async getTeamInvitations({ userId, teamId }) {
    const team = await Team.findOne({ _id: teamId })
      .select('teamLeaderId')
      .setOptions({ lean: true });

    if (userId !== team.teamLeaderId) {
      throw new Error('You have no permission.');
    }

    return this.find({ teamId }).select('email').setOptions({ lean: true });
  }

  public static async getTeamByToken({ token }) {
    if (!token) {
      throw new Error('Bad data');
    }

    const invitation = await this.findOne({ token }).setOptions({ lean: true });

    if (!invitation) {
      throw new Error('Invitation not found');
    }

    const team = await Team.findById(invitation.teamId)
      .select('name slug avatarUrl memberIds')
      .setOptions({ lean: true });

    if (!team) {
      throw new Error('Team does not exist');
    }

    return team;
  }

  public static async addUserToTeam({ token, user }) {
    if (!token || !user) {
      throw new Error('Bad data');
    }

    const invitation = await this.findOne({ token }).setOptions({ lean: true });

    if (!invitation || invitation.email !== user.email) {
      throw new Error('Invitation not found');
    }

    await this.deleteOne({ token });

    const team = await Team.findById(invitation.teamId)
      .select('memberIds slug teamLeaderId')
      .setOptions({ lean: true });

    if (!team) {
      throw new Error('Team does not exist');
    }

    if (team && !team.memberIds.includes(user._id)) {
      await Team.updateOne({ _id: team._id }, { $addToSet: { memberIds: user._id } });

      if (user._id !== team.teamLeaderId) {
        await User.findByIdAndUpdate(user._id, { $set: { defaultTeamSlug: team.slug } });
      }
    }

    return team.slug;
  }
}

mongoSchema.loadClass(InvitationClass);

const Invitation = mongoose.model<InvitationDocument, InvitationModel>('Invitation', mongoSchema);

export default Invitation;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\server\models\Post.ts -----

import * as mongoose from "mongoose";

import * as he from "he";
import hljs from "highlight.js";
import { marked } from "marked";

import Discussion from "./Discussion";
import Team from "./Team";

const mongoSchema = new mongoose.Schema({
  createdUserId: {
    type: String,
    required: true,
  },
  discussionId: {
    type: String,
    required: true,
  },
  content: {
    type: String,
    required: true,
  },
  htmlContent: {
    type: String,
    required: true,
  },
  isEdited: {
    type: Boolean,
    default: false,
  },
  lastUpdatedAt: Date,
  createdAt: {
    type: Date,
    required: true,
  },
});

function markdownToHtml(content) {
  const renderer = new marked.Renderer();

  renderer.link = ({ href, title, text }) => {
    const t = title ? ` title="${title}"` : "";

    if (text.startsWith("<code>@#")) {
      return `${text.replace("<code>@#", "<code>@")} `;
    }

    return `
      <a target="_blank" href="${href}" rel="noopener noreferrer"${t}>
        ${text}
      </a>
    `;
  };

  renderer.code = ({ text, lang }) => {
    const language = hljs.getLanguage(lang) ? lang : "plaintext";

    return `<pre><code class="hljs language-${lang}">${hljs.highlight(text, { language }).value}</code></pre>`;
  };

  marked.setOptions({
    renderer,
    breaks: true,
  });

  return marked(he.decode(content));
}

export interface PostDocument extends mongoose.Document {
  createdUserId: string;
  discussionId: string;
  content: string;
  isEdited: boolean;
  lastUpdatedAt: Date;
  createdAt: Date;
}

interface PostModel extends mongoose.Model<PostDocument> {
  getList({ userId, discussionId }: { userId: string; discussionId: string }): Promise<PostDocument[]>;

  add({
    content,
    userId,
    discussionId,
  }: {
    content: string;
    userId: string;
    discussionId: string;
  }): Promise<PostDocument>;

  edit({ content, userId, id }: { content: string; userId: string; id: string }): Promise<PostDocument>;

  delete({ userId, id }: { userId: string; id: string }): Promise<void>;

  checkPermissionAndGetTeamAndDiscussion({
    userId,
    discussionId,
    post,
  }: {
    userId: string;
    discussionId: string;
    post: PostDocument;
  }): Promise<{ TeamDocument; DiscussionDocument }>;
}

class PostClass extends mongoose.Model {
  public static async getList({ userId, discussionId }) {
    await this.checkPermissionAndGetTeamAndDiscussion({ userId, discussionId });

    const filter: any = { discussionId };

    const posts: any[] = await this.find(filter).sort({ createdAt: 1 }).setOptions({ lean: true });

    return posts;
  }

  public static async add({ content, userId, discussionId }) {
    if (!content) {
      throw new Error("Bad data");
    }

    await this.checkPermissionAndGetTeamAndDiscussion({ userId, discussionId });

    const htmlContent = markdownToHtml(content);

    const post = await this.create({
      createdUserId: userId,
      discussionId,
      content,
      htmlContent,
      createdAt: new Date(),
    });

    return post;
  }

  public static async edit({ content, userId, id }) {
    if (!content || !id) {
      throw new Error("Bad data");
    }

    const post = await this.findById(id).select("createdUserId discussionId").setOptions({ lean: true });

    await this.checkPermissionAndGetTeamAndDiscussion({
      userId,
      discussionId: post.discussionId,
      post,
    });

    const htmlContent = markdownToHtml(content);

    const updatedObj = await this.findOneAndUpdate(
      { _id: id },
      { content, htmlContent, isEdited: true, lastUpdatedAt: new Date() },
      { runValidators: true, new: true }
    );

    return updatedObj;
  }

  public static async delete({ userId, id }) {
    if (!id) {
      throw new Error("Bad data");
    }

    const post = await this.findById(id).select("createdUserId discussionId content").setOptions({ lean: true });

    await this.checkPermissionAndGetTeamAndDiscussion({
      userId,
      discussionId: post.discussionId,
      post,
    });

    await this.deleteOne({ _id: id });
  }

  private static async checkPermissionAndGetTeamAndDiscussion({ userId, discussionId, post = null }) {
    if (!userId || !discussionId) {
      throw new Error("Bad data");
    }

    if (post && post.createdUserId !== userId) {
      throw new Error("Permission denied");
    }

    const discussion = await Discussion.findById(discussionId)
      .select("teamId memberIds slug")
      .setOptions({ lean: true });

    if (!discussion) {
      throw new Error("Discussion not found");
    }

    if (discussion.memberIds.indexOf(userId) === -1) {
      throw new Error("Permission denied");
    }

    const team = await Team.findById(discussion.teamId).select("memberIds slug").setOptions({ lean: true });

    if (!team || team.memberIds.indexOf(userId) === -1) {
      throw new Error("Team not found");
    }

    return { team, discussion };
  }
}

mongoSchema.loadClass(PostClass);

const Post = mongoose.model<PostDocument, PostModel>("Post", mongoSchema);

export default Post;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\server\models\Team.ts -----

import * as mongoose from 'mongoose';

import { generateNumberSlug } from '../utils/slugify';
import User from './User';

const mongoSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
  },
  slug: {
    type: String,
    required: true,
    unique: true,
  },
  avatarUrl: String,
  createdAt: {
    type: Date,
    required: true,
  },
  teamLeaderId: {
    type: String,
    required: true,
  },
  memberIds: [
    {
      type: String,
      required: true,
    },
  ],
  defaultTeam: {
    type: Boolean,
    default: false,
  },
});

export interface TeamDocument extends mongoose.Document {
  name: string;
  slug: string;
  avatarUrl: string;
  createdAt: Date;

  teamLeaderId: string;
  memberIds: string[];
  defaultTeam: boolean;
}

interface TeamModel extends mongoose.Model<TeamDocument> {
  addTeam({
    name,
    userId,
  }: {
    userId: string;
    name: string;
    avatarUrl: string;
  }): Promise<TeamDocument>;

  updateTeam({
    userId,
    teamId,
    name,
    avatarUrl,
  }: {
    userId: string;
    teamId: string;
    name: string;
    avatarUrl: string;
  }): Promise<TeamDocument>;

  getAllTeamsForUser(userId: string): Promise<TeamDocument[]>;

  removeMember({
    teamId,
    teamLeaderId,
    userId,
  }: {
    teamId: string;
    teamLeaderId: string;
    userId: string;
  }): Promise<void>;
}

class TeamClass extends mongoose.Model {
  public static async addTeam({ userId, name, avatarUrl }) {
    console.log(`Static method: ${name}, ${avatarUrl}`);

    if (!userId || !name || !avatarUrl) {
      throw new Error('Bad data');
    }

    const slug = await generateNumberSlug(this);

    let defaultTeam = false;
    if ((await this.countDocuments({ teamLeaderId: userId })) === 0) {
      await User.findByIdAndUpdate(userId, { $set: { defaultTeamSlug: slug } });
      defaultTeam = true;
    }

    const team = await this.create({
      teamLeaderId: userId,
      name,
      slug,
      avatarUrl,
      memberIds: [userId],
      createdAt: new Date(),
      defaultTeam,
    });

    return team;
  }

  public static async updateTeam({ userId, teamId, name, avatarUrl }) {
    const team = await this.findById(teamId, 'name teamLeaderId');

    if (!team) {
      throw new Error('Team not found');
    }

    if (team.teamLeaderId !== userId) {
      throw new Error('Permission denied');
    }

    const modifier = { name: team.name, avatarUrl };

    if (name !== team.name) {
      modifier.name = name;
    }

    await this.updateOne({ _id: teamId }, { $set: modifier }, { runValidators: true });

    return this.findById(teamId, 'name avatarUrl slug defaultTeam').setOptions({ lean: true });
  }

  public static getAllTeamsForUser(userId: string) {
    console.log(`userId:${userId}`);
    return this.find({ memberIds: userId }).setOptions({ lean: true });
  }

  public static async removeMember({ teamId, teamLeaderId, userId }) {
    const team = await this.findById(teamId).select('memberIds teamLeaderId');

    if (!team) {
      throw new Error('Team does not exist');
    }

    if (team.teamLeaderId !== teamLeaderId || teamLeaderId === userId) {
      throw new Error('Permission denied');
    }

    await this.findByIdAndUpdate(teamId, { $pull: { memberIds: userId } });
  }
}

mongoSchema.loadClass(TeamClass);

const Team = mongoose.model<TeamDocument, TeamModel>('Team', mongoSchema);

export default Team;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\server\models\User.ts -----

import * as _ from 'lodash';
import * as mongoose from 'mongoose';

import sendEmail from '../aws-ses';
import { addToMailchimp } from '../mailchimp';
import { generateSlug } from '../utils/slugify';
import getEmailTemplate from './EmailTemplate';
import Team, { TeamDocument } from './Team';

const mongoSchema = new mongoose.Schema({
  slug: {
    type: String,
    required: true,
    unique: true,
  },
  createdAt: {
    type: Date,
    required: true,
  },
  email: {
    type: String,
    required: true,
    unique: true,
  },
  displayName: String,
  avatarUrl: String,
  googleId: {
    type: String,
    unique: true,
    sparse: true,
  },
  googleToken: {
    accessToken: String,
    refreshToken: String,
  },
  isSignedupViaGoogle: {
    type: Boolean,
    required: true,
    default: false,
  },
  darkTheme: Boolean,
  defaultTeamSlug: {
    type: String,
    default: '',
  },
});

export interface UserDocument extends mongoose.Document {
  slug: string;
  createdAt: Date;
  email: string;
  displayName: string;
  avatarUrl: string;
  googleId: string;
  googleToken: { accessToken: string; refreshToken: string };
  isSignedupViaGoogle: boolean;
  darkTheme: boolean;
  defaultTeamSlug: string;
}

interface UserModel extends mongoose.Model<UserDocument> {
  getUserBySlug({ slug }: { slug: string }): Promise<UserDocument>;

  updateProfile({
    userId,
    name,
    avatarUrl,
  }: {
    userId: string;
    name: string;
    avatarUrl: string;
  }): Promise<UserDocument[]>;

  publicFields(): string[];

  signInOrSignUpViaGoogle({
    googleId,
    email,
    displayName,
    avatarUrl,
    googleToken,
  }: {
    googleId: string;
    email: string;
    displayName: string;
    avatarUrl: string;
    googleToken: { accessToken?: string; refreshToken?: string };
  }): Promise<UserDocument>;

  signInOrSignUpByPasswordless({
    uid,
    email,
  }: {
    uid: string;
    email: string;
  }): Promise<UserDocument>;

  toggleTheme({ userId, darkTheme }: { userId: string; darkTheme: boolean }): Promise<void>;

  getMembersForTeam({
    userId,
    teamId,
  }: {
    userId: string;
    teamId: string;
  }): Promise<UserDocument[]>;

  checkPermissionAndGetTeam({
    userId,
    teamId,
  }: {
    userId: string;
    teamId: string;
  }): Promise<TeamDocument>;
}

class UserClass extends mongoose.Model {
  public static async getUserBySlug({ slug }) {
    console.log('Static method: getUserBySlug');

    return this.findOne({ slug }, 'email displayName avatarUrl').setOptions({ lean: true });
  }

  public static async updateProfile({ userId, name, avatarUrl }) {
    console.log('Static method: updateProfile');

    const user = await this.findById(userId, 'slug displayName');

    const modifier = { displayName: user.displayName, avatarUrl, slug: user.slug };

    console.log(user.slug);

    if (name !== user.displayName) {
      modifier.displayName = name;
      modifier.slug = await generateSlug(this, name);
    }

    return this.findByIdAndUpdate(userId, { $set: modifier }, { new: true, runValidators: true })
      .select('displayName avatarUrl slug')
      .setOptions({ lean: true });
  }

  public static publicFields(): string[] {
    return [
      '_id',
      'id',
      'displayName',
      'email',
      'avatarUrl',
      'slug',
      'isSignedupViaGoogle',
      'darkTheme',
      'defaultTeamSlug',
    ];
  }

  public static async signInOrSignUpViaGoogle({
    googleId,
    email,
    displayName,
    avatarUrl,
    googleToken,
  }) {
    const user = await this.findOne({ email })
      .select([...this.publicFields(), 'googleId'].join(' '))
      .setOptions({ lean: true });

    if (user) {
      if (_.isEmpty(googleToken) && user.googleId) {
        return user;
      }

      const modifier = { googleId };
      if (googleToken.accessToken) {
        modifier['googleToken.accessToken'] = googleToken.accessToken;
      }

      if (googleToken.refreshToken) {
        modifier['googleToken.refreshToken'] = googleToken.refreshToken;
      }

      await this.updateOne({ email }, { $set: modifier });

      return user;
    }

    const slug = await generateSlug(this, displayName);

    const newUser = await this.create({
      createdAt: new Date(),
      googleId,
      email,
      googleToken,
      displayName,
      avatarUrl,
      slug,
      isSignedupViaGoogle: true,
      defaultTeamSlug: '',
      darkTheme: false,
    });

    const emailTemplate = await getEmailTemplate('welcome', { userName: displayName });

    if (!emailTemplate) {
      throw new Error('Welcome email template not found');
    }

    try {
      await sendEmail({
        from: `Kelly from saas-app.async-await.com <${process.env.EMAIL_SUPPORT_FROM_ADDRESS}>`,
        to: [email],
        subject: emailTemplate.subject,
        body: emailTemplate.message,
      });
    } catch (err) {
      console.error('Email sending error:', err);
    }

    try {
      await addToMailchimp({ email, listName: 'signups' });
    } catch (error) {
      console.error('Mailchimp error:', error);
    }

    return _.pick(newUser, this.publicFields());
  }

  public static async signInOrSignUpByPasswordless({ uid, email }) {
    const user = await this.findOne({ email })
      .select(this.publicFields().join(' '))
      .setOptions({ lean: true });

    if (user) {
      throw Error('User already exists');
    }

    const slug = await generateSlug(this, email);

    const newUser = await this.create({
      _id: uid,
      createdAt: new Date(),
      email,
      slug,
      defaultTeamSlug: '',
    });

    const emailTemplate = await getEmailTemplate('welcome', { userName: email });

    if (!emailTemplate) {
      throw new Error('Email template "welcome" not found in database.');
    }

    try {
      await sendEmail({
        from: `Kelly from saas-app.async-await.com <${process.env.EMAIL_SUPPORT_FROM_ADDRESS}>`,
        to: [email],
        subject: emailTemplate.subject,
        body: emailTemplate.message,
      });
    } catch (err) {
      console.error('Email sending error:', err);
    }

    try {
      await addToMailchimp({ email, listName: 'signups' });
    } catch (error) {
      console.error('Mailchimp error:', error);
    }

    return _.pick(newUser, this.publicFields());
  }

  public static toggleTheme({ userId, darkTheme }) {
    return this.updateOne({ _id: userId }, { darkTheme: !!darkTheme });
  }

  public static async getMembersForTeam({ userId, teamId }) {
    const team = await this.checkPermissionAndGetTeam({ userId, teamId });

    return this.find({ _id: { $in: team.memberIds } })
      .select(this.publicFields().join(' '))
      .setOptions({ lean: true });
  }

  private static async checkPermissionAndGetTeam({ userId, teamId }) {
    console.log(userId, teamId);

    if (!userId || !teamId) {
      throw new Error('Bad data');
    }

    const team = await Team.findById(teamId).select('memberIds').setOptions({ lean: true });

    if (!team || team.memberIds.indexOf(userId) === -1) {
      throw new Error('Team not found');
    }

    return team;
  }
}

mongoSchema.loadClass(UserClass);

const User = mongoose.model<UserDocument, UserModel>('User', mongoSchema);

export default User;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\server\utils\slugify.ts -----

import * as _ from 'lodash';

const slugify = (text) => _.kebabCase(text);

async function createUniqueSlug(Model, slug, count, filter) {
  const obj = await Model.findOne({ slug: `${slug}-${count}`, ...filter })
    .select('_id')
    .setOptions({ lean: true });

  if (!obj) {
    return `${slug}-${count}`;
  }

  return createUniqueSlug(Model, slug, count + 1, filter);
}

async function generateSlug(Model, name, filter = {}) {
  const origSlug = slugify(name);

  const obj = await Model.findOne({ slug: origSlug, ...filter })
    .select('_id')
    .setOptions({ lean: true });

  if (!obj) {
    return origSlug;
  }

  return createUniqueSlug(Model, origSlug, 1, filter);
}

async function generateNumberSlug(Model, filter = {}, n = 1) {
  const obj = await Model.findOne({ slug: n, ...filter })
    .select('_id')
    .setOptions({ lean: true });

  if (!obj) {
    return `${n}`;
  }

  return generateNumberSlug(Model, filter, ++n);
}

export { generateSlug, generateNumberSlug };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\server\utils\sum.ts -----

function sum(a, b) {
  return a + b;
}

export { sum };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\server\aws-s3.ts -----

import * as url from 'url';
import * as aws from 'aws-sdk';

async function signRequestForUpload({ fileName, fileType, prefix, bucket }) {
  const randomStringForPrefix =
    Math.random().toString(36).substring(2, 12) + Math.random().toString(36).substring(2, 12);

  const key = `${prefix}/${randomStringForPrefix}/${fileName}`;

  const acl = 'public-read';

  const params = {
    Bucket: bucket,
    Key: key,
    Expires: 60,
    ContentType: fileType,
    ACL: acl,
  };

  console.log(key, bucket);

  const s3 = new aws.S3({
    apiVersion: 'latest',
    region: process.env.AWS_REGION,
    accessKeyId: process.env.AWS_ACCESSKEYID,
    secretAccessKey: process.env.AWS_SECRETACCESSKEY,
  });

  return new Promise((resolve, reject) => {
    s3.getSignedUrl('putObject', params, (err, data) => {
      const parsedUrl = url.parse(data);

      const returnData = {
        signedRequest: data,
        url: `${parsedUrl.protocol}//${parsedUrl.hostname}${parsedUrl.pathname}`,
      };

      console.log(returnData);

      if (err) {
        console.error(err);
        reject(err);
      } else {
        resolve(returnData);
      }
    });
  });
}

export { signRequestForUpload };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\server\aws-ses.ts -----

import * as aws from 'aws-sdk';

export default function sendEmail(options) {
  const ses = new aws.SES({
    apiVersion: 'latest',
    region: process.env.AWS_REGION,
    accessKeyId: process.env.AWS_ACCESSKEYID,
    secretAccessKey: process.env.AWS_SECRETACCESSKEY,
  });

  return new Promise((resolve, reject) => {
    ses.sendEmail(
      {
        Source: options.from,
        Destination: {
          CcAddresses: options.cc,
          ToAddresses: options.to,
        },
        Message: {
          Subject: {
            Data: options.subject,
          },
          Body: {
            Html: {
              Data: options.body,
            },
          },
        },
        ReplyToAddresses: options.replyTo,
      },
      (err, info) => {
        if (err) {
          reject(err);
        } else {
          resolve(info);
        }
      },
    );
  });
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\server\google-auth.ts -----

import * as passport from 'passport';
import { OAuth2Strategy as Strategy } from 'passport-google-oauth';

import User, { UserDocument } from './models/User';
import Invitation from './models/Invitation';

function setupGoogle({ server }) {
  if (!process.env.GOOGLE_CLIENTID) {
    return;
  }

  const verify = async (req, accessToken, refreshToken, profile, done) => {
    let email;
    let avatarUrl;

    if (profile.emails) {
      email = profile.emails[0].value;
    }

    if (profile.photos && profile.photos.length > 0) {
      avatarUrl = profile.photos[0].value.replace('sz=50', 'sz=128');
    }

    try {
      const user = await User.signInOrSignUpViaGoogle({
        googleId: profile.id,
        email,
        googleToken: { accessToken, refreshToken },
        displayName: profile.displayName,
        avatarUrl,
      });

      let teamSlugOfInvitedTeam;
      if (user && req.session.invitationToken) {
        teamSlugOfInvitedTeam = await Invitation.addUserToTeam({
          token: req.session.invitationToken,
          user,
        }).catch((err) => console.error(err));
      }

      user.defaultTeamSlug = teamSlugOfInvitedTeam ? teamSlugOfInvitedTeam : user.defaultTeamSlug;

      done(null, user);
    } catch (err) {
      done(err);
      console.error(err);
    }
  };

  passport.use(
    new Strategy(
      {
        clientID: process.env.GOOGLE_CLIENTID,
        clientSecret: process.env.GOOGLE_CLIENTSECRET,
        callbackURL: `${process.env.URL_API}/oauth2callback`,
        passReqToCallback: true,
      },
      verify,
    ),
  );

  passport.serializeUser((user: UserDocument, done) => {
    done(null, user._id);
  });

  passport.deserializeUser((id, done) => {
    User.findById(id, User.publicFields())
      .then((user) => {
        done(null, user);
      })
      .catch((error) => {
        done(error, null);
      });
  });

  server.use(passport.initialize());
  server.use(passport.session());

  server.get('/auth/google', (req, res, next) => {
    const options = {
      scope: ['profile', 'email'],
      prompt: 'select_account',
    };

    if (req.query && req.query.invitationToken) {
      req.session.invitationToken = req.query.invitationToken;
    } else {
      req.session.invitationToken = null;
    }

    passport.authenticate('google', options)(req, res, next);
  });

  server.get(
    '/oauth2callback',
    passport.authenticate('google', {
      failureRedirect: '/login',
    }),
    async (req, res) => {
      let teamSlugOfInvitedTeam;

      if (req.user && req.session.invitationToken) {
        teamSlugOfInvitedTeam = await Invitation.addUserToTeam({
          token: req.session.invitationToken,
          user: req.user,
        }).catch((err) => console.error(err));

        req.session.invitationToken = null;
      }

      let redirectUrlAfterLogin;
      const defaultTeamSlug = req.user && req.user.defaultTeamSlug;

      if (teamSlugOfInvitedTeam || defaultTeamSlug) {
        redirectUrlAfterLogin = `/your-settings`;
      } else {
        redirectUrlAfterLogin = `/create-team`;
      }

      res.redirect(`${process.env.URL_APP}${redirectUrlAfterLogin}`);
    },
  );
}

export { setupGoogle };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\server\mailchimp.ts -----

import fetch, { Response } from 'node-fetch';

// eslint-disable-next-line
require('dotenv').config();

const LIST_IDS = {
  signups: process.env.MAILCHIMP_SAAS_ALL_LIST_ID,
};

function callAPI({ path, method, data }): Promise<Response> {
  const ROOT_URI = `https://${process.env.MAILCHIMP_REGION}.api.mailchimp.com/3.0`;

  return fetch(`${ROOT_URI}${path}`, {
    method,
    headers: {
      Accept: 'application/json',
      Authorization: `Basic ${Buffer.from(`apikey:${process.env.MAILCHIMP_API_KEY}`).toString(
        'base64',
      )}`,
    },
    body: JSON.stringify(data),
  });
}

async function addToMailchimp({ email, listName }) {
  const data = {
    // eslint-disable-next-line
    email_address: email,
    status: 'subscribed',
  };

  const path = `/lists/${LIST_IDS[listName]}/members/`;

  await callAPI({ path, method: 'POST', data });
}

export { addToMailchimp };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\server\passwordless-auth.ts -----

import * as passwordless from 'passwordless';

import sendEmail from './aws-ses';
import getEmailTemplate from './models/EmailTemplate';
import User from './models/User';
import PasswordlessMongoStore from './passwordless-token-mongostore';
import Invitation from './models/Invitation';

function setupPasswordless({ server }) {
  const mongoStore = new PasswordlessMongoStore();

  passwordless.addDelivery(async (tokenToSend, uidToSend, recipient, callback) => {
    try {
      const template = await getEmailTemplate('login', {
        loginURL: `${
          process.env.URL_API
        }/auth/logged_in?token=${tokenToSend}&uid=${encodeURIComponent(uidToSend)}`,
      });

      await sendEmail({
        from: `Kelly from saas-app.async-await.com <${process.env.EMAIL_SUPPORT_FROM_ADDRESS}>`,
        to: [recipient],
        subject: template.subject,
        body: template.message,
      });

      callback();
    } catch (err) {
      console.error('Email sending error:', err);
      callback(err);
    }
  });

  passwordless.init(mongoStore);
  server.use(passwordless.sessionSupport());

  server.use((req, __, next) => {
    if (req.user && typeof req.user === 'string') {
      User.findById(req.user, User.publicFields())
        .then((user) => {
          req.user = user;
          console.log('passwordless middleware');
          next();
        })
        .catch((err) => {
          next(err);
        });
    } else {
      next();
    }
  });

  server.post(
    '/auth/email-login-link',
    passwordless.requestToken(async (email, __, callback) => {
      try {
        const user = await User.findOne({ email }).select('_id').setOptions({ lean: true });

        if (user) {
          callback(null, user._id);
        } else {
          const id = await mongoStore.storeOrUpdateByEmail(email);
          callback(null, id);
        }
      } catch (error) {
        callback(error, null);
      }
    }),
    (req, res) => {
      if (req.query && req.query.invitationToken) {
        req.session.invitationToken = req.query.invitationToken;
      } else {
        req.session.invitationToken = null;
      }

      res.json({ done: 1 });
    },
  );

  server.get(
    '/auth/logged_in',
    passwordless.acceptToken(),
    (req, __, next) => {
      if (req.user && typeof req.user === 'string') {
        User.findById(req.user, User.publicFields())
          .then((user) => {
            req.user = user;
            next();
          })
          .catch((err) => {
            next(err);
          });
      } else {
        next();
      }
    },
    async (req, res) => {
      let teamSlugOfInvitedTeam;

      if (req.user && req.session.invitationToken) {
        teamSlugOfInvitedTeam = await Invitation.addUserToTeam({
          token: req.session.invitationToken,
          user: req.user,
        }).catch((err) => console.error(err));

        req.session.invitationToken = null;
      }

      let redirectUrlAfterLogin;
      const defaultTeamSlug = req.user && req.user.defaultTeamSlug;

      if (teamSlugOfInvitedTeam || defaultTeamSlug) {
        redirectUrlAfterLogin = `/your-settings`;
      } else {
        redirectUrlAfterLogin = `/create-team`;
      }

      res.redirect(`${process.env.URL_APP}${redirectUrlAfterLogin}`);
    },
  );

  server.get('/logout', (req, res, next) => {
    req.logout((err) => {
      if (err) {
        next(err);
      }

      if (req.query && req.query.invitationToken) {
        res.redirect(`${process.env.URL_APP}/invitation?token=${req.query.invitationToken}`);
      } else {
        res.redirect(`${process.env.URL_APP}/login`);
      }
    });
  });
}

export { setupPasswordless };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\server\passwordless-token-mongostore.ts -----

import * as bcrypt from 'bcrypt';
import * as mongoose from 'mongoose';
import * as TokenStore from 'passwordless-tokenstore';
import * as util from 'util';

import User from './models/User';

interface TokenDocument extends mongoose.Document {
  hashedToken: string;
  uid: string;
  ttl: Date;
  originUrl: string;
  email: string;
}

const mongoSchema = new mongoose.Schema({
  hashedToken: {
    type: String,
    required: true,
  },
  uid: {
    type: String,
    required: true,
    unique: true,
  },
  ttl: {
    type: Date,
    required: true,
    expires: 0,
  },
  originUrl: String,
  email: String,
});

const PasswordlessToken = mongoose.model<TokenDocument>(
  'PasswordlessToken',
  mongoSchema,
  'passwordless-token',
);

function MongoStore(options = {}) {
  TokenStore.call(this);

  this._options = options || {};
}

util.inherits(MongoStore, TokenStore);

MongoStore.prototype.authenticate = async function (token, uid, callback) {
  if (!token || !uid || !callback) {
    throw new Error('TokenStore:authenticate called with invalid parameters');
  }

  try {
    const tokenDoc = await PasswordlessToken.findOne({ uid, ttl: { $gt: new Date() } }).setOptions({
      lean: true,
    });

    if (tokenDoc) {
      const isMatch = await bcrypt.compare(token, tokenDoc.hashedToken);
      if (isMatch) {
        if (tokenDoc.email) {
          await User.signInOrSignUpByPasswordless({ uid, email: tokenDoc.email });
        }

        callback(null, true, tokenDoc.originUrl);
      } else {
        callback(null, false, null);
      }
    } else {
      callback(null, false, null);
    }
  } catch (error) {
    callback(error, false, null);
  }
};

MongoStore.prototype.storeOrUpdate = async function (token, uid, msToLive, originUrl, callback) {
  if (!token || !uid || !msToLive || !callback) {
    throw new Error('TokenStore:storeOrUpdate called with invalid parameters');
  }

  const saltRounds = 10;

  try {
    const hashedToken = await bcrypt.hash(token, saltRounds);
    const newRecord = { hashedToken, uid, ttl: new Date(Date.now() + msToLive), originUrl };

    await PasswordlessToken.updateOne(
      { uid },
      { $set: newRecord },
      { upsert: true, runValidators: true },
    );
    callback();
  } catch (error) {
    callback(error);
  }
};

MongoStore.prototype.invalidateUser = async function (uid, callback) {
  if (!uid || !callback) {
    throw new Error('TokenStore:invalidateUser called with invalid parameters');
  }

  try {
    await PasswordlessToken.deleteOne({ uid });
    callback();
  } catch (error) {
    callback(error);
  }
};

MongoStore.prototype.clear = async function (callback) {
  if (!callback) {
    throw new Error('TokenStore:clear called with invalid parameters');
  }

  try {
    await PasswordlessToken.deleteMany({});
    callback();
  } catch (error) {
    callback(error);
  }
};

MongoStore.prototype.length = function (callback) {
  PasswordlessToken.countDocuments(callback);
};

MongoStore.prototype.storeOrUpdateByEmail = async function addEmail(email: string) {
  if (!email) {
    throw new Error('TokenStore:addEmail called with invalid parameters');
  }

  const obj = await PasswordlessToken.findOne({ email }).select('uid').setOptions({ lean: true });

  if (obj) {
    return obj.uid;
  }

  const uid = new mongoose.Types.ObjectId().toHexString();
  await PasswordlessToken.updateOne({ uid }, { email }, { upsert: true });

  return uid;
};

export default MongoStore;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\server\server.ts -----

// eslint-disable-next-line @typescript-eslint/no-var-requires
const MongoStore = require('connect-mongo');

import * as cors from 'cors';
import * as express from 'express';
import * as session from 'express-session';
import * as httpModule from 'http';
import * as mongoose from 'mongoose';

import api from './api';
import { setupGoogle } from './google-auth';
import { setupPasswordless } from './passwordless-auth';
import { setupSockets } from './sockets';

// eslint-disable-next-line
require('dotenv').config();

mongoose.connect(process.env.MONGO_URL_TEST);

const server = express();

server.use(
  cors({
    origin: process.env.URL_APP,
    methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',
    credentials: true,
  }),
);

server.use(express.json());

const sessionOptions = {
  name: process.env.SESSION_NAME,
  secret: process.env.SESSION_SECRET,
  resave: false,
  saveUninitialized: false,
  store: MongoStore.create({
    mongoUrl: process.env.MONGO_URL_TEST,
    ttl: 14 * 24 * 60 * 60, // save session 14 days
    autoRemove: 'interval',
    autoRemoveInterval: 1440, // clears every day
  }),
  cookie: {
    httpOnly: true,
    maxAge: 14 * 24 * 60 * 60 * 1000, // expires in 14 days
    secure: false,
  },
};

const sessionMiddleware = session(sessionOptions);
server.use(sessionMiddleware);

setupGoogle({ server });
setupPasswordless({ server });

api(server);

const httpServer = httpModule.createServer(server);
setupSockets({ httpServer, origin: process.env.URL_APP, sessionMiddleware });

server.get('*', (_, res) => {
  res.sendStatus(403);
});

httpServer.listen(process.env.PORT_API, () => {
  console.log(`> Ready on ${process.env.URL_API}`);
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\server\sockets.ts -----

import { Response } from 'express';
import { Server } from 'socket.io';

import { DiscussionDocument } from './models/Discussion';
import { PostDocument } from './models/Post';

let io: Server = null;
// const dev = process.env.NODE_ENV !== 'production';

function setupSockets({ httpServer, origin, sessionMiddleware }) {
  if (io === null) {
    io = new Server(httpServer, {
      cors: {
        origin,
        methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',
        credentials: true,
      },
      cookie: {
        name: 'io',
        httpOnly: true,
        maxAge: 14 * 24 * 60 * 60 * 1000, // expires in 14 days
        domain: 'localhost',
        secure: false,
      },
      serveClient: false,
      transports: ['polling', 'websocket'],
    });

    const wrap = (middleware) => (socket, next) => middleware(socket.request, {} as Response, next);

    io.use(wrap(sessionMiddleware));

    io.on('connection', (socket: any) => {
      if (
        !socket.request.session ||
        ((!socket.request.session.passport || !socket.request.session.passport.user) &&
          !socket.request.session.passwordless)
      ) {
        socket.disconnect(true);
        return;
      }

      socket.on('joinTeamRoom', (teamId) => {
        console.log(`    joinTeamRoom ${teamId}`);
        socket.join(`teamRoom-${teamId}`);
      });

      socket.on('leaveTeamRoom', (teamId) => {
        console.log(`** leaveTeamRoom ${teamId}`);
        socket.leave(`teamRoom-${teamId}`);
      });

      socket.on('joinDiscussionRoom', (discussionId) => {
        console.log(`    joinDiscussionRoom ${discussionId}`);
        socket.join(`discussionRoom-${discussionId}`);
      });

      socket.on('leaveDiscussionRoom', (discussionId) => {
        console.log(`** leaveDiscussionRoom ${discussionId}`);
        socket.leave(`discussionRoom-${discussionId}`);
      });

      socket.on('disconnect', (reason) => {
        console.log(`disconnected`, `reason: ` + reason);
      });
    });
  }
}

function getSocket(socketId?: string) {
  if (!io) {
    return null;
  }

  if (socketId && io.sockets.sockets.get(socketId)) {
    return io.sockets.sockets.get(socketId).broadcast;
  } else {
    return io;
  }
}

function discussionAdded({
  socketId,
  discussion,
}: {
  socketId?: string;
  discussion: DiscussionDocument;
}) {
  const roomName = `teamRoom-${discussion.teamId}`;

  const socket = getSocket(socketId);
  if (socket) {
    socket.to(roomName).emit('discussionEvent', { actionType: 'added', discussion });
  }
}

function discussionEdited({
  socketId,
  discussion,
}: {
  socketId?: string;
  discussion: DiscussionDocument;
}) {
  const roomName = `teamRoom-${discussion.teamId}`;
  const socket = getSocket(socketId);

  if (socket) {
    socket.to(roomName).emit('discussionEvent', {
      actionType: 'edited',
      discussion,
    });
  }
}

function discussionDeleted({
  socketId,
  teamId,
  id,
}: {
  socketId?: string;
  teamId: string;
  id: string;
}) {
  const roomName = `teamRoom-${teamId}`;
  const socket = getSocket(socketId);

  if (socket) {
    socket.to(roomName).emit('discussionEvent', { actionType: 'deleted', id });
  }
}

function postAdded({ socketId, post }: { socketId?: string; post: PostDocument }) {
  const roomName = `discussionRoom-${post.discussionId}`;

  const socket = getSocket(socketId);
  if (socket) {
    socket.to(roomName).emit('postEvent', { actionType: 'added', post });
  }
}

function postEdited({ socketId, post }: { socketId?: string; post: PostDocument }) {
  const roomName = `discussionRoom-${post.discussionId}`;

  const socket = getSocket(socketId);
  if (socket) {
    socket.to(roomName).emit('postEvent', { actionType: 'edited', post });
  }
}

function postDeleted({
  socketId,
  id,
  discussionId,
}: {
  socketId?: string;
  id: string;
  discussionId: string;
}) {
  const roomName = `discussionRoom-${discussionId}`;

  const socket = getSocket(socketId);
  if (socket) {
    socket.to(roomName).emit('postEvent', { actionType: 'deleted', id });
  }
}

export {
  setupSockets,
  postAdded,
  postEdited,
  postDeleted,
  discussionAdded,
  discussionEdited,
  discussionDeleted,
};

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\test\server\utils\slugify.test.ts -----

import * as mongoose from 'mongoose';
import User from '../../../server/models/User';
import { generateSlug } from '../../../server/utils/slugify';

// eslint-disable-next-line
require('dotenv').config();

describe('slugify', () => {
  beforeAll(async () => {
    await mongoose.connect(process.env.MONGO_URL_TEST);

    const mockUsers = [
      {
        slug: 'john',
        email: 'john@example.com',
        createdAt: new Date(),
        displayName: 'abc',
        avatarUrl: 'def',
      },
      {
        slug: 'john-johnson',
        email: 'john-johnson@example.com',
        createdAt: new Date(),
        displayName: 'abc',
        avatarUrl: 'def',
      },
      {
        slug: 'john-johnson-1',
        email: 'john-johnson-1@example.com',
        createdAt: new Date(),
        displayName: 'abc',
        avatarUrl: 'def',
      },
    ];

    await User.insertMany(mockUsers);
  });

  test('not duplicated', async () => {
    expect.assertions(1);

    await expect(generateSlug(User, 'John J Johnson@#$')).resolves.toEqual('john-j-johnson');
  });

  test('one time duplicated', async () => {
    expect.assertions(1);

    await expect(generateSlug(User, ' John@#$')).resolves.toEqual('john-1');
  });

  test('multiple duplicated', async () => {
    expect.assertions(1);

    await expect(generateSlug(User, 'John & Johnson@#$')).resolves.toEqual('john-johnson-2');
  });

  afterAll(async () => {
    await User.deleteMany({ slug: { $in: ['john', 'john-johnson', 'john-johnson-1'] } });
    await mongoose.disconnect();
  });
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\test\server\utils\sum.test.ts -----

import { sum } from '../../../server/utils/sum';

console.log(sum(1, 2));

describe.skip('testing sum function', () => {
  test('adds 1 + 2 to equal 3', () => {
    expect(sum(1, 2)).toBe(3);
  });
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\.eslintrc.js -----

module.exports = {
  parser: "@typescript-eslint/parser",
  extends: ["plugin:@typescript-eslint/recommended", "prettier"],
  env: {
    "es6": true,
    "node": true,
  },
  plugins: ["prettier"],
  rules: {
    'prettier/prettier': [
      'error',
      {
        singleQuote: true,
        trailingComma: 'all',
        arrowParens: 'always',
        printWidth: 100,
        semi: true,
      },
    ],
    '@typescript-eslint/no-unused-vars': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/no-explicit-any': 'off',
    'prefer-arrow-callback': 'error',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
 },
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\nodemon.json -----

{
  "watch": ["server"],
  "exec": "ts-node --project tsconfig.server.json",
  "ext": "ts"
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\package.json -----

{
  "name": "8-end-api",
  "version": "1",
  "license": "MIT",
  "scripts": {
    "dev": "nodemon server/server.ts",
    "lint": "eslint . --ext .ts,.tsx",
    "test": "jest"
  },
  "jest": {
    "preset": "ts-jest",
    "testPathIgnorePatterns": [
      "production-server"
    ],
    "testEnvironment": "node"
  },
  "dependencies": {
    "aws-sdk": "^2.1692.0",
    "bcrypt": "^5.1.1",
    "connect-mongo": "^5.1.0",
    "cors": "^2.8.5",
    "dotenv": "^16.4.7",
    "express": "^4.21.2",
    "express-session": "^1.18.1",
    "he": "^1.2.0",
    "highlight.js": "^11.11.1",
    "lodash": "^4.17.21",
    "marked": "^15.0.7",
    "mongoose": "^8.12.1",
    "node-fetch": "2",
    "passport": "^0.7.0",
    "passport-google-oauth": "^2.0.0",
    "passwordless": "^1.1.3",
    "passwordless-tokenstore": "^0.0.10",
    "socket.io": "^4.8.1",
    "typescript": "^5.8.2"
  },
  "devDependencies": {
    "@types/connect-mongo": "^3.1.6",
    "@types/dotenv": "^8.2.3",
    "@types/express": "^5.0.1",
    "@types/express-session": "^1.18.1",
    "@types/jest": "^29.5.14",
    "@types/lodash": "^4.17.16",
    "@types/mongoose": "^5.11.97",
    "@types/node": "^22.13.11",
    "@types/node-fetch": "^2.6.12",
    "@types/passport": "^1.0.17",
    "@types/socket.io": "^3.0.2",
    "@typescript-eslint/eslint-plugin": "^8.27.0",
    "@typescript-eslint/parser": "^8.27.0",
    "eslint": "^9.22.0",
    "eslint-config-prettier": "^10.1.1",
    "eslint-plugin-prettier": "^5.2.3",
    "jest": "^29.7.0",
    "nodemon": "^3.1.9",
    "prettier": "^3.5.3",
    "ts-jest": "^29.2.6",
    "ts-node": "^10.9.2"
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\tsconfig.json -----

{
  "compileOnSave": false,
  "compilerOptions": {
    "jsx": "preserve",
    "allowJs": true,
    "alwaysStrict": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "removeComments": false,
    "preserveConstEnums": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "sourceMap": true,
    "skipLibCheck": true,
    "baseUrl": ".",
    "experimentalDecorators": true,
    "typeRoots": ["./node_modules/@types"],
    "lib": ["es2015", "es2016"]
  },
  "exclude": ["production-server", "node_modules"]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\api\tsconfig.server.json -----

{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "module": "commonjs",
    "outDir": "production-server/"
  },
  "include": ["./server/**/*.ts"],
  "exclude": ["./server/**/*.test.ts"]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\components\common\Confirmer.tsx -----

import Button from "@mui/material/Button";
import Dialog from "@mui/material/Dialog";
import DialogActions from "@mui/material/DialogActions";
import DialogContent from "@mui/material/DialogContent";
import DialogContentText from "@mui/material/DialogContentText";
import DialogTitle from "@mui/material/DialogTitle";
import React from "react";

export let openConfirmDialogExternal;

type State = {
  open: boolean;
  title: string;
  message: string;
  onAnswer: (answer) => void;
};

class Confirmer extends React.Component<any, State> {
  constructor(props) {
    super(props);

    this.state = {
      open: false,
      title: "Are you sure?",
      message: "",
      onAnswer: null,
    };

    openConfirmDialogExternal = this.openConfirmDialog;
  }

  public render() {
    return (
      <Dialog
        open={this.state.open}
        onClose={this.handleClose}
        aria-labelledby="alert-dialog-title"
        aria-describedby="alert-dialog-description"
      >
        <DialogTitle id="alert-dialog-title">{this.state.title}</DialogTitle>
        <DialogContent>
          <DialogContentText id="alert-dialog-description">{this.state.message}</DialogContentText>
        </DialogContent>
        <DialogActions style={{ padding: "10px" }}>
          <Button onClick={this.handleClose} variant="contained" color="primary" autoFocus>
            Cancel
          </Button>
          <Button onClick={this.handleYes} variant="contained" color="secondary">
            OK
          </Button>
        </DialogActions>
      </Dialog>
    );
  }

  public handleClose = () => {
    this.setState({ open: false });
    this.state.onAnswer(false);
  };

  public handleYes = () => {
    this.setState({ open: false });
    this.state.onAnswer(true);
  };

  public openConfirmDialog = ({ title, message, onAnswer }) => {
    this.setState({ open: true, title, message, onAnswer });
  };
}

export default Confirmer;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\components\common\LoginButton.tsx -----

import Button from "@mui/material/Button";
import TextField from "@mui/material/TextField";
import React from "react";

import { emailLoginLinkApiMethod } from "../../lib/api/public";
import notify from "../../lib/notify";
import { makeQueryString } from "../../lib/api/makeQueryString";

type Props = { invitationToken?: string };
type State = { email: string };

class LoginButton extends React.PureComponent<Props, State> {
  constructor(props) {
    super(props);

    this.state = { email: "" };
  }

  public render() {
    const { invitationToken } = this.props;

    let url = `${process.env.NEXT_PUBLIC_URL_API}/auth/google`;
    const qs = makeQueryString({ invitationToken });

    if (qs) {
      url += `?${qs}`;
    }

    // console.log(url);

    return (
      <React.Fragment>
        <Button variant="contained" color="secondary" href={url}>
          <img src="https://storage.googleapis.com/async-await-all/G.svg" alt="Log in with Google" />
          &nbsp;&nbsp;&nbsp; Log in with Google
        </Button>
        <p />
        <br />
        <hr style={{ width: "60px" }} /> <h4>OR</h4> <hr style={{ width: "60px" }} />
        <p />
        <br />
        <div>
          <form autoComplete="off" onSubmit={this.onSubmit}>
            <TextField
              required
              type="email"
              label="Email address"
              value={this.state.email}
              onChange={(event) => {
                this.setState({ email: event.target.value });
              }}
              style={{ width: "300px" }}
            />
            <p />
            <Button variant="contained" color="primary" type="submit">
              Log in with email
            </Button>
          </form>
          <p />
          <br />
        </div>
      </React.Fragment>
    );
  }

  private onSubmit = async (event) => {
    event.preventDefault();
    const { email } = this.state;
    const { invitationToken } = this.props;

    if (!email) {
      notify("Email is required");
    }

    try {
      await emailLoginLinkApiMethod({ email, invitationToken });
      this.setState({ email: "" });
      notify("SaaS boilerplate emailed you a login link.");
    } catch (error) {
      notify(error);
    }
  };
}

export default LoginButton;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\components\common\MemberChooser.tsx -----

import React from "react";

import Autocomplete from "@mui/material/Autocomplete";
import TextField from "@mui/material/TextField";

import { User } from "../../lib/store/user";

type Props = {
  onChange: (item) => void;
  selectedMemberIds?: string[];
  members: User[];
  label?: string;
  helperText?: string;
};

type State = {
  selectedItems: { label: string; id: string }[];
};

class MemberChooser extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    const suggestions = this.props.members.map((user) => ({
      label: user.displayName || user.email,
      id: user._id,
    }));

    const selectedItems = suggestions.filter((s) => this.props.selectedMemberIds.indexOf(s.id) !== -1);

    this.state = {
      selectedItems: selectedItems || [],
    };
  }

  public render() {
    const suggestions = this.props.members.map((user) => ({
      label: user.displayName || user.email,
      id: user._id,
    }));

    return (
      <Autocomplete
        multiple
        id="tags-standard"
        options={suggestions}
        getOptionLabel={(option) => option.label}
        isOptionEqualToValue={(option, value) => option.id === value.id}
        value={this.state.selectedItems}
        renderInput={(params) => (
          <TextField
            {...params}
            variant="standard"
            label="Find team member by name"
            placeholder="Select participants"
          />
        )}
        onChange={this.handleChange}
        filterSelectedOptions={true}
        noOptionsText="No team members to select from"
      />
    );
  }

  public handleChange = (event, value) => {
    event.preventDefault();

    const selectedItems = value;

    this.setState({ selectedItems });

    this.props.onChange(selectedItems.map((i) => i.id));
  };
}

export default MemberChooser;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\components\common\MenuWithLinks.tsx -----

import Menu from "@mui/material/Menu";
import MenuItem from "@mui/material/MenuItem";
import Link from "next/link";
import { NextRouter, withRouter } from "next/router";
import React from "react";

type Props = {
  options: {
    href: string;
    as: string;
    highlighterSlug: string;
    text: string;
    externalServer: boolean;
    separator: boolean;
  }[];
  router: NextRouter;
  children: any;
};

type State = {
  anchorEl: Element | ((element: Element) => Element);
};

class MenuWithLinks extends React.PureComponent<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      anchorEl: null,
    };
  }

  public render() {
    const { options, children, router } = this.props;
    const { anchorEl } = this.state;

    return (
      <div style={{ textAlign: "center" }}>
        <div
          aria-controls={anchorEl ? "simple-menu" : null}
          aria-haspopup="true"
          onClick={this.handleClick}
          onKeyPress={this.handleClick}
        >
          {children}
        </div>
        <Menu id="simple-menu" anchorEl={anchorEl} open={Boolean(anchorEl)} onClose={this.handleClose} keepMounted>
          {options.map((option, i) =>
            option.separator ? (
              <hr style={{ width: "95%", margin: "10px auto" }} key={`separated-${i}`} />
            ) : option.externalServer ? (
              <MenuItem
                onClick={(event) => {
                  event.preventDefault();
                  window.location.href = option.href;
                  this.handleClose();
                }}
                key={option.href || option.text}
              >
                {option.text}
              </MenuItem>
            ) : (
              <Link key={option.href} href={option.href} as={option.as} passHref>
                <MenuItem
                  key={option.href}
                  style={{
                    fontWeight: router.asPath.includes(option.highlighterSlug) ? 600 : 300,
                    fontSize: "14px",
                  }}
                >
                  {option.text}
                </MenuItem>
              </Link>
            )
          )}
        </Menu>
      </div>
    );
  }

  public handleClick = (event) => {
    this.setState({ anchorEl: event.currentTarget });
  };

  public handleClose = () => {
    this.setState({ anchorEl: null });
  };
}

export default withRouter(MenuWithLinks);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\components\common\MenuWithMenuItems.tsx -----

import Menu from "@mui/material/Menu";
import MenuItem from "@mui/material/MenuItem";
import React from "react";

type Props = {
  menuOptions: any;
  itemOptions: any[];
};

type State = {
  menuElem: Element | ((element: Element) => Element);
};

class MenuWithMenuItems extends React.PureComponent<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      menuElem: null,
    };
  }

  public render() {
    const { menuOptions, itemOptions } = this.props;
    const { menuElem } = this.state;

    return (
      <div style={{ verticalAlign: "middle" }}>
        <i
          aria-controls={menuElem ? menuOptions.id : null}
          data-id={menuOptions.dataId}
          aria-haspopup="true"
          style={{ fontSize: "14px", opacity: 0.7, cursor: "pointer" }}
          className="material-icons"
          onClick={(e) => this.handleClick(e)}
        >
          more_vert
        </i>

        <Menu id={menuOptions.id} anchorEl={menuElem} open={Boolean(menuElem)} onClose={this.handleClose}>
          {itemOptions.map((option, i) => (
            <MenuItem
              key={option.dataId + i}
              data-id={option.dataId}
              data-more-id={option.dataMoreId}
              onClick={(e) => {
                this.setState({ menuElem: null });
                option.onClick(e);
              }}
            >
              {option.text}
            </MenuItem>
          ))}
        </Menu>
      </div>
    );
  }

  public handleClick = (event) => {
    event.preventDefault();
    this.setState({ menuElem: event.currentTarget });
  };

  public handleClose = () => {
    this.setState({ menuElem: null });
  };
}

export default MenuWithMenuItems;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\components\common\Notifier.tsx -----

import Snackbar from "@mui/material/Snackbar";
import React from "react";

export let openSnackbarExternal;

type State = {
  open: boolean;
  message: string;
};

class Notifier extends React.PureComponent<any, State> {
  constructor(props) {
    super(props);
    openSnackbarExternal = this.openSnackbar;

    this.state = {
      open: false,
      message: "",
    };
  }

  public render() {
    const message = <span id="snackbar-message-id" dangerouslySetInnerHTML={{ __html: this.state.message }} />;

    return (
      <Snackbar
        anchorOrigin={{ vertical: "top", horizontal: "right" }}
        message={message}
        autoHideDuration={5000}
        onClose={this.handleSnackbarClose}
        open={this.state.open}
        ContentProps={{
          "aria-describedby": "snackbar-message-id",
        }}
      />
    );
  }

  public handleSnackbarClose = () => {
    this.setState({
      open: false,
      message: "",
    });
  };

  public openSnackbar = ({ message }) => {
    this.setState({ open: true, message });
  };
}

export default Notifier;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\components\discussions\CreateDiscussionForm.tsx -----

import Button from "@mui/material/Button";
import Dialog from "@mui/material/Dialog";
import DialogContent from "@mui/material/DialogContent";
import DialogTitle from "@mui/material/DialogTitle";
import TextField from "@mui/material/TextField";
import { observer } from "mobx-react";
import Head from "next/head";
import Router from "next/router";
import NProgress from "nprogress";
import React from "react";

import notify from "../../lib/notify";
import { Store } from "../../lib/store";
import MemberChooser from "../common/MemberChooser";
import PostEditor from "../posts/PostEditor";

type Props = {
  isMobile: boolean;
  store: Store;
  open: boolean;
  onClose: () => void;
};

type State = {
  name: string;
  memberIds: string[];
  disabled: boolean;
  content: string;
};

class CreateDiscussionForm extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      name: "",
      memberIds: [],
      disabled: false,
      content: "",
    };
  }

  public render() {
    const { open, isMobile, store } = this.props;
    const { currentTeam, currentUser } = store;

    const membersMinusCreator = Array.from(currentTeam.members.values()).filter((user) => user._id !== currentUser._id);

    return (
      <React.Fragment>
        {open ? (
          <Head>
            <title>New Discussion</title>
            <meta name="description" content="Create new discussion" />
          </Head>
        ) : null}
        <Dialog onClose={this.handleClose} aria-labelledby="simple-dialog-title" open={open} fullScreen={true}>
          <DialogTitle id="simple-dialog-title">Create new Discussion</DialogTitle>
          <DialogContent>
            <br />
            <form style={{ width: "100%", height: "60%" }} onSubmit={this.onSubmit}>
              <p />
              <br />
              <TextField
                autoFocus
                label="Type name of Discussion"
                helperText="Give a short and informative name to new Discussion"
                value={this.state.name}
                onChange={(event) => {
                  this.setState({ name: event.target.value });
                }}
              />
              <br />
              <p />
              <MemberChooser
                helperText="These members will see all posts and be notified about unread posts in this discussion."
                onChange={this.handleMembersChange}
                members={membersMinusCreator}
                selectedMemberIds={this.state.memberIds}
              />
              <p />
              <br />
              <div>
                <Button type="submit" variant="contained" color="primary" disabled={this.state.disabled}>
                  Create Discussion
                </Button>
                {isMobile ? <p /> : null}
                <Button
                  variant="outlined"
                  onClick={this.handleClose}
                  disabled={this.state.disabled}
                  style={{ marginLeft: isMobile ? "0px" : "20px" }}
                >
                  Cancel
                </Button>{" "}
              </div>
              <p />
              <PostEditor
                content={this.state.content}
                onChanged={this.onContentChanged}
                members={Array.from(store.currentTeam.members.values())}
                store={store}
                parentComponent="CDF"
              />
              <p />
              <div>
                <Button type="submit" variant="contained" color="primary" disabled={this.state.disabled}>
                  Create Discussion
                </Button>
                {isMobile ? <p /> : null}
                <Button
                  variant="outlined"
                  onClick={this.handleClose}
                  disabled={this.state.disabled}
                  style={{ marginLeft: isMobile ? "0px" : "20px" }}
                >
                  Cancel
                </Button>{" "}
                <p />
                <br />
                <br />
              </div>
            </form>
          </DialogContent>
        </Dialog>
      </React.Fragment>
    );
  }

  public handleMembersChange = (memberIds) => {
    this.setState({ memberIds });
  };

  public handleClose = () => {
    this.setState({ name: "", memberIds: [], disabled: false, content: "" });
    this.props.onClose();
  };

  private onContentChanged = (content: string) => {
    console.log("onContentChanged", content);
    this.setState({ content });
  };

  private onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();

    const { store } = this.props;
    const { currentTeam } = store;

    if (!currentTeam) {
      notify("Team have not selected");
      return;
    }

    const { name, memberIds, content } = this.state;

    if (!name) {
      notify("Name is required");
      return;
    }

    if (!content) {
      notify("Content is required");
      return;
    }

    if (!memberIds || memberIds.length < 1) {
      notify("Please assign at least one person to this Discussion.");
      return;
    }

    this.setState({ disabled: true });
    NProgress.start();

    try {
      const discussion = await currentTeam.addDiscussion({
        name,
        memberIds,
      });

      await discussion.addPost(content);

      this.setState({ name: "", memberIds: [], content: "" });

      notify("You successfully added new Discussion.");

      Router.push(
        `/discussion?teamSlug=${currentTeam.slug}&discussionSlug=${discussion.slug}`,
        `/team/${currentTeam.slug}/discussions/${discussion.slug}`
      );
    } catch (error) {
      console.log(error);
      notify(error);
    } finally {
      this.setState({ disabled: false });
      NProgress.done();
      this.props.onClose();
    }
  };
}

export default observer(CreateDiscussionForm);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\components\discussions\DiscussionActionMenu.tsx -----

import { observer } from 'mobx-react';
import NProgress from 'nprogress';
import React from 'react';

import confirm from '../../lib/confirm';
import notify from '../../lib/notify';
import { Store } from '../../lib/store';
import { Discussion } from '../../lib/store/discussion';

import MenuWithMenuItems from '../common/MenuWithMenuItems';
import EditDiscussionForm from './EditDiscussionForm';

const getMenuOptions = (discussion) => ({
  dataId: discussion._id,
  id: `discussion-menu-${discussion._id}`,
});

const getMenuItemOptionsForCreator = (discussion, component) => [
  {
    text: 'Copy URL',
    dataId: discussion._id,
    onClick: component.handleCopyUrl,
  },
  {
    text: 'Edit',
    dataId: discussion._id,
    onClick: component.editDiscussion,
  },
  {
    text: 'Delete',
    dataId: discussion._id,
    onClick: component.deleteDiscussion,
  },
];

const getMenuItemOptions = (discussion, component) => [
  {
    text: 'Copy URL',
    dataId: discussion._id,
    onClick: component.handleCopyUrl,
  },
];

type Props = {
  discussion: Discussion;
  store: Store;
  isMobile: boolean;
};

type State = {
  discussionFormOpen: boolean;
  selectedDiscussion: Discussion;
};

class DiscussionActionMenu extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      discussionFormOpen: false,
      selectedDiscussion: null,
    };
  }

  public render() {
    const { discussion, store } = this.props;
    const { currentUser } = store;

    const isCreator = currentUser._id === discussion.createdUserId ? true : false;

    return (
      <React.Fragment>
        <MenuWithMenuItems
          menuOptions={getMenuOptions(discussion)}
          itemOptions={
            isCreator
              ? getMenuItemOptionsForCreator(discussion, this)
              : getMenuItemOptions(discussion, this)
          }
        />

        {this.state.discussionFormOpen ? (
          <EditDiscussionForm
            open={true}
            onClose={this.handleDiscussionFormClose}
            discussion={discussion}
            isMobile={this.props.isMobile}
            store={store}
          />
        ) : null}
      </React.Fragment>
    );
  }

  public handleCopyUrl = async (event) => {
    const { store } = this.props;
    const { currentTeam } = store;

    const id = event.currentTarget.dataset.id;
    if (!id) {
      return;
    }

    const selectedDiscussion = currentTeam.discussions.find((d) => d._id === id);
    const discussionUrl = `${process.env.NEXT_PUBLIC_URL_APP}/team/${currentTeam.slug}/discussions/${selectedDiscussion.slug}`;

    try {
      if (window.navigator) {
        await window.navigator.clipboard.writeText(discussionUrl);
        notify('You successfully copied URL.');
      }
    } catch (err) {
      notify(err);
    } finally {
      this.setState({ discussionFormOpen: false, selectedDiscussion: null });
    }
  };

  public editDiscussion = (event) => {
    const { currentTeam } = this.props.store;
    if (!currentTeam) {
      notify('You have not selected Team.');
      return;
    }

    const id = event.currentTarget.dataset.id;
    if (!id) {
      return;
    }

    const selectedDiscussion = currentTeam.discussions.find((d) => d._id === id);

    this.setState({ discussionFormOpen: true, selectedDiscussion });
  };

  public deleteDiscussion = async (event) => {
    const { currentTeam } = this.props.store;
    if (!currentTeam) {
      notify('You have not selected Team.');
      return;
    }

    const id = event.currentTarget.dataset.id;

    confirm({
      title: 'Are you sure?',
      message: '',
      onAnswer: async (answer) => {
        if (!answer) {
          return;
        }

        NProgress.start();

        try {
          await currentTeam.deleteDiscussion(id);

          notify('You successfully deleted Discussion.');
        } catch (error) {
          console.error(error);
          notify(error);
        } finally {
          NProgress.done();
        }
      },
    });
  };

  public handleDiscussionFormClose = () => {
    this.setState({ discussionFormOpen: false, selectedDiscussion: null });
  };
}

export default observer(DiscussionActionMenu);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\components\discussions\DiscussionList.tsx -----

import Tooltip from "@mui/material/Tooltip";
import { observer } from "mobx-react";
import React from "react";

import { Store } from "../../lib/store";
import { Team } from "../../lib/store/team";

import CreateDiscussionForm from "./CreateDiscussionForm";
import DiscussionListItem from "./DiscussionListItem";

import notify from "../../lib/notify";

type Props = { store: Store; team: Team; isMobile: boolean };

type State = { discussionFormOpen: boolean };

class DiscussionList extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      discussionFormOpen: false,
    };
  }

  public componentDidMount() {
    this.props.team.loadDiscussions().catch((err) => notify(err));
  }

  public componentDidUpdate(prevProps: Props) {
    if (this.props.team._id !== prevProps.team._id) {
      this.props.team.loadDiscussions().catch((err) => notify(err));
    }
  }

  public render() {
    const { store, team } = this.props;

    const isThemeDark = store && store.currentUser && store.currentUser.darkTheme === true;

    return (
      <div>
        Discussions
        <Tooltip title="Add Discussion" placement="right" disableFocusListener disableTouchListener>
          <a onClick={this.addDiscussion} style={{ float: "right", padding: "0px 10px" }}>
            <i
              className="material-icons"
              color="action"
              style={{ fontSize: 14, opacity: 0.7, color: isThemeDark ? "#fff" : "#000" }}
            >
              add_circle_outline
            </i>{" "}
          </a>
        </Tooltip>
        <p />
        <ul style={{ listStyle: "none", padding: "0px" }}>
          {team &&
            team.orderedDiscussions.map((d) => {
              return (
                <DiscussionListItem
                  key={d._id}
                  discussion={d}
                  team={team}
                  isMobile={this.props.isMobile}
                  store={this.props.store}
                />
              );
            })}
        </ul>
        <CreateDiscussionForm
          isMobile={this.props.isMobile}
          store={this.props.store}
          open={this.state.discussionFormOpen}
          onClose={this.handleDiscussionFormClose}
        />
      </div>
    );
  }

  public addDiscussion = (event) => {
    event.preventDefault();
    this.setState({ discussionFormOpen: true });
  };

  public handleDiscussionFormClose = () => {
    this.setState({ discussionFormOpen: false });
  };
}

export default observer(DiscussionList);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\components\discussions\DiscussionListItem.tsx -----

import Paper from "@mui/material/Paper";
import { observer } from "mobx-react";
import Link from "next/link";
import React from "react";

import { Store } from "../../lib/store";
import { Discussion } from "../../lib/store/discussion";
import { Team } from "../../lib/store/team";

import DiscussionActionMenu from "./DiscussionActionMenu";

type Props = {
  store: Store;
  discussion: Discussion;
  team: Team;
  isMobile: boolean;
};

class DiscussionListItem extends React.Component<Props> {
  public render() {
    const { store, discussion, team, isMobile } = this.props;
    const trimmingLength = 16;

    const selectedDiscussion = store.currentUrl === `/team/${team.slug}/discussions/${discussion.slug}`;

    console.log(store.currentUrl);

    const isThemeDark = store && store.currentUser && store.currentUser.darkTheme === true;

    const selectedItemBorder = isThemeDark ? "1px rgba(255, 255, 255, 0.75) solid" : "1px rgba(0, 0, 0, 0.75) solid";

    return (
      <Paper
        key={discussion._id}
        style={{
          margin: "10px 10px 5px 0px",
          padding: "8px",
          border: selectedDiscussion ? selectedItemBorder : "none",
        }}
        elevation={selectedDiscussion ? 24 : 1}
      >
        <li key={discussion._id} style={{ whiteSpace: "nowrap", paddingRight: "10px" }}>
          <Link
            scroll={false}
            href={`/discussion?teamSlug=${team.slug}&discussionSlug=${discussion.slug}`}
            as={`/team/${team.slug}/discussions/${discussion.slug}`}
            style={{ fontWeight: 300, color: isThemeDark ? "#fff" : "#000" }}
            key={discussion._id}
          >
            {discussion.name.length > trimmingLength
              ? `${discussion.name.substring(0, trimmingLength)}...`
              : discussion.name}
          </Link>
          <div
            style={{
              float: "right",
              marginRight: "-12px",
            }}
          >
            <DiscussionActionMenu discussion={discussion} isMobile={isMobile} store={store} />
          </div>
        </li>
      </Paper>
    );
  }
}

export default observer(DiscussionListItem);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\components\discussions\EditDiscussionForm.tsx -----

import Button from "@mui/material/Button";
import Dialog from "@mui/material/Dialog";
import DialogActions from "@mui/material/DialogActions";
import DialogContent from "@mui/material/DialogContent";
import DialogContentText from "@mui/material/DialogContentText";
import DialogTitle from "@mui/material/DialogTitle";
import TextField from "@mui/material/TextField";
import { observer } from "mobx-react";
import NProgress from "nprogress";
import React from "react";

import notify from "../../lib/notify";
import { Store } from "../../lib/store";
import { Discussion } from "../../lib/store/discussion";
import MemberChooser from "../common/MemberChooser";

type Props = {
  store: Store;
  onClose: () => void;
  open: boolean;
  discussion: Discussion;
  isMobile: boolean;
};

type State = {
  name: string;
  memberIds: string[];
  disabled: boolean;
  discussionId: string;
};

class EditDiscussionForm extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      name: "",
      memberIds: [],
      disabled: false,
      content: "",
    };
  }

  public static getDerivedStateFromProps(props: Props, state: State) {
    const { discussion } = props;

    if (state.discussionId === discussion._id) {
      return null;
    }

    return {
      name: (discussion && discussion.name) || "",
      memberIds: (discussion && discussion.memberIds) || [],
      discussionId: discussion._id,
    };
  }

  public render() {
    const { open, store } = this.props;
    const { currentTeam, currentUser } = store;

    const membersMinusCreator = Array.from(currentTeam.members.values()).filter((user) => user._id !== currentUser._id);

    // console.log(currentTeam.members);

    return (
      <Dialog onClose={this.handleClose} aria-labelledby="simple-dialog-title" open={open}>
        <DialogTitle id="simple-dialog-title">Edit Discussion</DialogTitle>
        <DialogContent>
          <DialogContentText>Edit discussion</DialogContentText>
          <br />
          <form onSubmit={this.onSubmit}>
            <TextField
              label="Type name of Discussion"
              helperText="Give a short and informative name to Discussion"
              value={this.state.name}
              onChange={(event) => {
                this.setState({ name: event.target.value });
              }}
            />
            <br />
            <p />
            <MemberChooser
              helperText="These members will see all posts and be notified about unread posts in this discussion."
              onChange={this.handleMembersChange}
              members={membersMinusCreator}
              selectedMemberIds={this.state.memberIds}
            />
            <p />
            <br />
            <DialogActions>
              <Button color="primary" variant="outlined" onClick={this.handleClose} disabled={this.state.disabled}>
                Cancel
              </Button>
              <Button type="submit" variant="contained" color="primary" disabled={this.state.disabled}>
                Update Discussion
              </Button>
            </DialogActions>
          </form>
        </DialogContent>
      </Dialog>
    );
  }

  public handleMembersChange = (memberIds) => {
    this.setState({ memberIds });
  };

  public handleClose = () => {
    this.setState({ name: "", memberIds: [], disabled: false });
    this.props.onClose();
  };

  private onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();

    const { discussion, store } = this.props;
    const { currentTeam } = store;

    if (!currentTeam) {
      notify("Team have not selected");
      return;
    }

    const { name, memberIds } = this.state;

    if (!name) {
      notify("Please name this Discussion.");
      return;
    }

    if (memberIds && !memberIds.includes(discussion.store.currentUser._id)) {
      memberIds.push(discussion.store.currentUser._id);
    }

    if (!memberIds || memberIds.length < 1) {
      notify("Please assign at least one person to this Discussion.");
      return;
    }

    NProgress.start();
    try {
      await discussion.editDiscussion({ name, memberIds });

      this.setState({ name: "", memberIds: [], disabled: false });
      notify("You successfully edited Discussion.");
    } catch (error) {
      console.log(error);
      notify(error);
    } finally {
      this.setState({ disabled: false });
      NProgress.done();

      this.props.onClose();
    }
  };
}

export default observer(EditDiscussionForm);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\components\layout\index.tsx -----

import Avatar from "@mui/material/Avatar";
import Button from "@mui/material/Button";
import Grid from "@mui/material/Grid";

import Link from "next/link";
import React from "react";

import MenuWithLinks from "../common/MenuWithLinks";
import Confirmer from "../common/Confirmer";
import Notifier from "../common/Notifier";

import { Store } from "../../lib/store";
import DiscussionList from "../discussions/DiscussionList";

const styleGrid = {
  width: "100%",
  height: "100vh",
  maxWidth: "100%",
  padding: "0px 10px",
  display: "flex",
  overflow: "hidden",
};

const styleGridIsMobile = {
  width: "100%",
  height: "100vh",
  maxWidth: "100%",
  padding: "0px 0px 0px 10px",
  display: "flex",
  overflow: "hidden",
};

function LayoutWrapper({
  children,
  isMobile,
  firstGridItem,
  store,
}: {
  children: React.ReactNode;
  isMobile: boolean;
  firstGridItem: boolean;
  store: Store;
}) {
  const isThemeDark = store.currentUser ? store.currentUser.darkTheme : true;

  return (
    <React.Fragment>
      <Grid
        container
        direction="row"
        justify="flex-start"
        alignItems="stretch"
        style={isMobile ? styleGridIsMobile : styleGrid}
      >
        {firstGridItem ? (
          <Grid
            item
            sm={2}
            xs={12}
            style={{
              borderRight: "1px #707070 solid",
              justifyContent: "center",
              overflow: "hidden",
            }}
          >
            <div style={{ display: "flex", justifyContent: "space-between" }}>
              <svg
                xmlns="http://www.w3.org/2000/svg"
                width="124"
                height="40"
                viewBox="0 0 124 40"
                style={{
                  marginTop: "20px",
                  display: "inline-flex",
                  height: "40px",
                }}
              >
                <g id="async-logo">
                  <g id="async-logo-40">
                    <circle id="Ellipse 2" cx="20" cy="20" r="20" fill="black" />
                    <path
                      id="path-async-logo"
                      d="M7.07825 -0.0960007V16H4.51825V13.088C4.04892 14.0907 3.33425 14.8693 2.37425 15.424C1.43558 15.9573 0.336917 16.224 -0.92175 16.224C-2.35108 16.224 -3.60975 15.8827 -4.69775 15.2C-5.76442 14.5173 -6.59642 13.5573 -7.19375 12.32C-7.76975 11.0613 -8.05775 9.6 -8.05775 7.936C-8.05775 6.272 -7.75908 4.81067 -7.16175 3.552C-6.56442 2.272 -5.73242 1.28 -4.66575 0.576C-3.57775 -0.128 -2.32975 -0.48 -0.92175 -0.48C0.336917 -0.48 1.43558 -0.202666 2.37425 0.352C3.31292 0.906667 4.02758 1.68533 4.51825 2.688V-0.0960007H7.07825ZM-0.40975 14.08C1.16892 14.08 2.38492 13.5467 3.23825 12.48C4.09158 11.392 4.51825 9.856 4.51825 7.872C4.51825 5.888 4.09158 4.36267 3.23825 3.296C2.38492 2.22933 1.16892 1.696 -0.40975 1.696C-1.98842 1.696 -3.22575 2.25067 -4.12175 3.36C-4.99642 4.448 -5.43375 5.97333 -5.43375 7.936C-5.43375 9.89867 -4.99642 11.4133 -4.12175 12.48C-3.24708 13.5467 -2.00975 14.08 -0.40975 14.08Z"
                      transform="translate(19.5938 12)"
                      fill="white"
                    />
                  </g>
                  <path
                    id="path-async-text"
                    d="M22.6251 11.928V24H20.7051V21.816C20.3531 22.568 19.8171 23.152 19.0971 23.568C18.3931 23.968 17.5691 24.168 16.6251 24.168C15.5531 24.168 14.6091 23.912 13.7931 23.4C12.9931 22.888 12.3691 22.168 11.9211 21.24C11.4891 20.296 11.2731 19.2 11.2731 17.952C11.2731 16.704 11.4971 15.608 11.9451 14.664C12.3931 13.704 13.0171 12.96 13.8171 12.432C14.6331 11.904 15.5691 11.64 16.6251 11.64C17.5691 11.64 18.3931 11.848 19.0971 12.264C19.8011 12.68 20.3371 13.264 20.7051 14.016V11.928H22.6251ZM17.0091 22.56C18.1931 22.56 19.1051 22.16 19.7451 21.36C20.3851 20.544 20.7051 19.392 20.7051 17.904C20.7051 16.416 20.3851 15.272 19.7451 14.472C19.1051 13.672 18.1931 13.272 17.0091 13.272C15.8251 13.272 14.8971 13.688 14.2251 14.52C13.5691 15.336 13.2411 16.48 13.2411 17.952C13.2411 19.424 13.5691 20.56 14.2251 21.36C14.8811 22.16 15.8091 22.56 17.0091 22.56ZM30.4637 24.168C28.4317 24.168 26.8237 23.648 25.6397 22.608L26.2877 21.168C26.9437 21.68 27.6077 22.048 28.2797 22.272C28.9517 22.496 29.7037 22.608 30.5357 22.608C31.4477 22.608 32.1357 22.456 32.5997 22.152C33.0797 21.832 33.3197 21.376 33.3197 20.784C33.3197 20.304 33.1597 19.92 32.8397 19.632C32.5197 19.344 31.9917 19.12 31.2557 18.96L29.2157 18.48C28.2077 18.256 27.4237 17.856 26.8637 17.28C26.3197 16.704 26.0477 16.016 26.0477 15.216C26.0477 14.16 26.4717 13.304 27.3197 12.648C28.1677 11.976 29.2877 11.64 30.6797 11.64C31.5277 11.64 32.3277 11.776 33.0797 12.048C33.8317 12.32 34.4637 12.712 34.9757 13.224L34.3277 14.64C33.1917 13.696 31.9757 13.224 30.6797 13.224C29.8157 13.224 29.1437 13.392 28.6637 13.728C28.1997 14.048 27.9677 14.504 27.9677 15.096C27.9677 15.592 28.1117 15.984 28.3997 16.272C28.7037 16.56 29.1837 16.784 29.8397 16.944L31.8797 17.448C32.9997 17.704 33.8317 18.104 34.3757 18.648C34.9197 19.176 35.1917 19.872 35.1917 20.736C35.1917 21.776 34.7677 22.608 33.9197 23.232C33.0717 23.856 31.9197 24.168 30.4637 24.168ZM48.687 11.928L43.047 25.104C42.455 26.48 41.711 27.488 40.815 28.128C39.919 28.768 38.815 29.208 37.503 29.448L37.095 27.936C38.231 27.68 39.087 27.336 39.663 26.904C40.255 26.488 40.743 25.84 41.127 24.96L41.607 23.88L36.495 11.928H38.535L42.615 21.888L46.743 11.928H48.687ZM56.853 11.64C59.749 11.64 61.197 13.232 61.197 16.416V24H59.253V16.512C59.253 15.392 59.029 14.576 58.581 14.064C58.133 13.536 57.429 13.272 56.469 13.272C55.349 13.272 54.453 13.616 53.781 14.304C53.109 14.992 52.773 15.92 52.773 17.088V24H50.829V15.312C50.829 14.064 50.765 12.936 50.637 11.928H52.485L52.677 14.088C53.045 13.304 53.597 12.704 54.333 12.288C55.069 11.856 55.909 11.64 56.853 11.64ZM69.9321 24.168C68.7641 24.168 67.7401 23.912 66.8601 23.4C65.9961 22.888 65.3241 22.168 64.8441 21.24C64.3801 20.296 64.1481 19.2 64.1481 17.952C64.1481 16.704 64.3881 15.608 64.8681 14.664C65.3481 13.704 66.0281 12.96 66.9081 12.432C67.8041 11.904 68.8441 11.64 70.0281 11.64C70.8441 11.64 71.6281 11.784 72.3801 12.072C73.1481 12.344 73.7801 12.728 74.2761 13.224L73.6281 14.664C73.0201 14.184 72.4281 13.832 71.8521 13.608C71.2921 13.384 70.7161 13.272 70.1241 13.272C68.8921 13.272 67.9241 13.688 67.2201 14.52C66.5161 15.336 66.1641 16.48 66.1641 17.952C66.1641 19.408 66.5081 20.544 67.1961 21.36C67.9001 22.16 68.8761 22.56 70.1241 22.56C70.7161 22.56 71.2921 22.448 71.8521 22.224C72.4281 22 73.0201 21.648 73.6281 21.168L74.2761 22.608C73.7641 23.088 73.1161 23.472 72.3321 23.76C71.5641 24.032 70.7641 24.168 69.9321 24.168Z"
                    transform="translate(39 4)"
                    fill={isThemeDark ? "white" : "black"}
                  />
                </g>
              </svg>
              <MenuWithLinks
                options={[
                  {
                    text: "Team Settings",
                    href: `/team-settings?teamSlug=${store.currentTeam.slug}`,
                    as: `/team/${store.currentTeam.slug}/team-settings`,
                    simple: true,
                  },
                  {
                    text: "Billing",
                    href: `/billing?teamSlug=${store.currentTeam.slug}`,
                    as: `/team/${store.currentTeam.slug}/billing`,
                    simple: true,
                  },
                  {
                    text: "Your Settings",
                    href: "/your-settings",
                    highlighterSlug: "/your-settings",
                  },
                  {
                    separator: true,
                  },
                  {
                    text: "Log out",
                    href: `${process.env.NEXT_PUBLIC_URL_API}/logout`,
                    as: `${process.env.NEXT_PUBLIC_URL_API}/logout`,
                    externalServer: true,
                  },
                ]}
              >
                <Avatar
                  src={store.currentUser.avatarUrl}
                  alt="Add username here later in the book"
                  style={{
                    margin: "20px auto",
                    cursor: "pointer",
                    display: "inline-flex",
                    width: "40px",
                    height: "40px",
                  }}
                />

                <i className="material-icons" color="action" style={{ verticalAlign: "super" }}>
                  arrow_drop_down
                </i>
              </MenuWithLinks>
            </div>
            <hr />
            <p />
            <p />
            <DiscussionList store={store} team={store.currentTeam} isMobile={isMobile} />
          </Grid>
        ) : null}

        {children}
      </Grid>
      <Notifier />
      <Confirmer />
    </React.Fragment>
  );
}

type Props = {
  children: React.ReactNode;
  isMobile?: boolean;
  firstGridItem?: boolean;
  store?: Store;
  teamRequired?: boolean;
};

class Layout extends React.Component<Props> {
  public render() {
    const { children, isMobile, firstGridItem, store, teamRequired } = this.props;

    const { currentUser, currentTeam } = store;

    // console.log(this.props.store.currentUser.darkTheme);

    // const isThemeDark = false;

    // console.log(isMobile);

    // console.log(currentTeam);

    if (!currentUser) {
      return (
        <LayoutWrapper firstGridItem={firstGridItem} isMobile={isMobile} store={store}>
          <Grid item sm={12} xs={12}>
            {children}
          </Grid>
        </LayoutWrapper>
      );
    }

    if (!currentTeam) {
      if (teamRequired) {
        return (
          <LayoutWrapper firstGridItem={firstGridItem} isMobile={isMobile} store={store}>
            <Grid item sm={10} xs={12} style={{ padding: "0px 35px", overflow: "auto", height: "auto" }}>
              <div style={{ padding: "20px" }}>
                Select existing team or create a new team.
                <p />
                <Link href="/create-team" as="/create-team">
                  <Button variant="outlined" color="primary">
                    Create new team
                  </Button>
                </Link>
              </div>
            </Grid>
          </LayoutWrapper>
        );
      } else {
        console.log("team not required");
        return (
          <LayoutWrapper firstGridItem={firstGridItem} isMobile={isMobile} store={store}>
            <Grid item sm={10} xs={12} style={{ padding: "0px 35px", overflow: "auto", height: "auto" }}>
              {children}
            </Grid>
          </LayoutWrapper>
        );
      }
    }

    return (
      <LayoutWrapper firstGridItem={firstGridItem} isMobile={isMobile} store={store}>
        <Grid
          item
          sm={firstGridItem ? 10 : 12}
          xs={12}
          style={{ padding: "0px 35px", overflowY: "auto", height: "inherit" }}
        >
          <div>
            {isMobile || store.currentUrl.includes("create-team") ? null : (
              <React.Fragment>
                <i
                  style={{
                    float: "left",
                    margin: "15px 0px 10px 25px",
                    opacity: 0.8,
                    fontSize: "18px",
                    cursor: "pointer",
                    verticalAlign: "top",
                  }}
                  className="material-icons"
                  onClick={async () => {
                    await store.currentUser.toggleTheme(!store.currentUser.darkTheme);
                  }}
                >
                  lens
                </i>
              </React.Fragment>
            )}
            <div style={{ clear: "both" }} />
          </div>
          {children}
        </Grid>
      </LayoutWrapper>
    );
  }
}

export default Layout;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\components\posts\PostContent.tsx -----

import React from 'react';

type Props = { html: string };

class PostContent extends React.Component<Props> {
  public render() {
    const { html } = this.props;

    return (
      <div
        style={{ fontSize: '15px', lineHeight: '2em', fontWeight: 300, wordBreak: 'break-all' }}
        dangerouslySetInnerHTML={{ __html: html }}
      />
    );
  }
}

export default PostContent;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\components\posts\PostDetail.tsx -----

import Avatar from "@mui/material/Avatar";
import Paper from "@mui/material/Paper";
import Tooltip from "@mui/material/Tooltip";
import { observer } from "mobx-react";
import moment from "moment";
import React from "react";

import confirm from "../../lib/confirm";
import notify from "../../lib/notify";
import { Store } from "../../lib/store";
import { Post } from "../../lib/store/post";
import { User } from "../../lib/store/user";

import MenuWithMenuItems from "../common/MenuWithMenuItems";

import PostContent from "./PostContent";

const stylePaper = {
  margin: "10px 0px",
  padding: "20px",
};

const styleLineSeparator = {
  verticalAlign: "text-bottom",
  fontWeight: 300,
  fontSize: "16px",
  margin: "0px 5px",
  opacity: 0.75,
};

const getMenuOptions = (post) => ({
  dataId: post._id,
  id: `post-menu-${post._id}`,
});

const getMenuItemOptions = (post: Post, currentUser: User, component) => {
  const items = [];

  if (post.createdUserId !== currentUser._id) {
    items.push({
      text: "Show Markdown",
      dataId: post._id,
      onClick: component.showMarkdown,
    });
  }

  if (post.createdUserId === currentUser._id) {
    const isFirstPost = post.discussion.posts.indexOf(post) === 0;

    items.push({
      text: "Edit",
      dataId: post._id,
      onClick: component.editPost,
    });

    if (!isFirstPost) {
      items.push({
        text: "Delete",
        dataId: post._id,
        onClick: component.deletePost,
      });
    }
  }

  return items;
};

type Props = {
  post: Post;
  store: Store;
  isMobile: boolean;
  onEditClick: (post) => void;
  onShowMarkdownClick: (post) => void;
};

class PostDetail extends React.Component<Props> {
  public render() {
    const { post, isMobile } = this.props;

    return <Paper style={stylePaper}>{this.renderPostDetail(post, isMobile)}</Paper>;
  }

  public renderPostDetail(post: Post, isMobile) {
    const createdDate = moment(post.createdAt).local().format("MMM Do YYYY");
    const lastUpdatedDate = moment(post.lastUpdatedAt).fromNow();

    return (
      <React.Fragment>
        <div
          style={{
            float: "left",
            margin: "-12px 10px 0px -15px",
            zIndex: 1000,
          }}
        >
          {this.renderMenu()}
        </div>
        <div id={`post-${post._id}`}>
          {post.user && (
            <Tooltip title={post.user.displayName} placement="top" disableFocusListener disableTouchListener>
              <Avatar
                src={post.user.avatarUrl}
                alt={post.user.displayName}
                style={{
                  width: "40px",
                  height: "40px",
                  margin: "0px 10px 0px 5px",
                  cursor: "pointer",
                  float: "left",
                }}
              />
            </Tooltip>
          )}
          <div
            style={{
              margin: isMobile ? "0px" : "0px 20px 0px 70px",
              fontWeight: 300,
              lineHeight: "1em",
            }}
          >
            <span style={{ fontSize: "12px", fontWeight: 400 }}>
              {`By: ${post.user && post.user.displayName}` || "User"}
              <span style={styleLineSeparator}>|</span>
              {`Created: ${post.createdAt && createdDate}` || ""}

              {post.isEdited ? (
                <React.Fragment>
                  <span style={styleLineSeparator}>|</span>
                  Last edited: {lastUpdatedDate}
                </React.Fragment>
              ) : null}
            </span>

            <PostContent html={post.htmlContent} />
          </div>
        </div>
      </React.Fragment>
    );
  }

  public renderMenu() {
    const { post, store } = this.props;
    const { currentUser } = store;

    if (!post.user || !currentUser) {
      return null;
    }

    return (
      <MenuWithMenuItems
        menuOptions={getMenuOptions(post)}
        itemOptions={getMenuItemOptions(post, store.currentUser, this)}
      />
    );
  }

  public showMarkdown = () => {
    const { post, onShowMarkdownClick } = this.props;
    if (onShowMarkdownClick) {
      onShowMarkdownClick(post);
    }
  };

  public editPost = () => {
    const { post, onEditClick } = this.props;
    if (onEditClick) {
      onEditClick(post);
    }
    console.log(`PostDetail: ${post._id}`);
  };

  public deletePost = () => {
    confirm({
      title: "Are you sure?",
      message: "",
      onAnswer: async (answer) => {
        if (answer) {
          const { post } = this.props;
          await post.discussion.deletePost(post);
          notify("You successfully deleted Post.");
        }
      },
    });
  };
}

export default observer(PostDetail);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\components\posts\PostEditor.tsx -----

import Avatar from "@mui/material/Avatar";
import Button from "@mui/material/Button";
import he from "he";
import { marked } from "marked";
import { observer } from "mobx-react";
import NProgress from "nprogress";
import React from "react";
import { Mention, MentionsInput } from "react-mentions";

import {
  getSignedRequestForUploadApiMethod,
  uploadFileUsingSignedPutRequestApiMethod,
} from "../../lib/api/team-member";
import notify from "../../lib/notify";
import { resizeImage } from "../../lib/resizeImage";
import { Store } from "../../lib/store";
import { User } from "../../lib/store/user";

import PostContent from "./PostContent";

function getImageDimension(file): Promise<{ width: number; height: number }> {
  const reader = new FileReader();
  const img = new Image();

  return new Promise((resolve) => {
    reader.readAsDataURL(file);

    reader.onload = (e) => {
      img.onload = () => {
        resolve({ width: img.width, height: img.height });
      };

      img.src = e.target.result.toString();
    };
  });
}

type Props = {
  store: Store;
  onChanged: (content) => void;
  content: string;
  members: User[];
  textareaHeight?: string;
  placeholder?: string;
  parentComponent: string;
};

type State = { htmlContent: string };

class PostEditor extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      htmlContent: "",
    };
  }

  public render() {
    const { htmlContent } = this.state;
    const { content, members, store, parentComponent } = this.props;
    const { currentUser } = store;

    const membersMinusCurrentUser = members.filter((member) => member._id !== currentUser._id);

    const isThemeDark = store && store.currentUser && store.currentUser.darkTheme === true;
    const textareaBackgroundColor = isThemeDark ? "#0d1117" : "#fff";

    return (
      <div style={{ marginTop: "20px" }}>
        <div style={{ display: "inline-flex" }}>
          <Button
            onClick={this.showMarkdownContent}
            variant="text"
            style={{ fontWeight: htmlContent ? 300 : 600, color: "#58a6ff" }}
          >
            Markdown
          </Button>{" "}
          <Button
            onClick={this.showHtmlContent}
            variant="text"
            style={{ fontWeight: htmlContent ? 600 : 300, color: "#58a6ff" }}
          >
            HTML
          </Button>
        </div>

        <div style={{ display: "inline", float: "left" }}>
          <label htmlFor={"upload-file-post-editor-" + parentComponent}>
            <Button component="span">
              <i className="material-icons" style={{ fontSize: "22px", color: "#58a6ff" }}>
                insert_photo
              </i>
            </Button>
          </label>
          <input
            accept="image/*"
            name={"upload-file-post-editor-" + parentComponent}
            id={"upload-file-post-editor-" + parentComponent}
            type="file"
            style={{ display: "none" }}
            onChange={async (event) => {
              const file = event.target.files[0];
              await this.uploadFile(file);
              event.target.value = "";
            }}
          />
        </div>
        <br />
        <div
          style={{
            width: "100%",
            height: "100vh",
            padding: "10px 15px",
            border: isThemeDark ? "1px solid rgba(255, 255, 255, 0.5)" : "1px solid rgba(0, 0, 0, 0.5)",
          }}
        >
          {htmlContent ? (
            <PostContent html={htmlContent} />
          ) : (
            <MentionsInput
              style={{
                input: {
                  border: "none",
                  outline: "none",
                  color: isThemeDark ? "#fff" : "#000",
                  fontWeight: 300,
                  height: "100vh",
                  lineHeight: "1.5em",
                  backgroundColor: content ? textareaBackgroundColor : "transparent",
                },
                suggestions: {
                  list: {
                    backgroundColor: "#222",
                    color: "#fff",
                  },

                  item: {
                    padding: "5px 15px",
                    borderBottom: "1px solid rgba(0,0,0,0.15)",

                    "&focused": {
                      backgroundColor: "rgba(255, 255, 255, 0.1)",
                    },
                  },
                },
              }}
              autoFocus
              value={content}
              placeholder={this.props.placeholder ? this.props.placeholder : "Compose new post"}
              onChange={(event) => {
                this.props.onChanged(event.target.value);
              }}
            >
              <Mention
                trigger="@"
                data={membersMinusCurrentUser.map((u) => ({
                  id: u.avatarUrl,
                  display: u.displayName,
                  // you: u._id === currentUser._id ? true : false,
                }))}
                markup={"[`@#__display__`](__id__)"}
                displayTransform={(_, display) => {
                  return `@${display}`;
                }}
                renderSuggestion={(suggestion) => (
                  <React.Fragment>
                    <Avatar
                      role="presentation"
                      src={suggestion.id}
                      alt={suggestion.display}
                      style={{
                        width: "24px",
                        height: "24px",
                        marginRight: "10px",
                        display: "inline-flex",
                        verticalAlign: "middle",
                      }}
                    />
                    <span style={{ marginRight: "5px" }}>{suggestion.display}</span>
                  </React.Fragment>
                )}
              />
            </MentionsInput>
          )}
        </div>
      </div>
    );
  }

  public showMarkdownContent = () => {
    this.setState({ htmlContent: "" });
  };

  public showHtmlContent = async () => {
    const { content } = this.props;

    function markdownToHtml(postContent) {
      const renderer = new marked.Renderer();

      renderer.link = (href, title, text) => {
        const t = title ? ` title="${title}"` : "";

        if (text.startsWith("<code>@#")) {
          return `${text.replace("<code>@#", "<code>@")} `;
        }

        return `
          <a target="_blank" href="${href}" rel="noopener noreferrer"${t}>
            ${text}
          </a>
        `;
      };

      marked.setOptions({
        renderer,
        breaks: true,
      });

      return marked(he.decode(postContent));
    }

    const htmlContent = content ? markdownToHtml(content) : "<span>Nothing to preview.</span>";
    this.setState({ htmlContent });
  };

  private uploadFile = async (file: File) => {
    if (!file) {
      notify("No file selected.");
      return;
    }

    if (!file.type || (!file.type.startsWith("image/") && file.type !== "application/pdf")) {
      notify("Wrong file.");
      return;
    }

    const { store } = this.props;
    const { currentTeam } = store;

    NProgress.start();

    const bucket = process.env.NEXT_PUBLIC_BUCKET_FOR_POSTS;
    const prefix = `${currentTeam.slug}`;
    const fileName = file.name;
    const fileType = file.type;

    try {
      const responseFromApiServerForUpload = await getSignedRequestForUploadApiMethod({
        fileName,
        fileType,
        prefix,
        bucket,
      });

      let fileHtmlOrMarkdown;
      let fileUrl;

      if (file.type.startsWith("image/")) {
        const { width } = await getImageDimension(file);
        const resizedFile = await resizeImage(file, 1024, 1024);

        await uploadFileUsingSignedPutRequestApiMethod(resizedFile, responseFromApiServerForUpload.signedRequest);

        fileUrl = responseFromApiServerForUpload.url;

        console.log(fileUrl);

        const finalWidth = width > 768 ? "100%" : `${width}px`;

        fileHtmlOrMarkdown = `
          <div>
            <img style="max-width: ${finalWidth}; width:100%" src="${fileUrl}" alt="Async" class="s3-image" />
          </div>`;
      } else {
        await uploadFileUsingSignedPutRequestApiMethod(file, responseFromApiServerForUpload.signedRequest);

        fileUrl = responseFromApiServerForUpload.url;
        fileHtmlOrMarkdown = `[${file.name}](${fileUrl})`;
      }

      const content = `${this.props.content}\n${fileHtmlOrMarkdown.replace(/\s+/g, " ")}`;

      this.props.onChanged(content);

      notify("You successfully uploaded file.");
    } catch (error) {
      console.log(error);
      notify(error);
    } finally {
      NProgress.done();
    }
  };
}

export default observer(PostEditor);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\components\posts\PostForm.tsx -----

import Button from "@mui/material/Button";
import he from "he";
import { marked } from "marked";
import { observer } from "mobx-react";
import NProgress from "nprogress";
import React from "react";

import notify from "../../lib/notify";
import { Store } from "../../lib/store";
import { Discussion } from "../../lib/store/discussion";
import { Post } from "../../lib/store/post";
import { User } from "../../lib/store/user";

import PostEditor from "./PostEditor";

type Props = {
  store: Store;
  isMobile: boolean;
  members: User[];
  post: Post;
  discussion: Discussion;
  showMarkdownToNonCreator?: boolean;
  onFinished?: () => void;
};

type State = {
  postId: string;
  content: string;
  disabled: boolean;
};

class PostForm extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      postId: null,
      content: "",
      disabled: false,
    };
  }

  public static getDerivedStateFromProps(props: Props, state: State) {
    const { post } = props;

    if (!post && !state.postId) {
      return null;
    }

    if (post && post._id === state.postId) {
      return null;
    }

    return {
      postId: (post && post._id) || null,
      content: (post && post.content) || "",
    };
  }

  public render() {
    const { store, members, post, isMobile, showMarkdownToNonCreator } = this.props;
    const isEditingPost = !!post;

    let title = "Add Post";
    if (showMarkdownToNonCreator) {
      title = "Showing Markdown";
    } else if (isEditingPost) {
      title = "Edit Post";
    }

    return (
      <div style={{ height: "100%", margin: "0px 20px" }}>
        <p />
        <br />
        <h3>{title}</h3>
        <form style={{ width: "100%", height: "100%" }} onSubmit={this.onSubmit} autoComplete="off">
          <p />
          <br />
          <div>
            {showMarkdownToNonCreator ? null : (
              <React.Fragment>
                <Button type="submit" variant="contained" color="primary" disabled={this.state.disabled}>
                  {isEditingPost ? "Save changes" : "Publish Post"}
                </Button>
                {isMobile ? <p /> : null}
              </React.Fragment>
            )}
            {isEditingPost ? (
              <Button
                variant="outlined"
                onClick={this.closeForm}
                disabled={this.state.disabled}
                style={{ marginLeft: "10px" }}
              >
                {showMarkdownToNonCreator ? "Go back" : "Cancel"}
              </Button>
            ) : null}
          </div>
          <p />
          <br />
          <PostEditor
            content={this.state.content}
            onChanged={this.onContentChanged}
            members={members}
            store={store}
            textareaHeight="100%"
            parentComponent="PF"
          />
          <p />
          <div style={{ margin: "20px 0px" }}>
            {isEditingPost ? (
              <Button
                variant="outlined"
                onClick={this.closeForm}
                disabled={this.state.disabled}
                style={{ marginLeft: "10px" }}
              >
                {showMarkdownToNonCreator ? "Go back" : "Cancel"}
              </Button>
            ) : null}
          </div>
          <p />
          <br />
        </form>
      </div>
    );
  }

  private onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();

    const { content } = this.state;
    const htmlContent = marked(he.decode(content));
    const { post, onFinished, store, discussion } = this.props;
    const isEditingPost = !!post;

    if (!content) {
      notify("Add content to your Post");
      return;
    }

    if (isEditingPost) {
      this.setState({ disabled: true });
      NProgress.start();
      try {
        await post.editPost({ content, htmlContent });
        notify("You successfully edited Post");
      } catch (error) {
        console.log(error);
        notify(error);
      } finally {
        this.setState({ disabled: false });
        NProgress.done();
      }

      if (onFinished) {
        onFinished();
      }

      return;
    }

    const { currentTeam } = store;
    if (!currentTeam) {
      notify("Team is not selected or does not exist.");
      return;
    }

    NProgress.start();
    this.setState({ disabled: true });

    try {
      await discussion.addPost(content);

      this.setState({ content: "" });
      notify("You successfully published new Post.");
    } catch (error) {
      console.log(error);
      notify(error);
    } finally {
      this.setState({ disabled: false });
      NProgress.done();
    }

    if (onFinished) {
      onFinished();
    }
  };

  private onContentChanged = (content: string) => {
    this.setState({ content });
  };

  private closeForm = () => {
    this.setState({ postId: null, content: "" });

    const { onFinished } = this.props;
    if (onFinished) {
      onFinished();
    }
  };
}

export default observer(PostForm);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\components\teams\InviteMember.tsx -----

import Button from "@mui/material/Button";
import Dialog from "@mui/material/Dialog";
import DialogContent from "@mui/material/DialogContent";
import DialogTitle from "@mui/material/DialogTitle";
import TextField from "@mui/material/TextField";
import { inject, observer } from "mobx-react";
import NProgress from "nprogress";
import React from "react";

import notify from "../../lib/notify";
import { Store } from "../../lib/store";

type Props = {
  store: Store;
  onClose: () => void;
  open: boolean;
};

type State = {
  email: string;
  disabled: boolean;
};

class InviteMember extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      email: "",
      disabled: false,
    };
  }

  public render() {
    const { open } = this.props;

    return (
      <Dialog onClose={this.handleClose} aria-labelledby="invite-member-dialog-title" open={open}>
        <DialogTitle id="invite-member-dialog-title">Invite member</DialogTitle>
        <DialogContent>
          <form onSubmit={this.onSubmit} style={{ padding: "20px" }}>
            <TextField
              autoComplete="off"
              value={this.state.email}
              placeholder="Email"
              onChange={(event) => {
                this.setState({ email: event.target.value });
              }}
            />
            <p />
            <br />
            <Button variant="outlined" onClick={this.handleClose} disabled={this.state.disabled}>
              Cancel
            </Button>{" "}
            <Button type="submit" variant="contained" color="primary" disabled={this.state.disabled}>
              Invite
            </Button>
          </form>
        </DialogContent>
      </Dialog>
    );
  }

  private handleClose = () => {
    this.setState({ email: "", disabled: false });
    this.props.onClose();
  };

  private onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();

    const { store } = this.props;

    if (!store.currentTeam) {
      notify("Team have not selected");
      return;
    }

    const { email } = this.state;

    if (!email) {
      notify("Email is required");
      return;
    }

    NProgress.start();
    try {
      this.setState({ disabled: true });
      await store.currentTeam.inviteMember(email);

      this.setState({ email: "" });
      notify("You successfully sent invitation.");
      NProgress.done();
    } catch (error) {
      console.log(error);
      notify(error);
    } finally {
      this.props.onClose();
      this.setState({ disabled: false });
      NProgress.done();
    }
  };
}

export default inject("store")(observer(InviteMember));

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\lib\api\makeQueryString.ts -----

function makeQueryString(params) {
  const query = Object.keys(params)
    .filter((k) => !!params[k])
    .map((k) => `${encodeURIComponent(k)}=${encodeURIComponent(params[k])}`)
    .join('&');

  return query;
}

export { makeQueryString };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\lib\api\public.ts -----

import sendRequestAndGetResponse from './sendRequestAndGetResponse';

const BASE_PATH = '/api/v1/public';

export const getUserApiMethod = (request) =>
  sendRequestAndGetResponse(`${BASE_PATH}/get-user`, {
    request,
    method: 'GET',
  });

export const getUserBySlugApiMethod = (slug) =>
  sendRequestAndGetResponse(`${BASE_PATH}/get-user-by-slug`, {
    body: JSON.stringify({ slug }),
  });

export const emailLoginLinkApiMethod = ({
  email,
  invitationToken,
}: {
  email: string;
  invitationToken?: string;
}) =>
  sendRequestAndGetResponse('/auth/email-login-link', {
    qs: { invitationToken },
    body: JSON.stringify({ user: email }),
  });

export const getTeamByTokenApiMethod = (token: string, request) =>
  sendRequestAndGetResponse(`${BASE_PATH}/invitations/get-team-by-token`, {
    request,
    method: 'GET',
    qs: { token },
  });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\lib\api\sendRequestAndGetResponse.ts -----

import 'isomorphic-unfetch';

import { makeQueryString } from './makeQueryString';

export default async function sendRequestAndGetResponse(path, opts: any = {}) {
  const headers = Object.assign(
    {},
    opts.headers || {},
    opts.externalServer
      ? {}
      : {
          'Content-type': 'application/json; charset=UTF-8',
        },
  );

  const { request } = opts;

  if (request && request.headers && request.headers.cookie) {
    headers.cookie = request.headers.cookie;
  }

  // const qs = opts.qs || '';

  const qs = (opts.qs && `?${makeQueryString(opts.qs)}`) || '';

  // console.log(`before: ${process.env.NEXT_PUBLIC_URL_API}${path}${qs}`);

  const response = await fetch(
    opts.externalServer ? `${path}${qs}` : `${process.env.NEXT_PUBLIC_URL_API}${path}${qs}`,
    Object.assign({ method: 'POST', credentials: 'include' }, opts, { headers }),
  );

  // console.log(`after: ${process.env.NEXT_PUBLIC_URL_API}${path}${qs}`);

  // console.log(response.status);
  // console.log(response.statusText);

  const text = await response.text();

  if (response.status >= 400) {
    console.error(text);
    throw new Error(response.status.toString());
  }

  try {
    const data = JSON.parse(text);

    return data;
  } catch (err) {
    if (err instanceof SyntaxError) {
      return text;
    }

    throw err;
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\lib\api\team-leader.ts -----

import sendRequestAndGetResponse from './sendRequestAndGetResponse';

const BASE_PATH = '/api/v1/team-leader';

export const addTeamApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams/add`, {
    body: JSON.stringify(data),
  });

export const updateTeamApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams/update`, {
    body: JSON.stringify(data),
  });

export const getTeamInvitationsApiMethod = (teamId: string) =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams/get-invitations-for-team`, {
    method: 'GET',
    qs: { teamId },
  });

export const inviteMemberApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams/invite-member`, {
    body: JSON.stringify(data),
  });

export const removeMemberApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams/remove-member`, {
    body: JSON.stringify(data),
  });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\lib\api\team-member.ts -----

import sendRequestAndGetResponse from './sendRequestAndGetResponse';

const BASE_PATH = '/api/v1/team-member';

export const getSignedRequestForUploadApiMethod = ({ fileName, fileType, prefix, bucket }) =>
  sendRequestAndGetResponse(`${BASE_PATH}/aws/get-signed-request-for-upload-to-s3`, {
    body: JSON.stringify({ fileName, fileType, prefix, bucket }),
  });

export const uploadFileUsingSignedPutRequestApiMethod = (file, signedRequest, headers = {}) =>
  sendRequestAndGetResponse(signedRequest, {
    externalServer: true,
    method: 'PUT',
    body: file,
    headers,
  });

export const updateProfileApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/user/update-profile`, {
    body: JSON.stringify(data),
  });

export const toggleThemeApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/user/toggle-theme`, {
    body: JSON.stringify(data),
  });

export const getInitialDataApiMethod = (options: any = {}) =>
  sendRequestAndGetResponse(
    `${BASE_PATH}/get-initial-data`,
    Object.assign(
      {
        body: JSON.stringify(options.data || {}),
      },
      options,
    ),
  );

export const getTeamListApiMethod = () =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams`, {
    method: 'GET',
  });

export const getTeamMembersApiMethod = (teamId: string) =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams/get-members`, {
    method: 'GET',
    qs: { teamId },
  });

// Discussion and Post

export const getDiscussionListApiMethod = (params): Promise<{ discussions: any[] }> =>
  sendRequestAndGetResponse(`${BASE_PATH}/discussions/list`, {
    method: 'GET',
    qs: params,
  });

export const addDiscussionApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/discussions/add`, {
    body: JSON.stringify(data),
  });

export const editDiscussionApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/discussions/edit`, {
    body: JSON.stringify(data),
  });

export const deleteDiscussionApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/discussions/delete`, {
    body: JSON.stringify(data),
  });

export const getPostListApiMethod = (discussionId: string) =>
  sendRequestAndGetResponse(`${BASE_PATH}/posts/list`, {
    method: 'GET',
    qs: { discussionId },
  });

export const addPostApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/posts/add`, {
    body: JSON.stringify(data),
  });

export const editPostApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/posts/edit`, {
    body: JSON.stringify(data),
  });

export const deletePostApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/posts/delete`, {
    body: JSON.stringify(data),
  });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\lib\store\discussion.ts -----

import { action, decorate, IObservableArray, observable, runInAction, computed } from 'mobx';

import {
  addPostApiMethod,
  deletePostApiMethod,
  editDiscussionApiMethod,
  getPostListApiMethod,
} from '../api/team-member';
import { Store } from './index';
import { Team } from './team';
import { Post } from './post';

class Discussion {
  public _id: string;
  public createdUserId: string;
  public store: Store;
  public team: Team;

  public name: string;
  public slug: string;
  public memberIds: IObservableArray<string> = observable([]);
  public posts: IObservableArray<Post> = observable([]);
  public isLoadingPosts = false;

  constructor(params) {
    this._id = params._id;
    this.createdUserId = params.createdUserId;
    this.store = params.store;
    this.team = params.team;

    this.name = params.name;
    this.slug = params.slug;
    this.memberIds.replace(params.memberIds || []);

    if (params.initialPosts) {
      this.setInitialPosts(params.initialPosts);
      console.log(params.initialPosts[0]);
    } else {
      this.loadPosts();
    }
  }

  public async editDiscussion(data) {
    try {
      await editDiscussionApiMethod({
        id: this._id,
        ...data,
        socketId: (this.store.socket && this.store.socket.id) || null,
      });

      runInAction(() => {
        this.changeLocalCache(data);
      });
    } catch (error) {
      console.error(error);
      throw error;
    }
  }

  public changeLocalCache(data) {
    this.name = data.name;
    this.memberIds.replace(data.memberIds || []);
  }

  get members() {
    return this.memberIds.map((id) => this.team.members.get(id)).filter((u) => !!u);
  }

  public setInitialPosts(posts) {
    const postObjs = posts.map((p) => new Post({ discussion: this, store: this.store, ...p }));
    this.posts.replace(postObjs);
  }

  public async loadPosts() {
    if (this.store.isServer || this.isLoadingPosts) {
      return;
    }

    this.isLoadingPosts = true;

    try {
      const { posts = [] } = await getPostListApiMethod(this._id);

      runInAction(() => {
        const postObjs = posts.map((t) => new Post({ discussion: this, store: this.store, ...t }));
        this.posts.replace(postObjs);
      });
    } finally {
      runInAction(() => {
        this.isLoadingPosts = false;
      });
    }
  }

  public async addPost(content: string): Promise<Post> {
    const { post } = await addPostApiMethod({
      discussionId: this._id,
      content,
      socketId: (this.store.socket && this.store.socket.id) || null,
    });

    return new Promise<Post>((resolve) => {
      runInAction(() => {
        const obj = this.addPostToLocalCache(post);
        resolve(obj);
      });
    });
  }

  public addPostToLocalCache(data) {
    const postObj = new Post({ discussion: this, store: this.store, ...data });

    this.posts.push(postObj);

    return postObj;
  }

  public async deletePost(post: Post) {
    await deletePostApiMethod({
      id: post._id,
      discussionId: this._id,
      socketId: (this.store.socket && this.store.socket.id) || null,
    });

    runInAction(() => {
      this.posts.remove(post);
    });
  }

  public joinSocketRooms() {
    if (this.store.socket) {
      console.log('joining socket discussion room', this.name);
      this.store.socket.emit('joinTeamRoom', this.team._id);
      this.store.socket.emit('joinDiscussionRoom', this._id);
    }
  }

  public leaveSocketRooms() {
    if (this.store.socket) {
      console.log('leaving socket discussion room', this.name);
      this.store.socket.emit('leaveTeamRoom', this.team._id);
      this.store.socket.emit('leaveDiscussionRoom', this._id);
    }
  }

  public handleDiscussionRealtimeEvent = (data) => {
    console.log('discussion realtime event', data);
    const { actionType } = data;

    if (actionType === 'added') {
      this.addDiscussionToLocalCache(data.discussion);
    } else if (actionType === 'edited') {
      this.editDiscussionFromLocalCache(data.discussion);
    } else if (actionType === 'deleted') {
      this.deleteDiscussionFromLocalCache(data.id);
    }
  };

  public addDiscussionToLocalCache(data): Discussion {
    const obj = new Discussion({ team: this.team, store: this.store, ...data });

    if (obj.memberIds.includes(this.store.currentUser._id)) {
      this.team.discussions.push(obj);
    }

    return obj;
  }

  public editDiscussionFromLocalCache(data) {
    const discussion = this.team.discussions.find((item) => item._id === data._id);
    if (discussion) {
      if (data.memberIds && data.memberIds.includes(this.store.currentUser._id)) {
        discussion.changeLocalCache(data);
      } else {
        this.deleteDiscussionFromLocalCache(data._id);
      }
    } else if (data.memberIds && data.memberIds.includes(this.store.currentUser._id)) {
      this.addDiscussionToLocalCache(data);
    }
  }

  public deleteDiscussionFromLocalCache(discussionId: string) {
    const discussion = this.team.discussions.find((item) => item._id === discussionId);
    this.team.discussions.remove(discussion);
  }

  public handlePostRealtimeEvent(data) {
    const { actionType } = data;

    if (actionType === 'added') {
      this.addPostToLocalCache(data.post);
    } else if (actionType === 'edited') {
      this.editPostFromLocalCache(data.post);
    } else if (actionType === 'deleted') {
      this.deletePostFromLocalCache(data.id);
    }
  }

  public editPostFromLocalCache(data) {
    const post = this.posts.find((t) => t._id === data._id);
    if (post) {
      post.changeLocalCache(data);
    }
  }

  public deletePostFromLocalCache(postId) {
    const post = this.posts.find((t) => t._id === postId);
    this.posts.remove(post);
  }
}

decorate(Discussion, {
  name: observable,
  slug: observable,
  memberIds: observable,
  posts: observable,
  isLoadingPosts: observable,

  editDiscussion: action,
  changeLocalCache: action,

  setInitialPosts: action,
  loadPosts: action,
  addPost: action,
  addPostToLocalCache: action,
  deletePost: action,

  addDiscussionToLocalCache: action,
  editDiscussionFromLocalCache: action,
  deleteDiscussionFromLocalCache: action,
  editPostFromLocalCache: action,
  deletePostFromLocalCache: action,

  members: computed,
});

export { Discussion };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\lib\store\index.ts -----

import * as mobx from 'mobx';
import { action, decorate, IObservableArray, observable } from 'mobx';
import { useStaticRendering } from 'mobx-react';
// @ts-expect-error no exported member io socket.io-client
import { io } from 'socket.io-client';

import { addTeamApiMethod, getTeamInvitationsApiMethod } from '../api/team-leader';
import { getTeamListApiMethod, getTeamMembersApiMethod } from '../api/team-member';

import { User } from './user';
import { Team } from './team';

useStaticRendering(typeof window === 'undefined');

mobx.configure({ enforceActions: 'observed' });

class Store {
  public isServer: boolean;

  public currentUser?: User = null;
  public currentUrl = '';

  public currentTeam?: Team;

  public teams: IObservableArray<Team> = observable([]);

  public socket: SocketIOClient.Socket;

  constructor({
    initialState = {},
    isServer,
    socket = null,
  }: {
    initialState?: any;
    isServer: boolean;
    socket?: SocketIOClient.Socket;
  }) {
    this.isServer = !!isServer;

    this.setCurrentUser(initialState.user);

    this.currentUrl = initialState.currentUrl || '';

    // console.log(initialState.user);

    if (initialState.teamSlug || (initialState.user && initialState.user.defaultTeamSlug)) {
      this.setCurrentTeam(
        initialState.teamSlug || initialState.user.defaultTeamSlug,
        initialState.teams,
      );
    }

    if (initialState.teams && initialState.teams.length > 0) {
      this.setInitialTeamsStoreMethod(initialState.teams);
    }

    this.socket = socket;

    if (socket) {
      socket.on('disconnect', () => {
        console.log('socket: ## disconnected');
      });

      socket.on('reconnect', (attemptNumber) => {
        console.log('socket: $$ reconnected', attemptNumber);
      });
    }
  }

  public changeCurrentUrl(url: string) {
    this.currentUrl = url;
  }

  public async setCurrentUser(user) {
    if (user) {
      this.currentUser = new User({ store: this, ...user });
    } else {
      this.currentUser = null;
    }
  }

  public async addTeam({ name, avatarUrl }: { name: string; avatarUrl: string }): Promise<Team> {
    const data = await addTeamApiMethod({ name, avatarUrl });
    const team = new Team({ store: this, ...data });

    return team;
  }

  public async setCurrentTeam(slug: string, initialTeams: any[]) {
    if (this.currentTeam) {
      if (this.currentTeam.slug === slug) {
        return;
      }
    }

    let found = false;

    const teams = initialTeams || (await getTeamListApiMethod()).teams;

    for (const team of teams) {
      if (team.slug === slug) {
        found = true;
        this.currentTeam = new Team({ ...team, store: this });

        const users =
          team.initialMembers || (await getTeamMembersApiMethod(this.currentTeam._id)).users;

        const invitations =
          team.initialInvitations ||
          (await getTeamInvitationsApiMethod(this.currentTeam._id)).invitations;

        this.currentTeam.setInitialMembersAndInvitations(users, invitations);

        break;
      }
    }

    if (!found) {
      this.currentTeam = null;
    }
  }

  private setInitialTeamsStoreMethod(teams: any[]) {
    // console.log(initialTeams);

    const teamObjs = teams.map((t) => new Team({ store: this, ...t }));

    this.teams.replace(teamObjs);
  }
}

decorate(Store, {
  currentUser: observable,
  currentUrl: observable,
  currentTeam: observable,

  changeCurrentUrl: action,
  setCurrentUser: action,
  setCurrentTeam: action,
});

let store: Store = null;

function initializeStore(initialState = {}) {
  const isServer = typeof window === 'undefined';

  const socket = isServer
    ? null
    : io(process.env.NEXT_PUBLIC_URL_API, {
        reconnection: true,
        autoConnect: true,
        transports: ['polling', 'websocket'],
        withCredentials: true,
      });

  const _store =
    store !== null && store !== undefined ? store : new Store({ initialState, isServer, socket });

  // For SSG and SSR always create a new store
  if (typeof window === 'undefined') {
    return _store;
  }
  // Create the store once in the client
  if (!store) {
    store = _store;
  }

  // console.log(_store);

  return _store;
}

function getStore() {
  return store;
}

export { Store, initializeStore, getStore };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\lib\store\invitation.ts -----

class Invitation {
  public _id: string;
  public teamId: string;
  public email: string;
  public createdAt: Date;

  constructor(params) {
    Object.assign(this, params);
  }
}

export { Invitation };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\lib\store\post.ts -----

import { action, computed, decorate, observable, runInAction } from 'mobx';

import { editPostApiMethod } from '../api/team-member';

import { Store } from './index';
import { User } from './user';
import { Discussion } from './discussion';

export class Post {
  public _id: string;
  public createdUserId: string;
  public createdAt: Date;
  public discussionId: string;

  public discussion: Discussion;
  public store: Store;

  public content: string;
  public htmlContent: string;

  public isEdited: boolean;
  public lastUpdatedAt: Date;

  constructor(params) {
    this._id = params._id;
    this.createdUserId = params.createdUserId;
    this.createdAt = params.createdAt;
    this.discussionId = params.discussionId;

    this.content = params.content;
    this.htmlContent = params.htmlContent;

    this.discussion = params.discussion;
    this.store = params.store;

    this.isEdited = params.isEdited;
    this.lastUpdatedAt = params.lastUpdatedAt;
  }

  public async editPost(data) {
    try {
      await editPostApiMethod({
        id: this._id,
        content: data.content,
        socketId: (this.store.socket && this.store.socket.id) || null,
      });

      runInAction(() => {
        this.changeLocalCache(data);
      });
    } catch (error) {
      console.error(error);
      throw error;
    }
  }

  public changeLocalCache(data) {
    this.content = data.content;
    this.htmlContent = data.htmlContent;
    this.isEdited = true;
    this.lastUpdatedAt = data.lastUpdatedAt;
  }

  get user(): User {
    return this.discussion.team.members.get(this.createdUserId) || null;
  }
}

decorate(Post, {
  content: observable,
  htmlContent: observable,
  isEdited: observable,
  lastUpdatedAt: observable,

  editPost: action,
  changeLocalCache: action,

  user: computed,
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\lib\store\team.ts -----

import { action, computed, decorate, IObservableArray, observable, runInAction } from 'mobx';
import Router from 'next/router';
import {
  inviteMemberApiMethod,
  removeMemberApiMethod,
  updateTeamApiMethod,
} from '../api/team-leader';
import {
  addDiscussionApiMethod,
  deleteDiscussionApiMethod,
  getDiscussionListApiMethod,
} from '../api/team-member';
import { Store } from './index';
import { User } from './user';
import { Invitation } from './invitation';
import { Discussion } from './discussion';

class Team {
  public store: Store;

  public _id: string;
  public teamLeaderId: string;

  public name: string;
  public slug: string;
  public avatarUrl: string;
  public memberIds: IObservableArray<string> = observable([]);
  public members: Map<string, User> = new Map();
  public invitations: Map<string, Invitation> = new Map();

  public currentDiscussion?: Discussion;
  public currentDiscussionSlug?: string;
  public discussions: IObservableArray<Discussion> = observable([]);
  public isLoadingDiscussions = false;

  constructor(params) {
    this._id = params._id;
    this.teamLeaderId = params.teamLeaderId;
    this.slug = params.slug;
    this.name = params.name;
    this.avatarUrl = params.avatarUrl;
    this.memberIds.replace(params.memberIds || []);
    this.currentDiscussionSlug = params.currentDiscussionSlug || null;

    this.store = params.store;

    if (params.initialDiscussions) {
      this.setInitialDiscussions(params.initialDiscussions);
    } else {
      this.loadDiscussions();
    }
  }

  public setInitialMembersAndInvitations(users, invitations) {
    this.members.clear();
    this.invitations.clear();

    for (const user of users) {
      if (this.store.currentUser && this.store.currentUser._id === user._id) {
        this.members.set(user._id, this.store.currentUser);
      } else {
        this.members.set(user._id, new User(user));
      }
    }

    for (const invitation of invitations || []) {
      this.invitations.set(invitation._id, new Invitation(invitation));
    }

    // console.log(this.members);
  }

  public async updateTheme({ name, avatarUrl }: { name: string; avatarUrl: string }) {
    try {
      const { slug } = await updateTeamApiMethod({
        teamId: this._id,
        name,
        avatarUrl,
      });

      runInAction(() => {
        this.name = name;
        this.avatarUrl = avatarUrl;
        this.slug = slug;
      });
    } catch (error) {
      console.error(error);
      throw error;
    }
  }

  public async inviteMember(email: string) {
    try {
      const { newInvitation } = await inviteMemberApiMethod({ teamId: this._id, email });

      runInAction(() => {
        this.invitations.set(newInvitation._id, new Invitation(newInvitation));
      });
    } catch (error) {
      console.error(error);
      throw error;
    }
  }

  public async removeMember(userId: string) {
    try {
      await removeMemberApiMethod({ teamId: this._id, userId });

      runInAction(() => {
        this.members.delete(userId);
        this.memberIds.remove(userId);
      });
    } catch (error) {
      console.error(error);
      throw error;
    }
  }

  public setCurrentDiscussion({ slug }: { slug: string }) {
    this.currentDiscussionSlug = slug;
    for (const discussion of this.discussions) {
      if (discussion && discussion.slug === slug) {
        this.currentDiscussion = discussion;
        break;
      }
    }
  }

  public setInitialDiscussions(discussions) {
    const discussionObjs = discussions.map(
      (d) => new Discussion({ team: this, store: this.store, ...d }),
    );

    this.discussions.replace(discussionObjs);

    if (!this.currentDiscussionSlug && this.discussions.length > 0) {
      this.currentDiscussionSlug = this.orderedDiscussions[0].slug;
    }

    if (this.currentDiscussionSlug) {
      this.setCurrentDiscussion({ slug: this.currentDiscussionSlug });
    }
  }

  public async loadDiscussions() {
    if (this.store.isServer || this.isLoadingDiscussions) {
      return;
    }

    this.isLoadingDiscussions = true;

    try {
      const { discussions = [] } = await getDiscussionListApiMethod({
        teamId: this._id,
      });
      const newList: Discussion[] = [];

      runInAction(() => {
        discussions.forEach((d) => {
          const disObj = this.discussions.find((obj) => obj._id === d._id);
          if (disObj) {
            disObj.changeLocalCache(d);
            newList.push(disObj);
          } else {
            newList.push(new Discussion({ team: this, store: this.store, ...d }));
          }
        });

        this.discussions.replace(newList);
      });
    } finally {
      runInAction(() => {
        this.isLoadingDiscussions = false;
      });
    }
  }

  public changeLocalCache(data) {
    this.name = data.name;
    this.memberIds.replace(data.memberIds || []);
  }

  public async addDiscussion(data): Promise<Discussion> {
    const { discussion } = await addDiscussionApiMethod({
      teamId: this._id,
      socketId: (this.store.socket && this.store.socket.id) || null,
      ...data,
    });

    return new Promise<Discussion>((resolve) => {
      runInAction(() => {
        const obj = this.addDiscussionToLocalCache(discussion);
        resolve(obj);
      });
    });
  }

  public addDiscussionToLocalCache(data): Discussion {
    const obj = new Discussion({ team: this, store: this.store, ...data });

    if (obj.memberIds.includes(this.store.currentUser._id)) {
      this.discussions.push(obj);
    }

    return obj;
  }

  public async deleteDiscussion(id: string) {
    await deleteDiscussionApiMethod({
      id,
      socketId: (this.store.socket && this.store.socket.id) || null,
    });

    runInAction(() => {
      this.deleteDiscussionFromLocalCache(id);

      const discussion = this.discussions.find((d) => d._id === id);

      if (this.currentDiscussion === discussion) {
        this.currentDiscussion = null;
        this.currentDiscussionSlug = null;

        if (this.discussions.length > 0) {
          const d = this.discussions[0];

          Router.push(
            `/discussion?teamSlug=${this.slug}&discussionSlug=${d.slug}`,
            `/team/${this.slug}/discussions/${d.slug}`,
          );
        } else {
          Router.push(`/discussion?teamSlug=${this.slug}`, `/team/${this.slug}/discussions`);
        }
      }
    });
  }

  public deleteDiscussionFromLocalCache(discussionId: string) {
    const discussion = this.discussions.find((item) => item._id === discussionId);
    this.discussions.remove(discussion);
  }

  public getDiscussionBySlug(slug: string): Discussion {
    return this.discussions.find((d) => d.slug === slug);
  }

  get orderedDiscussions() {
    return this.discussions.slice().sort();
  }
}

decorate(Team, {
  name: observable,
  slug: observable,
  avatarUrl: observable,
  memberIds: observable,
  members: observable,
  invitations: observable,
  currentDiscussion: observable,
  currentDiscussionSlug: observable,
  isLoadingDiscussions: observable,
  discussions: observable,

  setInitialMembersAndInvitations: action,
  updateTheme: action,
  inviteMember: action,
  removeMember: action,
  setInitialDiscussions: action,
  loadDiscussions: action,
  addDiscussion: action,
  addDiscussionToLocalCache: action,
  deleteDiscussion: action,
  deleteDiscussionFromLocalCache: action,
  getDiscussionBySlug: action,

  orderedDiscussions: computed,
});

export { Team };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\lib\store\user.ts -----

import { action, decorate, observable, runInAction } from 'mobx';

import * as NProgress from 'nprogress';

import { toggleThemeApiMethod, updateProfileApiMethod } from '../api/team-member';
import { Store } from './index';

class User {
  public store: Store;

  public _id: string;
  public slug: string;
  public email: string | null;
  public displayName: string | null;
  public avatarUrl: string | null;
  public isSignedupViaGoogle: boolean;

  public darkTheme = false;
  public defaultTeamSlug: string;

  constructor(params) {
    this.store = params.store;
    this._id = params._id;
    this.slug = params.slug;
    this.email = params.email;
    this.displayName = params.displayName;
    this.avatarUrl = params.avatarUrl;
    this.isSignedupViaGoogle = !!params.isSignedupViaGoogle;
    this.darkTheme = !!params.darkTheme;
    this.defaultTeamSlug = params.defaultTeamSlug;
  }

  public async updateProfile({ name, avatarUrl }: { name: string; avatarUrl: string }) {
    const { updatedUser } = await updateProfileApiMethod({
      name,
      avatarUrl,
    });

    runInAction(() => {
      this.displayName = updatedUser.displayName;
      this.avatarUrl = updatedUser.avatarUrl;
      this.slug = updatedUser.slug;
    });
  }

  public async toggleTheme(darkTheme: boolean) {
    await toggleThemeApiMethod({ darkTheme });
    runInAction(() => {
      this.darkTheme = darkTheme;
    });
    NProgress.start();
    NProgress.set(0.5);
    window.location.reload();
  }
}

decorate(User, {
  slug: observable,
  email: observable,
  displayName: observable,
  avatarUrl: observable,
  // darkTheme: observable,
  defaultTeamSlug: observable,

  updateProfile: action,
  toggleTheme: action,
});

export { User };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\lib\confirm.ts -----

import { openConfirmDialogExternal } from '../components/common/Confirmer';

export default function confirm({
  title,
  message,
  onAnswer,
}: {
  title: string;
  message: string;
  onAnswer: (answer) => void;
}) {
  openConfirmDialogExternal({ title, message, onAnswer });
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\lib\isMobile.ts -----

const mobileRE = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i;

export function isMobile(opts) {
  if (!opts) {
    opts = {};
  }

  let ua = opts.ua;

  if (!ua && typeof navigator !== 'undefined') {
    ua = navigator.userAgent;
  }

  if (!ua && opts.req && opts.req.headers && typeof opts.req.headers['user-agent'] === 'string') {
    ua = opts.req.headers['user-agent'];
    // console.log(ua);
  }

  if (typeof ua !== 'string') {
    return false;
  }

  return mobileRE.test(ua);
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\lib\notify.ts -----

import { openSnackbarExternal } from '../components/common/Notifier';

export default function notify(obj) {
  openSnackbarExternal({ message: obj.message || obj.toString() });
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\lib\resizeImage.ts -----

function resizeImage(file: File, MAX_WIDTH, MAX_HEIGHT) {
  const image = document.createElement('img');

  const resize = (resolve) => () => {
    let isResizeNeeded = false;
    let width = image.width;
    let height = image.height;

    if (width > height) {
      if (width > MAX_WIDTH) {
        isResizeNeeded = true;
        height *= MAX_WIDTH / width;
        width = MAX_WIDTH;
      }
    } else {
      if (height > MAX_HEIGHT) {
        isResizeNeeded = true;
        width *= MAX_HEIGHT / height;
        height = MAX_HEIGHT;
      }
    }

    if (isResizeNeeded) {
      const canvas = document.createElement('canvas');

      canvas.width = width;
      canvas.height = height;

      console.log(width, height);

      const ctx = canvas.getContext('2d');
      ctx.drawImage(image, 0, 0, width, height);

      canvas.toBlob((blob) => {
        resolve(blob);
      }, file.type);
    } else {
      resolve(file);
    }
  };

  return new Promise((resolve) => {
    const reader = new FileReader();

    console.log(`before ${image.src}`);

    reader.readAsDataURL(file);

    reader.onload = (e) => {
      image.src = e.target.result.toString();

      image.onload = resize(resolve);

      console.log(`after ${image.src}`);
    };
  });
}

export { resizeImage };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\lib\sharedStyles.ts -----

const styleBigAvatar = {
  width: '80px',
  height: '80px',
  margin: '0px auto 15px',
};

const styleRaisedButton = {
  margin: '15px',
  font: '14px Roboto',
};

const styleToolbar = {
  background: '#FFF',
  height: '64px',
  paddingRight: '20px',
};

const styleTextField = {
  font: '15px Roboto',
  color: '#222',
  fontWeight: '300',
};

const styleForm = {
  margin: '7% auto',
  width: '360px',
};

export {
  styleBigAvatar,
  styleRaisedButton,
  styleToolbar,
  styleTextField,
  styleForm,
};

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\lib\theme.ts -----

import { createMuiTheme } from "@mui/material/styles";

const themeDark = createMuiTheme({
  palette: {
    primary: { main: "#238636" },
    secondary: { main: "#b62324" },
    type: "dark",
    background: { default: "#0d1117" },
    text: {
      primary: "#c9d1d9",
    },
  },
  typography: {
    button: {
      textTransform: "none",
    },
  },
});

const themeLight = createMuiTheme({
  palette: {
    primary: { main: "#238636" },
    secondary: { main: "#b62324" },
    type: "light",
    background: { default: "#fff" },
    text: {
      primary: "#222",
    },
  },
  typography: {
    button: {
      textTransform: "none",
    },
  },
});

export { themeDark, themeLight };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\lib\withAuth.tsx -----

import { observer } from 'mobx-react';
import Router from 'next/router';
import React from 'react';

import * as NProgress from 'nprogress';

import { Store, getStore } from './store';

Router.events.on('routeChangeStart', () => {
  NProgress.start();
});

Router.events.on('routeChangeComplete', (url) => {
  const store = getStore();
  if (store) {
    store.changeCurrentUrl(url);
  }

  NProgress.done();
});

Router.events.on('routeChangeError', () => NProgress.done());

export default function withAuth(Component, { loginRequired = true, logoutRequired = false } = {}) {
  class WithAuth extends React.Component<{ store: Store }> {
    public static async getInitialProps(ctx) {
      console.log('WithAuth.getInitialProps');

      const { req } = ctx;

      let pageComponentProps = {};

      if (Component.getInitialProps) {
        pageComponentProps = await Component.getInitialProps(ctx);
      }

      return {
        ...pageComponentProps,
        isServer: !!req,
      };
    }

    public componentDidMount() {
      console.log('WithAuth.componentDidMount');

      const { store } = this.props;
      const user = store.currentUser;

      if (loginRequired && !logoutRequired && !user) {
        Router.push('/login');
        return;
      }

      let redirectUrl = '/login';
      let asUrl = '/login';
      if (user) {
        if (!user.defaultTeamSlug) {
          redirectUrl = '/create-team';
          asUrl = '/create-team';
        } else {
          redirectUrl = `/your-settings`;
          asUrl = `/your-settings`;
        }
      }

      if (logoutRequired && user) {
        Router.push(redirectUrl, asUrl);
      }
    }

    public render() {
      const { store } = this.props;
      const user = store.currentUser;

      if (loginRequired && !logoutRequired && !user) {
        return null;
      }

      if (logoutRequired && user) {
        return null;
      }

      return <Component {...this.props} />;
    }
  }

  return observer(WithAuth);
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\pages\create-team.tsx -----

import { inject, observer } from "mobx-react";
import * as React from "react";

import Avatar from "@mui/material/Avatar";
import Button from "@mui/material/Button";
import Grid from "@mui/material/Grid";
import TextField from "@mui/material/TextField";
import Head from "next/head";
import Router from "next/router";

import { getSignedRequestForUploadApiMethod, uploadFileUsingSignedPutRequestApiMethod } from "../lib/api/team-member";
import notify from "../lib/notify";
import { resizeImage } from "../lib/resizeImage";
import { Store } from "../lib/store";
import withAuth from "../lib/withAuth";

import Layout from "../components/layout";

const styleGrid = {
  height: "100%",
};

type Props = { store: Store; isMobile: boolean; teamRequired: boolean };

type State = { newName: string; newAvatarUrl: string; disabled: boolean };

class CreateTeam extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      newName: "",
      newAvatarUrl: "https://storage.googleapis.com/async-await/default-user.png?v=1",
      disabled: false,
    };
  }

  public render() {
    const { newAvatarUrl } = this.state;

    console.log(this.props.store);

    return (
      <Layout {...this.props}>
        <Head>
          <title>Create Team</title>
          <meta name="description" content="Create a new Team at SaaS Boilerplate" />
        </Head>
        <div style={{ padding: "0px", fontSize: "14px", height: "100%" }}>
          <Grid container style={styleGrid}>
            <Grid item sm={12} xs={12} style={{ padding: this.props.isMobile ? "0px" : "0px 30px" }}>
              <h3>Create team</h3>
              <p />
              <form onSubmit={this.onSubmit}>
                <h4>Team name</h4>
                <TextField
                  value={this.state.newName}
                  label="Type your team's name."
                  helperText="Team name as seen by your team members."
                  onChange={(event) => {
                    this.setState({ newName: event.target.value });
                  }}
                />
                <p />
                <h4 style={{ marginTop: "40px" }}>Team logo (optional)</h4>
                <Avatar
                  src={newAvatarUrl}
                  style={{
                    display: "inline-flex",
                    verticalAlign: "middle",
                    marginRight: 20,
                    width: 60,
                    height: 60,
                  }}
                />
                <label htmlFor="upload-file">
                  <Button variant="outlined" color="primary" component="span">
                    Select team logo
                  </Button>
                </label>
                <input
                  accept="image/*"
                  name="upload-file"
                  id="upload-file"
                  type="file"
                  style={{ display: "none" }}
                  onChange={this.previewTeamLogo}
                />
                <p />
                <br />
                <br />
                <Button variant="contained" color="primary" type="submit" disabled={this.state.disabled}>
                  Create new team
                </Button>
              </form>
            </Grid>
          </Grid>
          <br />
        </div>
      </Layout>
    );
  }

  private onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();

    const { newName } = this.state;

    const { store } = this.props;

    if (!newName) {
      notify("Team name is required.");
      return;
    }

    const file = (document.getElementById("upload-file") as HTMLFormElement).files[0];

    try {
      this.setState({ disabled: true });

      const defaultAvatarUrl = "https://storage.googleapis.com/async-await/default-user.png?v=1";
      const team = await store.addTeam({
        name: newName,
        avatarUrl: defaultAvatarUrl,
      });

      console.log(`Returned to client: ${team._id}, ${team.name}, ${team.slug}`);

      if (file == null) {
        Router.push(`/team/${team.slug}/team-settings`);
        notify("You successfully created Team.<p />Redirecting...");
        return;
      }

      const fileName = file.name;
      const fileType = file.type;
      const bucket = process.env.NEXT_PUBLIC_BUCKET_FOR_TEAM_LOGOS;
      const prefix = team.slug;

      const responseFromApiServerForUpload = await getSignedRequestForUploadApiMethod({
        fileName,
        fileType,
        prefix,
        bucket,
      });

      const resizedFile = await resizeImage(file, 128, 128);

      await uploadFileUsingSignedPutRequestApiMethod(resizedFile, responseFromApiServerForUpload.signedRequest, {
        "Cache-Control": "max-age=2592000",
      });

      const uploadedAvatarUrl = responseFromApiServerForUpload.url;

      await team.updateTheme({ name: team.name, avatarUrl: uploadedAvatarUrl });

      this.setState({
        newName: "",
        newAvatarUrl: "https://storage.googleapis.com/async-await/default-user.png?v=1",
      });

      (document.getElementById("upload-file") as HTMLFormElement).value = "";

      Router.push(`/team/${team.slug}/team-settings`);

      notify("You successfully created Team. Redirecting ...");
    } catch (error) {
      console.log(error);
      notify(error);
    } finally {
      this.setState({ disabled: false });
    }
  };

  private previewTeamLogo = () => {
    const file = (document.getElementById("upload-file") as HTMLFormElement).files[0];
    if (!file) {
      return;
    }

    const reader = new FileReader();

    reader.readAsDataURL(file);

    reader.onload = (e) => {
      this.setState({ newAvatarUrl: e.target.result as string });
    };
  };
}

export default withAuth(inject("store")(observer(CreateTeam)));

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\pages\discussion.tsx -----

import Avatar from "@mui/material/Avatar";
import Tooltip from "@mui/material/Tooltip";
import Head from "next/head";
import Router from "next/router";
import * as React from "react";

import { observer } from "mobx-react";

import Layout from "../components/layout";
import PostDetail from "../components/posts/PostDetail";
import PostForm from "../components/posts/PostForm";
import notify from "../lib/notify";
import { Store } from "../lib/store";
import { Discussion } from "../lib/store/discussion";
import withAuth from "../lib/withAuth";
import { Post } from "lib/store/post";

type Props = {
  store: Store;
  teamSlug: string;
  discussionSlug: string;
  isServer: boolean;
  isMobile: boolean;
  teamRequired: boolean;
};

type State = {
  selectedPost: Post;
  showMarkdownClicked: boolean;
};

class DiscussionPageComp extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      selectedPost: null,
      showMarkdownClicked: false,
    };
  }

  public render() {
    const { store, isMobile, discussionSlug } = this.props;
    const { currentTeam } = store;
    const { selectedPost } = this.state;

    if (!currentTeam || currentTeam.slug !== this.props.teamSlug) {
      return (
        <Layout {...this.props}>
          <Head>
            <title>No Team is found.</title>
          </Head>
          <div style={{ padding: isMobile ? "0px" : "0px 30px" }}>No Team is found.</div>
        </Layout>
      );
    }

    const discussion = this.getDiscussion(discussionSlug);

    if (!discussion) {
      if (currentTeam.isLoadingDiscussions) {
        return (
          <Layout {...this.props}>
            <Head>
              <title>Loading...</title>
            </Head>
            <div style={{ padding: isMobile ? "0px" : "0px 30px" }}>
              <p>Loading Discussions...</p>
            </div>
          </Layout>
        );
      } else {
        return (
          <Layout {...this.props}>
            <Head>
              <title>No Discussion is found.</title>
            </Head>
            <div style={{ padding: isMobile ? "0px" : "0px 30px" }}>
              <p>No Discussion is found.</p>
            </div>
          </Layout>
        );
      }
    }

    const title = discussion ? `${discussion.name}  Discussion` : "Discussions";

    return (
      <Layout {...this.props}>
        <Head>
          <title>{title}</title>
          <meta
            name="description"
            content={discussion ? `Discussion ${discussion.name} by Team ${currentTeam.name}` : "Discussions"}
          />
        </Head>
        <div style={{ padding: isMobile ? "0px" : "0px 30px", height: "100vh" }}>
          <h4>
            <span style={{ fontWeight: 300 }}>Discussion : </span>
            {(discussion && discussion.name) || "No Discussion is found."}
          </h4>{" "}
          Visible to :{" "}
          {discussion
            ? discussion.members.map((m) => (
                <Tooltip title={m.displayName} placement="right" disableFocusListener disableTouchListener key={m._id}>
                  <Avatar
                    role="presentation"
                    src={m.avatarUrl}
                    alt={m.avatarUrl}
                    key={m._id}
                    style={{
                      margin: "0px 5px",
                      display: "inline-flex",
                      width: "30px",
                      height: "30px",
                      verticalAlign: "middle",
                    }}
                  />
                </Tooltip>
              ))
            : null}
          <p />
          {this.renderPosts()}
          {discussion && !discussion.isLoadingPosts ? (
            <React.Fragment>
              {selectedPost ? null : (
                <PostForm
                  post={null}
                  discussion={discussion}
                  members={discussion.members}
                  isMobile={this.props.isMobile}
                  store={store}
                />
              )}
            </React.Fragment>
          ) : null}
          <p />
          <br />
        </div>
      </Layout>
    );
  }

  public getDiscussion(slug: string): Discussion {
    const { store, teamSlug } = this.props;
    const { currentTeam } = store;

    if (!currentTeam) {
      return;
    }

    if (!slug && currentTeam.discussions.length > 0) {
      Router.replace(
        `/discussion?teamSlug=${teamSlug}&discussionSlug=${currentTeam.orderedDiscussions[0].slug}`,
        `/team/${teamSlug}/discussions/${currentTeam.orderedDiscussions[0].slug}`
      );
      return;
    }

    if (slug && currentTeam) {
      return currentTeam.getDiscussionBySlug(slug);
    }

    return null;
  }

  public renderPosts() {
    const { isServer, store, isMobile } = this.props;
    const { selectedPost, showMarkdownClicked } = this.state;
    const discussion = this.getDiscussion(this.props.discussionSlug);

    if (!discussion.isLoadingPosts && discussion.posts.length === 0) {
      return <p>Empty Discussion.</p>;
    }

    let loading = "loading Posts ...";
    if (discussion.posts.length > 0) {
      loading = "checking for newer Posts ...";
    }

    return (
      <React.Fragment>
        {discussion
          ? discussion.posts.map((p) =>
              selectedPost && selectedPost._id === p._id ? (
                <PostForm
                  store={store}
                  isMobile={isMobile}
                  key={p._id}
                  post={p}
                  showMarkdownToNonCreator={showMarkdownClicked}
                  discussion={discussion}
                  members={discussion.members}
                  onFinished={() => {
                    this.setState({
                      selectedPost: null,
                      showMarkdownClicked: false,
                    });
                  }}
                />
              ) : (
                <PostDetail
                  key={p._id}
                  post={p}
                  onEditClick={this.onEditClickCallback}
                  onShowMarkdownClick={this.onSnowMarkdownClickCallback}
                  isMobile={this.props.isMobile}
                  store={store}
                />
              )
            )
          : null}

        {discussion && discussion.isLoadingPosts && !isServer ? <p>{loading}</p> : null}
      </React.Fragment>
    );
  }

  public onEditClickCallback = (post) => {
    this.setState({ selectedPost: post, showMarkdownClicked: false });
  };

  public onSnowMarkdownClickCallback = (post) => {
    this.setState({ selectedPost: post, showMarkdownClicked: true });
  };

  public componentDidMount() {
    const { discussionSlug, store, isServer } = this.props;

    if (store.currentTeam && (!isServer || !discussionSlug)) {
      store.currentTeam.loadDiscussions().catch((err) => notify(err));
    }

    const discussion = this.getDiscussion(discussionSlug);

    if (discussion) {
      discussion.joinSocketRooms();
    }

    console.log(store.socket);

    store.socket.on("discussionEvent", this.handleDiscussionEvent);
    store.socket.on("postEvent", this.handlePostEvent);
    store.socket.on("reconnect", this.handleSocketReconnect);
  }

  public componentWillUnmount() {
    const { discussionSlug, store } = this.props;

    const discussion = this.getDiscussion(discussionSlug);

    if (discussion) {
      discussion.leaveSocketRooms();
    }

    store.socket.off("discussionEvent", this.handleDiscussionEvent);
    store.socket.off("postEvent", this.handlePostEvent);
    store.socket.off("reconnect", this.handleSocketReconnect);
  }

  public componentDidUpdate(prevProps: Props) {
    const { discussionSlug, isServer } = this.props;

    if (prevProps.discussionSlug !== discussionSlug) {
      if (prevProps.discussionSlug) {
        const prevDiscussion = this.getDiscussion(prevProps.discussionSlug);
        if (prevDiscussion) {
          prevDiscussion.leaveSocketRooms();
        }
      }

      const discussion = this.getDiscussion(discussionSlug);

      if (!isServer && discussion) {
        discussion.loadPosts().catch((err) => notify(err));
      }

      if (discussion) {
        discussion.joinSocketRooms();
      }
    }
  }

  private handleDiscussionEvent = (data) => {
    console.log("discussion realtime event", data);

    const discussion = this.getDiscussion(this.props.discussionSlug);
    if (discussion) {
      discussion.handleDiscussionRealtimeEvent(data);
    }
  };

  private handlePostEvent = (data) => {
    console.log("post realtime event", data);

    const discussion = this.getDiscussion(this.props.discussionSlug);
    if (discussion) {
      discussion.handlePostRealtimeEvent(data);
    }
  };

  private handleSocketReconnect = () => {
    console.log("pages/discussion.tsx: socket re-connected");

    const discussion = this.getDiscussion(this.props.discussionSlug);
    if (discussion) {
      discussion.loadPosts().catch((err) => notify(err));
      discussion.joinSocketRooms();
    }
  };
}

export default withAuth(observer(DiscussionPageComp));

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\pages\invitation.tsx -----

import Avatar from "@mui/material/Avatar";
import { observer } from "mobx-react";
import Error from "next/error";
import Head from "next/head";
import Router from "next/router";
// import { NextPageContext } from 'next';
import React from "react";

import LoginButton from "../components/common/LoginButton";
import Layout from "../components/layout";
import { getTeamByTokenApiMethod } from "../lib/api/public";
import { Team } from "../lib/store/team";
import { Store } from "../lib/store";
import withAuth from "../lib/withAuth";

class InvitationPageComp extends React.Component<{ store: Store; team: Team; token: string }> {
  public static async getInitialProps(ctx) {
    const { token } = ctx.query;
    if (!token) {
      return {};
    }

    try {
      const { team } = await getTeamByTokenApiMethod(token, ctx.req);

      return { team, token };
    } catch (error) {
      console.log(error);
      return {};
    }
  }

  public render() {
    const { team, token, store } = this.props;

    if (!team) {
      return <Error statusCode={404} />;
    }

    const user = store.currentUser;

    if (user) {
      return null;
    }

    return (
      <Layout {...this.props}>
        <Head>
          <title>Invitation to {team.name}</title>
          <meta name="description" content={`Invitation to join ${team.name}`} />
        </Head>
        <div style={{ textAlign: "center", margin: "0 20px" }}>
          <br />
          <Avatar
            src={`${team.avatarUrl || "https://storage.googleapis.com/async-await/default-user.png?v=1"}`}
            alt="Team logo"
            style={{
              verticalAlign: "middle",
              display: "inline-flex",
            }}
          />{" "}
          <h2>{team.name}</h2>
          <p>
            Join <b>{team.name}</b> by logging in or signing up.
          </p>
          <br />
          <LoginButton invitationToken={token} />
        </div>
      </Layout>
    );
  }

  public async componentDidMount() {
    const { store, team, token } = this.props;

    const user = store.currentUser;

    if (user && team) {
      Router.push(
        `${process.env.NEXT_PUBLIC_URL_API}/logout?invitationToken=${token}`,
        `${process.env.NEXT_PUBLIC_URL_API}/logout`
      );
    }
  }
}

// export async function getServerSideProps(context: NextPageContext) {
//   const { token } = context.query;

//   try {
//     const { team } = await getTeamByTokenApiMethod(token as string, context.req);

//     if (team && token) {
//       return { props: { team, token } };
//     } else {
//       return { props: {} };
//     }
//   } catch (error) {
//     console.log(error);
//     return { props: {} };
//   }
// }

// see our explanation for not using getServerSideProps at this time: https://github.com/async-labs/saas/issues/193

export default withAuth(observer(InvitationPageComp), { loginRequired: false });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\pages\login.tsx -----

import Head from 'next/head';
import React from 'react';
import LoginButton from '../components/common/LoginButton';
import Layout from '../components/layout';
import withAuth from '../lib/withAuth';

class Login extends React.Component {
  public render() {
    return (
      <Layout {...this.props}>
        <div style={{ textAlign: 'center', margin: '0 20px' }}>
          <Head>
            <title>Log in to SaaS boilerplate by Async</title>
            <meta
              name="description"
              content="Login and signup page for SaaS boilerplate demo by Async"
            />
          </Head>
          <br />
          <p style={{ margin: '45px auto', fontSize: '44px', fontWeight: 400 }}>Log in</p>
          <p>Youll be logged in for 14 days unless you log out manually.</p>
          <br />

          <LoginButton />
        </div>
      </Layout>
    );
  }
}

export default withAuth(Login, { logoutRequired: true });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\pages\team-settings.tsx -----

import Avatar from "@mui/material/Avatar";
import Button from "@mui/material/Button";
import Hidden from "@mui/material/Hidden";
import TextField from "@mui/material/TextField";
import { inject, observer } from "mobx-react";
import Head from "next/head";
import NProgress from "nprogress";
import * as React from "react";
import Table from "@mui/material/Table";
import TableBody from "@mui/material/TableBody";
import TableCell from "@mui/material/TableCell";
import TableContainer from "@mui/material/TableContainer";
import TableHead from "@mui/material/TableHead";
import TableRow from "@mui/material/TableRow";

import Layout from "../components/layout";
import InviteMember from "../components/teams/InviteMember";
import { getSignedRequestForUploadApiMethod, uploadFileUsingSignedPutRequestApiMethod } from "../lib/api/team-member";
import confirm from "../lib/confirm";
import notify from "../lib/notify";
import { resizeImage } from "../lib/resizeImage";
import { Store } from "../lib/store";
import withAuth from "../lib/withAuth";

type Props = { isMobile: boolean; store: Store; teamSlug: string };

type State = {
  newName: string;
  newAvatarUrl: string;
  disabled: boolean;
  inviteMemberOpen: boolean;
};

class TeamSettings extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      newName: this.props.store.currentTeam.name,
      newAvatarUrl: this.props.store.currentTeam.avatarUrl,
      disabled: false,
      inviteMemberOpen: false,
    };
  }

  public render() {
    const { store, isMobile } = this.props;
    const { currentTeam, currentUser } = store;
    const { newName, newAvatarUrl } = this.state;
    const isTeamLeader = currentTeam && currentUser && currentUser._id === currentTeam.teamLeaderId;

    // console.log(this.props.firstGridItem);

    if (!currentTeam || currentTeam.slug !== this.props.teamSlug) {
      return (
        <Layout {...this.props}>
          <div style={{ padding: isMobile ? "0px" : "0px 30px" }}>
            <p>You did not select any team.</p>
            <p>To access this page, please select existing team or create new team if you have no teams.</p>
          </div>
        </Layout>
      );
    }

    if (!isTeamLeader) {
      return (
        <Layout {...this.props}>
          <div style={{ padding: isMobile ? "0px" : "0px 30px" }}>
            <p>Only the Team Leader can access this page.</p>
            <p>Create your own team to become a Team Leader.</p>
          </div>
        </Layout>
      );
    }

    return (
      <Layout {...this.props}>
        <Head>
          <title>Team Settings</title>
          <meta name="description" content={`Edit team settings. Add or edit members for Team ${currentTeam.name}`} />
        </Head>
        <div style={{ padding: isMobile ? "0px" : "0px 30px", fontSize: "15px", height: "100%" }}>
          <h3>Team Settings</h3>
          <p />
          <br />
          <form onSubmit={this.onSubmit}>
            <h4>Team name</h4>
            <TextField
              value={newName}
              helperText="Team name as seen by your team members"
              onChange={(event) => {
                this.setState({ newName: event.target.value });
              }}
            />
            <br />
            <br />
            <Button variant="contained" color="primary" type="submit" disabled={this.state.disabled}>
              Update username
            </Button>
          </form>
          <p />
          <br />
          <h4>Team logo</h4>
          <Avatar
            src={newAvatarUrl}
            style={{
              display: "inline-flex",
              verticalAlign: "middle",
              marginRight: 20,
              width: 60,
              height: 60,
            }}
          />
          <label htmlFor="upload-file-team-logo">
            <Button variant="contained" color="primary" component="span" disabled={this.state.disabled}>
              Update logo
            </Button>
          </label>
          <input
            accept="image/*"
            name="upload-file-team-logo"
            id="upload-file-team-logo"
            type="file"
            style={{ display: "none" }}
            onChange={this.uploadFile}
          />
          <p />
          <br />
          <br />
          <h4 style={{ marginRight: 20, display: "inline" }}>
            Team Members ( {Array.from(currentTeam.members.values()).length} / 20 )
          </h4>
          <Button
            onClick={this.openInviteMember}
            variant="contained"
            color="primary"
            style={{ float: "right", marginTop: "-20px" }}
            disabled={this.state.disabled}
          >
            Invite member
          </Button>
          <p />
          <TableContainer>
            <Table>
              <TableHead>
                <TableRow>
                  <TableCell>Person</TableCell>
                  <TableCell>Role</TableCell>
                  <TableCell>Action</TableCell>
                </TableRow>
              </TableHead>

              <TableBody>
                {currentTeam.memberIds
                  .map((userId) => currentTeam.members.get(userId))
                  .map((m) => (
                    <TableRow key={m._id}>
                      <TableCell style={{ width: "300px" }}>
                        <Hidden smDown>
                          <Avatar
                            role="presentation"
                            src={m.avatarUrl}
                            alt={(m.displayName || m.email)[0]}
                            key={m._id}
                            style={{
                              margin: "0px 5px",
                              display: "inline-flex",
                              width: "30px",
                              height: "30px",
                              verticalAlign: "middle",
                            }}
                          />
                        </Hidden>
                        {m.email}
                      </TableCell>
                      <TableCell>{isTeamLeader && m._id !== currentUser._id ? "Team Member" : "Team Leader"}</TableCell>
                      <TableCell>
                        {isTeamLeader && m._id !== currentUser._id ? (
                          <i
                            color="action"
                            data-id={m._id}
                            onClick={this.removeMember}
                            style={{
                              marginLeft: "20px",
                              fontSize: "16px",
                              opacity: 0.6,
                              cursor: "pointer",
                              verticalAlign: "middle",
                            }}
                            className="material-icons"
                          >
                            delete
                          </i>
                        ) : null}
                      </TableCell>
                    </TableRow>
                  ))}
              </TableBody>
            </Table>
          </TableContainer>

          <p />
          <br />

          {Array.from(currentTeam.invitations.values()).length > 0 ? (
            <React.Fragment>
              <h4>Invited users</h4>
              <p />
              <TableContainer>
                <Table>
                  <TableHead>
                    <TableRow>
                      <TableCell>Email</TableCell>
                      <TableCell>Status</TableCell>
                    </TableRow>
                  </TableHead>

                  <TableBody>
                    {Array.from(currentTeam.invitations.values()).map((i) => (
                      <TableRow key={i._id}>
                        <TableCell style={{ width: "300px" }}>{i.email}</TableCell>
                        <TableCell>Sent</TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              </TableContainer>
            </React.Fragment>
          ) : null}
          <p />
          <br />
          <InviteMember
            open={this.state.inviteMemberOpen}
            onClose={this.handleInviteMemberClose}
            store={this.props.store}
          />
          <br />
        </div>
      </Layout>
    );
  }

  private onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    const { newName, newAvatarUrl } = this.state;
    const { currentTeam } = this.props.store;

    if (!newName) {
      notify("Team name is required");
      return;
    }

    NProgress.start();

    try {
      this.setState({ disabled: true });

      await currentTeam.updateTheme({ name: newName, avatarUrl: newAvatarUrl });

      notify("You successfully updated Team name.");
    } catch (error) {
      notify(error);
    } finally {
      this.setState({ disabled: false });
      NProgress.done();
    }
  };

  private uploadFile = async () => {
    const { store } = this.props;
    const { currentTeam } = store;

    const fileElement = document.getElementById("upload-file-team-logo") as HTMLFormElement;
    const file = fileElement.files[0];

    if (file == null) {
      notify("No file selected for upload.");
      return;
    }

    const fileName = file.name;
    const fileType = file.type;

    NProgress.start();
    this.setState({ disabled: true });

    const bucket = process.env.NEXT_PUBLIC_BUCKET_FOR_TEAM_LOGOS;
    const prefix = `${currentTeam.slug}`;

    console.log(bucket);

    try {
      const responseFromApiServerForUpload = await getSignedRequestForUploadApiMethod({
        fileName,
        fileType,
        prefix,
        bucket,
      });

      const resizedFile = await resizeImage(file, 128, 128);

      await uploadFileUsingSignedPutRequestApiMethod(resizedFile, responseFromApiServerForUpload.signedRequest, {
        "Cache-Control": "max-age=2592000",
      });

      this.setState({
        newAvatarUrl: responseFromApiServerForUpload.url,
      });

      await currentTeam.updateTheme({
        name: this.state.newName,
        avatarUrl: this.state.newAvatarUrl,
      });

      notify("You successfully uploaded new Team logo.");
    } catch (error) {
      notify(error);
    } finally {
      this.setState({ disabled: false });
      NProgress.done();
    }
  };

  private openInviteMember = async () => {
    const { currentTeam } = this.props.store;
    if (!currentTeam) {
      notify("You have not selected a Team.");
      return;
    }

    this.setState({ inviteMemberOpen: true });
  };

  private handleInviteMemberClose = () => {
    this.setState({ inviteMemberOpen: false });
  };

  private removeMember = (event) => {
    const { currentTeam } = this.props.store;
    if (!currentTeam) {
      notify("You have not selected a Team.");
      return;
    }

    const userId = event.currentTarget.dataset.id;
    if (!userId) {
      notify("Select user.");
      return;
    }

    confirm({
      title: "Are you sure?",
      message: "",
      onAnswer: async (answer) => {
        if (answer) {
          try {
            await currentTeam.removeMember(userId);
          } catch (error) {
            notify(error);
          }
        }
      },
    });
  };
}

export default withAuth(inject("store")(observer(TeamSettings)));

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\pages\your-settings.tsx -----

import Avatar from "@mui/material/Avatar";
import Button from "@mui/material/Button";
import TextField from "@mui/material/TextField";
import { inject, observer } from "mobx-react";
import Head from "next/head";
import NProgress from "nprogress";
import * as React from "react";

import Layout from "../components/layout";

import { getSignedRequestForUploadApiMethod, uploadFileUsingSignedPutRequestApiMethod } from "../lib/api/team-member";

import notify from "../lib/notify";
import { resizeImage } from "../lib/resizeImage";
import { Store } from "../lib/store";
import withAuth from "../lib/withAuth";

type Props = { isMobile: boolean; store: Store };

type State = { newName: string; newAvatarUrl: string; disabled: boolean };

class YourSettings extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      newName: this.props.store.currentUser.displayName,
      newAvatarUrl: this.props.store.currentUser.avatarUrl,
      disabled: false,
    };
  }

  public render() {
    const { currentUser } = this.props.store;
    const { newName, newAvatarUrl } = this.state;

    return (
      <Layout {...this.props}>
        <Head>
          <title>Your Settings at Async</title>
          <meta name="description" content="description" />
        </Head>
        <div
          style={{
            padding: this.props.isMobile ? "0px" : "0px 30px",
            fontSize: "15px",
            height: "100%",
          }}
        >
          <h3>Your Settings</h3>
          <h4 style={{ marginTop: "40px" }}>Your account</h4>
          <div>
            <i className="material-icons" color="action" style={{ verticalAlign: "text-bottom" }}>
              done
            </i>{" "}
            {currentUser.isSignedupViaGoogle
              ? "You signed up on Async using your Google account."
              : "You signed up on Async using your email."}
            <p />
            <li>
              Your email: <b>{currentUser.email}</b>
            </li>
            <li>
              Your username: <b>{currentUser.displayName}</b>
            </li>
          </div>
          <form onSubmit={this.onSubmit} autoComplete="off">
            <h4>Your username</h4>
            <TextField
              autoComplete="off"
              value={newName}
              helperText="Your username as seen by your team members"
              onChange={(event) => {
                this.setState({ newName: event.target.value });
              }}
            />
            <br />
            <br />
            <Button variant="contained" color="primary" type="submit" disabled={this.state.disabled}>
              Update username
            </Button>
          </form>

          <br />
          <h4>Your photo</h4>
          <Avatar
            src={newAvatarUrl}
            style={{
              display: "inline-flex",
              verticalAlign: "middle",
              marginRight: 20,
              width: 60,
              height: 60,
            }}
          />
          <label htmlFor="upload-file-user-avatar">
            <Button variant="outlined" color="primary" component="span" disabled={this.state.disabled}>
              Update avatar
            </Button>
          </label>
          <input
            accept="image/*"
            name="upload-file-user-avatar"
            id="upload-file-user-avatar"
            type="file"
            style={{ display: "none" }}
            onChange={this.uploadFile}
          />
          <p />
          <br />
        </div>
      </Layout>
    );
  }

  private onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();

    const { currentUser } = this.props.store;

    const { newName, newAvatarUrl } = this.state;

    console.log(newName);

    if (!newName) {
      notify("Name is required");
      return;
    }

    NProgress.start();
    this.setState({ disabled: true });

    try {
      await currentUser.updateProfile({ name: newName, avatarUrl: newAvatarUrl });

      notify("You successfully updated your profile.");
    } catch (error) {
      notify(error);
    } finally {
      this.setState({ disabled: false });
      NProgress.done();
    }
  };

  private uploadFile = async () => {
    const fileElement = document.getElementById("upload-file-user-avatar") as HTMLFormElement;
    const file = fileElement.files[0];

    const { currentUser } = this.props.store;

    if (file == null) {
      notify("No file selected for upload.");
      return;
    }

    const fileName = file.name;
    const fileType = file.type;

    NProgress.start();
    this.setState({ disabled: true });

    const bucket = process.env.NEXT_PUBLIC_BUCKET_FOR_AVATARS;

    const prefix = `${currentUser.slug}`;

    try {
      const responseFromApiServerForUpload = await getSignedRequestForUploadApiMethod({
        fileName,
        fileType,
        prefix,
        bucket,
      });

      const resizedFile = await resizeImage(file, 128, 128);

      console.log(file);
      console.log(resizedFile);

      await uploadFileUsingSignedPutRequestApiMethod(resizedFile, responseFromApiServerForUpload.signedRequest, {
        "Cache-Control": "max-age=2592000",
      });

      this.setState({
        newAvatarUrl: responseFromApiServerForUpload.url,
      });

      await currentUser.updateProfile({
        name: this.state.newName,
        avatarUrl: this.state.newAvatarUrl,
      });

      notify("You successfully uploaded new avatar.");
    } catch (error) {
      notify(error);
    } finally {
      fileElement.value = "";
      this.setState({ disabled: false });
      NProgress.done();
    }
  };
}

export default withAuth(inject("store")(observer(YourSettings)));

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\pages\_app.tsx -----

import CssBaseline from "@mui/material/CssBaseline";
import { ThemeProvider } from "@mui/material";
import { Provider } from "mobx-react";
import App from "next/app";
import Head from "next/head";
import React from "react";

import { themeDark, themeLight } from "../lib/theme";
import { getUserApiMethod } from "../lib/api/public";
import { getInitialDataApiMethod } from "../lib/api/team-member";
import { isMobile } from "../lib/isMobile";
import { getStore, initializeStore, Store } from "../lib/store";

class MyApp extends App {
  public static async getInitialProps({ Component, ctx }) {
    let firstGridItem = true;
    let teamRequired = false;

    if (
      ctx.pathname.includes("/login") ||
      ctx.pathname.includes("/create-team") ||
      ctx.pathname.includes("/invitation")
    ) {
      firstGridItem = false;
    }

    if (
      ctx.pathname.includes("/team-settings") ||
      ctx.pathname.includes("/discussion") ||
      ctx.pathname.includes("/billing")
    ) {
      teamRequired = true;
    }

    const { teamSlug, discussionSlug } = ctx.query;

    const pageProps = {
      isMobile: isMobile({ req: ctx.req }),
      firstGridItem,
      teamRequired,
      teamSlug,
      discussionSlug,
    };

    if (Component.getInitialProps) {
      Object.assign(pageProps, await Component.getInitialProps(ctx));
    }

    const appProps = { pageProps };

    const store = getStore();
    if (store) {
      return appProps;
    }

    let userObj = null;
    try {
      const { user } = await getUserApiMethod(ctx.req);
      userObj = user;
    } catch (error) {
      console.log(error);
    }

    let initialData = {};

    if (userObj) {
      try {
        initialData = await getInitialDataApiMethod({
          request: ctx.req,
          data: { teamSlug, discussionSlug },
        });
      } catch (error) {
        console.error(error);
      }
    }

    // console.log(initialData);

    // console.log(teamSlug);

    return {
      ...appProps,
      initialState: { user: userObj, currentUrl: ctx.asPath, teamSlug, ...initialData },
    };
  }

  public componentDidMount() {
    // Remove the server-side injected CSS.
    const jssStyles = document.querySelector("#jss-server-side");
    if (jssStyles && jssStyles.parentNode) {
      jssStyles.parentNode.removeChild(jssStyles);
    }
  }

  private store: Store;

  constructor(props) {
    super(props);

    console.log("MyApp.constructor");

    this.store = initializeStore(props.initialState);
  }

  public render() {
    const { Component, pageProps } = this.props;
    const store = this.store;

    const isThemeDark = store.currentUser ? store.currentUser.darkTheme : true;

    return (
      <ThemeProvider theme={isThemeDark ? themeDark : themeLight}>
        <Head>
          <meta name="viewport" content="width=device-width, initial-scale=1.0" />

          <link
            rel="stylesheet"
            href={
              isThemeDark
                ? "https://storage.googleapis.com/async-await/nprogress-light.min.css?v=1"
                : "https://storage.googleapis.com/async-await/nprogress-dark.min.css?v=1"
            }
          />
        </Head>
        <CssBaseline />
        <Provider store={store}>
          <Component {...pageProps} store={store} />
        </Provider>
      </ThemeProvider>
    );
  }
}

export default MyApp;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\pages\_document.tsx -----

import Document, { Head, Html, Main, NextScript } from "next/document";
import React from "react";

class MyDocument extends Document {
  public static getInitialProps = async (ctx) => {
    const initialProps = await Document.getInitialProps(ctx);

    return {
      ...initialProps,
    };
  };

  public render() {
    // console.log('rendered on the server');

    const isThemeDark = this.props.__NEXT_DATA__.props.initialState.user
      ? this.props.__NEXT_DATA__.props.initialState.user.darkTheme
      : true;

    return (
      <Html lang="en">
        <Head>
          <meta charSet="utf-8" />
          <meta name="google" content="notranslate" />
          <meta name="theme-color" content="#303030" />

          <link rel="shortcut icon" href="https://storage.googleapis.com/async-await/async-favicon32.png" />

          <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons" />

          <link
            rel="stylesheet"
            href={
              isThemeDark
                ? "https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/a11y-dark.min.css"
                : "https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/a11y-light.min.css"
            }
          />

          <style>
            {`
              #__next {
                width: 100%;
                height: 100%;
              }
              a {
                font-weight: 400;
                color: #58a6ff;
                text-decoration: none;
                outline: none;
              }
              hr {
                border: 0.5px #707070 solid;
                color: #000;
              }
              blockquote {
                padding: 0 0.5em;
                margin: 20px 1em;
                border-left: 0.25em solid #dfe2e5;
                color: #000;
              }
              pre {
                display: block;
                overflow-x: auto;
                padding: 0.5em;
                background: #d0d0d0;
                border: 1px solid #ddd;
                font-size: 14px;
                color: #000;
              }
              pre code {
                font-size: 13px;
                background: #d0d0d0;
                padding: 0px;
                color: #000;
              }
              code {
                font-size: 13px;
                background: #d0d0d0;
                padding: 3px 5px;
                color: #000;
              }
              mark {
                background-color: #ffff0060;
              }
              summary:focus {
                outline: none;
              }
              table {
                border-collapse: collapse;
                margin: 15px 0px;
              }
              table, th, td {
                border: 1px solid #a1a1a1;
              }
              th, td {
                line-height: 1.5em;
                padding: 10px;
              }
            `}
          </style>
        </Head>
        <body>
          <Main />
          <NextScript />
        </body>
      </Html>
    );
  }
}

export default MyDocument;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\server\server.ts -----

import express from 'express';
import next from 'next';

const NODE_ENV = process.env.NODE_ENV || 'development';
const IS_DEV = NODE_ENV !== 'production';

const app = next({ dev: IS_DEV });
const handle = app.getRequestHandler();

app.prepare().then(() => {
  const server = express();

  // give all Nextjs's request to Nextjs before anything else
  server.get('/_next/*', (req, res) => {
    // console.log('next server, page');
    handle(req, res);
  });

  server.use(express.json());

  // server.get('/api/v1/public/get-user', (_, res) => {
  //   res.json({ user: { email: 'team@builderbook.org' } });
  // });

  server.get('/team/:teamSlug/team-settings', (req, res) => {
    const { teamSlug } = req.params;
    app.render(req, res, '/team-settings', { teamSlug });
  });

  server.get('/team/:teamSlug/discussions/:discussionSlug', (req, res) => {
    const { teamSlug, discussionSlug } = req.params;
    app.render(req, res, '/discussion', { teamSlug, discussionSlug });
  });

  server.get('/team/:teamSlug/discussions', (req, res) => {
    const { teamSlug } = req.params;
    app.render(req, res, '/discussion', { teamSlug });
  });

  server.get('/invitation', (req, res) => {
    app.render(req, res, '/invitation', { token: req.query.token as string });
  });

  server.all('*', (req, res) => {
    handle(req, res);
  });

  server.listen(process.env.NEXT_PUBLIC_PORT_APP, () => {
    console.log(`> Ready on ${process.env.NEXT_PUBLIC_URL_APP}`);
  });
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\.eslintrc.js -----

module.exports = {
  settings: {
    react: { version: 'detect' },
  },
  parser: '@typescript-eslint/parser',
  extends: ['plugin:react/recommended', 'plugin:@typescript-eslint/recommended', 'prettier'],
  env: {
    es6: true,
    node: true,
  },
  plugins: ['prettier', 'react'],
  rules: {
    'prettier/prettier': [
      'error',
      {
        singleQuote: true,
        trailingComma: 'all',
        arrowParens: 'always',
        printWidth: 100,
        semi: true,
      },
    ],
    '@typescript-eslint/camelcase': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    'react/no-unescaped-entities': 'off',
    'react/jsx-filename-extension': ['error', { extensions: ['.tsx'] }],
    '@typescript-eslint/no-explicit-any': 'off',
    'prefer-arrow-callback': 'error',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
  },
};

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\next-env.d.ts -----

/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/basic-features/typescript for more information.

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\next.config.js -----

module.exports = {
  poweredByHeader: false,
  webpack5: true,
  typescript: {
    ignoreBuildErrors: true,
  },
};

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\nodemon.json -----

{
  "watch": ["server"],
  "exec": "ts-node --project tsconfig.server.json",
  "ext": "ts"
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\package.json -----

{
  "name": "8-end-app",
  "version": "1",
  "license": "MIT",
  "scripts": {
    "dev": "nodemon server/server.ts",
    "build": "next build",
    "lint": "eslint . --ext .ts,.tsx"
  },
  "dependencies": {
    "@emotion/react": "^11.14.0",
    "@emotion/styled": "^11.14.0",
    "@material-ui/lab": "^4.0.0-alpha.61",
    "@mui/material": "^6.4.8",
    "@mui/system": "^6.4.8",
    "dotenv": "^16.3.1",
    "express": "^4.18.2",
    "he": "^1.2.0",
    "isomorphic-unfetch": "^4.0.2",
    "keycode": "^2.2.1",
    "marked": "^11.0.0",
    "mobx": "5.15.7",
    "mobx-react": "6.3.1",
    "moment": "^2.29.4",
    "next": "^14.0.3",
    "nprogress": "^0.2.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-mentions": "^4.4.10",
    "socket.io-client": "^4.7.2",
    "typescript": "^5.3.2"
  },
  "devDependencies": {
    "@types/express": "^4.17.21",
    "@types/he": "^1.2.3",
    "@types/marked": "^6.0.0",
    "@types/node": "^20.10.3",
    "@types/react": "^18.2.41",
    "@types/react-dom": "^18.2.17",
    "@types/socket.io-client": "^3.0.0",
    "@typescript-eslint/eslint-plugin": "^6.13.1",
    "@typescript-eslint/parser": "^6.13.1",
    "eslint": "^8.55.0",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-prettier": "^5.0.1",
    "eslint-plugin-react": "^7.33.2",
    "nodemon": "^3.0.2",
    "prettier": "^3.1.0",
    "ts-node": "^10.9.1"
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\tsconfig.json -----

{
  "compileOnSave": false,
  "compilerOptions": {
    "target": "esnext",
    "module": "esnext",
    "jsx": "preserve",
    "allowJs": true,
    "alwaysStrict": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "removeComments": true,
    "preserveConstEnums": true,
    "sourceMap": false,
    "skipLibCheck": true,
    "baseUrl": ".",
    "typeRoots": [
      "./node_modules/@types"
    ],
    "lib": [
      "dom",
      "es2017"
    ],
    "strict": false,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "incremental": true
  },
  "include": [
    "next-env.d.ts",
    "./**/*.tsx",
    "./**/*.ts"
  ],
  "exclude": [
    "dist",
    "production-server",
    ".next",
    "out",
    "next.config.js",
    "node_modules"
  ]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\8-end\app\tsconfig.server.json -----

{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "module": "commonjs",
    "outDir": "production-server/",
    "target": "es2017",
    "isolatedModules": false,
    "noEmit": false
  },
  "exclude": ["./server/types.d.ts"],
  "include": ["./server/**/*.ts"],
  "typeRoots": ["./node_modules/@types", "./server/types.d.ts"]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\server\api\index.ts -----

import * as express from 'express';

import publicExpressRoutes from './public';
import teamMemberExpressRoutes from './team-member';
import teamLeaderApi from './team-leader';

function handleError(err, _, res, __) {
  console.error(err.stack);

  res.json({ error: err.message || err.toString() });
}

export default function api(server: express.Express) {
  server.use('/api/v1/public', publicExpressRoutes, handleError);
  server.use('/api/v1/team-member', teamMemberExpressRoutes, handleError);
  server.use('/api/v1/team-leader', teamLeaderApi, handleError);
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\server\api\public.ts -----

import * as express from 'express';

import User from '../models/User';
import Invitation from '../models/Invitation';

const router = express.Router();

router.get('/get-user', (req, res) => {
  console.log(req.user);
  res.json({ user: req.user || null });
});

router.post('/get-user-by-slug', async (req, res, next) => {
  console.log('Express route: /get-user-by-slug');

  // req.session.foo = 'bar';

  try {
    const { slug } = req.body;

    const user = await User.getUserBySlug({ slug });

    res.json({ user });
  } catch (err) {
    next(err);
  }
});

router.get('/invitations/get-team-by-token', async (req, res, next) => {
  const token = req.query.token as string;

  try {
    const team = await Invitation.getTeamByToken({ token });

    res.json({ team });
  } catch (err) {
    next(err);
  }
});

export default router;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\server\api\team-leader.ts -----

import * as express from 'express';

import Invitation from '../models/Invitation';
import Team from '../models/Team';

const router = express.Router();

router.use((req, res, next) => {
  console.log('team leader API', req.path);

  if (!req.user) {
    res.status(401).json({ error: 'Unauthorized' });
    return;
  }

  next();
});

router.post('/teams/add', async (req: any, res, next) => {
  try {
    const { name, avatarUrl } = req.body;

    console.log(`Express route: ${name}, ${avatarUrl}`);

    const team = await Team.addTeam({ userId: req.user.id, name, avatarUrl });

    res.json(team);
  } catch (err) {
    next(err);
  }
});

router.post('/teams/update', async (req: any, res, next) => {
  try {
    const { teamId, name, avatarUrl } = req.body;

    // console.log(req.user.id, typeof req.user.id);
    // console.log(req.user._id, typeof req.user._id);

    const team = await Team.updateTeam({
      userId: req.user.id,
      teamId,
      name,
      avatarUrl,
    });

    res.json(team);
  } catch (err) {
    next(err);
  }
});

router.get('/teams/get-invitations-for-team', async (req: any, res, next) => {
  try {
    const invitations = await Invitation.getTeamInvitations({
      userId: req.user.id,
      teamId: req.query.teamId as string,
    });

    res.json({ invitations });
  } catch (err) {
    next(err);
  }
});

router.post('/teams/invite-member', async (req: any, res, next) => {
  try {
    const { teamId, email } = req.body;

    const newInvitation = await Invitation.add({ userId: req.user.id, teamId, email });

    res.json({ newInvitation });
  } catch (err) {
    next(err);
  }
});

router.post('/teams/remove-member', async (req: any, res, next) => {
  try {
    const { teamId, userId } = req.body;

    await Team.removeMember({ teamLeaderId: req.user.id, teamId, userId });

    res.json({ done: 1 });
  } catch (err) {
    next(err);
  }
});

export default router;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\server\api\team-member.ts -----

import * as express from "express";

import { signRequestForUpload } from "../aws-s3";

import User from "../models/User";
import Team from "../models/Team";
import Invitation from "../models/Invitation";
import Discussion from "../models/Discussion";
import Post from "../models/Post";

import { discussionAdded, discussionDeleted, discussionEdited, postAdded, postDeleted, postEdited } from "../sockets";

const router = express.Router();

router.use((req, res, next) => {
  console.log("team member API", req.path);
  if (!req.user) {
    res.status(401).json({ error: "Unauthorized" });
    return;
  }

  next();
});

// Get signed request from AWS S3 server
router.post("/aws/get-signed-request-for-upload-to-s3", async (req, res, next) => {
  try {
    const { fileName, fileType, prefix, bucket } = req.body;

    const returnData = await signRequestForUpload({
      fileName,
      fileType,
      prefix,
      bucket,
    });

    console.log(bucket);

    res.json(returnData);
  } catch (err) {
    next(err);
  }
});

router.post("/user/update-profile", async (req: any, res, next) => {
  try {
    const { name, avatarUrl } = req.body;

    const updatedUser = await User.updateProfile({
      userId: req.user.id,
      name,
      avatarUrl,
    });

    res.json({ updatedUser });
  } catch (err) {
    next(err);
  }
});

router.post("/user/toggle-theme", async (req: any, res, next) => {
  try {
    const { darkTheme } = req.body;

    await User.toggleTheme({ userId: req.user.id, darkTheme });

    res.json({ done: 1 });
  } catch (err) {
    next(err);
  }
});

async function loadDiscussionsData(team, userId, body) {
  const { discussionSlug } = body;

  if (!discussionSlug) {
    return [];
  }

  const { discussions } = await Discussion.getList({
    userId,
    teamId: team._id,
  });

  for (const discussion of discussions) {
    if (discussion.slug === discussionSlug) {
      Object.assign(discussion, {
        initialPosts: await Post.getList({
          userId,
          discussionId: discussion._id.toString(),
        }),
      });

      break;
    }
  }

  return discussions;
}

async function loadTeamData(team, userId, body) {
  const initialMembers = await User.getMembersForTeam({
    userId,
    teamId: team._id,
  });

  let initialInvitations = [];
  if (userId === team.teamLeaderId) {
    initialInvitations = await Invitation.getTeamInvitations({
      userId,
      teamId: team._id,
    });
  }

  console.log(`initialMembers:${initialMembers}`);

  const initialDiscussions = await loadDiscussionsData(team, userId, body);

  const data: any = { initialMembers, initialInvitations, initialDiscussions };

  // console.log(`Express route:${data.initialPosts}`);

  return data;
}

router.post("/get-initial-data", async (req: any, res, next) => {
  try {
    const teams = await Team.getAllTeamsForUser(req.user.id);

    let selectedTeamSlug = req.body.teamSlug;
    if (!selectedTeamSlug && teams && teams.length > 0) {
      selectedTeamSlug = teams[0].slug;
    }

    for (const team of teams) {
      if (team.slug === selectedTeamSlug) {
        Object.assign(team, await loadTeamData(team, req.user.id, req.body));
        break;
      }
    }

    res.json({ teams });
  } catch (err) {
    next(err);
  }
});

router.get("/teams", async (req: any, res, next) => {
  try {
    const teams = await Team.getAllTeamsForUser(req.user.id);

    console.log(teams);

    res.json({ teams });
  } catch (err) {
    next(err);
  }
});

router.get("/teams/get-members", async (req: any, res, next) => {
  try {
    const users = await User.getMembersForTeam({
      userId: req.user.id,
      teamId: req.query.teamId as string,
    });

    res.json({ users });
  } catch (err) {
    next(err);
  }
});

router.post("/discussions/add", async (req: any, res, next) => {
  try {
    const { name, teamId, memberIds = [], socketId } = req.body;

    const discussion = await Discussion.add({
      userId: req.user.id,
      name,
      teamId,
      memberIds,
    });

    discussionAdded({ socketId, discussion });

    res.json({ discussion });
  } catch (err) {
    next(err);
  }
});

router.post("/discussions/edit", async (req: any, res, next) => {
  try {
    const { name, id, memberIds = [], socketId } = req.body;

    const updatedDiscussion = await Discussion.edit({
      userId: req.user.id,
      name,
      id,
      memberIds,
    });

    discussionEdited({ socketId, discussion: updatedDiscussion });

    res.json({ done: 1 });
  } catch (err) {
    next(err);
  }
});

router.post("/discussions/delete", async (req: any, res, next) => {
  try {
    const { id, socketId } = req.body;

    const { teamId } = await Discussion.delete({ userId: req.user.id, id });

    discussionDeleted({ socketId, teamId, id });

    res.json({ done: 1 });
  } catch (err) {
    next(err);
  }
});

router.get("/discussions/list", async (req: any, res, next) => {
  try {
    const { discussions } = await Discussion.getList({
      userId: req.user.id,
      teamId: req.query.teamId as string,
    });

    res.json({ discussions });
  } catch (err) {
    next(err);
  }
});

router.get("/posts/list", async (req: any, res, next) => {
  try {
    const posts = await Post.getList({
      userId: req.user.id,
      discussionId: req.query.discussionId as string,
    });

    res.json({ posts });
  } catch (err) {
    next(err);
  }
});

router.post("/posts/add", async (req: any, res, next) => {
  try {
    const { content, discussionId, socketId } = req.body;

    const post = await Post.add({ userId: req.user.id, content, discussionId });

    postAdded({ socketId, post });

    res.json({ post });
  } catch (err) {
    next(err);
  }
});

router.post("/posts/edit", async (req: any, res, next) => {
  try {
    const { content, id, socketId } = req.body;

    const updatedPost = await Post.edit({ userId: req.user.id, content, id });

    postEdited({ socketId, post: updatedPost });

    res.json({ done: 1 });
  } catch (err) {
    next(err);
  }
});

router.post("/posts/delete", async (req: any, res, next) => {
  try {
    const { id, discussionId, socketId } = req.body;

    await Post.delete({ userId: req.user.id, id });

    postDeleted({ socketId, id, discussionId });

    res.json({ done: 1 });
  } catch (err) {
    next(err);
  }
});

export default router;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\server\models\Discussion.ts -----

import { uniq } from 'lodash';
import * as mongoose from 'mongoose';

import { generateNumberSlug } from '../utils/slugify';
import Team, { TeamDocument } from './Team';
import Post from './Post';

const mongoSchema = new mongoose.Schema({
  createdUserId: {
    type: String,
    required: true,
  },
  teamId: {
    type: String,
    required: true,
  },
  name: {
    type: String,
    required: true,
  },
  slug: {
    type: String,
    required: true,
  },
  memberIds: [
    {
      type: String,
    },
  ],
  createdAt: {
    type: Date,
    required: true,
    default: Date.now,
  },
});

export interface DiscussionDocument extends mongoose.Document {
  createdUserId: string;
  teamId: string;
  name: string;
  slug: string;
  memberIds: string[];
  createdAt: Date;
}

interface DiscussionModel extends mongoose.Model<DiscussionDocument> {
  getList({
    userId,
    teamId,
  }: {
    userId: string;
    teamId: string;
  }): Promise<{ discussions: DiscussionDocument[] }>;

  add({
    name,
    userId,
    teamId,
    memberIds,
  }: {
    name: string;
    userId: string;
    teamId: string;
    memberIds: string[];
  }): Promise<DiscussionDocument>;

  edit({
    userId,
    id,
    name,
    memberIds,
  }: {
    userId: string;
    id: string;
    name: string;
    memberIds: string[];
  }): Promise<DiscussionDocument>;

  delete({ userId, id }: { userId: string; id: string }): Promise<{ teamId: string }>;

  checkPermissionAndGetTeam({
    userId,
    teamId,
    memberIds,
  }: {
    userId: string;
    teamId: string;
    memberIds: string[];
  }): Promise<TeamDocument>;
}

class DiscussionClass extends mongoose.Model {
  public static async getList({ userId, teamId }) {
    await this.checkPermissionAndGetTeam({ userId, teamId });

    const filter: any = { teamId, memberIds: userId };

    const discussions: any[] = await this.find(filter).setOptions({ lean: true });

    return { discussions };
  }

  public static async add({ name, userId, teamId, memberIds = [] }) {
    if (!name) {
      throw new Error('Bad data');
    }

    await this.checkPermissionAndGetTeam({ userId, teamId, memberIds });

    const slug = await generateNumberSlug(this, { teamId });

    return this.create({
      createdUserId: userId,
      teamId,
      name,
      slug,
      memberIds: uniq([userId, ...memberIds]),
      createdAt: new Date(),
    });
  }

  public static async edit({ userId, id, name, memberIds = [] }) {
    if (!id) {
      throw new Error('Bad data');
    }

    const discussion = await this.findById(id)
      .select('teamId createdUserId')
      .setOptions({ lean: true });

    const team = await this.checkPermissionAndGetTeam({
      userId,
      teamId: discussion.teamId,
      memberIds,
    });

    if (discussion.createdUserId !== userId && team.teamLeaderId !== userId) {
      throw new Error('Permission denied. Only author or team leader can edit Discussion.');
    }

    const updatedObj = await this.findOneAndUpdate(
      { _id: id },
      {
        name,
        memberIds: uniq([userId, ...memberIds]),
      },
      { runValidators: true, new: true },
    );

    return updatedObj;
  }

  public static async delete({ userId, id }) {
    if (!id) {
      throw new Error('Bad data');
    }

    const discussion = await this.findById(id).select('teamId').setOptions({ lean: true });

    await this.checkPermissionAndGetTeam({ userId, teamId: discussion.teamId });

    await Post.deleteMany({ discussionId: id });

    await this.deleteOne({ _id: id });

    return { teamId: discussion.teamId };
  }

  private static async checkPermissionAndGetTeam({ userId, teamId, memberIds = [] }) {
    if (!userId || !teamId) {
      throw new Error('Bad data');
    }

    const team = await Team.findById(teamId)
      .select('memberIds teamLeaderId')
      .setOptions({ lean: true });

    if (!team || team.memberIds.indexOf(userId) === -1) {
      throw new Error('Team not found');
    }

    for (const id of memberIds) {
      if (team.memberIds.indexOf(id) === -1) {
        throw new Error('Permission denied');
      }
    }

    return team;
  }
}

mongoSchema.loadClass(DiscussionClass);

const Discussion = mongoose.model<DiscussionDocument, DiscussionModel>('Discussion', mongoSchema);

export default Discussion;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\server\models\EmailTemplate.ts -----

import * as _ from 'lodash';
import * as mongoose from 'mongoose';

interface EmailTemplateDocument extends mongoose.Document {
  name: string;
  subject: string;
  message: string;
}

const EmailTemplate = mongoose.model<EmailTemplateDocument>(
  'EmailTemplate',
  new mongoose.Schema({
    name: {
      type: String,
      required: true,
      unique: true,
    },
    subject: {
      type: String,
      required: true,
    },
    message: {
      type: String,
      required: true,
    },
  }),
);

export async function insertTemplates() {
  const templates = [
    {
      name: 'welcome',
      subject: 'Welcome to SaaS boilerplate by Async',
      message: `Welcome <%= userName %>,
        <p>
          Thanks for signing up on our <a href="https://github.com/async-labs/saas" target="blank">SaaS boilerplate</a>!
        </p>
        <p>
          If you are learning how to build a SaaS web app, check out our 2 books:
           <a href="https://builderbook.org" target="blank">Builder Book</a>
           and
           <a href="https://builderbook.org/book" target="blank">SaaS Boilerplate</a>.
        </p>
        <p>
          Also check out
          <a href="https://async-await.com" target="blank"> Async</a>
          , our communication tool for small teams of software developers.
        </p>
        Kelly & Timur, Team Async
      `,
    },
    {
      name: 'login',
      subject: 'Login link for saas-app.async-await.com',
      message: `
        <p>Log into your account by clicking on this link: <a href="<%= loginURL %>"><%= loginURL %></a>.</p>`,
    },
    {
      name: 'invitation',
      subject: 'You are invited to join a team at saas-app.async-await.com',
      message: `You've been invited to join <b><%= teamName%></b>.
        <br/>Click here to accept the invitation: <%= invitationURL%>
      `,
    },
    // {
    //   name: 'newPost',
    //   subject: 'New Post was created in Discussion: <%= discussionName %>',
    //   message: `<p>New Post in Discussion: "<%= discussionName%>" by <%= authorName%></p>
    //     New Post: "<%= postContent %>"
    //     <p>---</p>
    //     <p>View it at <a href="<%= discussionLink %>"><%= discussionLink %></a>.</p>
    //   `,
    // },
  ];

  for (const t of templates) {
    const et = await EmailTemplate.findOne({ name: t.name }).setOptions({ lean: true });
    const message = t.message.replace(/\n/g, '').replace(/[ ]+/g, ' ').trim();

    if (!et) {
      EmailTemplate.create(Object.assign({}, t, { message }));
    } else if (et.subject !== t.subject || et.message !== message) {
      EmailTemplate.updateOne({ _id: et._id }, { $set: { message, subject: t.subject } }).exec();
    }
  }
}

export default async function getEmailTemplate(name: string, params: any) {
  await insertTemplates();

  const et = await EmailTemplate.findOne({ name }).setOptions({ lean: true });

  if (!et) {
    throw new Error('Email Template is not found in database.');
  }

  return {
    message: _.template(et.message)(params),
    subject: _.template(et.subject)(params),
  };
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\server\models\Invitation.ts -----

import * as mongoose from 'mongoose';

import sendEmail from '../aws-ses';
import getEmailTemplate from './EmailTemplate';
import Team from './Team';
import User, { UserDocument } from './User';

const mongoSchema = new mongoose.Schema({
  teamId: {
    type: String,
    required: true,
  },
  email: {
    type: String,
    required: true,
  },
  createdAt: {
    type: Date,
    required: true,
    default: Date.now,
    expires: 60 * 60 * 24, // delete doc after 24 hours
  },
  token: {
    type: String,
    required: true,
    unique: true,
  },
});

mongoSchema.index({ teamId: 1, email: 1 }, { unique: true });

interface InvitationDocument extends mongoose.Document {
  teamId: string;
  email: string;
  createdAt: Date;
  token: string;
}

interface InvitationModel extends mongoose.Model<InvitationDocument> {
  add({
    userId,
    teamId,
    email,
  }: {
    userId: string;
    teamId: string;
    email: string;
  }): InvitationDocument;

  getTeamInvitations({ userId, teamId }: { userId: string; teamId: string });
  getTeamByToken({ token }: { token: string });
  addUserToTeam({ token, user }: { token: string; user: UserDocument });
}

function generateToken() {
  const gen = () =>
    Math.random().toString(36).substring(2, 12) + Math.random().toString(36).substring(2, 12);

  return `${gen()}`;
}

class InvitationClass extends mongoose.Model {
  public static async add({ userId, teamId, email }) {
    if (!teamId || !email) {
      throw new Error('Bad data');
    }

    const team = await Team.findById(teamId).setOptions({ lean: true });
    if (!team || team.teamLeaderId !== userId) {
      throw new Error('Team does not exist or you have no permission');
    }

    const registeredUser = await User.findOne({ email }).setOptions({ lean: true });

    if (registeredUser && team.memberIds.includes(registeredUser._id.toString())) {
      throw new Error('This user is already Team Member.');
    }

    let token;
    const invitation = await this.findOne({ teamId, email })
      .select('token')
      .setOptions({ lean: true });

    if (invitation) {
      token = invitation.token;
    } else {
      token = generateToken();
      while ((await this.countDocuments({ token })) > 0) {
        token = generateToken();
      }

      await this.create({
        teamId,
        email,
        token,
      });
    }

    const emailTemplate = await getEmailTemplate('invitation', {
      teamName: team.name,
      invitationURL: `${process.env.URL_APP}/invitation?token=${token}`,
    });

    if (!emailTemplate) {
      throw new Error('Invitation email template not found');
    }

    try {
      await sendEmail({
        from: `Kelly from saas-app.async-await.com <${process.env.EMAIL_SUPPORT_FROM_ADDRESS}>`,
        to: [email],
        subject: emailTemplate.subject,
        body: emailTemplate.message,
      });
    } catch (err) {
      console.log('Email sending error:', err);
    }

    return await this.findOne({ teamId, email }).setOptions({ lean: true });
  }

  public static async getTeamInvitations({ userId, teamId }) {
    const team = await Team.findOne({ _id: teamId })
      .select('teamLeaderId')
      .setOptions({ lean: true });

    if (userId !== team.teamLeaderId) {
      throw new Error('You have no permission.');
    }

    return this.find({ teamId }).select('email').setOptions({ lean: true });
  }

  public static async getTeamByToken({ token }) {
    if (!token) {
      throw new Error('Bad data');
    }

    const invitation = await this.findOne({ token }).setOptions({ lean: true });

    if (!invitation) {
      throw new Error('Invitation not found');
    }

    const team = await Team.findById(invitation.teamId)
      .select('name slug avatarUrl memberIds')
      .setOptions({ lean: true });

    if (!team) {
      throw new Error('Team does not exist');
    }

    return team;
  }

  public static async addUserToTeam({ token, user }) {
    if (!token || !user) {
      throw new Error('Bad data');
    }

    const invitation = await this.findOne({ token }).setOptions({ lean: true });

    if (!invitation || invitation.email !== user.email) {
      throw new Error('Invitation not found');
    }

    await this.deleteOne({ token });

    const team = await Team.findById(invitation.teamId)
      .select('memberIds slug teamLeaderId')
      .setOptions({ lean: true });

    if (!team) {
      throw new Error('Team does not exist');
    }

    if (team && !team.memberIds.includes(user._id)) {
      await Team.updateOne({ _id: team._id }, { $addToSet: { memberIds: user._id } });

      if (user._id !== team.teamLeaderId) {
        await User.findByIdAndUpdate(user._id, { $set: { defaultTeamSlug: team.slug } });
      }
    }

    return team.slug;
  }
}

mongoSchema.loadClass(InvitationClass);

const Invitation = mongoose.model<InvitationDocument, InvitationModel>('Invitation', mongoSchema);

export default Invitation;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\server\models\Post.ts -----

import * as mongoose from "mongoose";

import * as he from "he";
import hljs from "highlight.js";
import { marked } from "marked";

import Discussion from "./Discussion";
import Team from "./Team";

const mongoSchema = new mongoose.Schema({
  createdUserId: {
    type: String,
    required: true,
  },
  discussionId: {
    type: String,
    required: true,
  },
  content: {
    type: String,
    required: true,
  },
  htmlContent: {
    type: String,
    required: true,
  },
  isEdited: {
    type: Boolean,
    default: false,
  },
  lastUpdatedAt: Date,
  createdAt: {
    type: Date,
    required: true,
  },
});

function markdownToHtml(content) {
  const renderer = new marked.Renderer();

  renderer.link = ({ href, title, text }) => {
    const t = title ? ` title="${title}"` : "";

    if (text.startsWith("<code>@#")) {
      return `${text.replace("<code>@#", "<code>@")} `;
    }

    return `
      <a target="_blank" href="${href}" rel="noopener noreferrer"${t}>
        ${text}
      </a>
    `;
  };

  renderer.code = ({ text, lang }) => {
    const language = hljs.getLanguage(lang) ? lang : "plaintext";

    return `<pre><code class="hljs language-${lang}">${hljs.highlight(text, { language }).value}</code></pre>`;
  };

  marked.setOptions({
    renderer,
    breaks: true,
  });

  return marked(he.decode(content));
}

export interface PostDocument extends mongoose.Document {
  createdUserId: string;
  discussionId: string;
  content: string;
  isEdited: boolean;
  lastUpdatedAt: Date;
  createdAt: Date;
}

interface PostModel extends mongoose.Model<PostDocument> {
  getList({ userId, discussionId }: { userId: string; discussionId: string }): Promise<PostDocument[]>;

  add({
    content,
    userId,
    discussionId,
  }: {
    content: string;
    userId: string;
    discussionId: string;
  }): Promise<PostDocument>;

  edit({ content, userId, id }: { content: string; userId: string; id: string }): Promise<PostDocument>;

  delete({ userId, id }: { userId: string; id: string }): Promise<void>;

  checkPermissionAndGetTeamAndDiscussion({
    userId,
    discussionId,
    post,
  }: {
    userId: string;
    discussionId: string;
    post: PostDocument;
  }): Promise<{ TeamDocument; DiscussionDocument }>;
}

class PostClass extends mongoose.Model {
  public static async getList({ userId, discussionId }) {
    await this.checkPermissionAndGetTeamAndDiscussion({ userId, discussionId });

    const filter: any = { discussionId };

    const posts: any[] = await this.find(filter).sort({ createdAt: 1 }).setOptions({ lean: true });

    return posts;
  }

  public static async add({ content, userId, discussionId }) {
    if (!content) {
      throw new Error("Bad data");
    }

    await this.checkPermissionAndGetTeamAndDiscussion({ userId, discussionId });

    const htmlContent = markdownToHtml(content);

    const post = await this.create({
      createdUserId: userId,
      discussionId,
      content,
      htmlContent,
      createdAt: new Date(),
    });

    return post;
  }

  public static async edit({ content, userId, id }) {
    if (!content || !id) {
      throw new Error("Bad data");
    }

    const post = await this.findById(id).select("createdUserId discussionId").setOptions({ lean: true });

    await this.checkPermissionAndGetTeamAndDiscussion({
      userId,
      discussionId: post.discussionId,
      post,
    });

    const htmlContent = markdownToHtml(content);

    const updatedObj = await this.findOneAndUpdate(
      { _id: id },
      { content, htmlContent, isEdited: true, lastUpdatedAt: new Date() },
      { runValidators: true, new: true }
    );

    return updatedObj;
  }

  public static async delete({ userId, id }) {
    if (!id) {
      throw new Error("Bad data");
    }

    const post = await this.findById(id).select("createdUserId discussionId content").setOptions({ lean: true });

    await this.checkPermissionAndGetTeamAndDiscussion({
      userId,
      discussionId: post.discussionId,
      post,
    });

    await this.deleteOne({ _id: id });
  }

  private static async checkPermissionAndGetTeamAndDiscussion({ userId, discussionId, post = null }) {
    if (!userId || !discussionId) {
      throw new Error("Bad data");
    }

    if (post && post.createdUserId !== userId) {
      throw new Error("Permission denied");
    }

    const discussion = await Discussion.findById(discussionId)
      .select("teamId memberIds slug")
      .setOptions({ lean: true });

    if (!discussion) {
      throw new Error("Discussion not found");
    }

    if (discussion.memberIds.indexOf(userId) === -1) {
      throw new Error("Permission denied");
    }

    const team = await Team.findById(discussion.teamId).select("memberIds slug").setOptions({ lean: true });

    if (!team || team.memberIds.indexOf(userId) === -1) {
      throw new Error("Team not found");
    }

    return { team, discussion };
  }
}

mongoSchema.loadClass(PostClass);

const Post = mongoose.model<PostDocument, PostModel>("Post", mongoSchema);

export default Post;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\server\models\Team.ts -----

import * as mongoose from 'mongoose';

import { generateNumberSlug } from '../utils/slugify';
import User from './User';

const mongoSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
  },
  slug: {
    type: String,
    required: true,
    unique: true,
  },
  avatarUrl: String,
  createdAt: {
    type: Date,
    required: true,
  },
  teamLeaderId: {
    type: String,
    required: true,
  },
  memberIds: [
    {
      type: String,
      required: true,
    },
  ],
  defaultTeam: {
    type: Boolean,
    default: false,
  },
});

export interface TeamDocument extends mongoose.Document {
  name: string;
  slug: string;
  avatarUrl: string;
  createdAt: Date;

  teamLeaderId: string;
  memberIds: string[];
  defaultTeam: boolean;
}

interface TeamModel extends mongoose.Model<TeamDocument> {
  addTeam({
    name,
    userId,
  }: {
    userId: string;
    name: string;
    avatarUrl: string;
  }): Promise<TeamDocument>;

  updateTeam({
    userId,
    teamId,
    name,
    avatarUrl,
  }: {
    userId: string;
    teamId: string;
    name: string;
    avatarUrl: string;
  }): Promise<TeamDocument>;

  getAllTeamsForUser(userId: string): Promise<TeamDocument[]>;

  removeMember({
    teamId,
    teamLeaderId,
    userId,
  }: {
    teamId: string;
    teamLeaderId: string;
    userId: string;
  }): Promise<void>;
}

class TeamClass extends mongoose.Model {
  public static async addTeam({ userId, name, avatarUrl }) {
    console.log(`Static method: ${name}, ${avatarUrl}`);

    if (!userId || !name || !avatarUrl) {
      throw new Error('Bad data');
    }

    const slug = await generateNumberSlug(this);

    let defaultTeam = false;
    if ((await this.countDocuments({ teamLeaderId: userId })) === 0) {
      await User.findByIdAndUpdate(userId, { $set: { defaultTeamSlug: slug } });
      defaultTeam = true;
    }

    const team = await this.create({
      teamLeaderId: userId,
      name,
      slug,
      avatarUrl,
      memberIds: [userId],
      createdAt: new Date(),
      defaultTeam,
    });

    return team;
  }

  public static async updateTeam({ userId, teamId, name, avatarUrl }) {
    const team = await this.findById(teamId, 'name teamLeaderId');

    if (!team) {
      throw new Error('Team not found');
    }

    if (team.teamLeaderId !== userId) {
      throw new Error('Permission denied');
    }

    const modifier = { name: team.name, avatarUrl };

    if (name !== team.name) {
      modifier.name = name;
    }

    await this.updateOne({ _id: teamId }, { $set: modifier }, { runValidators: true });

    return this.findById(teamId, 'name avatarUrl slug defaultTeam').setOptions({ lean: true });
  }

  public static getAllTeamsForUser(userId: string) {
    console.log(`userId:${userId}`);
    return this.find({ memberIds: userId }).setOptions({ lean: true });
  }

  public static async removeMember({ teamId, teamLeaderId, userId }) {
    const team = await this.findById(teamId).select('memberIds teamLeaderId');

    if (!team) {
      throw new Error('Team does not exist');
    }

    if (team.teamLeaderId !== teamLeaderId || teamLeaderId === userId) {
      throw new Error('Permission denied');
    }

    await this.findByIdAndUpdate(teamId, { $pull: { memberIds: userId } });
  }
}

mongoSchema.loadClass(TeamClass);

const Team = mongoose.model<TeamDocument, TeamModel>('Team', mongoSchema);

export default Team;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\server\models\User.ts -----

import * as _ from 'lodash';
import * as mongoose from 'mongoose';

import sendEmail from '../aws-ses';
import { addToMailchimp } from '../mailchimp';
import { generateSlug } from '../utils/slugify';
import getEmailTemplate from './EmailTemplate';
import Team, { TeamDocument } from './Team';

const mongoSchema = new mongoose.Schema({
  slug: {
    type: String,
    required: true,
    unique: true,
  },
  createdAt: {
    type: Date,
    required: true,
  },
  email: {
    type: String,
    required: true,
    unique: true,
  },
  displayName: String,
  avatarUrl: String,
  googleId: {
    type: String,
    unique: true,
    sparse: true,
  },
  googleToken: {
    accessToken: String,
    refreshToken: String,
  },
  isSignedupViaGoogle: {
    type: Boolean,
    required: true,
    default: false,
  },
  darkTheme: Boolean,
  defaultTeamSlug: {
    type: String,
    default: '',
  },
});

export interface UserDocument extends mongoose.Document {
  slug: string;
  createdAt: Date;
  email: string;
  displayName: string;
  avatarUrl: string;
  googleId: string;
  googleToken: { accessToken: string; refreshToken: string };
  isSignedupViaGoogle: boolean;
  darkTheme: boolean;
  defaultTeamSlug: string;
}

interface UserModel extends mongoose.Model<UserDocument> {
  getUserBySlug({ slug }: { slug: string }): Promise<UserDocument>;

  updateProfile({
    userId,
    name,
    avatarUrl,
  }: {
    userId: string;
    name: string;
    avatarUrl: string;
  }): Promise<UserDocument[]>;

  publicFields(): string[];

  signInOrSignUpViaGoogle({
    googleId,
    email,
    displayName,
    avatarUrl,
    googleToken,
  }: {
    googleId: string;
    email: string;
    displayName: string;
    avatarUrl: string;
    googleToken: { accessToken?: string; refreshToken?: string };
  }): Promise<UserDocument>;

  signInOrSignUpByPasswordless({
    uid,
    email,
  }: {
    uid: string;
    email: string;
  }): Promise<UserDocument>;

  toggleTheme({ userId, darkTheme }: { userId: string; darkTheme: boolean }): Promise<void>;

  getMembersForTeam({
    userId,
    teamId,
  }: {
    userId: string;
    teamId: string;
  }): Promise<UserDocument[]>;

  checkPermissionAndGetTeam({
    userId,
    teamId,
  }: {
    userId: string;
    teamId: string;
  }): Promise<TeamDocument>;
}

class UserClass extends mongoose.Model {
  public static async getUserBySlug({ slug }) {
    console.log('Static method: getUserBySlug');

    return this.findOne({ slug }, 'email displayName avatarUrl').setOptions({ lean: true });
  }

  public static async updateProfile({ userId, name, avatarUrl }) {
    console.log('Static method: updateProfile');

    const user = await this.findById(userId, 'slug displayName');

    const modifier = { displayName: user.displayName, avatarUrl, slug: user.slug };

    console.log(user.slug);

    if (name !== user.displayName) {
      modifier.displayName = name;
      modifier.slug = await generateSlug(this, name);
    }

    return this.findByIdAndUpdate(userId, { $set: modifier }, { new: true, runValidators: true })
      .select('displayName avatarUrl slug')
      .setOptions({ lean: true });
  }

  public static publicFields(): string[] {
    return [
      '_id',
      'id',
      'displayName',
      'email',
      'avatarUrl',
      'slug',
      'isSignedupViaGoogle',
      'darkTheme',
      'defaultTeamSlug',
    ];
  }

  public static async signInOrSignUpViaGoogle({
    googleId,
    email,
    displayName,
    avatarUrl,
    googleToken,
  }) {
    const user = await this.findOne({ email })
      .select([...this.publicFields(), 'googleId'].join(' '))
      .setOptions({ lean: true });

    if (user) {
      if (_.isEmpty(googleToken) && user.googleId) {
        return user;
      }

      const modifier = { googleId };
      if (googleToken.accessToken) {
        modifier['googleToken.accessToken'] = googleToken.accessToken;
      }

      if (googleToken.refreshToken) {
        modifier['googleToken.refreshToken'] = googleToken.refreshToken;
      }

      await this.updateOne({ email }, { $set: modifier });

      return user;
    }

    const slug = await generateSlug(this, displayName);

    const newUser = await this.create({
      createdAt: new Date(),
      googleId,
      email,
      googleToken,
      displayName,
      avatarUrl,
      slug,
      isSignedupViaGoogle: true,
      defaultTeamSlug: '',
      darkTheme: false,
    });

    const emailTemplate = await getEmailTemplate('welcome', { userName: displayName });

    if (!emailTemplate) {
      throw new Error('Welcome email template not found');
    }

    try {
      await sendEmail({
        from: `Kelly from saas-app.async-await.com <${process.env.EMAIL_SUPPORT_FROM_ADDRESS}>`,
        to: [email],
        subject: emailTemplate.subject,
        body: emailTemplate.message,
      });
    } catch (err) {
      console.error('Email sending error:', err);
    }

    try {
      await addToMailchimp({ email, listName: 'signups' });
    } catch (error) {
      console.error('Mailchimp error:', error);
    }

    return _.pick(newUser, this.publicFields());
  }

  public static async signInOrSignUpByPasswordless({ uid, email }) {
    const user = await this.findOne({ email })
      .select(this.publicFields().join(' '))
      .setOptions({ lean: true });

    if (user) {
      throw Error('User already exists');
    }

    const slug = await generateSlug(this, email);

    const newUser = await this.create({
      _id: uid,
      createdAt: new Date(),
      email,
      slug,
      defaultTeamSlug: '',
    });

    const emailTemplate = await getEmailTemplate('welcome', { userName: email });

    if (!emailTemplate) {
      throw new Error('Email template "welcome" not found in database.');
    }

    try {
      await sendEmail({
        from: `Kelly from saas-app.async-await.com <${process.env.EMAIL_SUPPORT_FROM_ADDRESS}>`,
        to: [email],
        subject: emailTemplate.subject,
        body: emailTemplate.message,
      });
    } catch (err) {
      console.error('Email sending error:', err);
    }

    try {
      await addToMailchimp({ email, listName: 'signups' });
    } catch (error) {
      console.error('Mailchimp error:', error);
    }

    return _.pick(newUser, this.publicFields());
  }

  public static toggleTheme({ userId, darkTheme }) {
    return this.updateOne({ _id: userId }, { darkTheme: !!darkTheme });
  }

  public static async getMembersForTeam({ userId, teamId }) {
    const team = await this.checkPermissionAndGetTeam({ userId, teamId });

    return this.find({ _id: { $in: team.memberIds } })
      .select(this.publicFields().join(' '))
      .setOptions({ lean: true });
  }

  private static async checkPermissionAndGetTeam({ userId, teamId }) {
    console.log(userId, teamId);

    if (!userId || !teamId) {
      throw new Error('Bad data');
    }

    const team = await Team.findById(teamId).select('memberIds').setOptions({ lean: true });

    if (!team || team.memberIds.indexOf(userId) === -1) {
      throw new Error('Team not found');
    }

    return team;
  }
}

mongoSchema.loadClass(UserClass);

const User = mongoose.model<UserDocument, UserModel>('User', mongoSchema);

export default User;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\server\utils\slugify.ts -----

import * as _ from 'lodash';

const slugify = (text) => _.kebabCase(text);

async function createUniqueSlug(Model, slug, count, filter) {
  const obj = await Model.findOne({ slug: `${slug}-${count}`, ...filter })
    .select('_id')
    .setOptions({ lean: true });

  if (!obj) {
    return `${slug}-${count}`;
  }

  return createUniqueSlug(Model, slug, count + 1, filter);
}

async function generateSlug(Model, name, filter = {}) {
  const origSlug = slugify(name);

  const obj = await Model.findOne({ slug: origSlug, ...filter })
    .select('_id')
    .setOptions({ lean: true });

  if (!obj) {
    return origSlug;
  }

  return createUniqueSlug(Model, origSlug, 1, filter);
}

async function generateNumberSlug(Model, filter = {}, n = 1) {
  const obj = await Model.findOne({ slug: n, ...filter })
    .select('_id')
    .setOptions({ lean: true });

  if (!obj) {
    return `${n}`;
  }

  return generateNumberSlug(Model, filter, ++n);
}

export { generateSlug, generateNumberSlug };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\server\utils\sum.ts -----

function sum(a, b) {
  return a + b;
}

export { sum };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\server\aws-s3.ts -----

import * as url from 'url';
import * as aws from 'aws-sdk';

async function signRequestForUpload({ fileName, fileType, prefix, bucket }) {
  const randomStringForPrefix =
    Math.random().toString(36).substring(2, 12) + Math.random().toString(36).substring(2, 12);

  const key = `${prefix}/${randomStringForPrefix}/${fileName}`;

  const acl = 'public-read';

  const params = {
    Bucket: bucket,
    Key: key,
    Expires: 60,
    ContentType: fileType,
    ACL: acl,
  };

  console.log(key, bucket);

  const s3 = new aws.S3({
    apiVersion: 'latest',
    region: process.env.AWS_REGION,
    accessKeyId: process.env.AWS_ACCESSKEYID,
    secretAccessKey: process.env.AWS_SECRETACCESSKEY,
  });

  return new Promise((resolve, reject) => {
    s3.getSignedUrl('putObject', params, (err, data) => {
      const parsedUrl = url.parse(data);

      const returnData = {
        signedRequest: data,
        url: `${parsedUrl.protocol}//${parsedUrl.hostname}${parsedUrl.pathname}`,
      };

      console.log(returnData);

      if (err) {
        console.error(err);
        reject(err);
      } else {
        resolve(returnData);
      }
    });
  });
}

export { signRequestForUpload };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\server\aws-ses.ts -----

import * as aws from 'aws-sdk';

export default function sendEmail(options) {
  const ses = new aws.SES({
    apiVersion: 'latest',
    region: process.env.AWS_REGION,
    accessKeyId: process.env.AWS_ACCESSKEYID,
    secretAccessKey: process.env.AWS_SECRETACCESSKEY,
  });

  return new Promise((resolve, reject) => {
    ses.sendEmail(
      {
        Source: options.from,
        Destination: {
          CcAddresses: options.cc,
          ToAddresses: options.to,
        },
        Message: {
          Subject: {
            Data: options.subject,
          },
          Body: {
            Html: {
              Data: options.body,
            },
          },
        },
        ReplyToAddresses: options.replyTo,
      },
      (err, info) => {
        if (err) {
          reject(err);
        } else {
          resolve(info);
        }
      },
    );
  });
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\server\google-auth.ts -----

import * as passport from 'passport';
import { OAuth2Strategy as Strategy } from 'passport-google-oauth';

import User, { UserDocument } from './models/User';
import Invitation from './models/Invitation';

function setupGoogle({ server }) {
  if (!process.env.GOOGLE_CLIENTID) {
    return;
  }

  const verify = async (req, accessToken, refreshToken, profile, done) => {
    let email;
    let avatarUrl;

    if (profile.emails) {
      email = profile.emails[0].value;
    }

    if (profile.photos && profile.photos.length > 0) {
      avatarUrl = profile.photos[0].value.replace('sz=50', 'sz=128');
    }

    try {
      const user = await User.signInOrSignUpViaGoogle({
        googleId: profile.id,
        email,
        googleToken: { accessToken, refreshToken },
        displayName: profile.displayName,
        avatarUrl,
      });

      let teamSlugOfInvitedTeam;
      if (user && req.session.invitationToken) {
        teamSlugOfInvitedTeam = await Invitation.addUserToTeam({
          token: req.session.invitationToken,
          user,
        }).catch((err) => console.error(err));
      }

      user.defaultTeamSlug = teamSlugOfInvitedTeam ? teamSlugOfInvitedTeam : user.defaultTeamSlug;

      done(null, user);
    } catch (err) {
      done(err);
      console.error(err);
    }
  };

  passport.use(
    new Strategy(
      {
        clientID: process.env.GOOGLE_CLIENTID,
        clientSecret: process.env.GOOGLE_CLIENTSECRET,
        callbackURL: `${process.env.URL_API}/oauth2callback`,
        passReqToCallback: true,
      },
      verify,
    ),
  );

  passport.serializeUser((user: UserDocument, done) => {
    done(null, user._id);
  });

  passport.deserializeUser((id, done) => {
    User.findById(id, User.publicFields())
      .then((user) => {
        done(null, user);
      })
      .catch((error) => {
        done(error, null);
      });
  });

  server.use(passport.initialize());
  server.use(passport.session());

  server.get('/auth/google', (req, res, next) => {
    const options = {
      scope: ['profile', 'email'],
      prompt: 'select_account',
    };

    if (req.query && req.query.invitationToken) {
      req.session.invitationToken = req.query.invitationToken;
    } else {
      req.session.invitationToken = null;
    }

    passport.authenticate('google', options)(req, res, next);
  });

  server.get(
    '/oauth2callback',
    passport.authenticate('google', {
      failureRedirect: '/login',
    }),
    async (req, res) => {
      let teamSlugOfInvitedTeam;

      if (req.user && req.session.invitationToken) {
        teamSlugOfInvitedTeam = await Invitation.addUserToTeam({
          token: req.session.invitationToken,
          user: req.user,
        }).catch((err) => console.error(err));

        req.session.invitationToken = null;
      }

      let redirectUrlAfterLogin;
      const defaultTeamSlug = req.user && req.user.defaultTeamSlug;

      if (teamSlugOfInvitedTeam || defaultTeamSlug) {
        redirectUrlAfterLogin = `/your-settings`;
      } else {
        redirectUrlAfterLogin = `/create-team`;
      }

      res.redirect(`${process.env.URL_APP}${redirectUrlAfterLogin}`);
    },
  );
}

export { setupGoogle };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\server\mailchimp.ts -----

import fetch, { Response } from 'node-fetch';

// eslint-disable-next-line
require('dotenv').config();

const LIST_IDS = {
  signups: process.env.MAILCHIMP_SAAS_ALL_LIST_ID,
};

function callAPI({ path, method, data }): Promise<Response> {
  const ROOT_URI = `https://${process.env.MAILCHIMP_REGION}.api.mailchimp.com/3.0`;

  return fetch(`${ROOT_URI}${path}`, {
    method,
    headers: {
      Accept: 'application/json',
      Authorization: `Basic ${Buffer.from(`apikey:${process.env.MAILCHIMP_API_KEY}`).toString(
        'base64',
      )}`,
    },
    body: JSON.stringify(data),
  });
}

async function addToMailchimp({ email, listName }) {
  const data = {
    // eslint-disable-next-line
    email_address: email,
    status: 'subscribed',
  };

  const path = `/lists/${LIST_IDS[listName]}/members/`;

  await callAPI({ path, method: 'POST', data });
}

export { addToMailchimp };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\server\passwordless-auth.ts -----

import * as passwordless from 'passwordless';

import sendEmail from './aws-ses';
import getEmailTemplate from './models/EmailTemplate';
import User from './models/User';
import PasswordlessMongoStore from './passwordless-token-mongostore';
import Invitation from './models/Invitation';

function setupPasswordless({ server }) {
  const mongoStore = new PasswordlessMongoStore();

  passwordless.addDelivery(async (tokenToSend, uidToSend, recipient, callback) => {
    try {
      const template = await getEmailTemplate('login', {
        loginURL: `${
          process.env.URL_API
        }/auth/logged_in?token=${tokenToSend}&uid=${encodeURIComponent(uidToSend)}`,
      });

      await sendEmail({
        from: `Kelly from saas-app.async-await.com <${process.env.EMAIL_SUPPORT_FROM_ADDRESS}>`,
        to: [recipient],
        subject: template.subject,
        body: template.message,
      });

      callback();
    } catch (err) {
      console.error('Email sending error:', err);
      callback(err);
    }
  });

  passwordless.init(mongoStore);
  server.use(passwordless.sessionSupport());

  server.use((req, __, next) => {
    if (req.user && typeof req.user === 'string') {
      User.findById(req.user, User.publicFields())
        .then((user) => {
          req.user = user;
          console.log('passwordless middleware');
          next();
        })
        .catch((err) => {
          next(err);
        });
    } else {
      next();
    }
  });

  server.post(
    '/auth/email-login-link',
    passwordless.requestToken(async (email, __, callback) => {
      try {
        const user = await User.findOne({ email }).select('_id').setOptions({ lean: true });

        if (user) {
          callback(null, user._id);
        } else {
          const id = await mongoStore.storeOrUpdateByEmail(email);
          callback(null, id);
        }
      } catch (error) {
        callback(error, null);
      }
    }),
    (req, res) => {
      if (req.query && req.query.invitationToken) {
        req.session.invitationToken = req.query.invitationToken;
      } else {
        req.session.invitationToken = null;
      }

      res.json({ done: 1 });
    },
  );

  server.get(
    '/auth/logged_in',
    passwordless.acceptToken(),
    (req, __, next) => {
      if (req.user && typeof req.user === 'string') {
        User.findById(req.user, User.publicFields())
          .then((user) => {
            req.user = user;
            next();
          })
          .catch((err) => {
            next(err);
          });
      } else {
        next();
      }
    },
    async (req, res) => {
      let teamSlugOfInvitedTeam;

      if (req.user && req.session.invitationToken) {
        teamSlugOfInvitedTeam = await Invitation.addUserToTeam({
          token: req.session.invitationToken,
          user: req.user,
        }).catch((err) => console.error(err));

        req.session.invitationToken = null;
      }

      let redirectUrlAfterLogin;
      const defaultTeamSlug = req.user && req.user.defaultTeamSlug;

      if (teamSlugOfInvitedTeam || defaultTeamSlug) {
        redirectUrlAfterLogin = `/your-settings`;
      } else {
        redirectUrlAfterLogin = `/create-team`;
      }

      res.redirect(`${process.env.URL_APP}${redirectUrlAfterLogin}`);
    },
  );

  server.get('/logout', (req, res, next) => {
    req.logout((err) => {
      if (err) {
        next(err);
      }

      if (req.query && req.query.invitationToken) {
        res.redirect(`${process.env.URL_APP}/invitation?token=${req.query.invitationToken}`);
      } else {
        res.redirect(`${process.env.URL_APP}/login`);
      }
    });
  });
}

export { setupPasswordless };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\server\passwordless-token-mongostore.ts -----

import * as bcrypt from 'bcrypt';
import * as mongoose from 'mongoose';
import * as TokenStore from 'passwordless-tokenstore';
import * as util from 'util';

import User from './models/User';

interface TokenDocument extends mongoose.Document {
  hashedToken: string;
  uid: string;
  ttl: Date;
  originUrl: string;
  email: string;
}

const mongoSchema = new mongoose.Schema({
  hashedToken: {
    type: String,
    required: true,
  },
  uid: {
    type: String,
    required: true,
    unique: true,
  },
  ttl: {
    type: Date,
    required: true,
    expires: 0,
  },
  originUrl: String,
  email: String,
});

const PasswordlessToken = mongoose.model<TokenDocument>(
  'PasswordlessToken',
  mongoSchema,
  'passwordless-token',
);

function MongoStore(options = {}) {
  TokenStore.call(this);

  this._options = options || {};
}

util.inherits(MongoStore, TokenStore);

MongoStore.prototype.authenticate = async function (token, uid, callback) {
  if (!token || !uid || !callback) {
    throw new Error('TokenStore:authenticate called with invalid parameters');
  }

  try {
    const tokenDoc = await PasswordlessToken.findOne({ uid, ttl: { $gt: new Date() } }).setOptions({
      lean: true,
    });

    if (tokenDoc) {
      const isMatch = await bcrypt.compare(token, tokenDoc.hashedToken);
      if (isMatch) {
        if (tokenDoc.email) {
          await User.signInOrSignUpByPasswordless({ uid, email: tokenDoc.email });
        }

        callback(null, true, tokenDoc.originUrl);
      } else {
        callback(null, false, null);
      }
    } else {
      callback(null, false, null);
    }
  } catch (error) {
    callback(error, false, null);
  }
};

MongoStore.prototype.storeOrUpdate = async function (token, uid, msToLive, originUrl, callback) {
  if (!token || !uid || !msToLive || !callback) {
    throw new Error('TokenStore:storeOrUpdate called with invalid parameters');
  }

  const saltRounds = 10;

  try {
    const hashedToken = await bcrypt.hash(token, saltRounds);
    const newRecord = { hashedToken, uid, ttl: new Date(Date.now() + msToLive), originUrl };

    await PasswordlessToken.updateOne(
      { uid },
      { $set: newRecord },
      { upsert: true, runValidators: true },
    );
    callback();
  } catch (error) {
    callback(error);
  }
};

MongoStore.prototype.invalidateUser = async function (uid, callback) {
  if (!uid || !callback) {
    throw new Error('TokenStore:invalidateUser called with invalid parameters');
  }

  try {
    await PasswordlessToken.deleteOne({ uid });
    callback();
  } catch (error) {
    callback(error);
  }
};

MongoStore.prototype.clear = async function (callback) {
  if (!callback) {
    throw new Error('TokenStore:clear called with invalid parameters');
  }

  try {
    await PasswordlessToken.deleteMany({});
    callback();
  } catch (error) {
    callback(error);
  }
};

MongoStore.prototype.length = function (callback) {
  PasswordlessToken.countDocuments(callback);
};

MongoStore.prototype.storeOrUpdateByEmail = async function addEmail(email: string) {
  if (!email) {
    throw new Error('TokenStore:addEmail called with invalid parameters');
  }

  const obj = await PasswordlessToken.findOne({ email }).select('uid').setOptions({ lean: true });

  if (obj) {
    return obj.uid;
  }

  const uid = new mongoose.Types.ObjectId().toHexString();
  await PasswordlessToken.updateOne({ uid }, { email }, { upsert: true });

  return uid;
};

export default MongoStore;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\server\server.ts -----

// eslint-disable-next-line @typescript-eslint/no-var-requires
const MongoStore = require('connect-mongo');

import * as cors from 'cors';
import * as express from 'express';
import * as session from 'express-session';
import * as httpModule from 'http';
import * as mongoose from 'mongoose';

import api from './api';
import { setupGoogle } from './google-auth';
import { setupPasswordless } from './passwordless-auth';
import { setupSockets } from './sockets';

// eslint-disable-next-line
require('dotenv').config();

mongoose.connect(process.env.MONGO_URL_TEST);

const server = express();

server.use(
  cors({
    origin: process.env.URL_APP,
    methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',
    credentials: true,
  }),
);

server.use(express.json());

const sessionOptions = {
  name: process.env.SESSION_NAME,
  secret: process.env.SESSION_SECRET,
  resave: false,
  saveUninitialized: false,
  store: MongoStore.create({
    mongoUrl: process.env.MONGO_URL_TEST,
    ttl: 14 * 24 * 60 * 60, // save session 14 days
    autoRemove: 'interval',
    autoRemoveInterval: 1440, // clears every day
  }),
  cookie: {
    httpOnly: true,
    maxAge: 14 * 24 * 60 * 60 * 1000, // expires in 14 days
    secure: false,
  },
};

const sessionMiddleware = session(sessionOptions);
server.use(sessionMiddleware);

setupGoogle({ server });
setupPasswordless({ server });

api(server);

const httpServer = httpModule.createServer(server);
setupSockets({ httpServer, origin: process.env.URL_APP, sessionMiddleware });

server.get('*', (_, res) => {
  res.sendStatus(403);
});

httpServer.listen(process.env.PORT_API, () => {
  console.log(`> Ready on ${process.env.URL_API}`);
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\server\sockets.ts -----

import { Response } from 'express';
import { Server } from 'socket.io';

import { DiscussionDocument } from './models/Discussion';
import { PostDocument } from './models/Post';

let io: Server = null;
// const dev = process.env.NODE_ENV !== 'production';

function setupSockets({ httpServer, origin, sessionMiddleware }) {
  if (io === null) {
    io = new Server(httpServer, {
      cors: {
        origin,
        methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',
        credentials: true,
      },
      cookie: {
        name: 'io',
        httpOnly: true,
        maxAge: 14 * 24 * 60 * 60 * 1000, // expires in 14 days
        domain: 'localhost',
        secure: false,
      },
      serveClient: false,
      transports: ['polling', 'websocket'],
    });

    const wrap = (middleware) => (socket, next) => middleware(socket.request, {} as Response, next);

    io.use(wrap(sessionMiddleware));

    io.on('connection', (socket: any) => {
      if (
        !socket.request.session ||
        ((!socket.request.session.passport || !socket.request.session.passport.user) &&
          !socket.request.session.passwordless)
      ) {
        socket.disconnect(true);
        return;
      }

      socket.on('joinTeamRoom', (teamId) => {
        console.log(`    joinTeamRoom ${teamId}`);
        socket.join(`teamRoom-${teamId}`);
      });

      socket.on('leaveTeamRoom', (teamId) => {
        console.log(`** leaveTeamRoom ${teamId}`);
        socket.leave(`teamRoom-${teamId}`);
      });

      socket.on('joinDiscussionRoom', (discussionId) => {
        console.log(`    joinDiscussionRoom ${discussionId}`);
        socket.join(`discussionRoom-${discussionId}`);
      });

      socket.on('leaveDiscussionRoom', (discussionId) => {
        console.log(`** leaveDiscussionRoom ${discussionId}`);
        socket.leave(`discussionRoom-${discussionId}`);
      });

      socket.on('disconnect', (reason) => {
        console.log(`disconnected`, `reason: ` + reason);
      });
    });
  }
}

function getSocket(socketId?: string) {
  if (!io) {
    return null;
  }

  if (socketId && io.sockets.sockets.get(socketId)) {
    return io.sockets.sockets.get(socketId).broadcast;
  } else {
    return io;
  }
}

function discussionAdded({
  socketId,
  discussion,
}: {
  socketId?: string;
  discussion: DiscussionDocument;
}) {
  const roomName = `teamRoom-${discussion.teamId}`;

  const socket = getSocket(socketId);
  if (socket) {
    socket.to(roomName).emit('discussionEvent', { actionType: 'added', discussion });
  }
}

function discussionEdited({
  socketId,
  discussion,
}: {
  socketId?: string;
  discussion: DiscussionDocument;
}) {
  const roomName = `teamRoom-${discussion.teamId}`;
  const socket = getSocket(socketId);

  if (socket) {
    socket.to(roomName).emit('discussionEvent', {
      actionType: 'edited',
      discussion,
    });
  }
}

function discussionDeleted({
  socketId,
  teamId,
  id,
}: {
  socketId?: string;
  teamId: string;
  id: string;
}) {
  const roomName = `teamRoom-${teamId}`;
  const socket = getSocket(socketId);

  if (socket) {
    socket.to(roomName).emit('discussionEvent', { actionType: 'deleted', id });
  }
}

function postAdded({ socketId, post }: { socketId?: string; post: PostDocument }) {
  const roomName = `discussionRoom-${post.discussionId}`;

  const socket = getSocket(socketId);
  if (socket) {
    socket.to(roomName).emit('postEvent', { actionType: 'added', post });
  }
}

function postEdited({ socketId, post }: { socketId?: string; post: PostDocument }) {
  const roomName = `discussionRoom-${post.discussionId}`;

  const socket = getSocket(socketId);
  if (socket) {
    socket.to(roomName).emit('postEvent', { actionType: 'edited', post });
  }
}

function postDeleted({
  socketId,
  id,
  discussionId,
}: {
  socketId?: string;
  id: string;
  discussionId: string;
}) {
  const roomName = `discussionRoom-${discussionId}`;

  const socket = getSocket(socketId);
  if (socket) {
    socket.to(roomName).emit('postEvent', { actionType: 'deleted', id });
  }
}

export {
  setupSockets,
  postAdded,
  postEdited,
  postDeleted,
  discussionAdded,
  discussionEdited,
  discussionDeleted,
};

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\test\server\utils\slugify.test.ts -----

import * as mongoose from 'mongoose';
import User from '../../../server/models/User';
import { generateSlug } from '../../../server/utils/slugify';

// eslint-disable-next-line
require('dotenv').config();

describe('slugify', () => {
  beforeAll(async () => {
    await mongoose.connect(process.env.MONGO_URL_TEST);

    const mockUsers = [
      {
        slug: 'john',
        email: 'john@example.com',
        createdAt: new Date(),
        displayName: 'abc',
        avatarUrl: 'def',
      },
      {
        slug: 'john-johnson',
        email: 'john-johnson@example.com',
        createdAt: new Date(),
        displayName: 'abc',
        avatarUrl: 'def',
      },
      {
        slug: 'john-johnson-1',
        email: 'john-johnson-1@example.com',
        createdAt: new Date(),
        displayName: 'abc',
        avatarUrl: 'def',
      },
    ];

    await User.insertMany(mockUsers);
  });

  test('not duplicated', async () => {
    expect.assertions(1);

    await expect(generateSlug(User, 'John J Johnson@#$')).resolves.toEqual('john-j-johnson');
  });

  test('one time duplicated', async () => {
    expect.assertions(1);

    await expect(generateSlug(User, ' John@#$')).resolves.toEqual('john-1');
  });

  test('multiple duplicated', async () => {
    expect.assertions(1);

    await expect(generateSlug(User, 'John & Johnson@#$')).resolves.toEqual('john-johnson-2');
  });

  afterAll(async () => {
    await User.deleteMany({ slug: { $in: ['john', 'john-johnson', 'john-johnson-1'] } });
    await mongoose.disconnect();
  });
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\test\server\utils\sum.test.ts -----

import { sum } from '../../../server/utils/sum';

console.log(sum(1, 2));

describe.skip('testing sum function', () => {
  test('adds 1 + 2 to equal 3', () => {
    expect(sum(1, 2)).toBe(3);
  });
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\.eslintrc.js -----

module.exports = {
  parser: "@typescript-eslint/parser",
  extends: ["plugin:@typescript-eslint/recommended", "prettier"],
  env: {
    "es6": true,
    "node": true,
  },
  plugins: ["prettier"],
  rules: {
    'prettier/prettier': [
      'error',
      {
        singleQuote: true,
        trailingComma: 'all',
        arrowParens: 'always',
        printWidth: 100,
        semi: true,
      },
    ],
    '@typescript-eslint/no-unused-vars': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/no-explicit-any': 'off',
    'prefer-arrow-callback': 'error',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
 },
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\nodemon.json -----

{
  "watch": ["server"],
  "exec": "ts-node --project tsconfig.server.json",
  "ext": "ts"
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\package.json -----

{
  "name": "9-begin-api",
  "version": "1",
  "license": "MIT",
  "scripts": {
    "dev": "nodemon server/server.ts",
    "lint": "eslint . --ext .ts,.tsx",
    "test": "jest"
  },
  "jest": {
    "preset": "ts-jest",
    "testPathIgnorePatterns": [
      "production-server"
    ],
    "testEnvironment": "node"
  },
  "dependencies": {
    "aws-sdk": "^2.1692.0",
    "bcrypt": "^5.1.1",
    "connect-mongo": "^5.1.0",
    "cors": "^2.8.5",
    "dotenv": "^16.4.7",
    "express": "^4.21.2",
    "express-session": "^1.18.1",
    "he": "^1.2.0",
    "highlight.js": "^11.11.1",
    "lodash": "^4.17.21",
    "marked": "^15.0.7",
    "mongoose": "^8.12.1",
    "node-fetch": "2",
    "passport": "^0.7.0",
    "passport-google-oauth": "^2.0.0",
    "passwordless": "^1.1.3",
    "passwordless-tokenstore": "^0.0.10",
    "socket.io": "^4.8.1",
    "typescript": "^5.8.2"
  },
  "devDependencies": {
    "@types/connect-mongo": "^3.1.6",
    "@types/dotenv": "^8.2.3",
    "@types/express": "^5.0.1",
    "@types/express-session": "^1.18.1",
    "@types/jest": "^29.5.14",
    "@types/lodash": "^4.17.16",
    "@types/mongoose": "^5.11.97",
    "@types/node": "^22.13.11",
    "@types/node-fetch": "^2.6.12",
    "@types/passport": "^1.0.17",
    "@types/socket.io": "^3.0.2",
    "@typescript-eslint/eslint-plugin": "^8.27.0",
    "@typescript-eslint/parser": "^8.27.0",
    "eslint": "^9.22.0",
    "eslint-config-prettier": "^10.1.1",
    "eslint-plugin-prettier": "^5.2.3",
    "jest": "^29.7.0",
    "nodemon": "^3.1.9",
    "prettier": "^3.5.3",
    "ts-jest": "^29.2.6",
    "ts-node": "^10.9.2"
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\tsconfig.json -----

{
  "compileOnSave": false,
  "compilerOptions": {
    "jsx": "preserve",
    "allowJs": true,
    "alwaysStrict": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "removeComments": false,
    "preserveConstEnums": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "sourceMap": true,
    "skipLibCheck": true,
    "baseUrl": ".",
    "experimentalDecorators": true,
    "typeRoots": ["./node_modules/@types"],
    "lib": ["es2015", "es2016"]
  },
  "exclude": ["production-server", "node_modules"]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\api\tsconfig.server.json -----

{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "module": "commonjs",
    "outDir": "production-server/"
  },
  "include": ["./server/**/*.ts"],
  "exclude": ["./server/**/*.test.ts"]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\components\common\Confirmer.tsx -----

import Button from "@mui/material/Button";
import Dialog from "@mui/material/Dialog";
import DialogActions from "@mui/material/DialogActions";
import DialogContent from "@mui/material/DialogContent";
import DialogContentText from "@mui/material/DialogContentText";
import DialogTitle from "@mui/material/DialogTitle";
import React from "react";

export let openConfirmDialogExternal;

type State = {
  open: boolean;
  title: string;
  message: string;
  onAnswer: (answer) => void;
};

class Confirmer extends React.Component<any, State> {
  constructor(props) {
    super(props);

    this.state = {
      open: false,
      title: "Are you sure?",
      message: "",
      onAnswer: null,
    };

    openConfirmDialogExternal = this.openConfirmDialog;
  }

  public render() {
    return (
      <Dialog
        open={this.state.open}
        onClose={this.handleClose}
        aria-labelledby="alert-dialog-title"
        aria-describedby="alert-dialog-description"
      >
        <DialogTitle id="alert-dialog-title">{this.state.title}</DialogTitle>
        <DialogContent>
          <DialogContentText id="alert-dialog-description">{this.state.message}</DialogContentText>
        </DialogContent>
        <DialogActions style={{ padding: "10px" }}>
          <Button onClick={this.handleClose} variant="contained" color="primary" autoFocus>
            Cancel
          </Button>
          <Button onClick={this.handleYes} variant="contained" color="secondary">
            OK
          </Button>
        </DialogActions>
      </Dialog>
    );
  }

  public handleClose = () => {
    this.setState({ open: false });
    this.state.onAnswer(false);
  };

  public handleYes = () => {
    this.setState({ open: false });
    this.state.onAnswer(true);
  };

  public openConfirmDialog = ({ title, message, onAnswer }) => {
    this.setState({ open: true, title, message, onAnswer });
  };
}

export default Confirmer;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\components\common\LoginButton.tsx -----

import Button from "@mui/material/Button";
import TextField from "@mui/material/TextField";
import React from "react";

import { emailLoginLinkApiMethod } from "../../lib/api/public";
import notify from "../../lib/notify";
import { makeQueryString } from "../../lib/api/makeQueryString";

type Props = { invitationToken?: string };
type State = { email: string };

class LoginButton extends React.PureComponent<Props, State> {
  constructor(props) {
    super(props);

    this.state = { email: "" };
  }

  public render() {
    const { invitationToken } = this.props;

    let url = `${process.env.NEXT_PUBLIC_URL_API}/auth/google`;
    const qs = makeQueryString({ invitationToken });

    if (qs) {
      url += `?${qs}`;
    }

    // console.log(url);

    return (
      <React.Fragment>
        <Button variant="contained" color="secondary" href={url}>
          <img src="https://storage.googleapis.com/async-await-all/G.svg" alt="Log in with Google" />
          &nbsp;&nbsp;&nbsp; Log in with Google
        </Button>
        <p />
        <br />
        <hr style={{ width: "60px" }} /> <h4>OR</h4> <hr style={{ width: "60px" }} />
        <p />
        <br />
        <div>
          <form autoComplete="off" onSubmit={this.onSubmit}>
            <TextField
              required
              type="email"
              label="Email address"
              value={this.state.email}
              onChange={(event) => {
                this.setState({ email: event.target.value });
              }}
              style={{ width: "300px" }}
            />
            <p />
            <Button variant="contained" color="primary" type="submit">
              Log in with email
            </Button>
          </form>
          <p />
          <br />
        </div>
      </React.Fragment>
    );
  }

  private onSubmit = async (event) => {
    event.preventDefault();
    const { email } = this.state;
    const { invitationToken } = this.props;

    if (!email) {
      notify("Email is required");
    }

    try {
      await emailLoginLinkApiMethod({ email, invitationToken });
      this.setState({ email: "" });
      notify("SaaS boilerplate emailed you a login link.");
    } catch (error) {
      notify(error);
    }
  };
}

export default LoginButton;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\components\common\MemberChooser.tsx -----

import React from "react";

import Autocomplete from "@mui/material/Autocomplete";
import TextField from "@mui/material/TextField";

import { User } from "../../lib/store/user";

type Props = {
  onChange: (item) => void;
  selectedMemberIds?: string[];
  members: User[];
  label?: string;
  helperText?: string;
};

type State = {
  selectedItems: { label: string; id: string }[];
};

class MemberChooser extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    const suggestions = this.props.members.map((user) => ({
      label: user.displayName || user.email,
      id: user._id,
    }));

    const selectedItems = suggestions.filter((s) => this.props.selectedMemberIds.indexOf(s.id) !== -1);

    this.state = {
      selectedItems: selectedItems || [],
    };
  }

  public render() {
    const suggestions = this.props.members.map((user) => ({
      label: user.displayName || user.email,
      id: user._id,
    }));

    return (
      <Autocomplete
        multiple
        id="tags-standard"
        options={suggestions}
        getOptionLabel={(option) => option.label}
        isOptionEqualToValue={(option, value) => option.id === value.id}
        value={this.state.selectedItems}
        renderInput={(params) => (
          <TextField
            {...params}
            variant="standard"
            label="Find team member by name"
            placeholder="Select participants"
          />
        )}
        onChange={this.handleChange}
        filterSelectedOptions={true}
        noOptionsText="No team members to select from"
      />
    );
  }

  public handleChange = (event, value) => {
    event.preventDefault();

    const selectedItems = value;

    this.setState({ selectedItems });

    this.props.onChange(selectedItems.map((i) => i.id));
  };
}

export default MemberChooser;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\components\common\MenuWithLinks.tsx -----

import Menu from "@mui/material/Menu";
import MenuItem from "@mui/material/MenuItem";
import Link from "next/link";
import { NextRouter, withRouter } from "next/router";
import React from "react";

type Props = {
  options: {
    href: string;
    as: string;
    highlighterSlug: string;
    text: string;
    externalServer: boolean;
    separator: boolean;
  }[];
  router: NextRouter;
  children: any;
};

type State = {
  anchorEl: Element | ((element: Element) => Element);
};

class MenuWithLinks extends React.PureComponent<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      anchorEl: null,
    };
  }

  public render() {
    const { options, children, router } = this.props;
    const { anchorEl } = this.state;

    return (
      <div style={{ textAlign: "center" }}>
        <div
          aria-controls={anchorEl ? "simple-menu" : null}
          aria-haspopup="true"
          onClick={this.handleClick}
          onKeyPress={this.handleClick}
        >
          {children}
        </div>
        <Menu id="simple-menu" anchorEl={anchorEl} open={Boolean(anchorEl)} onClose={this.handleClose} keepMounted>
          {options.map((option, i) =>
            option.separator ? (
              <hr style={{ width: "95%", margin: "10px auto" }} key={`separated-${i}`} />
            ) : option.externalServer ? (
              <MenuItem
                onClick={(event) => {
                  event.preventDefault();
                  window.location.href = option.href;
                  this.handleClose();
                }}
                key={option.href || option.text}
              >
                {option.text}
              </MenuItem>
            ) : (
              <Link key={option.href} href={option.href} as={option.as} passHref>
                <MenuItem
                  key={option.href}
                  style={{
                    fontWeight: router.asPath.includes(option.highlighterSlug) ? 600 : 300,
                    fontSize: "14px",
                  }}
                >
                  {option.text}
                </MenuItem>
              </Link>
            )
          )}
        </Menu>
      </div>
    );
  }

  public handleClick = (event) => {
    this.setState({ anchorEl: event.currentTarget });
  };

  public handleClose = () => {
    this.setState({ anchorEl: null });
  };
}

export default withRouter(MenuWithLinks);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\components\common\MenuWithMenuItems.tsx -----

import Menu from "@mui/material/Menu";
import MenuItem from "@mui/material/MenuItem";
import React from "react";

type Props = {
  menuOptions: any;
  itemOptions: any[];
};

type State = {
  menuElem: Element | ((element: Element) => Element);
};

class MenuWithMenuItems extends React.PureComponent<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      menuElem: null,
    };
  }

  public render() {
    const { menuOptions, itemOptions } = this.props;
    const { menuElem } = this.state;

    return (
      <div style={{ verticalAlign: "middle" }}>
        <i
          aria-controls={menuElem ? menuOptions.id : null}
          data-id={menuOptions.dataId}
          aria-haspopup="true"
          style={{ fontSize: "14px", opacity: 0.7, cursor: "pointer" }}
          className="material-icons"
          onClick={(e) => this.handleClick(e)}
        >
          more_vert
        </i>

        <Menu id={menuOptions.id} anchorEl={menuElem} open={Boolean(menuElem)} onClose={this.handleClose}>
          {itemOptions.map((option, i) => (
            <MenuItem
              key={option.dataId + i}
              data-id={option.dataId}
              data-more-id={option.dataMoreId}
              onClick={(e) => {
                this.setState({ menuElem: null });
                option.onClick(e);
              }}
            >
              {option.text}
            </MenuItem>
          ))}
        </Menu>
      </div>
    );
  }

  public handleClick = (event) => {
    event.preventDefault();
    this.setState({ menuElem: event.currentTarget });
  };

  public handleClose = () => {
    this.setState({ menuElem: null });
  };
}

export default MenuWithMenuItems;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\components\common\Notifier.tsx -----

import Snackbar from "@mui/material/Snackbar";
import React from "react";

export let openSnackbarExternal;

type State = {
  open: boolean;
  message: string;
};

class Notifier extends React.PureComponent<any, State> {
  constructor(props) {
    super(props);
    openSnackbarExternal = this.openSnackbar;

    this.state = {
      open: false,
      message: "",
    };
  }

  public render() {
    const message = <span id="snackbar-message-id" dangerouslySetInnerHTML={{ __html: this.state.message }} />;

    return (
      <Snackbar
        anchorOrigin={{ vertical: "top", horizontal: "right" }}
        message={message}
        autoHideDuration={5000}
        onClose={this.handleSnackbarClose}
        open={this.state.open}
        ContentProps={{
          "aria-describedby": "snackbar-message-id",
        }}
      />
    );
  }

  public handleSnackbarClose = () => {
    this.setState({
      open: false,
      message: "",
    });
  };

  public openSnackbar = ({ message }) => {
    this.setState({ open: true, message });
  };
}

export default Notifier;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\components\discussions\CreateDiscussionForm.tsx -----

import Button from "@mui/material/Button";
import Dialog from "@mui/material/Dialog";
import DialogContent from "@mui/material/DialogContent";
import DialogTitle from "@mui/material/DialogTitle";
import TextField from "@mui/material/TextField";
import { observer } from "mobx-react";
import Head from "next/head";
import Router from "next/router";
import NProgress from "nprogress";
import React from "react";

import notify from "../../lib/notify";
import { Store } from "../../lib/store";
import MemberChooser from "../common/MemberChooser";
import PostEditor from "../posts/PostEditor";

type Props = {
  isMobile: boolean;
  store: Store;
  open: boolean;
  onClose: () => void;
};

type State = {
  name: string;
  memberIds: string[];
  disabled: boolean;
  content: string;
};

class CreateDiscussionForm extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      name: "",
      memberIds: [],
      disabled: false,
      content: "",
    };
  }

  public render() {
    const { open, isMobile, store } = this.props;
    const { currentTeam, currentUser } = store;

    const membersMinusCreator = Array.from(currentTeam.members.values()).filter((user) => user._id !== currentUser._id);

    return (
      <React.Fragment>
        {open ? (
          <Head>
            <title>New Discussion</title>
            <meta name="description" content="Create new discussion" />
          </Head>
        ) : null}
        <Dialog onClose={this.handleClose} aria-labelledby="simple-dialog-title" open={open} fullScreen={true}>
          <DialogTitle id="simple-dialog-title">Create new Discussion</DialogTitle>
          <DialogContent>
            <br />
            <form style={{ width: "100%", height: "60%" }} onSubmit={this.onSubmit}>
              <p />
              <br />
              <TextField
                autoFocus
                label="Type name of Discussion"
                helperText="Give a short and informative name to new Discussion"
                value={this.state.name}
                onChange={(event) => {
                  this.setState({ name: event.target.value });
                }}
              />
              <br />
              <p />
              <MemberChooser
                helperText="These members will see all posts and be notified about unread posts in this discussion."
                onChange={this.handleMembersChange}
                members={membersMinusCreator}
                selectedMemberIds={this.state.memberIds}
              />
              <p />
              <br />
              <div>
                <Button type="submit" variant="contained" color="primary" disabled={this.state.disabled}>
                  Create Discussion
                </Button>
                {isMobile ? <p /> : null}
                <Button
                  variant="outlined"
                  onClick={this.handleClose}
                  disabled={this.state.disabled}
                  style={{ marginLeft: isMobile ? "0px" : "20px" }}
                >
                  Cancel
                </Button>{" "}
              </div>
              <p />
              <PostEditor
                content={this.state.content}
                onChanged={this.onContentChanged}
                members={Array.from(store.currentTeam.members.values())}
                store={store}
                parentComponent="CDF"
              />
              <p />
              <div>
                <Button type="submit" variant="contained" color="primary" disabled={this.state.disabled}>
                  Create Discussion
                </Button>
                {isMobile ? <p /> : null}
                <Button
                  variant="outlined"
                  onClick={this.handleClose}
                  disabled={this.state.disabled}
                  style={{ marginLeft: isMobile ? "0px" : "20px" }}
                >
                  Cancel
                </Button>{" "}
                <p />
                <br />
                <br />
              </div>
            </form>
          </DialogContent>
        </Dialog>
      </React.Fragment>
    );
  }

  public handleMembersChange = (memberIds) => {
    this.setState({ memberIds });
  };

  public handleClose = () => {
    this.setState({ name: "", memberIds: [], disabled: false, content: "" });
    this.props.onClose();
  };

  private onContentChanged = (content: string) => {
    console.log("onContentChanged", content);
    this.setState({ content });
  };

  private onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();

    const { store } = this.props;
    const { currentTeam } = store;

    if (!currentTeam) {
      notify("Team have not selected");
      return;
    }

    const { name, memberIds, content } = this.state;

    if (!name) {
      notify("Name is required");
      return;
    }

    if (!content) {
      notify("Content is required");
      return;
    }

    if (!memberIds || memberIds.length < 1) {
      notify("Please assign at least one person to this Discussion.");
      return;
    }

    this.setState({ disabled: true });
    NProgress.start();

    try {
      const discussion = await currentTeam.addDiscussion({
        name,
        memberIds,
      });

      await discussion.addPost(content);

      this.setState({ name: "", memberIds: [], content: "" });

      notify("You successfully added new Discussion.");

      Router.push(
        `/discussion?teamSlug=${currentTeam.slug}&discussionSlug=${discussion.slug}`,
        `/team/${currentTeam.slug}/discussions/${discussion.slug}`
      );
    } catch (error) {
      console.log(error);
      notify(error);
    } finally {
      this.setState({ disabled: false });
      NProgress.done();
      this.props.onClose();
    }
  };
}

export default observer(CreateDiscussionForm);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\components\discussions\DiscussionActionMenu.tsx -----

import { observer } from 'mobx-react';
import NProgress from 'nprogress';
import React from 'react';

import confirm from '../../lib/confirm';
import notify from '../../lib/notify';
import { Store } from '../../lib/store';
import { Discussion } from '../../lib/store/discussion';

import MenuWithMenuItems from '../common/MenuWithMenuItems';
import EditDiscussionForm from './EditDiscussionForm';

const getMenuOptions = (discussion) => ({
  dataId: discussion._id,
  id: `discussion-menu-${discussion._id}`,
});

const getMenuItemOptionsForCreator = (discussion, component) => [
  {
    text: 'Copy URL',
    dataId: discussion._id,
    onClick: component.handleCopyUrl,
  },
  {
    text: 'Edit',
    dataId: discussion._id,
    onClick: component.editDiscussion,
  },
  {
    text: 'Delete',
    dataId: discussion._id,
    onClick: component.deleteDiscussion,
  },
];

const getMenuItemOptions = (discussion, component) => [
  {
    text: 'Copy URL',
    dataId: discussion._id,
    onClick: component.handleCopyUrl,
  },
];

type Props = {
  discussion: Discussion;
  store: Store;
  isMobile: boolean;
};

type State = {
  discussionFormOpen: boolean;
  selectedDiscussion: Discussion;
};

class DiscussionActionMenu extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      discussionFormOpen: false,
      selectedDiscussion: null,
    };
  }

  public render() {
    const { discussion, store } = this.props;
    const { currentUser } = store;

    const isCreator = currentUser._id === discussion.createdUserId ? true : false;

    return (
      <React.Fragment>
        <MenuWithMenuItems
          menuOptions={getMenuOptions(discussion)}
          itemOptions={
            isCreator
              ? getMenuItemOptionsForCreator(discussion, this)
              : getMenuItemOptions(discussion, this)
          }
        />

        {this.state.discussionFormOpen ? (
          <EditDiscussionForm
            open={true}
            onClose={this.handleDiscussionFormClose}
            discussion={discussion}
            isMobile={this.props.isMobile}
            store={store}
          />
        ) : null}
      </React.Fragment>
    );
  }

  public handleCopyUrl = async (event) => {
    const { store } = this.props;
    const { currentTeam } = store;

    const id = event.currentTarget.dataset.id;
    if (!id) {
      return;
    }

    const selectedDiscussion = currentTeam.discussions.find((d) => d._id === id);
    const discussionUrl = `${process.env.NEXT_PUBLIC_URL_APP}/team/${currentTeam.slug}/discussions/${selectedDiscussion.slug}`;

    try {
      if (window.navigator) {
        await window.navigator.clipboard.writeText(discussionUrl);
        notify('You successfully copied URL.');
      }
    } catch (err) {
      notify(err);
    } finally {
      this.setState({ discussionFormOpen: false, selectedDiscussion: null });
    }
  };

  public editDiscussion = (event) => {
    const { currentTeam } = this.props.store;
    if (!currentTeam) {
      notify('You have not selected Team.');
      return;
    }

    const id = event.currentTarget.dataset.id;
    if (!id) {
      return;
    }

    const selectedDiscussion = currentTeam.discussions.find((d) => d._id === id);

    this.setState({ discussionFormOpen: true, selectedDiscussion });
  };

  public deleteDiscussion = async (event) => {
    const { currentTeam } = this.props.store;
    if (!currentTeam) {
      notify('You have not selected Team.');
      return;
    }

    const id = event.currentTarget.dataset.id;

    confirm({
      title: 'Are you sure?',
      message: '',
      onAnswer: async (answer) => {
        if (!answer) {
          return;
        }

        NProgress.start();

        try {
          await currentTeam.deleteDiscussion(id);

          notify('You successfully deleted Discussion.');
        } catch (error) {
          console.error(error);
          notify(error);
        } finally {
          NProgress.done();
        }
      },
    });
  };

  public handleDiscussionFormClose = () => {
    this.setState({ discussionFormOpen: false, selectedDiscussion: null });
  };
}

export default observer(DiscussionActionMenu);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\components\discussions\DiscussionList.tsx -----

import Tooltip from "@mui/material/Tooltip";
import { observer } from "mobx-react";
import React from "react";

import { Store } from "../../lib/store";
import { Team } from "../../lib/store/team";

import CreateDiscussionForm from "./CreateDiscussionForm";
import DiscussionListItem from "./DiscussionListItem";

import notify from "../../lib/notify";

type Props = { store: Store; team: Team; isMobile: boolean };

type State = { discussionFormOpen: boolean };

class DiscussionList extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      discussionFormOpen: false,
    };
  }

  public componentDidMount() {
    this.props.team.loadDiscussions().catch((err) => notify(err));
  }

  public componentDidUpdate(prevProps: Props) {
    if (this.props.team._id !== prevProps.team._id) {
      this.props.team.loadDiscussions().catch((err) => notify(err));
    }
  }

  public render() {
    const { store, team } = this.props;

    const isThemeDark = store && store.currentUser && store.currentUser.darkTheme === true;

    return (
      <div>
        Discussions
        <Tooltip title="Add Discussion" placement="right" disableFocusListener disableTouchListener>
          <a onClick={this.addDiscussion} style={{ float: "right", padding: "0px 10px" }}>
            <i
              className="material-icons"
              color="action"
              style={{ fontSize: 14, opacity: 0.7, color: isThemeDark ? "#fff" : "#000" }}
            >
              add_circle_outline
            </i>{" "}
          </a>
        </Tooltip>
        <p />
        <ul style={{ listStyle: "none", padding: "0px" }}>
          {team &&
            team.orderedDiscussions.map((d) => {
              return (
                <DiscussionListItem
                  key={d._id}
                  discussion={d}
                  team={team}
                  isMobile={this.props.isMobile}
                  store={this.props.store}
                />
              );
            })}
        </ul>
        <CreateDiscussionForm
          isMobile={this.props.isMobile}
          store={this.props.store}
          open={this.state.discussionFormOpen}
          onClose={this.handleDiscussionFormClose}
        />
      </div>
    );
  }

  public addDiscussion = (event) => {
    event.preventDefault();
    this.setState({ discussionFormOpen: true });
  };

  public handleDiscussionFormClose = () => {
    this.setState({ discussionFormOpen: false });
  };
}

export default observer(DiscussionList);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\components\discussions\DiscussionListItem.tsx -----

import Paper from "@mui/material/Paper";
import { observer } from "mobx-react";
import Link from "next/link";
import React from "react";

import { Store } from "../../lib/store";
import { Discussion } from "../../lib/store/discussion";
import { Team } from "../../lib/store/team";

import DiscussionActionMenu from "./DiscussionActionMenu";

type Props = {
  store: Store;
  discussion: Discussion;
  team: Team;
  isMobile: boolean;
};

class DiscussionListItem extends React.Component<Props> {
  public render() {
    const { store, discussion, team, isMobile } = this.props;
    const trimmingLength = 16;

    const selectedDiscussion = store.currentUrl === `/team/${team.slug}/discussions/${discussion.slug}`;

    console.log(store.currentUrl);

    const isThemeDark = store && store.currentUser && store.currentUser.darkTheme === true;

    const selectedItemBorder = isThemeDark ? "1px rgba(255, 255, 255, 0.75) solid" : "1px rgba(0, 0, 0, 0.75) solid";

    return (
      <Paper
        key={discussion._id}
        style={{
          margin: "10px 10px 5px 0px",
          padding: "8px",
          border: selectedDiscussion ? selectedItemBorder : "none",
        }}
        elevation={selectedDiscussion ? 24 : 1}
      >
        <li key={discussion._id} style={{ whiteSpace: "nowrap", paddingRight: "10px" }}>
          <Link
            scroll={false}
            href={`/discussion?teamSlug=${team.slug}&discussionSlug=${discussion.slug}`}
            as={`/team/${team.slug}/discussions/${discussion.slug}`}
            style={{ fontWeight: 300, color: isThemeDark ? "#fff" : "#000" }}
            key={discussion._id}
          >
            {discussion.name.length > trimmingLength
              ? `${discussion.name.substring(0, trimmingLength)}...`
              : discussion.name}
          </Link>
          <div
            style={{
              float: "right",
              marginRight: "-12px",
            }}
          >
            <DiscussionActionMenu discussion={discussion} isMobile={isMobile} store={store} />
          </div>
        </li>
      </Paper>
    );
  }
}

export default observer(DiscussionListItem);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\components\discussions\EditDiscussionForm.tsx -----

import Button from "@mui/material/Button";
import Dialog from "@mui/material/Dialog";
import DialogActions from "@mui/material/DialogActions";
import DialogContent from "@mui/material/DialogContent";
import DialogContentText from "@mui/material/DialogContentText";
import DialogTitle from "@mui/material/DialogTitle";
import TextField from "@mui/material/TextField";
import { observer } from "mobx-react";
import NProgress from "nprogress";
import React from "react";

import notify from "../../lib/notify";
import { Store } from "../../lib/store";
import { Discussion } from "../../lib/store/discussion";
import MemberChooser from "../common/MemberChooser";

type Props = {
  store: Store;
  onClose: () => void;
  open: boolean;
  discussion: Discussion;
  isMobile: boolean;
};

type State = {
  name: string;
  memberIds: string[];
  disabled: boolean;
  discussionId: string;
};

class EditDiscussionForm extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      name: "",
      memberIds: [],
      disabled: false,
      content: "",
    };
  }

  public static getDerivedStateFromProps(props: Props, state: State) {
    const { discussion } = props;

    if (state.discussionId === discussion._id) {
      return null;
    }

    return {
      name: (discussion && discussion.name) || "",
      memberIds: (discussion && discussion.memberIds) || [],
      discussionId: discussion._id,
    };
  }

  public render() {
    const { open, store } = this.props;
    const { currentTeam, currentUser } = store;

    const membersMinusCreator = Array.from(currentTeam.members.values()).filter((user) => user._id !== currentUser._id);

    // console.log(currentTeam.members);

    return (
      <Dialog onClose={this.handleClose} aria-labelledby="simple-dialog-title" open={open}>
        <DialogTitle id="simple-dialog-title">Edit Discussion</DialogTitle>
        <DialogContent>
          <DialogContentText>Edit discussion</DialogContentText>
          <br />
          <form onSubmit={this.onSubmit}>
            <TextField
              label="Type name of Discussion"
              helperText="Give a short and informative name to Discussion"
              value={this.state.name}
              onChange={(event) => {
                this.setState({ name: event.target.value });
              }}
            />
            <br />
            <p />
            <MemberChooser
              helperText="These members will see all posts and be notified about unread posts in this discussion."
              onChange={this.handleMembersChange}
              members={membersMinusCreator}
              selectedMemberIds={this.state.memberIds}
            />
            <p />
            <br />
            <DialogActions>
              <Button color="primary" variant="outlined" onClick={this.handleClose} disabled={this.state.disabled}>
                Cancel
              </Button>
              <Button type="submit" variant="contained" color="primary" disabled={this.state.disabled}>
                Update Discussion
              </Button>
            </DialogActions>
          </form>
        </DialogContent>
      </Dialog>
    );
  }

  public handleMembersChange = (memberIds) => {
    this.setState({ memberIds });
  };

  public handleClose = () => {
    this.setState({ name: "", memberIds: [], disabled: false });
    this.props.onClose();
  };

  private onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();

    const { discussion, store } = this.props;
    const { currentTeam } = store;

    if (!currentTeam) {
      notify("Team have not selected");
      return;
    }

    const { name, memberIds } = this.state;

    if (!name) {
      notify("Please name this Discussion.");
      return;
    }

    if (memberIds && !memberIds.includes(discussion.store.currentUser._id)) {
      memberIds.push(discussion.store.currentUser._id);
    }

    if (!memberIds || memberIds.length < 1) {
      notify("Please assign at least one person to this Discussion.");
      return;
    }

    NProgress.start();
    try {
      await discussion.editDiscussion({ name, memberIds });

      this.setState({ name: "", memberIds: [], disabled: false });
      notify("You successfully edited Discussion.");
    } catch (error) {
      console.log(error);
      notify(error);
    } finally {
      this.setState({ disabled: false });
      NProgress.done();

      this.props.onClose();
    }
  };
}

export default observer(EditDiscussionForm);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\components\layout\index.tsx -----

import Avatar from "@mui/material/Avatar";
import Button from "@mui/material/Button";
import Grid from "@mui/material/Grid";

import Link from "next/link";
import React from "react";

import MenuWithLinks from "../common/MenuWithLinks";
import Confirmer from "../common/Confirmer";
import Notifier from "../common/Notifier";

import { Store } from "../../lib/store";
import DiscussionList from "../discussions/DiscussionList";

const styleGrid = {
  width: "100%",
  height: "100vh",
  maxWidth: "100%",
  padding: "0px 10px",
  display: "flex",
  overflow: "hidden",
};

const styleGridIsMobile = {
  width: "100%",
  height: "100vh",
  maxWidth: "100%",
  padding: "0px 0px 0px 10px",
  display: "flex",
  overflow: "hidden",
};

function LayoutWrapper({
  children,
  isMobile,
  firstGridItem,
  store,
}: {
  children: React.ReactNode;
  isMobile: boolean;
  firstGridItem: boolean;
  store: Store;
}) {
  const isThemeDark = store.currentUser ? store.currentUser.darkTheme : true;

  return (
    <React.Fragment>
      <Grid
        container
        direction="row"
        justify="flex-start"
        alignItems="stretch"
        style={isMobile ? styleGridIsMobile : styleGrid}
      >
        {firstGridItem ? (
          <Grid
            item
            sm={2}
            xs={12}
            style={{
              borderRight: "1px #707070 solid",
              justifyContent: "center",
              overflow: "hidden",
            }}
          >
            <div style={{ display: "flex", justifyContent: "space-between" }}>
              <svg
                xmlns="http://www.w3.org/2000/svg"
                width="124"
                height="40"
                viewBox="0 0 124 40"
                style={{
                  marginTop: "20px",
                  display: "inline-flex",
                  height: "40px",
                }}
              >
                <g id="async-logo">
                  <g id="async-logo-40">
                    <circle id="Ellipse 2" cx="20" cy="20" r="20" fill="black" />
                    <path
                      id="path-async-logo"
                      d="M7.07825 -0.0960007V16H4.51825V13.088C4.04892 14.0907 3.33425 14.8693 2.37425 15.424C1.43558 15.9573 0.336917 16.224 -0.92175 16.224C-2.35108 16.224 -3.60975 15.8827 -4.69775 15.2C-5.76442 14.5173 -6.59642 13.5573 -7.19375 12.32C-7.76975 11.0613 -8.05775 9.6 -8.05775 7.936C-8.05775 6.272 -7.75908 4.81067 -7.16175 3.552C-6.56442 2.272 -5.73242 1.28 -4.66575 0.576C-3.57775 -0.128 -2.32975 -0.48 -0.92175 -0.48C0.336917 -0.48 1.43558 -0.202666 2.37425 0.352C3.31292 0.906667 4.02758 1.68533 4.51825 2.688V-0.0960007H7.07825ZM-0.40975 14.08C1.16892 14.08 2.38492 13.5467 3.23825 12.48C4.09158 11.392 4.51825 9.856 4.51825 7.872C4.51825 5.888 4.09158 4.36267 3.23825 3.296C2.38492 2.22933 1.16892 1.696 -0.40975 1.696C-1.98842 1.696 -3.22575 2.25067 -4.12175 3.36C-4.99642 4.448 -5.43375 5.97333 -5.43375 7.936C-5.43375 9.89867 -4.99642 11.4133 -4.12175 12.48C-3.24708 13.5467 -2.00975 14.08 -0.40975 14.08Z"
                      transform="translate(19.5938 12)"
                      fill="white"
                    />
                  </g>
                  <path
                    id="path-async-text"
                    d="M22.6251 11.928V24H20.7051V21.816C20.3531 22.568 19.8171 23.152 19.0971 23.568C18.3931 23.968 17.5691 24.168 16.6251 24.168C15.5531 24.168 14.6091 23.912 13.7931 23.4C12.9931 22.888 12.3691 22.168 11.9211 21.24C11.4891 20.296 11.2731 19.2 11.2731 17.952C11.2731 16.704 11.4971 15.608 11.9451 14.664C12.3931 13.704 13.0171 12.96 13.8171 12.432C14.6331 11.904 15.5691 11.64 16.6251 11.64C17.5691 11.64 18.3931 11.848 19.0971 12.264C19.8011 12.68 20.3371 13.264 20.7051 14.016V11.928H22.6251ZM17.0091 22.56C18.1931 22.56 19.1051 22.16 19.7451 21.36C20.3851 20.544 20.7051 19.392 20.7051 17.904C20.7051 16.416 20.3851 15.272 19.7451 14.472C19.1051 13.672 18.1931 13.272 17.0091 13.272C15.8251 13.272 14.8971 13.688 14.2251 14.52C13.5691 15.336 13.2411 16.48 13.2411 17.952C13.2411 19.424 13.5691 20.56 14.2251 21.36C14.8811 22.16 15.8091 22.56 17.0091 22.56ZM30.4637 24.168C28.4317 24.168 26.8237 23.648 25.6397 22.608L26.2877 21.168C26.9437 21.68 27.6077 22.048 28.2797 22.272C28.9517 22.496 29.7037 22.608 30.5357 22.608C31.4477 22.608 32.1357 22.456 32.5997 22.152C33.0797 21.832 33.3197 21.376 33.3197 20.784C33.3197 20.304 33.1597 19.92 32.8397 19.632C32.5197 19.344 31.9917 19.12 31.2557 18.96L29.2157 18.48C28.2077 18.256 27.4237 17.856 26.8637 17.28C26.3197 16.704 26.0477 16.016 26.0477 15.216C26.0477 14.16 26.4717 13.304 27.3197 12.648C28.1677 11.976 29.2877 11.64 30.6797 11.64C31.5277 11.64 32.3277 11.776 33.0797 12.048C33.8317 12.32 34.4637 12.712 34.9757 13.224L34.3277 14.64C33.1917 13.696 31.9757 13.224 30.6797 13.224C29.8157 13.224 29.1437 13.392 28.6637 13.728C28.1997 14.048 27.9677 14.504 27.9677 15.096C27.9677 15.592 28.1117 15.984 28.3997 16.272C28.7037 16.56 29.1837 16.784 29.8397 16.944L31.8797 17.448C32.9997 17.704 33.8317 18.104 34.3757 18.648C34.9197 19.176 35.1917 19.872 35.1917 20.736C35.1917 21.776 34.7677 22.608 33.9197 23.232C33.0717 23.856 31.9197 24.168 30.4637 24.168ZM48.687 11.928L43.047 25.104C42.455 26.48 41.711 27.488 40.815 28.128C39.919 28.768 38.815 29.208 37.503 29.448L37.095 27.936C38.231 27.68 39.087 27.336 39.663 26.904C40.255 26.488 40.743 25.84 41.127 24.96L41.607 23.88L36.495 11.928H38.535L42.615 21.888L46.743 11.928H48.687ZM56.853 11.64C59.749 11.64 61.197 13.232 61.197 16.416V24H59.253V16.512C59.253 15.392 59.029 14.576 58.581 14.064C58.133 13.536 57.429 13.272 56.469 13.272C55.349 13.272 54.453 13.616 53.781 14.304C53.109 14.992 52.773 15.92 52.773 17.088V24H50.829V15.312C50.829 14.064 50.765 12.936 50.637 11.928H52.485L52.677 14.088C53.045 13.304 53.597 12.704 54.333 12.288C55.069 11.856 55.909 11.64 56.853 11.64ZM69.9321 24.168C68.7641 24.168 67.7401 23.912 66.8601 23.4C65.9961 22.888 65.3241 22.168 64.8441 21.24C64.3801 20.296 64.1481 19.2 64.1481 17.952C64.1481 16.704 64.3881 15.608 64.8681 14.664C65.3481 13.704 66.0281 12.96 66.9081 12.432C67.8041 11.904 68.8441 11.64 70.0281 11.64C70.8441 11.64 71.6281 11.784 72.3801 12.072C73.1481 12.344 73.7801 12.728 74.2761 13.224L73.6281 14.664C73.0201 14.184 72.4281 13.832 71.8521 13.608C71.2921 13.384 70.7161 13.272 70.1241 13.272C68.8921 13.272 67.9241 13.688 67.2201 14.52C66.5161 15.336 66.1641 16.48 66.1641 17.952C66.1641 19.408 66.5081 20.544 67.1961 21.36C67.9001 22.16 68.8761 22.56 70.1241 22.56C70.7161 22.56 71.2921 22.448 71.8521 22.224C72.4281 22 73.0201 21.648 73.6281 21.168L74.2761 22.608C73.7641 23.088 73.1161 23.472 72.3321 23.76C71.5641 24.032 70.7641 24.168 69.9321 24.168Z"
                    transform="translate(39 4)"
                    fill={isThemeDark ? "white" : "black"}
                  />
                </g>
              </svg>
              <MenuWithLinks
                options={[
                  {
                    text: "Team Settings",
                    href: `/team-settings?teamSlug=${store.currentTeam.slug}`,
                    as: `/team/${store.currentTeam.slug}/team-settings`,
                    simple: true,
                  },
                  {
                    text: "Billing",
                    href: `/billing?teamSlug=${store.currentTeam.slug}`,
                    as: `/team/${store.currentTeam.slug}/billing`,
                    simple: true,
                  },
                  {
                    text: "Your Settings",
                    href: "/your-settings",
                    highlighterSlug: "/your-settings",
                  },
                  {
                    separator: true,
                  },
                  {
                    text: "Log out",
                    href: `${process.env.NEXT_PUBLIC_URL_API}/logout`,
                    as: `${process.env.NEXT_PUBLIC_URL_API}/logout`,
                    externalServer: true,
                  },
                ]}
              >
                <Avatar
                  src={store.currentUser.avatarUrl}
                  alt="Add username here later in the book"
                  style={{
                    margin: "20px auto",
                    cursor: "pointer",
                    display: "inline-flex",
                    width: "40px",
                    height: "40px",
                  }}
                />

                <i className="material-icons" color="action" style={{ verticalAlign: "super" }}>
                  arrow_drop_down
                </i>
              </MenuWithLinks>
            </div>
            <hr />
            <p />
            <p />
            <DiscussionList store={store} team={store.currentTeam} isMobile={isMobile} />
          </Grid>
        ) : null}

        {children}
      </Grid>
      <Notifier />
      <Confirmer />
    </React.Fragment>
  );
}

type Props = {
  children: React.ReactNode;
  isMobile?: boolean;
  firstGridItem?: boolean;
  store?: Store;
  teamRequired?: boolean;
};

class Layout extends React.Component<Props> {
  public render() {
    const { children, isMobile, firstGridItem, store, teamRequired } = this.props;

    const { currentUser, currentTeam } = store;

    // console.log(this.props.store.currentUser.darkTheme);

    // const isThemeDark = false;

    // console.log(isMobile);

    // console.log(currentTeam);

    if (!currentUser) {
      return (
        <LayoutWrapper firstGridItem={firstGridItem} isMobile={isMobile} store={store}>
          <Grid item sm={12} xs={12}>
            {children}
          </Grid>
        </LayoutWrapper>
      );
    }

    if (!currentTeam) {
      if (teamRequired) {
        return (
          <LayoutWrapper firstGridItem={firstGridItem} isMobile={isMobile} store={store}>
            <Grid item sm={10} xs={12} style={{ padding: "0px 35px", overflow: "auto", height: "auto" }}>
              <div style={{ padding: "20px" }}>
                Select existing team or create a new team.
                <p />
                <Link href="/create-team" as="/create-team">
                  <Button variant="outlined" color="primary">
                    Create new team
                  </Button>
                </Link>
              </div>
            </Grid>
          </LayoutWrapper>
        );
      } else {
        console.log("team not required");
        return (
          <LayoutWrapper firstGridItem={firstGridItem} isMobile={isMobile} store={store}>
            <Grid item sm={10} xs={12} style={{ padding: "0px 35px", overflow: "auto", height: "auto" }}>
              {children}
            </Grid>
          </LayoutWrapper>
        );
      }
    }

    return (
      <LayoutWrapper firstGridItem={firstGridItem} isMobile={isMobile} store={store}>
        <Grid
          item
          sm={firstGridItem ? 10 : 12}
          xs={12}
          style={{ padding: "0px 35px", overflowY: "auto", height: "inherit" }}
        >
          <div>
            {isMobile || store.currentUrl.includes("create-team") ? null : (
              <React.Fragment>
                <i
                  style={{
                    float: "left",
                    margin: "15px 0px 10px 25px",
                    opacity: 0.8,
                    fontSize: "18px",
                    cursor: "pointer",
                    verticalAlign: "top",
                  }}
                  className="material-icons"
                  onClick={async () => {
                    await store.currentUser.toggleTheme(!store.currentUser.darkTheme);
                  }}
                >
                  lens
                </i>
              </React.Fragment>
            )}
            <div style={{ clear: "both" }} />
          </div>
          {children}
        </Grid>
      </LayoutWrapper>
    );
  }
}

export default Layout;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\components\posts\PostContent.tsx -----

import React from 'react';

type Props = { html: string };

class PostContent extends React.Component<Props> {
  public render() {
    const { html } = this.props;

    return (
      <div
        style={{ fontSize: '15px', lineHeight: '2em', fontWeight: 300, wordBreak: 'break-all' }}
        dangerouslySetInnerHTML={{ __html: html }}
      />
    );
  }
}

export default PostContent;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\components\posts\PostDetail.tsx -----

import Avatar from "@mui/material/Avatar";
import Paper from "@mui/material/Paper";
import Tooltip from "@mui/material/Tooltip";
import { observer } from "mobx-react";
import moment from "moment";
import React from "react";

import confirm from "../../lib/confirm";
import notify from "../../lib/notify";
import { Store } from "../../lib/store";
import { Post } from "../../lib/store/post";
import { User } from "../../lib/store/user";

import MenuWithMenuItems from "../common/MenuWithMenuItems";

import PostContent from "./PostContent";

const stylePaper = {
  margin: "10px 0px",
  padding: "20px",
};

const styleLineSeparator = {
  verticalAlign: "text-bottom",
  fontWeight: 300,
  fontSize: "16px",
  margin: "0px 5px",
  opacity: 0.75,
};

const getMenuOptions = (post) => ({
  dataId: post._id,
  id: `post-menu-${post._id}`,
});

const getMenuItemOptions = (post: Post, currentUser: User, component) => {
  const items = [];

  if (post.createdUserId !== currentUser._id) {
    items.push({
      text: "Show Markdown",
      dataId: post._id,
      onClick: component.showMarkdown,
    });
  }

  if (post.createdUserId === currentUser._id) {
    const isFirstPost = post.discussion.posts.indexOf(post) === 0;

    items.push({
      text: "Edit",
      dataId: post._id,
      onClick: component.editPost,
    });

    if (!isFirstPost) {
      items.push({
        text: "Delete",
        dataId: post._id,
        onClick: component.deletePost,
      });
    }
  }

  return items;
};

type Props = {
  post: Post;
  store: Store;
  isMobile: boolean;
  onEditClick: (post) => void;
  onShowMarkdownClick: (post) => void;
};

class PostDetail extends React.Component<Props> {
  public render() {
    const { post, isMobile } = this.props;

    return <Paper style={stylePaper}>{this.renderPostDetail(post, isMobile)}</Paper>;
  }

  public renderPostDetail(post: Post, isMobile) {
    const createdDate = moment(post.createdAt).local().format("MMM Do YYYY");
    const lastUpdatedDate = moment(post.lastUpdatedAt).fromNow();

    return (
      <React.Fragment>
        <div
          style={{
            float: "left",
            margin: "-12px 10px 0px -15px",
            zIndex: 1000,
          }}
        >
          {this.renderMenu()}
        </div>
        <div id={`post-${post._id}`}>
          {post.user && (
            <Tooltip title={post.user.displayName} placement="top" disableFocusListener disableTouchListener>
              <Avatar
                src={post.user.avatarUrl}
                alt={post.user.displayName}
                style={{
                  width: "40px",
                  height: "40px",
                  margin: "0px 10px 0px 5px",
                  cursor: "pointer",
                  float: "left",
                }}
              />
            </Tooltip>
          )}
          <div
            style={{
              margin: isMobile ? "0px" : "0px 20px 0px 70px",
              fontWeight: 300,
              lineHeight: "1em",
            }}
          >
            <span style={{ fontSize: "12px", fontWeight: 400 }}>
              {`By: ${post.user && post.user.displayName}` || "User"}
              <span style={styleLineSeparator}>|</span>
              {`Created: ${post.createdAt && createdDate}` || ""}

              {post.isEdited ? (
                <React.Fragment>
                  <span style={styleLineSeparator}>|</span>
                  Last edited: {lastUpdatedDate}
                </React.Fragment>
              ) : null}
            </span>

            <PostContent html={post.htmlContent} />
          </div>
        </div>
      </React.Fragment>
    );
  }

  public renderMenu() {
    const { post, store } = this.props;
    const { currentUser } = store;

    if (!post.user || !currentUser) {
      return null;
    }

    return (
      <MenuWithMenuItems
        menuOptions={getMenuOptions(post)}
        itemOptions={getMenuItemOptions(post, store.currentUser, this)}
      />
    );
  }

  public showMarkdown = () => {
    const { post, onShowMarkdownClick } = this.props;
    if (onShowMarkdownClick) {
      onShowMarkdownClick(post);
    }
  };

  public editPost = () => {
    const { post, onEditClick } = this.props;
    if (onEditClick) {
      onEditClick(post);
    }
    console.log(`PostDetail: ${post._id}`);
  };

  public deletePost = () => {
    confirm({
      title: "Are you sure?",
      message: "",
      onAnswer: async (answer) => {
        if (answer) {
          const { post } = this.props;
          await post.discussion.deletePost(post);
          notify("You successfully deleted Post.");
        }
      },
    });
  };
}

export default observer(PostDetail);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\components\posts\PostEditor.tsx -----

import Avatar from "@mui/material/Avatar";
import Button from "@mui/material/Button";
import he from "he";
import { marked } from "marked";
import { observer } from "mobx-react";
import NProgress from "nprogress";
import React from "react";
import { Mention, MentionsInput } from "react-mentions";

import {
  getSignedRequestForUploadApiMethod,
  uploadFileUsingSignedPutRequestApiMethod,
} from "../../lib/api/team-member";
import notify from "../../lib/notify";
import { resizeImage } from "../../lib/resizeImage";
import { Store } from "../../lib/store";
import { User } from "../../lib/store/user";

import PostContent from "./PostContent";

function getImageDimension(file): Promise<{ width: number; height: number }> {
  const reader = new FileReader();
  const img = new Image();

  return new Promise((resolve) => {
    reader.readAsDataURL(file);

    reader.onload = (e) => {
      img.onload = () => {
        resolve({ width: img.width, height: img.height });
      };

      img.src = e.target.result.toString();
    };
  });
}

type Props = {
  store: Store;
  onChanged: (content) => void;
  content: string;
  members: User[];
  textareaHeight?: string;
  placeholder?: string;
  parentComponent: string;
};

type State = { htmlContent: string };

class PostEditor extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      htmlContent: "",
    };
  }

  public render() {
    const { htmlContent } = this.state;
    const { content, members, store, parentComponent } = this.props;
    const { currentUser } = store;

    const membersMinusCurrentUser = members.filter((member) => member._id !== currentUser._id);

    const isThemeDark = store && store.currentUser && store.currentUser.darkTheme === true;
    const textareaBackgroundColor = isThemeDark ? "#0d1117" : "#fff";

    return (
      <div style={{ marginTop: "20px" }}>
        <div style={{ display: "inline-flex" }}>
          <Button
            onClick={this.showMarkdownContent}
            variant="text"
            style={{ fontWeight: htmlContent ? 300 : 600, color: "#58a6ff" }}
          >
            Markdown
          </Button>{" "}
          <Button
            onClick={this.showHtmlContent}
            variant="text"
            style={{ fontWeight: htmlContent ? 600 : 300, color: "#58a6ff" }}
          >
            HTML
          </Button>
        </div>

        <div style={{ display: "inline", float: "left" }}>
          <label htmlFor={"upload-file-post-editor-" + parentComponent}>
            <Button component="span">
              <i className="material-icons" style={{ fontSize: "22px", color: "#58a6ff" }}>
                insert_photo
              </i>
            </Button>
          </label>
          <input
            accept="image/*"
            name={"upload-file-post-editor-" + parentComponent}
            id={"upload-file-post-editor-" + parentComponent}
            type="file"
            style={{ display: "none" }}
            onChange={async (event) => {
              const file = event.target.files[0];
              await this.uploadFile(file);
              event.target.value = "";
            }}
          />
        </div>
        <br />
        <div
          style={{
            width: "100%",
            height: "100vh",
            padding: "10px 15px",
            border: isThemeDark ? "1px solid rgba(255, 255, 255, 0.5)" : "1px solid rgba(0, 0, 0, 0.5)",
          }}
        >
          {htmlContent ? (
            <PostContent html={htmlContent} />
          ) : (
            <MentionsInput
              style={{
                input: {
                  border: "none",
                  outline: "none",
                  color: isThemeDark ? "#fff" : "#000",
                  fontWeight: 300,
                  height: "100vh",
                  lineHeight: "1.5em",
                  backgroundColor: content ? textareaBackgroundColor : "transparent",
                },
                suggestions: {
                  list: {
                    backgroundColor: "#222",
                    color: "#fff",
                  },

                  item: {
                    padding: "5px 15px",
                    borderBottom: "1px solid rgba(0,0,0,0.15)",

                    "&focused": {
                      backgroundColor: "rgba(255, 255, 255, 0.1)",
                    },
                  },
                },
              }}
              autoFocus
              value={content}
              placeholder={this.props.placeholder ? this.props.placeholder : "Compose new post"}
              onChange={(event) => {
                this.props.onChanged(event.target.value);
              }}
            >
              <Mention
                trigger="@"
                data={membersMinusCurrentUser.map((u) => ({
                  id: u.avatarUrl,
                  display: u.displayName,
                  // you: u._id === currentUser._id ? true : false,
                }))}
                markup={"[`@#__display__`](__id__)"}
                displayTransform={(_, display) => {
                  return `@${display}`;
                }}
                renderSuggestion={(suggestion) => (
                  <React.Fragment>
                    <Avatar
                      role="presentation"
                      src={suggestion.id}
                      alt={suggestion.display}
                      style={{
                        width: "24px",
                        height: "24px",
                        marginRight: "10px",
                        display: "inline-flex",
                        verticalAlign: "middle",
                      }}
                    />
                    <span style={{ marginRight: "5px" }}>{suggestion.display}</span>
                  </React.Fragment>
                )}
              />
            </MentionsInput>
          )}
        </div>
      </div>
    );
  }

  public showMarkdownContent = () => {
    this.setState({ htmlContent: "" });
  };

  public showHtmlContent = async () => {
    const { content } = this.props;

    function markdownToHtml(postContent) {
      const renderer = new marked.Renderer();

      renderer.link = (href, title, text) => {
        const t = title ? ` title="${title}"` : "";

        if (text.startsWith("<code>@#")) {
          return `${text.replace("<code>@#", "<code>@")} `;
        }

        return `
          <a target="_blank" href="${href}" rel="noopener noreferrer"${t}>
            ${text}
          </a>
        `;
      };

      marked.setOptions({
        renderer,
        breaks: true,
      });

      return marked(he.decode(postContent));
    }

    const htmlContent = content ? markdownToHtml(content) : "<span>Nothing to preview.</span>";
    this.setState({ htmlContent });
  };

  private uploadFile = async (file: File) => {
    if (!file) {
      notify("No file selected.");
      return;
    }

    if (!file.type || (!file.type.startsWith("image/") && file.type !== "application/pdf")) {
      notify("Wrong file.");
      return;
    }

    const { store } = this.props;
    const { currentTeam } = store;

    NProgress.start();

    const bucket = process.env.NEXT_PUBLIC_BUCKET_FOR_POSTS;
    const prefix = `${currentTeam.slug}`;
    const fileName = file.name;
    const fileType = file.type;

    try {
      const responseFromApiServerForUpload = await getSignedRequestForUploadApiMethod({
        fileName,
        fileType,
        prefix,
        bucket,
      });

      let fileHtmlOrMarkdown;
      let fileUrl;

      if (file.type.startsWith("image/")) {
        const { width } = await getImageDimension(file);
        const resizedFile = await resizeImage(file, 1024, 1024);

        await uploadFileUsingSignedPutRequestApiMethod(resizedFile, responseFromApiServerForUpload.signedRequest);

        fileUrl = responseFromApiServerForUpload.url;

        console.log(fileUrl);

        const finalWidth = width > 768 ? "100%" : `${width}px`;

        fileHtmlOrMarkdown = `
          <div>
            <img style="max-width: ${finalWidth}; width:100%" src="${fileUrl}" alt="Async" class="s3-image" />
          </div>`;
      } else {
        await uploadFileUsingSignedPutRequestApiMethod(file, responseFromApiServerForUpload.signedRequest);

        fileUrl = responseFromApiServerForUpload.url;
        fileHtmlOrMarkdown = `[${file.name}](${fileUrl})`;
      }

      const content = `${this.props.content}\n${fileHtmlOrMarkdown.replace(/\s+/g, " ")}`;

      this.props.onChanged(content);

      notify("You successfully uploaded file.");
    } catch (error) {
      console.log(error);
      notify(error);
    } finally {
      NProgress.done();
    }
  };
}

export default observer(PostEditor);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\components\posts\PostForm.tsx -----

import Button from "@mui/material/Button";
import he from "he";
import { marked } from "marked";
import { observer } from "mobx-react";
import NProgress from "nprogress";
import React from "react";

import notify from "../../lib/notify";
import { Store } from "../../lib/store";
import { Discussion } from "../../lib/store/discussion";
import { Post } from "../../lib/store/post";
import { User } from "../../lib/store/user";

import PostEditor from "./PostEditor";

type Props = {
  store: Store;
  isMobile: boolean;
  members: User[];
  post: Post;
  discussion: Discussion;
  showMarkdownToNonCreator?: boolean;
  onFinished?: () => void;
};

type State = {
  postId: string;
  content: string;
  disabled: boolean;
};

class PostForm extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      postId: null,
      content: "",
      disabled: false,
    };
  }

  public static getDerivedStateFromProps(props: Props, state: State) {
    const { post } = props;

    if (!post && !state.postId) {
      return null;
    }

    if (post && post._id === state.postId) {
      return null;
    }

    return {
      postId: (post && post._id) || null,
      content: (post && post.content) || "",
    };
  }

  public render() {
    const { store, members, post, isMobile, showMarkdownToNonCreator } = this.props;
    const isEditingPost = !!post;

    let title = "Add Post";
    if (showMarkdownToNonCreator) {
      title = "Showing Markdown";
    } else if (isEditingPost) {
      title = "Edit Post";
    }

    return (
      <div style={{ height: "100%", margin: "0px 20px" }}>
        <p />
        <br />
        <h3>{title}</h3>
        <form style={{ width: "100%", height: "100%" }} onSubmit={this.onSubmit} autoComplete="off">
          <p />
          <br />
          <div>
            {showMarkdownToNonCreator ? null : (
              <React.Fragment>
                <Button type="submit" variant="contained" color="primary" disabled={this.state.disabled}>
                  {isEditingPost ? "Save changes" : "Publish Post"}
                </Button>
                {isMobile ? <p /> : null}
              </React.Fragment>
            )}
            {isEditingPost ? (
              <Button
                variant="outlined"
                onClick={this.closeForm}
                disabled={this.state.disabled}
                style={{ marginLeft: "10px" }}
              >
                {showMarkdownToNonCreator ? "Go back" : "Cancel"}
              </Button>
            ) : null}
          </div>
          <p />
          <br />
          <PostEditor
            content={this.state.content}
            onChanged={this.onContentChanged}
            members={members}
            store={store}
            textareaHeight="100%"
            parentComponent="PF"
          />
          <p />
          <div style={{ margin: "20px 0px" }}>
            {isEditingPost ? (
              <Button
                variant="outlined"
                onClick={this.closeForm}
                disabled={this.state.disabled}
                style={{ marginLeft: "10px" }}
              >
                {showMarkdownToNonCreator ? "Go back" : "Cancel"}
              </Button>
            ) : null}
          </div>
          <p />
          <br />
        </form>
      </div>
    );
  }

  private onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();

    const { content } = this.state;
    const htmlContent = marked(he.decode(content));
    const { post, onFinished, store, discussion } = this.props;
    const isEditingPost = !!post;

    if (!content) {
      notify("Add content to your Post");
      return;
    }

    if (isEditingPost) {
      this.setState({ disabled: true });
      NProgress.start();
      try {
        await post.editPost({ content, htmlContent });
        notify("You successfully edited Post");
      } catch (error) {
        console.log(error);
        notify(error);
      } finally {
        this.setState({ disabled: false });
        NProgress.done();
      }

      if (onFinished) {
        onFinished();
      }

      return;
    }

    const { currentTeam } = store;
    if (!currentTeam) {
      notify("Team is not selected or does not exist.");
      return;
    }

    NProgress.start();
    this.setState({ disabled: true });

    try {
      await discussion.addPost(content);

      this.setState({ content: "" });
      notify("You successfully published new Post.");
    } catch (error) {
      console.log(error);
      notify(error);
    } finally {
      this.setState({ disabled: false });
      NProgress.done();
    }

    if (onFinished) {
      onFinished();
    }
  };

  private onContentChanged = (content: string) => {
    this.setState({ content });
  };

  private closeForm = () => {
    this.setState({ postId: null, content: "" });

    const { onFinished } = this.props;
    if (onFinished) {
      onFinished();
    }
  };
}

export default observer(PostForm);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\components\teams\InviteMember.tsx -----

import Button from "@mui/material/Button";
import Dialog from "@mui/material/Dialog";
import DialogContent from "@mui/material/DialogContent";
import DialogTitle from "@mui/material/DialogTitle";
import TextField from "@mui/material/TextField";
import { inject, observer } from "mobx-react";
import NProgress from "nprogress";
import React from "react";

import notify from "../../lib/notify";
import { Store } from "../../lib/store";

type Props = {
  store: Store;
  onClose: () => void;
  open: boolean;
};

type State = {
  email: string;
  disabled: boolean;
};

class InviteMember extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      email: "",
      disabled: false,
    };
  }

  public render() {
    const { open } = this.props;

    return (
      <Dialog onClose={this.handleClose} aria-labelledby="invite-member-dialog-title" open={open}>
        <DialogTitle id="invite-member-dialog-title">Invite member</DialogTitle>
        <DialogContent>
          <form onSubmit={this.onSubmit} style={{ padding: "20px" }}>
            <TextField
              autoComplete="off"
              value={this.state.email}
              placeholder="Email"
              onChange={(event) => {
                this.setState({ email: event.target.value });
              }}
            />
            <p />
            <br />
            <Button variant="outlined" onClick={this.handleClose} disabled={this.state.disabled}>
              Cancel
            </Button>{" "}
            <Button type="submit" variant="contained" color="primary" disabled={this.state.disabled}>
              Invite
            </Button>
          </form>
        </DialogContent>
      </Dialog>
    );
  }

  private handleClose = () => {
    this.setState({ email: "", disabled: false });
    this.props.onClose();
  };

  private onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();

    const { store } = this.props;

    if (!store.currentTeam) {
      notify("Team have not selected");
      return;
    }

    const { email } = this.state;

    if (!email) {
      notify("Email is required");
      return;
    }

    NProgress.start();
    try {
      this.setState({ disabled: true });
      await store.currentTeam.inviteMember(email);

      this.setState({ email: "" });
      notify("You successfully sent invitation.");
      NProgress.done();
    } catch (error) {
      console.log(error);
      notify(error);
    } finally {
      this.props.onClose();
      this.setState({ disabled: false });
      NProgress.done();
    }
  };
}

export default inject("store")(observer(InviteMember));

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\lib\api\makeQueryString.ts -----

function makeQueryString(params) {
  const query = Object.keys(params)
    .filter((k) => !!params[k])
    .map((k) => `${encodeURIComponent(k)}=${encodeURIComponent(params[k])}`)
    .join('&');

  return query;
}

export { makeQueryString };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\lib\api\public.ts -----

import sendRequestAndGetResponse from './sendRequestAndGetResponse';

const BASE_PATH = '/api/v1/public';

export const getUserApiMethod = (request) =>
  sendRequestAndGetResponse(`${BASE_PATH}/get-user`, {
    request,
    method: 'GET',
  });

export const getUserBySlugApiMethod = (slug) =>
  sendRequestAndGetResponse(`${BASE_PATH}/get-user-by-slug`, {
    body: JSON.stringify({ slug }),
  });

export const emailLoginLinkApiMethod = ({
  email,
  invitationToken,
}: {
  email: string;
  invitationToken?: string;
}) =>
  sendRequestAndGetResponse('/auth/email-login-link', {
    qs: { invitationToken },
    body: JSON.stringify({ user: email }),
  });

export const getTeamByTokenApiMethod = (token: string, request) =>
  sendRequestAndGetResponse(`${BASE_PATH}/invitations/get-team-by-token`, {
    request,
    method: 'GET',
    qs: { token },
  });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\lib\api\sendRequestAndGetResponse.ts -----

import 'isomorphic-unfetch';

import { makeQueryString } from './makeQueryString';

export default async function sendRequestAndGetResponse(path, opts: any = {}) {
  const headers = Object.assign(
    {},
    opts.headers || {},
    opts.externalServer
      ? {}
      : {
          'Content-type': 'application/json; charset=UTF-8',
        },
  );

  const { request } = opts;

  if (request && request.headers && request.headers.cookie) {
    headers.cookie = request.headers.cookie;
  }

  // const qs = opts.qs || '';

  const qs = (opts.qs && `?${makeQueryString(opts.qs)}`) || '';

  // console.log(`before: ${process.env.NEXT_PUBLIC_URL_API}${path}${qs}`);

  const response = await fetch(
    opts.externalServer ? `${path}${qs}` : `${process.env.NEXT_PUBLIC_URL_API}${path}${qs}`,
    Object.assign({ method: 'POST', credentials: 'include' }, opts, { headers }),
  );

  // console.log(`after: ${process.env.NEXT_PUBLIC_URL_API}${path}${qs}`);

  // console.log(response.status);
  // console.log(response.statusText);

  const text = await response.text();

  if (response.status >= 400) {
    console.error(text);
    throw new Error(response.status.toString());
  }

  try {
    const data = JSON.parse(text);

    return data;
  } catch (err) {
    if (err instanceof SyntaxError) {
      return text;
    }

    throw err;
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\lib\api\team-leader.ts -----

import sendRequestAndGetResponse from './sendRequestAndGetResponse';

const BASE_PATH = '/api/v1/team-leader';

export const addTeamApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams/add`, {
    body: JSON.stringify(data),
  });

export const updateTeamApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams/update`, {
    body: JSON.stringify(data),
  });

export const getTeamInvitationsApiMethod = (teamId: string) =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams/get-invitations-for-team`, {
    method: 'GET',
    qs: { teamId },
  });

export const inviteMemberApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams/invite-member`, {
    body: JSON.stringify(data),
  });

export const removeMemberApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams/remove-member`, {
    body: JSON.stringify(data),
  });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\lib\api\team-member.ts -----

import sendRequestAndGetResponse from './sendRequestAndGetResponse';

const BASE_PATH = '/api/v1/team-member';

export const getSignedRequestForUploadApiMethod = ({ fileName, fileType, prefix, bucket }) =>
  sendRequestAndGetResponse(`${BASE_PATH}/aws/get-signed-request-for-upload-to-s3`, {
    body: JSON.stringify({ fileName, fileType, prefix, bucket }),
  });

export const uploadFileUsingSignedPutRequestApiMethod = (file, signedRequest, headers = {}) =>
  sendRequestAndGetResponse(signedRequest, {
    externalServer: true,
    method: 'PUT',
    body: file,
    headers,
  });

export const updateProfileApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/user/update-profile`, {
    body: JSON.stringify(data),
  });

export const toggleThemeApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/user/toggle-theme`, {
    body: JSON.stringify(data),
  });

export const getInitialDataApiMethod = (options: any = {}) =>
  sendRequestAndGetResponse(
    `${BASE_PATH}/get-initial-data`,
    Object.assign(
      {
        body: JSON.stringify(options.data || {}),
      },
      options,
    ),
  );

export const getTeamListApiMethod = () =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams`, {
    method: 'GET',
  });

export const getTeamMembersApiMethod = (teamId: string) =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams/get-members`, {
    method: 'GET',
    qs: { teamId },
  });

// Discussion and Post

export const getDiscussionListApiMethod = (params): Promise<{ discussions: any[] }> =>
  sendRequestAndGetResponse(`${BASE_PATH}/discussions/list`, {
    method: 'GET',
    qs: params,
  });

export const addDiscussionApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/discussions/add`, {
    body: JSON.stringify(data),
  });

export const editDiscussionApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/discussions/edit`, {
    body: JSON.stringify(data),
  });

export const deleteDiscussionApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/discussions/delete`, {
    body: JSON.stringify(data),
  });

export const getPostListApiMethod = (discussionId: string) =>
  sendRequestAndGetResponse(`${BASE_PATH}/posts/list`, {
    method: 'GET',
    qs: { discussionId },
  });

export const addPostApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/posts/add`, {
    body: JSON.stringify(data),
  });

export const editPostApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/posts/edit`, {
    body: JSON.stringify(data),
  });

export const deletePostApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/posts/delete`, {
    body: JSON.stringify(data),
  });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\lib\store\discussion.ts -----

import { action, decorate, IObservableArray, observable, runInAction, computed } from 'mobx';

import {
  addPostApiMethod,
  deletePostApiMethod,
  editDiscussionApiMethod,
  getPostListApiMethod,
} from '../api/team-member';
import { Store } from './index';
import { Team } from './team';
import { Post } from './post';

class Discussion {
  public _id: string;
  public createdUserId: string;
  public store: Store;
  public team: Team;

  public name: string;
  public slug: string;
  public memberIds: IObservableArray<string> = observable([]);
  public posts: IObservableArray<Post> = observable([]);
  public isLoadingPosts = false;

  constructor(params) {
    this._id = params._id;
    this.createdUserId = params.createdUserId;
    this.store = params.store;
    this.team = params.team;

    this.name = params.name;
    this.slug = params.slug;
    this.memberIds.replace(params.memberIds || []);

    if (params.initialPosts) {
      this.setInitialPosts(params.initialPosts);
      console.log(params.initialPosts[0]);
    } else {
      this.loadPosts();
    }
  }

  public async editDiscussion(data) {
    try {
      await editDiscussionApiMethod({
        id: this._id,
        ...data,
        socketId: (this.store.socket && this.store.socket.id) || null,
      });

      runInAction(() => {
        this.changeLocalCache(data);
      });
    } catch (error) {
      console.error(error);
      throw error;
    }
  }

  public changeLocalCache(data) {
    this.name = data.name;
    this.memberIds.replace(data.memberIds || []);
  }

  get members() {
    return this.memberIds.map((id) => this.team.members.get(id)).filter((u) => !!u);
  }

  public setInitialPosts(posts) {
    const postObjs = posts.map((p) => new Post({ discussion: this, store: this.store, ...p }));
    this.posts.replace(postObjs);
  }

  public async loadPosts() {
    if (this.store.isServer || this.isLoadingPosts) {
      return;
    }

    this.isLoadingPosts = true;

    try {
      const { posts = [] } = await getPostListApiMethod(this._id);

      runInAction(() => {
        const postObjs = posts.map((t) => new Post({ discussion: this, store: this.store, ...t }));
        this.posts.replace(postObjs);
      });
    } finally {
      runInAction(() => {
        this.isLoadingPosts = false;
      });
    }
  }

  public async addPost(content: string): Promise<Post> {
    const { post } = await addPostApiMethod({
      discussionId: this._id,
      content,
      socketId: (this.store.socket && this.store.socket.id) || null,
    });

    return new Promise<Post>((resolve) => {
      runInAction(() => {
        const obj = this.addPostToLocalCache(post);
        resolve(obj);
      });
    });
  }

  public addPostToLocalCache(data) {
    const postObj = new Post({ discussion: this, store: this.store, ...data });

    this.posts.push(postObj);

    return postObj;
  }

  public async deletePost(post: Post) {
    await deletePostApiMethod({
      id: post._id,
      discussionId: this._id,
      socketId: (this.store.socket && this.store.socket.id) || null,
    });

    runInAction(() => {
      this.posts.remove(post);
    });
  }

  public joinSocketRooms() {
    if (this.store.socket) {
      console.log('joining socket discussion room', this.name);
      this.store.socket.emit('joinTeamRoom', this.team._id);
      this.store.socket.emit('joinDiscussionRoom', this._id);
    }
  }

  public leaveSocketRooms() {
    if (this.store.socket) {
      console.log('leaving socket discussion room', this.name);
      this.store.socket.emit('leaveTeamRoom', this.team._id);
      this.store.socket.emit('leaveDiscussionRoom', this._id);
    }
  }

  public handleDiscussionRealtimeEvent = (data) => {
    console.log('discussion realtime event', data);
    const { actionType } = data;

    if (actionType === 'added') {
      this.addDiscussionToLocalCache(data.discussion);
    } else if (actionType === 'edited') {
      this.editDiscussionFromLocalCache(data.discussion);
    } else if (actionType === 'deleted') {
      this.deleteDiscussionFromLocalCache(data.id);
    }
  };

  public addDiscussionToLocalCache(data): Discussion {
    const obj = new Discussion({ team: this.team, store: this.store, ...data });

    if (obj.memberIds.includes(this.store.currentUser._id)) {
      this.team.discussions.push(obj);
    }

    return obj;
  }

  public editDiscussionFromLocalCache(data) {
    const discussion = this.team.discussions.find((item) => item._id === data._id);
    if (discussion) {
      if (data.memberIds && data.memberIds.includes(this.store.currentUser._id)) {
        discussion.changeLocalCache(data);
      } else {
        this.deleteDiscussionFromLocalCache(data._id);
      }
    } else if (data.memberIds && data.memberIds.includes(this.store.currentUser._id)) {
      this.addDiscussionToLocalCache(data);
    }
  }

  public deleteDiscussionFromLocalCache(discussionId: string) {
    const discussion = this.team.discussions.find((item) => item._id === discussionId);
    this.team.discussions.remove(discussion);
  }

  public handlePostRealtimeEvent(data) {
    const { actionType } = data;

    if (actionType === 'added') {
      this.addPostToLocalCache(data.post);
    } else if (actionType === 'edited') {
      this.editPostFromLocalCache(data.post);
    } else if (actionType === 'deleted') {
      this.deletePostFromLocalCache(data.id);
    }
  }

  public editPostFromLocalCache(data) {
    const post = this.posts.find((t) => t._id === data._id);
    if (post) {
      post.changeLocalCache(data);
    }
  }

  public deletePostFromLocalCache(postId) {
    const post = this.posts.find((t) => t._id === postId);
    this.posts.remove(post);
  }
}

decorate(Discussion, {
  name: observable,
  slug: observable,
  memberIds: observable,
  posts: observable,
  isLoadingPosts: observable,

  editDiscussion: action,
  changeLocalCache: action,

  setInitialPosts: action,
  loadPosts: action,
  addPost: action,
  addPostToLocalCache: action,
  deletePost: action,

  addDiscussionToLocalCache: action,
  editDiscussionFromLocalCache: action,
  deleteDiscussionFromLocalCache: action,
  editPostFromLocalCache: action,
  deletePostFromLocalCache: action,

  members: computed,
});

export { Discussion };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\lib\store\index.ts -----

import * as mobx from 'mobx';
import { action, decorate, IObservableArray, observable } from 'mobx';
import { useStaticRendering } from 'mobx-react';
// @ts-expect-error no exported member io socket.io-client
import { io } from 'socket.io-client';

import { addTeamApiMethod, getTeamInvitationsApiMethod } from '../api/team-leader';
import { getTeamListApiMethod, getTeamMembersApiMethod } from '../api/team-member';

import { User } from './user';
import { Team } from './team';

useStaticRendering(typeof window === 'undefined');

mobx.configure({ enforceActions: 'observed' });

class Store {
  public isServer: boolean;

  public currentUser?: User = null;
  public currentUrl = '';

  public currentTeam?: Team;

  public teams: IObservableArray<Team> = observable([]);

  public socket: SocketIOClient.Socket;

  constructor({
    initialState = {},
    isServer,
    socket = null,
  }: {
    initialState?: any;
    isServer: boolean;
    socket?: SocketIOClient.Socket;
  }) {
    this.isServer = !!isServer;

    this.setCurrentUser(initialState.user);

    this.currentUrl = initialState.currentUrl || '';

    // console.log(initialState.user);

    if (initialState.teamSlug || (initialState.user && initialState.user.defaultTeamSlug)) {
      this.setCurrentTeam(
        initialState.teamSlug || initialState.user.defaultTeamSlug,
        initialState.teams,
      );
    }

    if (initialState.teams && initialState.teams.length > 0) {
      this.setInitialTeamsStoreMethod(initialState.teams);
    }

    this.socket = socket;

    if (socket) {
      socket.on('disconnect', () => {
        console.log('socket: ## disconnected');
      });

      socket.on('reconnect', (attemptNumber) => {
        console.log('socket: $$ reconnected', attemptNumber);
      });
    }
  }

  public changeCurrentUrl(url: string) {
    this.currentUrl = url;
  }

  public async setCurrentUser(user) {
    if (user) {
      this.currentUser = new User({ store: this, ...user });
    } else {
      this.currentUser = null;
    }
  }

  public async addTeam({ name, avatarUrl }: { name: string; avatarUrl: string }): Promise<Team> {
    const data = await addTeamApiMethod({ name, avatarUrl });
    const team = new Team({ store: this, ...data });

    return team;
  }

  public async setCurrentTeam(slug: string, initialTeams: any[]) {
    if (this.currentTeam) {
      if (this.currentTeam.slug === slug) {
        return;
      }
    }

    let found = false;

    const teams = initialTeams || (await getTeamListApiMethod()).teams;

    for (const team of teams) {
      if (team.slug === slug) {
        found = true;
        this.currentTeam = new Team({ ...team, store: this });

        const users =
          team.initialMembers || (await getTeamMembersApiMethod(this.currentTeam._id)).users;

        const invitations =
          team.initialInvitations ||
          (await getTeamInvitationsApiMethod(this.currentTeam._id)).invitations;

        this.currentTeam.setInitialMembersAndInvitations(users, invitations);

        break;
      }
    }

    if (!found) {
      this.currentTeam = null;
    }
  }

  private setInitialTeamsStoreMethod(teams: any[]) {
    // console.log(initialTeams);

    const teamObjs = teams.map((t) => new Team({ store: this, ...t }));

    this.teams.replace(teamObjs);
  }
}

decorate(Store, {
  currentUser: observable,
  currentUrl: observable,
  currentTeam: observable,

  changeCurrentUrl: action,
  setCurrentUser: action,
  setCurrentTeam: action,
});

let store: Store = null;

function initializeStore(initialState = {}) {
  const isServer = typeof window === 'undefined';

  const socket = isServer
    ? null
    : io(process.env.NEXT_PUBLIC_URL_API, {
        reconnection: true,
        autoConnect: true,
        transports: ['polling', 'websocket'],
        withCredentials: true,
      });

  const _store =
    store !== null && store !== undefined ? store : new Store({ initialState, isServer, socket });

  // For SSG and SSR always create a new store
  if (typeof window === 'undefined') {
    return _store;
  }
  // Create the store once in the client
  if (!store) {
    store = _store;
  }

  // console.log(_store);

  return _store;
}

function getStore() {
  return store;
}

export { Store, initializeStore, getStore };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\lib\store\invitation.ts -----

class Invitation {
  public _id: string;
  public teamId: string;
  public email: string;
  public createdAt: Date;

  constructor(params) {
    Object.assign(this, params);
  }
}

export { Invitation };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\lib\store\post.ts -----

import { action, computed, decorate, observable, runInAction } from 'mobx';

import { editPostApiMethod } from '../api/team-member';

import { Store } from './index';
import { User } from './user';
import { Discussion } from './discussion';

export class Post {
  public _id: string;
  public createdUserId: string;
  public createdAt: Date;
  public discussionId: string;

  public discussion: Discussion;
  public store: Store;

  public content: string;
  public htmlContent: string;

  public isEdited: boolean;
  public lastUpdatedAt: Date;

  constructor(params) {
    this._id = params._id;
    this.createdUserId = params.createdUserId;
    this.createdAt = params.createdAt;
    this.discussionId = params.discussionId;

    this.content = params.content;
    this.htmlContent = params.htmlContent;

    this.discussion = params.discussion;
    this.store = params.store;

    this.isEdited = params.isEdited;
    this.lastUpdatedAt = params.lastUpdatedAt;
  }

  public async editPost(data) {
    try {
      await editPostApiMethod({
        id: this._id,
        content: data.content,
        socketId: (this.store.socket && this.store.socket.id) || null,
      });

      runInAction(() => {
        this.changeLocalCache(data);
      });
    } catch (error) {
      console.error(error);
      throw error;
    }
  }

  public changeLocalCache(data) {
    this.content = data.content;
    this.htmlContent = data.htmlContent;
    this.isEdited = true;
    this.lastUpdatedAt = data.lastUpdatedAt;
  }

  get user(): User {
    return this.discussion.team.members.get(this.createdUserId) || null;
  }
}

decorate(Post, {
  content: observable,
  htmlContent: observable,
  isEdited: observable,
  lastUpdatedAt: observable,

  editPost: action,
  changeLocalCache: action,

  user: computed,
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\lib\store\team.ts -----

import { action, computed, decorate, IObservableArray, observable, runInAction } from 'mobx';
import Router from 'next/router';
import {
  inviteMemberApiMethod,
  removeMemberApiMethod,
  updateTeamApiMethod,
} from '../api/team-leader';
import {
  addDiscussionApiMethod,
  deleteDiscussionApiMethod,
  getDiscussionListApiMethod,
} from '../api/team-member';
import { Store } from './index';
import { User } from './user';
import { Invitation } from './invitation';
import { Discussion } from './discussion';

class Team {
  public store: Store;

  public _id: string;
  public teamLeaderId: string;

  public name: string;
  public slug: string;
  public avatarUrl: string;
  public memberIds: IObservableArray<string> = observable([]);
  public members: Map<string, User> = new Map();
  public invitations: Map<string, Invitation> = new Map();

  public currentDiscussion?: Discussion;
  public currentDiscussionSlug?: string;
  public discussions: IObservableArray<Discussion> = observable([]);
  public isLoadingDiscussions = false;

  constructor(params) {
    this._id = params._id;
    this.teamLeaderId = params.teamLeaderId;
    this.slug = params.slug;
    this.name = params.name;
    this.avatarUrl = params.avatarUrl;
    this.memberIds.replace(params.memberIds || []);
    this.currentDiscussionSlug = params.currentDiscussionSlug || null;

    this.store = params.store;

    if (params.initialDiscussions) {
      this.setInitialDiscussions(params.initialDiscussions);
    } else {
      this.loadDiscussions();
    }
  }

  public setInitialMembersAndInvitations(users, invitations) {
    this.members.clear();
    this.invitations.clear();

    for (const user of users) {
      if (this.store.currentUser && this.store.currentUser._id === user._id) {
        this.members.set(user._id, this.store.currentUser);
      } else {
        this.members.set(user._id, new User(user));
      }
    }

    for (const invitation of invitations || []) {
      this.invitations.set(invitation._id, new Invitation(invitation));
    }

    // console.log(this.members);
  }

  public async updateTheme({ name, avatarUrl }: { name: string; avatarUrl: string }) {
    try {
      const { slug } = await updateTeamApiMethod({
        teamId: this._id,
        name,
        avatarUrl,
      });

      runInAction(() => {
        this.name = name;
        this.avatarUrl = avatarUrl;
        this.slug = slug;
      });
    } catch (error) {
      console.error(error);
      throw error;
    }
  }

  public async inviteMember(email: string) {
    try {
      const { newInvitation } = await inviteMemberApiMethod({ teamId: this._id, email });

      runInAction(() => {
        this.invitations.set(newInvitation._id, new Invitation(newInvitation));
      });
    } catch (error) {
      console.error(error);
      throw error;
    }
  }

  public async removeMember(userId: string) {
    try {
      await removeMemberApiMethod({ teamId: this._id, userId });

      runInAction(() => {
        this.members.delete(userId);
        this.memberIds.remove(userId);
      });
    } catch (error) {
      console.error(error);
      throw error;
    }
  }

  public setCurrentDiscussion({ slug }: { slug: string }) {
    this.currentDiscussionSlug = slug;
    for (const discussion of this.discussions) {
      if (discussion && discussion.slug === slug) {
        this.currentDiscussion = discussion;
        break;
      }
    }
  }

  public setInitialDiscussions(discussions) {
    const discussionObjs = discussions.map(
      (d) => new Discussion({ team: this, store: this.store, ...d }),
    );

    this.discussions.replace(discussionObjs);

    if (!this.currentDiscussionSlug && this.discussions.length > 0) {
      this.currentDiscussionSlug = this.orderedDiscussions[0].slug;
    }

    if (this.currentDiscussionSlug) {
      this.setCurrentDiscussion({ slug: this.currentDiscussionSlug });
    }
  }

  public async loadDiscussions() {
    if (this.store.isServer || this.isLoadingDiscussions) {
      return;
    }

    this.isLoadingDiscussions = true;

    try {
      const { discussions = [] } = await getDiscussionListApiMethod({
        teamId: this._id,
      });
      const newList: Discussion[] = [];

      runInAction(() => {
        discussions.forEach((d) => {
          const disObj = this.discussions.find((obj) => obj._id === d._id);
          if (disObj) {
            disObj.changeLocalCache(d);
            newList.push(disObj);
          } else {
            newList.push(new Discussion({ team: this, store: this.store, ...d }));
          }
        });

        this.discussions.replace(newList);
      });
    } finally {
      runInAction(() => {
        this.isLoadingDiscussions = false;
      });
    }
  }

  public changeLocalCache(data) {
    this.name = data.name;
    this.memberIds.replace(data.memberIds || []);
  }

  public async addDiscussion(data): Promise<Discussion> {
    const { discussion } = await addDiscussionApiMethod({
      teamId: this._id,
      socketId: (this.store.socket && this.store.socket.id) || null,
      ...data,
    });

    return new Promise<Discussion>((resolve) => {
      runInAction(() => {
        const obj = this.addDiscussionToLocalCache(discussion);
        resolve(obj);
      });
    });
  }

  public addDiscussionToLocalCache(data): Discussion {
    const obj = new Discussion({ team: this, store: this.store, ...data });

    if (obj.memberIds.includes(this.store.currentUser._id)) {
      this.discussions.push(obj);
    }

    return obj;
  }

  public async deleteDiscussion(id: string) {
    await deleteDiscussionApiMethod({
      id,
      socketId: (this.store.socket && this.store.socket.id) || null,
    });

    runInAction(() => {
      this.deleteDiscussionFromLocalCache(id);

      const discussion = this.discussions.find((d) => d._id === id);

      if (this.currentDiscussion === discussion) {
        this.currentDiscussion = null;
        this.currentDiscussionSlug = null;

        if (this.discussions.length > 0) {
          const d = this.discussions[0];

          Router.push(
            `/discussion?teamSlug=${this.slug}&discussionSlug=${d.slug}`,
            `/team/${this.slug}/discussions/${d.slug}`,
          );
        } else {
          Router.push(`/discussion?teamSlug=${this.slug}`, `/team/${this.slug}/discussions`);
        }
      }
    });
  }

  public deleteDiscussionFromLocalCache(discussionId: string) {
    const discussion = this.discussions.find((item) => item._id === discussionId);
    this.discussions.remove(discussion);
  }

  public getDiscussionBySlug(slug: string): Discussion {
    return this.discussions.find((d) => d.slug === slug);
  }

  get orderedDiscussions() {
    return this.discussions.slice().sort();
  }
}

decorate(Team, {
  name: observable,
  slug: observable,
  avatarUrl: observable,
  memberIds: observable,
  members: observable,
  invitations: observable,
  currentDiscussion: observable,
  currentDiscussionSlug: observable,
  isLoadingDiscussions: observable,
  discussions: observable,

  setInitialMembersAndInvitations: action,
  updateTheme: action,
  inviteMember: action,
  removeMember: action,
  setInitialDiscussions: action,
  loadDiscussions: action,
  addDiscussion: action,
  addDiscussionToLocalCache: action,
  deleteDiscussion: action,
  deleteDiscussionFromLocalCache: action,
  getDiscussionBySlug: action,

  orderedDiscussions: computed,
});

export { Team };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\lib\store\user.ts -----

import { action, decorate, observable, runInAction } from 'mobx';

import * as NProgress from 'nprogress';

import { toggleThemeApiMethod, updateProfileApiMethod } from '../api/team-member';
import { Store } from './index';

class User {
  public store: Store;

  public _id: string;
  public slug: string;
  public email: string | null;
  public displayName: string | null;
  public avatarUrl: string | null;
  public isSignedupViaGoogle: boolean;

  public darkTheme = false;
  public defaultTeamSlug: string;

  constructor(params) {
    this.store = params.store;
    this._id = params._id;
    this.slug = params.slug;
    this.email = params.email;
    this.displayName = params.displayName;
    this.avatarUrl = params.avatarUrl;
    this.isSignedupViaGoogle = !!params.isSignedupViaGoogle;
    this.darkTheme = !!params.darkTheme;
    this.defaultTeamSlug = params.defaultTeamSlug;
  }

  public async updateProfile({ name, avatarUrl }: { name: string; avatarUrl: string }) {
    const { updatedUser } = await updateProfileApiMethod({
      name,
      avatarUrl,
    });

    runInAction(() => {
      this.displayName = updatedUser.displayName;
      this.avatarUrl = updatedUser.avatarUrl;
      this.slug = updatedUser.slug;
    });
  }

  public async toggleTheme(darkTheme: boolean) {
    await toggleThemeApiMethod({ darkTheme });
    runInAction(() => {
      this.darkTheme = darkTheme;
    });
    NProgress.start();
    NProgress.set(0.5);
    window.location.reload();
  }
}

decorate(User, {
  slug: observable,
  email: observable,
  displayName: observable,
  avatarUrl: observable,
  // darkTheme: observable,
  defaultTeamSlug: observable,

  updateProfile: action,
  toggleTheme: action,
});

export { User };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\lib\confirm.ts -----

import { openConfirmDialogExternal } from '../components/common/Confirmer';

export default function confirm({
  title,
  message,
  onAnswer,
}: {
  title: string;
  message: string;
  onAnswer: (answer) => void;
}) {
  openConfirmDialogExternal({ title, message, onAnswer });
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\lib\isMobile.ts -----

const mobileRE = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i;

export function isMobile(opts) {
  if (!opts) {
    opts = {};
  }

  let ua = opts.ua;

  if (!ua && typeof navigator !== 'undefined') {
    ua = navigator.userAgent;
  }

  if (!ua && opts.req && opts.req.headers && typeof opts.req.headers['user-agent'] === 'string') {
    ua = opts.req.headers['user-agent'];
    // console.log(ua);
  }

  if (typeof ua !== 'string') {
    return false;
  }

  return mobileRE.test(ua);
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\lib\notify.ts -----

import { openSnackbarExternal } from '../components/common/Notifier';

export default function notify(obj) {
  openSnackbarExternal({ message: obj.message || obj.toString() });
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\lib\resizeImage.ts -----

function resizeImage(file: File, MAX_WIDTH, MAX_HEIGHT) {
  const image = document.createElement('img');

  const resize = (resolve) => () => {
    let isResizeNeeded = false;
    let width = image.width;
    let height = image.height;

    if (width > height) {
      if (width > MAX_WIDTH) {
        isResizeNeeded = true;
        height *= MAX_WIDTH / width;
        width = MAX_WIDTH;
      }
    } else {
      if (height > MAX_HEIGHT) {
        isResizeNeeded = true;
        width *= MAX_HEIGHT / height;
        height = MAX_HEIGHT;
      }
    }

    if (isResizeNeeded) {
      const canvas = document.createElement('canvas');

      canvas.width = width;
      canvas.height = height;

      console.log(width, height);

      const ctx = canvas.getContext('2d');
      ctx.drawImage(image, 0, 0, width, height);

      canvas.toBlob((blob) => {
        resolve(blob);
      }, file.type);
    } else {
      resolve(file);
    }
  };

  return new Promise((resolve) => {
    const reader = new FileReader();

    console.log(`before ${image.src}`);

    reader.readAsDataURL(file);

    reader.onload = (e) => {
      image.src = e.target.result.toString();

      image.onload = resize(resolve);

      console.log(`after ${image.src}`);
    };
  });
}

export { resizeImage };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\lib\sharedStyles.ts -----

const styleBigAvatar = {
  width: '80px',
  height: '80px',
  margin: '0px auto 15px',
};

const styleRaisedButton = {
  margin: '15px',
  font: '14px Roboto',
};

const styleToolbar = {
  background: '#FFF',
  height: '64px',
  paddingRight: '20px',
};

const styleTextField = {
  font: '15px Roboto',
  color: '#222',
  fontWeight: '300',
};

const styleForm = {
  margin: '7% auto',
  width: '360px',
};

export {
  styleBigAvatar,
  styleRaisedButton,
  styleToolbar,
  styleTextField,
  styleForm,
};

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\lib\theme.ts -----

import { createMuiTheme } from "@mui/material/styles";

const themeDark = createMuiTheme({
  palette: {
    primary: { main: "#238636" },
    secondary: { main: "#b62324" },
    type: "dark",
    background: { default: "#0d1117" },
    text: {
      primary: "#c9d1d9",
    },
  },
  typography: {
    button: {
      textTransform: "none",
    },
  },
});

const themeLight = createMuiTheme({
  palette: {
    primary: { main: "#238636" },
    secondary: { main: "#b62324" },
    type: "light",
    background: { default: "#fff" },
    text: {
      primary: "#222",
    },
  },
  typography: {
    button: {
      textTransform: "none",
    },
  },
});

export { themeDark, themeLight };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\lib\withAuth.tsx -----

import { observer } from 'mobx-react';
import Router from 'next/router';
import React from 'react';

import * as NProgress from 'nprogress';

import { Store, getStore } from './store';

Router.events.on('routeChangeStart', () => {
  NProgress.start();
});

Router.events.on('routeChangeComplete', (url) => {
  const store = getStore();
  if (store) {
    store.changeCurrentUrl(url);
  }

  NProgress.done();
});

Router.events.on('routeChangeError', () => NProgress.done());

export default function withAuth(Component, { loginRequired = true, logoutRequired = false } = {}) {
  class WithAuth extends React.Component<{ store: Store }> {
    public static async getInitialProps(ctx) {
      console.log('WithAuth.getInitialProps');

      const { req } = ctx;

      let pageComponentProps = {};

      if (Component.getInitialProps) {
        pageComponentProps = await Component.getInitialProps(ctx);
      }

      return {
        ...pageComponentProps,
        isServer: !!req,
      };
    }

    public componentDidMount() {
      console.log('WithAuth.componentDidMount');

      const { store } = this.props;
      const user = store.currentUser;

      if (loginRequired && !logoutRequired && !user) {
        Router.push('/login');
        return;
      }

      let redirectUrl = '/login';
      let asUrl = '/login';
      if (user) {
        if (!user.defaultTeamSlug) {
          redirectUrl = '/create-team';
          asUrl = '/create-team';
        } else {
          redirectUrl = `/your-settings`;
          asUrl = `/your-settings`;
        }
      }

      if (logoutRequired && user) {
        Router.push(redirectUrl, asUrl);
      }
    }

    public render() {
      const { store } = this.props;
      const user = store.currentUser;

      if (loginRequired && !logoutRequired && !user) {
        return null;
      }

      if (logoutRequired && user) {
        return null;
      }

      return <Component {...this.props} />;
    }
  }

  return observer(WithAuth);
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\pages\create-team.tsx -----

import { inject, observer } from "mobx-react";
import * as React from "react";

import Avatar from "@mui/material/Avatar";
import Button from "@mui/material/Button";
import Grid from "@mui/material/Grid";
import TextField from "@mui/material/TextField";
import Head from "next/head";
import Router from "next/router";

import { getSignedRequestForUploadApiMethod, uploadFileUsingSignedPutRequestApiMethod } from "../lib/api/team-member";
import notify from "../lib/notify";
import { resizeImage } from "../lib/resizeImage";
import { Store } from "../lib/store";
import withAuth from "../lib/withAuth";

import Layout from "../components/layout";

const styleGrid = {
  height: "100%",
};

type Props = { store: Store; isMobile: boolean; teamRequired: boolean };

type State = { newName: string; newAvatarUrl: string; disabled: boolean };

class CreateTeam extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      newName: "",
      newAvatarUrl: "https://storage.googleapis.com/async-await/default-user.png?v=1",
      disabled: false,
    };
  }

  public render() {
    const { newAvatarUrl } = this.state;

    console.log(this.props.store);

    return (
      <Layout {...this.props}>
        <Head>
          <title>Create Team</title>
          <meta name="description" content="Create a new Team at SaaS Boilerplate" />
        </Head>
        <div style={{ padding: "0px", fontSize: "14px", height: "100%" }}>
          <Grid container style={styleGrid}>
            <Grid item sm={12} xs={12} style={{ padding: this.props.isMobile ? "0px" : "0px 30px" }}>
              <h3>Create team</h3>
              <p />
              <form onSubmit={this.onSubmit}>
                <h4>Team name</h4>
                <TextField
                  value={this.state.newName}
                  label="Type your team's name."
                  helperText="Team name as seen by your team members."
                  onChange={(event) => {
                    this.setState({ newName: event.target.value });
                  }}
                />
                <p />
                <h4 style={{ marginTop: "40px" }}>Team logo (optional)</h4>
                <Avatar
                  src={newAvatarUrl}
                  style={{
                    display: "inline-flex",
                    verticalAlign: "middle",
                    marginRight: 20,
                    width: 60,
                    height: 60,
                  }}
                />
                <label htmlFor="upload-file">
                  <Button variant="outlined" color="primary" component="span">
                    Select team logo
                  </Button>
                </label>
                <input
                  accept="image/*"
                  name="upload-file"
                  id="upload-file"
                  type="file"
                  style={{ display: "none" }}
                  onChange={this.previewTeamLogo}
                />
                <p />
                <br />
                <br />
                <Button variant="contained" color="primary" type="submit" disabled={this.state.disabled}>
                  Create new team
                </Button>
              </form>
            </Grid>
          </Grid>
          <br />
        </div>
      </Layout>
    );
  }

  private onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();

    const { newName } = this.state;

    const { store } = this.props;

    if (!newName) {
      notify("Team name is required.");
      return;
    }

    const file = (document.getElementById("upload-file") as HTMLFormElement).files[0];

    try {
      this.setState({ disabled: true });

      const defaultAvatarUrl = "https://storage.googleapis.com/async-await/default-user.png?v=1";
      const team = await store.addTeam({
        name: newName,
        avatarUrl: defaultAvatarUrl,
      });

      console.log(`Returned to client: ${team._id}, ${team.name}, ${team.slug}`);

      if (file == null) {
        Router.push(`/team/${team.slug}/team-settings`);
        notify("You successfully created Team.<p />Redirecting...");
        return;
      }

      const fileName = file.name;
      const fileType = file.type;
      const bucket = process.env.NEXT_PUBLIC_BUCKET_FOR_TEAM_LOGOS;
      const prefix = team.slug;

      const responseFromApiServerForUpload = await getSignedRequestForUploadApiMethod({
        fileName,
        fileType,
        prefix,
        bucket,
      });

      const resizedFile = await resizeImage(file, 128, 128);

      await uploadFileUsingSignedPutRequestApiMethod(resizedFile, responseFromApiServerForUpload.signedRequest, {
        "Cache-Control": "max-age=2592000",
      });

      const uploadedAvatarUrl = responseFromApiServerForUpload.url;

      await team.updateTheme({ name: team.name, avatarUrl: uploadedAvatarUrl });

      this.setState({
        newName: "",
        newAvatarUrl: "https://storage.googleapis.com/async-await/default-user.png?v=1",
      });

      (document.getElementById("upload-file") as HTMLFormElement).value = "";

      Router.push(`/team/${team.slug}/team-settings`);

      notify("You successfully created Team. Redirecting ...");
    } catch (error) {
      console.log(error);
      notify(error);
    } finally {
      this.setState({ disabled: false });
    }
  };

  private previewTeamLogo = () => {
    const file = (document.getElementById("upload-file") as HTMLFormElement).files[0];
    if (!file) {
      return;
    }

    const reader = new FileReader();

    reader.readAsDataURL(file);

    reader.onload = (e) => {
      this.setState({ newAvatarUrl: e.target.result as string });
    };
  };
}

export default withAuth(inject("store")(observer(CreateTeam)));

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\pages\discussion.tsx -----

import Avatar from "@mui/material/Avatar";
import Tooltip from "@mui/material/Tooltip";
import Head from "next/head";
import Router from "next/router";
import * as React from "react";

import { observer } from "mobx-react";

import Layout from "../components/layout";
import PostDetail from "../components/posts/PostDetail";
import PostForm from "../components/posts/PostForm";
import notify from "../lib/notify";
import { Store } from "../lib/store";
import { Discussion } from "../lib/store/discussion";
import withAuth from "../lib/withAuth";
import { Post } from "lib/store/post";

type Props = {
  store: Store;
  teamSlug: string;
  discussionSlug: string;
  isServer: boolean;
  isMobile: boolean;
  teamRequired: boolean;
};

type State = {
  selectedPost: Post;
  showMarkdownClicked: boolean;
};

class DiscussionPageComp extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      selectedPost: null,
      showMarkdownClicked: false,
    };
  }

  public render() {
    const { store, isMobile, discussionSlug } = this.props;
    const { currentTeam } = store;
    const { selectedPost } = this.state;

    if (!currentTeam || currentTeam.slug !== this.props.teamSlug) {
      return (
        <Layout {...this.props}>
          <Head>
            <title>No Team is found.</title>
          </Head>
          <div style={{ padding: isMobile ? "0px" : "0px 30px" }}>No Team is found.</div>
        </Layout>
      );
    }

    const discussion = this.getDiscussion(discussionSlug);

    if (!discussion) {
      if (currentTeam.isLoadingDiscussions) {
        return (
          <Layout {...this.props}>
            <Head>
              <title>Loading...</title>
            </Head>
            <div style={{ padding: isMobile ? "0px" : "0px 30px" }}>
              <p>Loading Discussions...</p>
            </div>
          </Layout>
        );
      } else {
        return (
          <Layout {...this.props}>
            <Head>
              <title>No Discussion is found.</title>
            </Head>
            <div style={{ padding: isMobile ? "0px" : "0px 30px" }}>
              <p>No Discussion is found.</p>
            </div>
          </Layout>
        );
      }
    }

    const title = discussion ? `${discussion.name}  Discussion` : "Discussions";

    return (
      <Layout {...this.props}>
        <Head>
          <title>{title}</title>
          <meta
            name="description"
            content={discussion ? `Discussion ${discussion.name} by Team ${currentTeam.name}` : "Discussions"}
          />
        </Head>
        <div style={{ padding: isMobile ? "0px" : "0px 30px", height: "100vh" }}>
          <h4>
            <span style={{ fontWeight: 300 }}>Discussion : </span>
            {(discussion && discussion.name) || "No Discussion is found."}
          </h4>{" "}
          Visible to :{" "}
          {discussion
            ? discussion.members.map((m) => (
                <Tooltip title={m.displayName} placement="right" disableFocusListener disableTouchListener key={m._id}>
                  <Avatar
                    role="presentation"
                    src={m.avatarUrl}
                    alt={m.avatarUrl}
                    key={m._id}
                    style={{
                      margin: "0px 5px",
                      display: "inline-flex",
                      width: "30px",
                      height: "30px",
                      verticalAlign: "middle",
                    }}
                  />
                </Tooltip>
              ))
            : null}
          <p />
          {this.renderPosts()}
          {discussion && !discussion.isLoadingPosts ? (
            <React.Fragment>
              {selectedPost ? null : (
                <PostForm
                  post={null}
                  discussion={discussion}
                  members={discussion.members}
                  isMobile={this.props.isMobile}
                  store={store}
                />
              )}
            </React.Fragment>
          ) : null}
          <p />
          <br />
        </div>
      </Layout>
    );
  }

  public getDiscussion(slug: string): Discussion {
    const { store, teamSlug } = this.props;
    const { currentTeam } = store;

    if (!currentTeam) {
      return;
    }

    if (!slug && currentTeam.discussions.length > 0) {
      Router.replace(
        `/discussion?teamSlug=${teamSlug}&discussionSlug=${currentTeam.orderedDiscussions[0].slug}`,
        `/team/${teamSlug}/discussions/${currentTeam.orderedDiscussions[0].slug}`
      );
      return;
    }

    if (slug && currentTeam) {
      return currentTeam.getDiscussionBySlug(slug);
    }

    return null;
  }

  public renderPosts() {
    const { isServer, store, isMobile } = this.props;
    const { selectedPost, showMarkdownClicked } = this.state;
    const discussion = this.getDiscussion(this.props.discussionSlug);

    if (!discussion.isLoadingPosts && discussion.posts.length === 0) {
      return <p>Empty Discussion.</p>;
    }

    let loading = "loading Posts ...";
    if (discussion.posts.length > 0) {
      loading = "checking for newer Posts ...";
    }

    return (
      <React.Fragment>
        {discussion
          ? discussion.posts.map((p) =>
              selectedPost && selectedPost._id === p._id ? (
                <PostForm
                  store={store}
                  isMobile={isMobile}
                  key={p._id}
                  post={p}
                  showMarkdownToNonCreator={showMarkdownClicked}
                  discussion={discussion}
                  members={discussion.members}
                  onFinished={() => {
                    this.setState({
                      selectedPost: null,
                      showMarkdownClicked: false,
                    });
                  }}
                />
              ) : (
                <PostDetail
                  key={p._id}
                  post={p}
                  onEditClick={this.onEditClickCallback}
                  onShowMarkdownClick={this.onSnowMarkdownClickCallback}
                  isMobile={this.props.isMobile}
                  store={store}
                />
              )
            )
          : null}

        {discussion && discussion.isLoadingPosts && !isServer ? <p>{loading}</p> : null}
      </React.Fragment>
    );
  }

  public onEditClickCallback = (post) => {
    this.setState({ selectedPost: post, showMarkdownClicked: false });
  };

  public onSnowMarkdownClickCallback = (post) => {
    this.setState({ selectedPost: post, showMarkdownClicked: true });
  };

  public componentDidMount() {
    const { discussionSlug, store, isServer } = this.props;

    if (store.currentTeam && (!isServer || !discussionSlug)) {
      store.currentTeam.loadDiscussions().catch((err) => notify(err));
    }

    const discussion = this.getDiscussion(discussionSlug);

    if (discussion) {
      discussion.joinSocketRooms();
    }

    console.log(store.socket);

    store.socket.on("discussionEvent", this.handleDiscussionEvent);
    store.socket.on("postEvent", this.handlePostEvent);
    store.socket.on("reconnect", this.handleSocketReconnect);
  }

  public componentWillUnmount() {
    const { discussionSlug, store } = this.props;

    const discussion = this.getDiscussion(discussionSlug);

    if (discussion) {
      discussion.leaveSocketRooms();
    }

    store.socket.off("discussionEvent", this.handleDiscussionEvent);
    store.socket.off("postEvent", this.handlePostEvent);
    store.socket.off("reconnect", this.handleSocketReconnect);
  }

  public componentDidUpdate(prevProps: Props) {
    const { discussionSlug, isServer } = this.props;

    if (prevProps.discussionSlug !== discussionSlug) {
      if (prevProps.discussionSlug) {
        const prevDiscussion = this.getDiscussion(prevProps.discussionSlug);
        if (prevDiscussion) {
          prevDiscussion.leaveSocketRooms();
        }
      }

      const discussion = this.getDiscussion(discussionSlug);

      if (!isServer && discussion) {
        discussion.loadPosts().catch((err) => notify(err));
      }

      if (discussion) {
        discussion.joinSocketRooms();
      }
    }
  }

  private handleDiscussionEvent = (data) => {
    console.log("discussion realtime event", data);

    const discussion = this.getDiscussion(this.props.discussionSlug);
    if (discussion) {
      discussion.handleDiscussionRealtimeEvent(data);
    }
  };

  private handlePostEvent = (data) => {
    console.log("post realtime event", data);

    const discussion = this.getDiscussion(this.props.discussionSlug);
    if (discussion) {
      discussion.handlePostRealtimeEvent(data);
    }
  };

  private handleSocketReconnect = () => {
    console.log("pages/discussion.tsx: socket re-connected");

    const discussion = this.getDiscussion(this.props.discussionSlug);
    if (discussion) {
      discussion.loadPosts().catch((err) => notify(err));
      discussion.joinSocketRooms();
    }
  };
}

export default withAuth(observer(DiscussionPageComp));

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\pages\invitation.tsx -----

import Avatar from "@mui/material/Avatar";
import { observer } from "mobx-react";
import Error from "next/error";
import Head from "next/head";
import Router from "next/router";
// import { NextPageContext } from 'next';
import React from "react";

import LoginButton from "../components/common/LoginButton";
import Layout from "../components/layout";
import { getTeamByTokenApiMethod } from "../lib/api/public";
import { Team } from "../lib/store/team";
import { Store } from "../lib/store";
import withAuth from "../lib/withAuth";

class InvitationPageComp extends React.Component<{ store: Store; team: Team; token: string }> {
  public static async getInitialProps(ctx) {
    const { token } = ctx.query;
    if (!token) {
      return {};
    }

    try {
      const { team } = await getTeamByTokenApiMethod(token, ctx.req);

      return { team, token };
    } catch (error) {
      console.log(error);
      return {};
    }
  }

  public render() {
    const { team, token, store } = this.props;

    if (!team) {
      return <Error statusCode={404} />;
    }

    const user = store.currentUser;

    if (user) {
      return null;
    }

    return (
      <Layout {...this.props}>
        <Head>
          <title>Invitation to {team.name}</title>
          <meta name="description" content={`Invitation to join ${team.name}`} />
        </Head>
        <div style={{ textAlign: "center", margin: "0 20px" }}>
          <br />
          <Avatar
            src={`${team.avatarUrl || "https://storage.googleapis.com/async-await/default-user.png?v=1"}`}
            alt="Team logo"
            style={{
              verticalAlign: "middle",
              display: "inline-flex",
            }}
          />{" "}
          <h2>{team.name}</h2>
          <p>
            Join <b>{team.name}</b> by logging in or signing up.
          </p>
          <br />
          <LoginButton invitationToken={token} />
        </div>
      </Layout>
    );
  }

  public async componentDidMount() {
    const { store, team, token } = this.props;

    const user = store.currentUser;

    if (user && team) {
      Router.push(
        `${process.env.NEXT_PUBLIC_URL_API}/logout?invitationToken=${token}`,
        `${process.env.NEXT_PUBLIC_URL_API}/logout`
      );
    }
  }
}

// export async function getServerSideProps(context: NextPageContext) {
//   const { token } = context.query;

//   try {
//     const { team } = await getTeamByTokenApiMethod(token as string, context.req);

//     if (team && token) {
//       return { props: { team, token } };
//     } else {
//       return { props: {} };
//     }
//   } catch (error) {
//     console.log(error);
//     return { props: {} };
//   }
// }

// see our explanation for not using getServerSideProps at this time: https://github.com/async-labs/saas/issues/193

export default withAuth(observer(InvitationPageComp), { loginRequired: false });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\pages\login.tsx -----

import Head from 'next/head';
import React from 'react';
import LoginButton from '../components/common/LoginButton';
import Layout from '../components/layout';
import withAuth from '../lib/withAuth';

class Login extends React.Component {
  public render() {
    return (
      <Layout {...this.props}>
        <div style={{ textAlign: 'center', margin: '0 20px' }}>
          <Head>
            <title>Log in to SaaS boilerplate by Async</title>
            <meta
              name="description"
              content="Login and signup page for SaaS boilerplate demo by Async"
            />
          </Head>
          <br />
          <p style={{ margin: '45px auto', fontSize: '44px', fontWeight: 400 }}>Log in</p>
          <p>Youll be logged in for 14 days unless you log out manually.</p>
          <br />

          <LoginButton />
        </div>
      </Layout>
    );
  }
}

export default withAuth(Login, { logoutRequired: true });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\pages\team-settings.tsx -----

import Avatar from "@mui/material/Avatar";
import Button from "@mui/material/Button";
import Hidden from "@mui/material/Hidden";
import TextField from "@mui/material/TextField";
import { inject, observer } from "mobx-react";
import Head from "next/head";
import NProgress from "nprogress";
import * as React from "react";
import Table from "@mui/material/Table";
import TableBody from "@mui/material/TableBody";
import TableCell from "@mui/material/TableCell";
import TableContainer from "@mui/material/TableContainer";
import TableHead from "@mui/material/TableHead";
import TableRow from "@mui/material/TableRow";

import Layout from "../components/layout";
import InviteMember from "../components/teams/InviteMember";
import { getSignedRequestForUploadApiMethod, uploadFileUsingSignedPutRequestApiMethod } from "../lib/api/team-member";
import confirm from "../lib/confirm";
import notify from "../lib/notify";
import { resizeImage } from "../lib/resizeImage";
import { Store } from "../lib/store";
import withAuth from "../lib/withAuth";

type Props = { isMobile: boolean; store: Store; teamSlug: string };

type State = {
  newName: string;
  newAvatarUrl: string;
  disabled: boolean;
  inviteMemberOpen: boolean;
};

class TeamSettings extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      newName: this.props.store.currentTeam.name,
      newAvatarUrl: this.props.store.currentTeam.avatarUrl,
      disabled: false,
      inviteMemberOpen: false,
    };
  }

  public render() {
    const { store, isMobile } = this.props;
    const { currentTeam, currentUser } = store;
    const { newName, newAvatarUrl } = this.state;
    const isTeamLeader = currentTeam && currentUser && currentUser._id === currentTeam.teamLeaderId;

    // console.log(this.props.firstGridItem);

    if (!currentTeam || currentTeam.slug !== this.props.teamSlug) {
      return (
        <Layout {...this.props}>
          <div style={{ padding: isMobile ? "0px" : "0px 30px" }}>
            <p>You did not select any team.</p>
            <p>To access this page, please select existing team or create new team if you have no teams.</p>
          </div>
        </Layout>
      );
    }

    if (!isTeamLeader) {
      return (
        <Layout {...this.props}>
          <div style={{ padding: isMobile ? "0px" : "0px 30px" }}>
            <p>Only the Team Leader can access this page.</p>
            <p>Create your own team to become a Team Leader.</p>
          </div>
        </Layout>
      );
    }

    return (
      <Layout {...this.props}>
        <Head>
          <title>Team Settings</title>
          <meta name="description" content={`Edit team settings. Add or edit members for Team ${currentTeam.name}`} />
        </Head>
        <div style={{ padding: isMobile ? "0px" : "0px 30px", fontSize: "15px", height: "100%" }}>
          <h3>Team Settings</h3>
          <p />
          <br />
          <form onSubmit={this.onSubmit}>
            <h4>Team name</h4>
            <TextField
              value={newName}
              helperText="Team name as seen by your team members"
              onChange={(event) => {
                this.setState({ newName: event.target.value });
              }}
            />
            <br />
            <br />
            <Button variant="contained" color="primary" type="submit" disabled={this.state.disabled}>
              Update username
            </Button>
          </form>
          <p />
          <br />
          <h4>Team logo</h4>
          <Avatar
            src={newAvatarUrl}
            style={{
              display: "inline-flex",
              verticalAlign: "middle",
              marginRight: 20,
              width: 60,
              height: 60,
            }}
          />
          <label htmlFor="upload-file-team-logo">
            <Button variant="contained" color="primary" component="span" disabled={this.state.disabled}>
              Update logo
            </Button>
          </label>
          <input
            accept="image/*"
            name="upload-file-team-logo"
            id="upload-file-team-logo"
            type="file"
            style={{ display: "none" }}
            onChange={this.uploadFile}
          />
          <p />
          <br />
          <br />
          <h4 style={{ marginRight: 20, display: "inline" }}>
            Team Members ( {Array.from(currentTeam.members.values()).length} / 20 )
          </h4>
          <Button
            onClick={this.openInviteMember}
            variant="contained"
            color="primary"
            style={{ float: "right", marginTop: "-20px" }}
            disabled={this.state.disabled}
          >
            Invite member
          </Button>
          <p />
          <TableContainer>
            <Table>
              <TableHead>
                <TableRow>
                  <TableCell>Person</TableCell>
                  <TableCell>Role</TableCell>
                  <TableCell>Action</TableCell>
                </TableRow>
              </TableHead>

              <TableBody>
                {currentTeam.memberIds
                  .map((userId) => currentTeam.members.get(userId))
                  .map((m) => (
                    <TableRow key={m._id}>
                      <TableCell style={{ width: "300px" }}>
                        <Hidden smDown>
                          <Avatar
                            role="presentation"
                            src={m.avatarUrl}
                            alt={(m.displayName || m.email)[0]}
                            key={m._id}
                            style={{
                              margin: "0px 5px",
                              display: "inline-flex",
                              width: "30px",
                              height: "30px",
                              verticalAlign: "middle",
                            }}
                          />
                        </Hidden>
                        {m.email}
                      </TableCell>
                      <TableCell>{isTeamLeader && m._id !== currentUser._id ? "Team Member" : "Team Leader"}</TableCell>
                      <TableCell>
                        {isTeamLeader && m._id !== currentUser._id ? (
                          <i
                            color="action"
                            data-id={m._id}
                            onClick={this.removeMember}
                            style={{
                              marginLeft: "20px",
                              fontSize: "16px",
                              opacity: 0.6,
                              cursor: "pointer",
                              verticalAlign: "middle",
                            }}
                            className="material-icons"
                          >
                            delete
                          </i>
                        ) : null}
                      </TableCell>
                    </TableRow>
                  ))}
              </TableBody>
            </Table>
          </TableContainer>

          <p />
          <br />

          {Array.from(currentTeam.invitations.values()).length > 0 ? (
            <React.Fragment>
              <h4>Invited users</h4>
              <p />
              <TableContainer>
                <Table>
                  <TableHead>
                    <TableRow>
                      <TableCell>Email</TableCell>
                      <TableCell>Status</TableCell>
                    </TableRow>
                  </TableHead>

                  <TableBody>
                    {Array.from(currentTeam.invitations.values()).map((i) => (
                      <TableRow key={i._id}>
                        <TableCell style={{ width: "300px" }}>{i.email}</TableCell>
                        <TableCell>Sent</TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              </TableContainer>
            </React.Fragment>
          ) : null}
          <p />
          <br />
          <InviteMember
            open={this.state.inviteMemberOpen}
            onClose={this.handleInviteMemberClose}
            store={this.props.store}
          />
          <br />
        </div>
      </Layout>
    );
  }

  private onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    const { newName, newAvatarUrl } = this.state;
    const { currentTeam } = this.props.store;

    if (!newName) {
      notify("Team name is required");
      return;
    }

    NProgress.start();

    try {
      this.setState({ disabled: true });

      await currentTeam.updateTheme({ name: newName, avatarUrl: newAvatarUrl });

      notify("You successfully updated Team name.");
    } catch (error) {
      notify(error);
    } finally {
      this.setState({ disabled: false });
      NProgress.done();
    }
  };

  private uploadFile = async () => {
    const { store } = this.props;
    const { currentTeam } = store;

    const fileElement = document.getElementById("upload-file-team-logo") as HTMLFormElement;
    const file = fileElement.files[0];

    if (file == null) {
      notify("No file selected for upload.");
      return;
    }

    const fileName = file.name;
    const fileType = file.type;

    NProgress.start();
    this.setState({ disabled: true });

    const bucket = process.env.NEXT_PUBLIC_BUCKET_FOR_TEAM_LOGOS;
    const prefix = `${currentTeam.slug}`;

    console.log(bucket);

    try {
      const responseFromApiServerForUpload = await getSignedRequestForUploadApiMethod({
        fileName,
        fileType,
        prefix,
        bucket,
      });

      const resizedFile = await resizeImage(file, 128, 128);

      await uploadFileUsingSignedPutRequestApiMethod(resizedFile, responseFromApiServerForUpload.signedRequest, {
        "Cache-Control": "max-age=2592000",
      });

      this.setState({
        newAvatarUrl: responseFromApiServerForUpload.url,
      });

      await currentTeam.updateTheme({
        name: this.state.newName,
        avatarUrl: this.state.newAvatarUrl,
      });

      notify("You successfully uploaded new Team logo.");
    } catch (error) {
      notify(error);
    } finally {
      this.setState({ disabled: false });
      NProgress.done();
    }
  };

  private openInviteMember = async () => {
    const { currentTeam } = this.props.store;
    if (!currentTeam) {
      notify("You have not selected a Team.");
      return;
    }

    this.setState({ inviteMemberOpen: true });
  };

  private handleInviteMemberClose = () => {
    this.setState({ inviteMemberOpen: false });
  };

  private removeMember = (event) => {
    const { currentTeam } = this.props.store;
    if (!currentTeam) {
      notify("You have not selected a Team.");
      return;
    }

    const userId = event.currentTarget.dataset.id;
    if (!userId) {
      notify("Select user.");
      return;
    }

    confirm({
      title: "Are you sure?",
      message: "",
      onAnswer: async (answer) => {
        if (answer) {
          try {
            await currentTeam.removeMember(userId);
          } catch (error) {
            notify(error);
          }
        }
      },
    });
  };
}

export default withAuth(inject("store")(observer(TeamSettings)));

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\pages\your-settings.tsx -----

import Avatar from "@mui/material/Avatar";
import Button from "@mui/material/Button";
import TextField from "@mui/material/TextField";
import { inject, observer } from "mobx-react";
import Head from "next/head";
import NProgress from "nprogress";
import * as React from "react";

import Layout from "../components/layout";

import { getSignedRequestForUploadApiMethod, uploadFileUsingSignedPutRequestApiMethod } from "../lib/api/team-member";

import notify from "../lib/notify";
import { resizeImage } from "../lib/resizeImage";
import { Store } from "../lib/store";
import withAuth from "../lib/withAuth";

type Props = { isMobile: boolean; store: Store };

type State = { newName: string; newAvatarUrl: string; disabled: boolean };

class YourSettings extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      newName: this.props.store.currentUser.displayName,
      newAvatarUrl: this.props.store.currentUser.avatarUrl,
      disabled: false,
    };
  }

  public render() {
    const { currentUser } = this.props.store;
    const { newName, newAvatarUrl } = this.state;

    return (
      <Layout {...this.props}>
        <Head>
          <title>Your Settings at Async</title>
          <meta name="description" content="description" />
        </Head>
        <div
          style={{
            padding: this.props.isMobile ? "0px" : "0px 30px",
            fontSize: "15px",
            height: "100%",
          }}
        >
          <h3>Your Settings</h3>
          <h4 style={{ marginTop: "40px" }}>Your account</h4>
          <div>
            <i className="material-icons" color="action" style={{ verticalAlign: "text-bottom" }}>
              done
            </i>{" "}
            {currentUser.isSignedupViaGoogle
              ? "You signed up on Async using your Google account."
              : "You signed up on Async using your email."}
            <p />
            <li>
              Your email: <b>{currentUser.email}</b>
            </li>
            <li>
              Your username: <b>{currentUser.displayName}</b>
            </li>
          </div>
          <form onSubmit={this.onSubmit} autoComplete="off">
            <h4>Your username</h4>
            <TextField
              autoComplete="off"
              value={newName}
              helperText="Your username as seen by your team members"
              onChange={(event) => {
                this.setState({ newName: event.target.value });
              }}
            />
            <br />
            <br />
            <Button variant="contained" color="primary" type="submit" disabled={this.state.disabled}>
              Update username
            </Button>
          </form>

          <br />
          <h4>Your photo</h4>
          <Avatar
            src={newAvatarUrl}
            style={{
              display: "inline-flex",
              verticalAlign: "middle",
              marginRight: 20,
              width: 60,
              height: 60,
            }}
          />
          <label htmlFor="upload-file-user-avatar">
            <Button variant="outlined" color="primary" component="span" disabled={this.state.disabled}>
              Update avatar
            </Button>
          </label>
          <input
            accept="image/*"
            name="upload-file-user-avatar"
            id="upload-file-user-avatar"
            type="file"
            style={{ display: "none" }}
            onChange={this.uploadFile}
          />
          <p />
          <br />
        </div>
      </Layout>
    );
  }

  private onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();

    const { currentUser } = this.props.store;

    const { newName, newAvatarUrl } = this.state;

    console.log(newName);

    if (!newName) {
      notify("Name is required");
      return;
    }

    NProgress.start();
    this.setState({ disabled: true });

    try {
      await currentUser.updateProfile({ name: newName, avatarUrl: newAvatarUrl });

      notify("You successfully updated your profile.");
    } catch (error) {
      notify(error);
    } finally {
      this.setState({ disabled: false });
      NProgress.done();
    }
  };

  private uploadFile = async () => {
    const fileElement = document.getElementById("upload-file-user-avatar") as HTMLFormElement;
    const file = fileElement.files[0];

    const { currentUser } = this.props.store;

    if (file == null) {
      notify("No file selected for upload.");
      return;
    }

    const fileName = file.name;
    const fileType = file.type;

    NProgress.start();
    this.setState({ disabled: true });

    const bucket = process.env.NEXT_PUBLIC_BUCKET_FOR_AVATARS;

    const prefix = `${currentUser.slug}`;

    try {
      const responseFromApiServerForUpload = await getSignedRequestForUploadApiMethod({
        fileName,
        fileType,
        prefix,
        bucket,
      });

      const resizedFile = await resizeImage(file, 128, 128);

      console.log(file);
      console.log(resizedFile);

      await uploadFileUsingSignedPutRequestApiMethod(resizedFile, responseFromApiServerForUpload.signedRequest, {
        "Cache-Control": "max-age=2592000",
      });

      this.setState({
        newAvatarUrl: responseFromApiServerForUpload.url,
      });

      await currentUser.updateProfile({
        name: this.state.newName,
        avatarUrl: this.state.newAvatarUrl,
      });

      notify("You successfully uploaded new avatar.");
    } catch (error) {
      notify(error);
    } finally {
      fileElement.value = "";
      this.setState({ disabled: false });
      NProgress.done();
    }
  };
}

export default withAuth(inject("store")(observer(YourSettings)));

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\pages\_app.tsx -----

import CssBaseline from "@mui/material/CssBaseline";
import { ThemeProvider } from "@mui/material";
import { Provider } from "mobx-react";
import App from "next/app";
import Head from "next/head";
import React from "react";

import { themeDark, themeLight } from "../lib/theme";
import { getUserApiMethod } from "../lib/api/public";
import { getInitialDataApiMethod } from "../lib/api/team-member";
import { isMobile } from "../lib/isMobile";
import { getStore, initializeStore, Store } from "../lib/store";

class MyApp extends App {
  public static async getInitialProps({ Component, ctx }) {
    let firstGridItem = true;
    let teamRequired = false;

    if (
      ctx.pathname.includes("/login") ||
      ctx.pathname.includes("/create-team") ||
      ctx.pathname.includes("/invitation")
    ) {
      firstGridItem = false;
    }

    if (
      ctx.pathname.includes("/team-settings") ||
      ctx.pathname.includes("/discussion") ||
      ctx.pathname.includes("/billing")
    ) {
      teamRequired = true;
    }

    const { teamSlug, discussionSlug } = ctx.query;

    const pageProps = {
      isMobile: isMobile({ req: ctx.req }),
      firstGridItem,
      teamRequired,
      teamSlug,
      discussionSlug,
    };

    if (Component.getInitialProps) {
      Object.assign(pageProps, await Component.getInitialProps(ctx));
    }

    const appProps = { pageProps };

    const store = getStore();
    if (store) {
      return appProps;
    }

    let userObj = null;
    try {
      const { user } = await getUserApiMethod(ctx.req);
      userObj = user;
    } catch (error) {
      console.log(error);
    }

    let initialData = {};

    if (userObj) {
      try {
        initialData = await getInitialDataApiMethod({
          request: ctx.req,
          data: { teamSlug, discussionSlug },
        });
      } catch (error) {
        console.error(error);
      }
    }

    // console.log(initialData);

    // console.log(teamSlug);

    return {
      ...appProps,
      initialState: { user: userObj, currentUrl: ctx.asPath, teamSlug, ...initialData },
    };
  }

  public componentDidMount() {
    // Remove the server-side injected CSS.
    const jssStyles = document.querySelector("#jss-server-side");
    if (jssStyles && jssStyles.parentNode) {
      jssStyles.parentNode.removeChild(jssStyles);
    }
  }

  private store: Store;

  constructor(props) {
    super(props);

    console.log("MyApp.constructor");

    this.store = initializeStore(props.initialState);
  }

  public render() {
    const { Component, pageProps } = this.props;
    const store = this.store;

    const isThemeDark = store.currentUser ? store.currentUser.darkTheme : true;

    return (
      <ThemeProvider theme={isThemeDark ? themeDark : themeLight}>
        <Head>
          <meta name="viewport" content="width=device-width, initial-scale=1.0" />

          <link
            rel="stylesheet"
            href={
              isThemeDark
                ? "https://storage.googleapis.com/async-await/nprogress-light.min.css?v=1"
                : "https://storage.googleapis.com/async-await/nprogress-dark.min.css?v=1"
            }
          />
        </Head>
        <CssBaseline />
        <Provider store={store}>
          <Component {...pageProps} store={store} />
        </Provider>
      </ThemeProvider>
    );
  }
}

export default MyApp;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\pages\_document.tsx -----

import Document, { Head, Html, Main, NextScript } from "next/document";
import React from "react";

class MyDocument extends Document {
  public static getInitialProps = async (ctx) => {
    const initialProps = await Document.getInitialProps(ctx);

    return {
      ...initialProps,
    };
  };

  public render() {
    // console.log('rendered on the server');

    const isThemeDark = this.props.__NEXT_DATA__.props.initialState.user
      ? this.props.__NEXT_DATA__.props.initialState.user.darkTheme
      : true;

    return (
      <Html lang="en">
        <Head>
          <meta charSet="utf-8" />
          <meta name="google" content="notranslate" />
          <meta name="theme-color" content="#303030" />

          <link rel="shortcut icon" href="https://storage.googleapis.com/async-await/async-favicon32.png" />

          <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons" />

          <link
            rel="stylesheet"
            href={
              isThemeDark
                ? "https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/a11y-dark.min.css"
                : "https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/a11y-light.min.css"
            }
          />

          <style>
            {`
              #__next {
                width: 100%;
                height: 100%;
              }
              a {
                font-weight: 400;
                color: #58a6ff;
                text-decoration: none;
                outline: none;
              }
              hr {
                border: 0.5px #707070 solid;
                color: #000;
              }
              blockquote {
                padding: 0 0.5em;
                margin: 20px 1em;
                border-left: 0.25em solid #dfe2e5;
                color: #000;
              }
              pre {
                display: block;
                overflow-x: auto;
                padding: 0.5em;
                background: #d0d0d0;
                border: 1px solid #ddd;
                font-size: 14px;
                color: #000;
              }
              pre code {
                font-size: 13px;
                background: #d0d0d0;
                padding: 0px;
                color: #000;
              }
              code {
                font-size: 13px;
                background: #d0d0d0;
                padding: 3px 5px;
                color: #000;
              }
              mark {
                background-color: #ffff0060;
              }
              summary:focus {
                outline: none;
              }
              table {
                border-collapse: collapse;
                margin: 15px 0px;
              }
              table, th, td {
                border: 1px solid #a1a1a1;
              }
              th, td {
                line-height: 1.5em;
                padding: 10px;
              }
            `}
          </style>
        </Head>
        <body>
          <Main />
          <NextScript />
        </body>
      </Html>
    );
  }
}

export default MyDocument;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\server\server.ts -----

import express from 'express';
import next from 'next';

const NODE_ENV = process.env.NODE_ENV || 'development';
const IS_DEV = NODE_ENV !== 'production';

const app = next({ dev: IS_DEV });
const handle = app.getRequestHandler();

app.prepare().then(() => {
  const server = express();

  // give all Nextjs's request to Nextjs before anything else
  server.get('/_next/*', (req, res) => {
    // console.log('next server, page');
    handle(req, res);
  });

  server.use(express.json());

  // server.get('/api/v1/public/get-user', (_, res) => {
  //   res.json({ user: { email: 'team@builderbook.org' } });
  // });

  server.get('/team/:teamSlug/team-settings', (req, res) => {
    const { teamSlug } = req.params;
    app.render(req, res, '/team-settings', { teamSlug });
  });

  server.get('/team/:teamSlug/discussions/:discussionSlug', (req, res) => {
    const { teamSlug, discussionSlug } = req.params;
    app.render(req, res, '/discussion', { teamSlug, discussionSlug });
  });

  server.get('/team/:teamSlug/discussions', (req, res) => {
    const { teamSlug } = req.params;
    app.render(req, res, '/discussion', { teamSlug });
  });

  server.get('/invitation', (req, res) => {
    app.render(req, res, '/invitation', { token: req.query.token as string });
  });

  server.all('*', (req, res) => {
    handle(req, res);
  });

  server.listen(process.env.NEXT_PUBLIC_PORT_APP, () => {
    console.log(`> Ready on ${process.env.NEXT_PUBLIC_URL_APP}`);
  });
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\.eslintrc.js -----

module.exports = {
  settings: {
    react: { version: 'detect' },
  },
  parser: '@typescript-eslint/parser',
  extends: ['plugin:react/recommended', 'plugin:@typescript-eslint/recommended', 'prettier'],
  env: {
    es6: true,
    node: true,
  },
  plugins: ['prettier', 'react'],
  rules: {
    'prettier/prettier': [
      'error',
      {
        singleQuote: true,
        trailingComma: 'all',
        arrowParens: 'always',
        printWidth: 100,
        semi: true,
      },
    ],
    '@typescript-eslint/camelcase': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    'react/no-unescaped-entities': 'off',
    'react/jsx-filename-extension': ['error', { extensions: ['.tsx'] }],
    '@typescript-eslint/no-explicit-any': 'off',
    'prefer-arrow-callback': 'error',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
  },
};

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\next-env.d.ts -----

/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/basic-features/typescript for more information.

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\next.config.js -----

module.exports = {
  poweredByHeader: false,
  webpack5: true,
  typescript: {
    ignoreBuildErrors: true,
  },
};

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\nodemon.json -----

{
  "watch": ["server"],
  "exec": "ts-node --project tsconfig.server.json",
  "ext": "ts"
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\package.json -----

{
  "name": "9-begin-app",
  "version": "1",
  "license": "MIT",
  "scripts": {
    "dev": "nodemon server/server.ts",
    "build": "next build",
    "lint": "eslint . --ext .ts,.tsx"
  },
  "dependencies": {
    "@emotion/react": "^11.14.0",
    "@emotion/styled": "^11.14.0",
    "@material-ui/lab": "^4.0.0-alpha.61",
    "@mui/material": "^6.4.8",
    "@mui/system": "^6.4.8",
    "dotenv": "^16.3.1",
    "express": "^4.18.2",
    "he": "^1.2.0",
    "isomorphic-unfetch": "^4.0.2",
    "keycode": "^2.2.1",
    "marked": "^11.0.0",
    "mobx": "5.15.7",
    "mobx-react": "6.3.1",
    "moment": "^2.29.4",
    "next": "^14.0.3",
    "nprogress": "^0.2.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-mentions": "^4.4.10",
    "socket.io-client": "^4.7.2",
    "typescript": "^5.3.2"
  },
  "devDependencies": {
    "@types/express": "^4.17.21",
    "@types/he": "^1.2.3",
    "@types/marked": "^6.0.0",
    "@types/node": "^20.10.3",
    "@types/react": "^18.2.41",
    "@types/react-dom": "^18.2.17",
    "@types/socket.io-client": "^3.0.0",
    "@typescript-eslint/eslint-plugin": "^6.13.1",
    "@typescript-eslint/parser": "^6.13.1",
    "eslint": "^8.55.0",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-prettier": "^5.0.1",
    "eslint-plugin-react": "^7.33.2",
    "nodemon": "^3.0.2",
    "prettier": "^3.1.0",
    "ts-node": "^10.9.1"
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\tsconfig.json -----

{
  "compileOnSave": false,
  "compilerOptions": {
    "target": "esnext",
    "module": "esnext",
    "jsx": "preserve",
    "allowJs": true,
    "alwaysStrict": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "removeComments": true,
    "preserveConstEnums": true,
    "sourceMap": false,
    "skipLibCheck": true,
    "baseUrl": ".",
    "typeRoots": [
      "./node_modules/@types"
    ],
    "lib": [
      "dom",
      "es2017"
    ],
    "strict": false,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "incremental": true
  },
  "include": [
    "next-env.d.ts",
    "./**/*.tsx",
    "./**/*.ts"
  ],
  "exclude": [
    "dist",
    "production-server",
    ".next",
    "out",
    "next.config.js",
    "node_modules"
  ]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-begin\app\tsconfig.server.json -----

{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "module": "commonjs",
    "outDir": "production-server/",
    "target": "es2017",
    "isolatedModules": false,
    "noEmit": false
  },
  "exclude": ["./server/types.d.ts"],
  "include": ["./server/**/*.ts"],
  "typeRoots": ["./node_modules/@types", "./server/types.d.ts"]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\server\api\index.ts -----

import * as express from 'express';

import publicExpressRoutes from './public';
import teamMemberExpressRoutes from './team-member';
import teamLeaderApi from './team-leader';

function handleError(err, _, res, __) {
  console.error(err.stack);

  res.json({ error: err.message || err.toString() });
}

export default function api(server: express.Express) {
  server.use('/api/v1/public', publicExpressRoutes, handleError);
  server.use('/api/v1/team-member', teamMemberExpressRoutes, handleError);
  server.use('/api/v1/team-leader', teamLeaderApi, handleError);
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\server\api\public.ts -----

import * as express from 'express';

import User from '../models/User';
import Invitation from '../models/Invitation';

const router = express.Router();

router.get('/get-user', (req, res) => {
  console.log(req.user);
  res.json({ user: req.user || null });
});

router.post('/get-user-by-slug', async (req, res, next) => {
  console.log('Express route: /get-user-by-slug');

  // req.session.foo = 'bar';

  try {
    const { slug } = req.body;

    const user = await User.getUserBySlug({ slug });

    res.json({ user });
  } catch (err) {
    next(err);
  }
});

router.get('/invitations/get-team-by-token', async (req, res, next) => {
  const token = req.query.token as string;

  try {
    const team = await Invitation.getTeamByToken({ token });

    res.json({ team });
  } catch (err) {
    next(err);
  }
});

export default router;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\server\api\team-leader.ts -----

import * as express from 'express';

import Invitation from '../models/Invitation';
import Team from '../models/Team';
import User from '../models/User';
import { createSession } from '../stripe';

const router = express.Router();

router.use((req, res, next) => {
  console.log('team leader API', req.path);

  if (!req.user) {
    res.status(401).json({ error: 'Unauthorized' });
    return;
  }

  next();
});

router.post('/teams/add', async (req: any, res, next) => {
  try {
    const { name, avatarUrl } = req.body;

    console.log(`Express route: ${name}, ${avatarUrl}`);

    const team = await Team.addTeam({ userId: req.user.id, name, avatarUrl });

    res.json(team);
  } catch (err) {
    next(err);
  }
});

router.post('/teams/update', async (req: any, res, next) => {
  try {
    const { teamId, name, avatarUrl } = req.body;

    // console.log(req.user.id, typeof req.user.id);
    // console.log(req.user._id, typeof req.user._id);

    const team = await Team.updateTeam({
      userId: req.user.id,
      teamId,
      name,
      avatarUrl,
    });

    res.json(team);
  } catch (err) {
    next(err);
  }
});

router.get('/teams/get-invitations-for-team', async (req: any, res, next) => {
  try {
    const invitations = await Invitation.getTeamInvitations({
      userId: req.user.id,
      teamId: req.query.teamId as string,
    });

    res.json({ invitations });
  } catch (err) {
    next(err);
  }
});

router.post('/teams/invite-member', async (req: any, res, next) => {
  try {
    const { teamId, email } = req.body;

    const newInvitation = await Invitation.add({ userId: req.user.id, teamId, email });

    res.json({ newInvitation });
  } catch (err) {
    next(err);
  }
});

router.post('/teams/remove-member', async (req: any, res, next) => {
  try {
    const { teamId, userId } = req.body;

    await Team.removeMember({ teamLeaderId: req.user.id, teamId, userId });

    res.json({ done: 1 });
  } catch (err) {
    next(err);
  }
});

router.post('/stripe/fetch-checkout-session', async (req: any, res, next) => {
  try {
    const { mode, teamId } = req.body;

    const user = await User.findById(req.user.id)
      .select(['stripeCustomer', 'email'])
      .setOptions({ lean: true });

    const team = await Team.findById(teamId)
      .select(['stripeSubscription', 'slug', 'teamLeaderId'])
      .setOptions({ lean: true });

    if (!user || !team || team.teamLeaderId !== req.user.id) {
      throw new Error('Permission denied');
    }

    const session = await createSession({
      mode,
      userId: user._id.toString(),
      userEmail: user.email,
      teamId,
      teamSlug: team.slug,
      customerId: (user.stripeCustomer && user.stripeCustomer.id) || undefined,
      subscriptionId: (team.stripeSubscription && team.stripeSubscription.id) || undefined,
    });

    res.json({ sessionId: session.id });
  } catch (err) {
    next(err);
  }
});

router.post('/cancel-subscription', async (req: any, res, next) => {
  const { teamId } = req.body;

  try {
    const { isSubscriptionActive } = await Team.cancelSubscription({
      teamLeaderId: req.user.id,
      teamId,
    });

    res.json({ isSubscriptionActive });
  } catch (err) {
    next(err);
  }
});

router.get('/get-list-of-invoices-for-customer', async (req: any, res, next) => {
  try {
    const { stripeListOfInvoices } = await User.getListOfInvoicesForCustomer({
      userId: req.user.id,
    });
    res.json({ stripeListOfInvoices });
  } catch (err) {
    next(err);
  }
});

export default router;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\server\api\team-member.ts -----

import * as express from "express";

import { signRequestForUpload } from "../aws-s3";

import User from "../models/User";
import Team from "../models/Team";
import Invitation from "../models/Invitation";
import Discussion from "../models/Discussion";
import Post from "../models/Post";

import { discussionAdded, discussionDeleted, discussionEdited, postAdded, postDeleted, postEdited } from "../sockets";

const router = express.Router();

router.use((req, res, next) => {
  console.log("team member API", req.path);
  if (!req.user) {
    res.status(401).json({ error: "Unauthorized" });
    return;
  }

  next();
});

// Get signed request from AWS S3 server
router.post("/aws/get-signed-request-for-upload-to-s3", async (req, res, next) => {
  try {
    const { fileName, fileType, prefix, bucket } = req.body;

    const returnData = await signRequestForUpload({
      fileName,
      fileType,
      prefix,
      bucket,
    });

    console.log(bucket);

    res.json(returnData);
  } catch (err) {
    next(err);
  }
});

router.post("/user/update-profile", async (req: any, res, next) => {
  try {
    const { name, avatarUrl } = req.body;

    const updatedUser = await User.updateProfile({
      userId: req.user.id,
      name,
      avatarUrl,
    });

    res.json({ updatedUser });
  } catch (err) {
    next(err);
  }
});

router.post("/user/toggle-theme", async (req: any, res, next) => {
  try {
    const { darkTheme } = req.body;

    await User.toggleTheme({ userId: req.user.id, darkTheme });

    res.json({ done: 1 });
  } catch (err) {
    next(err);
  }
});

async function loadDiscussionsData(team, userId, body) {
  const { discussionSlug } = body;

  if (!discussionSlug) {
    return [];
  }

  const { discussions } = await Discussion.getList({
    userId,
    teamId: team._id,
  });

  for (const discussion of discussions) {
    if (discussion.slug === discussionSlug) {
      Object.assign(discussion, {
        initialPosts: await Post.getList({
          userId,
          discussionId: discussion._id.toString(),
        }),
      });

      break;
    }
  }

  return discussions;
}

async function loadTeamData(team, userId, body) {
  const initialMembers = await User.getMembersForTeam({
    userId,
    teamId: team._id,
  });

  let initialInvitations = [];
  if (userId === team.teamLeaderId) {
    initialInvitations = await Invitation.getTeamInvitations({
      userId,
      teamId: team._id,
    });
  }

  console.log(`initialMembers:${initialMembers}`);

  const initialDiscussions = await loadDiscussionsData(team, userId, body);

  const data: any = { initialMembers, initialInvitations, initialDiscussions };

  // console.log(`Express route:${data.initialPosts}`);

  return data;
}

router.post("/get-initial-data", async (req: any, res, next) => {
  try {
    const teams = await Team.getAllTeamsForUser(req.user.id);

    let selectedTeamSlug = req.body.teamSlug;
    if (!selectedTeamSlug && teams && teams.length > 0) {
      selectedTeamSlug = teams[0].slug;
    }

    for (const team of teams) {
      if (team.slug === selectedTeamSlug) {
        Object.assign(team, await loadTeamData(team, req.user.id, req.body));
        break;
      }
    }

    res.json({ teams });
  } catch (err) {
    next(err);
  }
});

router.get("/teams", async (req: any, res, next) => {
  try {
    const teams = await Team.getAllTeamsForUser(req.user.id);

    console.log(teams);

    res.json({ teams });
  } catch (err) {
    next(err);
  }
});

router.get("/teams/get-members", async (req: any, res, next) => {
  try {
    const users = await User.getMembersForTeam({
      userId: req.user.id,
      teamId: req.query.teamId as string,
    });

    res.json({ users });
  } catch (err) {
    next(err);
  }
});

router.post("/discussions/add", async (req: any, res, next) => {
  try {
    const { name, teamId, memberIds = [], socketId, notificationType } = req.body;

    const discussion = await Discussion.add({
      userId: req.user.id,
      name,
      teamId,
      memberIds,
      notificationType,
    });

    discussionAdded({ socketId, discussion });

    res.json({ discussion });
  } catch (err) {
    next(err);
  }
});

router.post("/discussions/edit", async (req: any, res, next) => {
  try {
    const { name, id, memberIds = [], socketId, notificationType } = req.body;

    const updatedDiscussion = await Discussion.edit({
      userId: req.user.id,
      name,
      id,
      memberIds,
      notificationType,
    });

    discussionEdited({ socketId, discussion: updatedDiscussion });

    res.json({ done: 1 });
  } catch (err) {
    next(err);
  }
});

router.post("/discussions/delete", async (req: any, res, next) => {
  try {
    const { id, socketId } = req.body;

    const { teamId } = await Discussion.delete({ userId: req.user.id, id });

    discussionDeleted({ socketId, teamId, id });

    res.json({ done: 1 });
  } catch (err) {
    next(err);
  }
});

router.get("/discussions/list", async (req: any, res, next) => {
  try {
    const { discussions } = await Discussion.getList({
      userId: req.user.id,
      teamId: req.query.teamId as string,
    });

    res.json({ discussions });
  } catch (err) {
    next(err);
  }
});

router.get("/posts/list", async (req: any, res, next) => {
  try {
    const posts = await Post.getList({
      userId: req.user.id,
      discussionId: req.query.discussionId as string,
    });

    res.json({ posts });
  } catch (err) {
    next(err);
  }
});

router.post("/posts/add", async (req: any, res, next) => {
  try {
    const { content, discussionId, socketId } = req.body;

    const post = await Post.add({ userId: req.user.id, content, discussionId });

    postAdded({ socketId, post });

    res.json({ post });
  } catch (err) {
    next(err);
  }
});

router.post("/posts/edit", async (req: any, res, next) => {
  try {
    const { content, id, socketId } = req.body;

    const updatedPost = await Post.edit({ userId: req.user.id, content, id });

    postEdited({ socketId, post: updatedPost });

    res.json({ done: 1 });
  } catch (err) {
    next(err);
  }
});

router.post("/posts/delete", async (req: any, res, next) => {
  try {
    const { id, discussionId, socketId } = req.body;

    await Post.delete({ userId: req.user.id, id });

    postDeleted({ socketId, id, discussionId });

    res.json({ done: 1 });
  } catch (err) {
    next(err);
  }
});

export default router;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\server\models\Discussion.ts -----

import { uniq } from 'lodash';
import * as mongoose from 'mongoose';

import { generateNumberSlug } from '../utils/slugify';
import Team, { TeamDocument } from './Team';
import Post from './Post';

const mongoSchema = new mongoose.Schema({
  createdUserId: {
    type: String,
    required: true,
  },
  teamId: {
    type: String,
    required: true,
  },
  name: {
    type: String,
    required: true,
  },
  slug: {
    type: String,
    required: true,
  },
  memberIds: [
    {
      type: String,
    },
  ],
  createdAt: {
    type: Date,
    required: true,
    default: Date.now,
  },
  notificationType: {
    type: String,
    enum: ['default', 'email'],
    required: true,
    default: 'default',
  },
});

export interface DiscussionDocument extends mongoose.Document {
  createdUserId: string;
  teamId: string;
  name: string;
  slug: string;
  memberIds: string[];
  createdAt: Date;
  notificationType: string;
}

interface DiscussionModel extends mongoose.Model<DiscussionDocument> {
  getList({
    userId,
    teamId,
  }: {
    userId: string;
    teamId: string;
  }): Promise<{ discussions: DiscussionDocument[] }>;

  add({
    name,
    userId,
    teamId,
    memberIds,
    notificationType,
  }: {
    name: string;
    userId: string;
    teamId: string;
    memberIds: string[];
    notificationType: string;
  }): Promise<DiscussionDocument>;

  edit({
    userId,
    id,
    name,
    memberIds,
    notificationType,
  }: {
    userId: string;
    id: string;
    name: string;
    memberIds: string[];
    notificationType: string;
  }): Promise<DiscussionDocument>;

  delete({ userId, id }: { userId: string; id: string }): Promise<{ teamId: string }>;

  checkPermissionAndGetTeam({
    userId,
    teamId,
    memberIds,
  }: {
    userId: string;
    teamId: string;
    memberIds: string[];
  }): Promise<TeamDocument>;
}

class DiscussionClass extends mongoose.Model {
  public static async getList({ userId, teamId }) {
    await this.checkPermissionAndGetTeam({ userId, teamId });

    const filter: any = { teamId, memberIds: userId };

    const discussions: any[] = await this.find(filter).setOptions({ lean: true });

    return { discussions };
  }

  public static async add({ name, userId, teamId, memberIds = [], notificationType }) {
    if (!name) {
      throw new Error('Bad data');
    }

    await this.checkPermissionAndGetTeam({ userId, teamId, memberIds });

    const slug = await generateNumberSlug(this, { teamId });

    return this.create({
      createdUserId: userId,
      teamId,
      name,
      slug,
      memberIds: uniq([userId, ...memberIds]),
      createdAt: new Date(),
      notificationType,
    });
  }

  public static async edit({ userId, id, name, memberIds = [], notificationType }) {
    if (!id) {
      throw new Error('Bad data');
    }

    const discussion = await this.findById(id)
      .select('teamId createdUserId')
      .setOptions({ lean: true });

    const team = await this.checkPermissionAndGetTeam({
      userId,
      teamId: discussion.teamId,
      memberIds,
    });

    if (discussion.createdUserId !== userId && team.teamLeaderId !== userId) {
      throw new Error('Permission denied. Only author or team leader can edit Discussion.');
    }

    const updatedObj = await this.findOneAndUpdate(
      { _id: id },
      {
        name,
        memberIds: uniq([userId, ...memberIds]),
        notificationType,
      },
      { runValidators: true, new: true },
    );

    return updatedObj;
  }

  public static async delete({ userId, id }) {
    if (!id) {
      throw new Error('Bad data');
    }

    const discussion = await this.findById(id).select('teamId').setOptions({ lean: true });

    await this.checkPermissionAndGetTeam({ userId, teamId: discussion.teamId });

    await Post.deleteMany({ discussionId: id });

    await this.deleteOne({ _id: id });

    return { teamId: discussion.teamId };
  }

  private static async checkPermissionAndGetTeam({ userId, teamId, memberIds = [] }) {
    if (!userId || !teamId) {
      throw new Error('Bad data');
    }

    const team = await Team.findById(teamId)
      .select('memberIds teamLeaderId')
      .setOptions({ lean: true });

    if (!team || team.memberIds.indexOf(userId) === -1) {
      throw new Error('Team not found');
    }

    for (const id of memberIds) {
      if (team.memberIds.indexOf(id) === -1) {
        throw new Error('Permission denied');
      }
    }

    return team;
  }
}

mongoSchema.loadClass(DiscussionClass);

const Discussion = mongoose.model<DiscussionDocument, DiscussionModel>('Discussion', mongoSchema);

export default Discussion;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\server\models\EmailTemplate.ts -----

import * as _ from 'lodash';
import * as mongoose from 'mongoose';

interface EmailTemplateDocument extends mongoose.Document {
  name: string;
  subject: string;
  message: string;
}

const EmailTemplate = mongoose.model<EmailTemplateDocument>(
  'EmailTemplate',
  new mongoose.Schema({
    name: {
      type: String,
      required: true,
      unique: true,
    },
    subject: {
      type: String,
      required: true,
    },
    message: {
      type: String,
      required: true,
    },
  }),
);

export async function insertTemplates() {
  const templates = [
    {
      name: 'welcome',
      subject: 'Welcome to SaaS boilerplate by Async',
      message: `Welcome <%= userName %>,
        <p>
          Thanks for signing up on our <a href="https://github.com/async-labs/saas" target="blank">SaaS boilerplate</a>!
        </p>
        <p>
          If you are learning how to build a SaaS web app, check out our 2 books:
           <a href="https://builderbook.org" target="blank">Builder Book</a>
           and
           <a href="https://builderbook.org/book" target="blank">SaaS Boilerplate</a>.
        </p>
        <p>
          Also check out
          <a href="https://async-await.com" target="blank"> Async</a>
          , our communication tool for small teams of software developers.
        </p>
        Kelly & Timur, Team Async
      `,
    },
    {
      name: 'login',
      subject: 'Login link for saas-app.async-await.com',
      message: `
        <p>Log into your account by clicking on this link: <a href="<%= loginURL %>"><%= loginURL %></a>.</p>`,
    },
    {
      name: 'invitation',
      subject: 'You are invited to join a team at saas-app.async-await.com',
      message: `You've been invited to join <b><%= teamName%></b>.
        <br/>Click here to accept the invitation: <%= invitationURL%>
      `,
    },
    {
      name: 'newPost',
      subject: 'New Post was created in Discussion: <%= discussionName %>',
      message: `<p>New Post in Discussion: "<%= discussionName%>" by <%= authorName%></p>
        New Post: "<%= postContent %>"
        <p>---</p>
        <p>View it at <a href="<%= discussionLink %>"><%= discussionLink %></a>.</p>
      `,
    },
  ];

  for (const t of templates) {
    const et = await EmailTemplate.findOne({ name: t.name }).setOptions({ lean: true });
    const message = t.message.replace(/\n/g, '').replace(/[ ]+/g, ' ').trim();

    if (!et) {
      EmailTemplate.create(Object.assign({}, t, { message }));
    } else if (et.subject !== t.subject || et.message !== message) {
      EmailTemplate.updateOne({ _id: et._id }, { $set: { message, subject: t.subject } }).exec();
    }
  }
}

export default async function getEmailTemplate(name: string, params: any) {
  await insertTemplates();

  const et = await EmailTemplate.findOne({ name }).setOptions({ lean: true });

  if (!et) {
    throw new Error('Email Template is not found in database.');
  }

  return {
    message: _.template(et.message)(params),
    subject: _.template(et.subject)(params),
  };
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\server\models\Invitation.ts -----

import * as mongoose from 'mongoose';

import sendEmail from '../aws-ses';
import getEmailTemplate from './EmailTemplate';
import Team from './Team';
import User, { UserDocument } from './User';

const mongoSchema = new mongoose.Schema({
  teamId: {
    type: String,
    required: true,
  },
  email: {
    type: String,
    required: true,
  },
  createdAt: {
    type: Date,
    required: true,
    default: Date.now,
    expires: 60 * 60 * 24, // delete doc after 24 hours
  },
  token: {
    type: String,
    required: true,
    unique: true,
  },
});

mongoSchema.index({ teamId: 1, email: 1 }, { unique: true });

interface InvitationDocument extends mongoose.Document {
  teamId: string;
  email: string;
  createdAt: Date;
  token: string;
}

interface InvitationModel extends mongoose.Model<InvitationDocument> {
  add({
    userId,
    teamId,
    email,
  }: {
    userId: string;
    teamId: string;
    email: string;
  }): InvitationDocument;

  getTeamInvitations({ userId, teamId }: { userId: string; teamId: string });
  getTeamByToken({ token }: { token: string });
  addUserToTeam({ token, user }: { token: string; user: UserDocument });
}

function generateToken() {
  const gen = () =>
    Math.random().toString(36).substring(2, 12) + Math.random().toString(36).substring(2, 12);

  return `${gen()}`;
}

class InvitationClass extends mongoose.Model {
  public static async add({ userId, teamId, email }) {
    if (!teamId || !email) {
      throw new Error('Bad data');
    }

    const team = await Team.findById(teamId).setOptions({ lean: true });
    if (!team || team.teamLeaderId !== userId) {
      throw new Error('Team does not exist or you have no permission');
    }

    const registeredUser = await User.findOne({ email }).setOptions({ lean: true });

    if (registeredUser && team.memberIds.includes(registeredUser._id.toString())) {
      throw new Error('This user is already Team Member.');
    }

    let token;
    const invitation = await this.findOne({ teamId, email })
      .select('token')
      .setOptions({ lean: true });

    if (invitation) {
      token = invitation.token;
    } else {
      token = generateToken();
      while ((await this.countDocuments({ token })) > 0) {
        token = generateToken();
      }

      await this.create({
        teamId,
        email,
        token,
      });
    }

    const emailTemplate = await getEmailTemplate('invitation', {
      teamName: team.name,
      invitationURL: `${process.env.URL_APP}/invitation?token=${token}`,
    });

    if (!emailTemplate) {
      throw new Error('Invitation email template not found');
    }

    try {
      await sendEmail({
        from: `Kelly from saas-app.async-await.com <${process.env.EMAIL_SUPPORT_FROM_ADDRESS}>`,
        to: [email],
        subject: emailTemplate.subject,
        body: emailTemplate.message,
      });
    } catch (err) {
      console.log('Email sending error:', err);
    }

    return await this.findOne({ teamId, email }).setOptions({ lean: true });
  }

  public static async getTeamInvitations({ userId, teamId }) {
    const team = await Team.findOne({ _id: teamId })
      .select('teamLeaderId')
      .setOptions({ lean: true });

    if (userId !== team.teamLeaderId) {
      throw new Error('You have no permission.');
    }

    return this.find({ teamId }).select('email').setOptions({ lean: true });
  }

  public static async getTeamByToken({ token }) {
    if (!token) {
      throw new Error('Bad data');
    }

    const invitation = await this.findOne({ token }).setOptions({ lean: true });

    if (!invitation) {
      throw new Error('Invitation not found');
    }

    const team = await Team.findById(invitation.teamId)
      .select('name slug avatarUrl memberIds')
      .setOptions({ lean: true });

    if (!team) {
      throw new Error('Team does not exist');
    }

    return team;
  }

  public static async addUserToTeam({ token, user }) {
    if (!token || !user) {
      throw new Error('Bad data');
    }

    const invitation = await this.findOne({ token }).setOptions({ lean: true });

    if (!invitation || invitation.email !== user.email) {
      throw new Error('Invitation not found');
    }

    await this.deleteOne({ token });

    const team = await Team.findById(invitation.teamId)
      .select('memberIds slug teamLeaderId')
      .setOptions({ lean: true });

    if (!team) {
      throw new Error('Team does not exist');
    }

    if (team && !team.memberIds.includes(user._id)) {
      await Team.updateOne({ _id: team._id }, { $addToSet: { memberIds: user._id } });

      if (user._id !== team.teamLeaderId) {
        await User.findByIdAndUpdate(user._id, { $set: { defaultTeamSlug: team.slug } });
      }
    }

    return team.slug;
  }
}

mongoSchema.loadClass(InvitationClass);

const Invitation = mongoose.model<InvitationDocument, InvitationModel>('Invitation', mongoSchema);

export default Invitation;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\server\models\Post.ts -----

import * as mongoose from "mongoose";

import * as he from "he";
import hljs from "highlight.js";
import { marked } from "marked";

import Discussion from "./Discussion";
import Team from "./Team";

const mongoSchema = new mongoose.Schema({
  createdUserId: {
    type: String,
    required: true,
  },
  discussionId: {
    type: String,
    required: true,
  },
  content: {
    type: String,
    required: true,
  },
  htmlContent: {
    type: String,
    required: true,
  },
  isEdited: {
    type: Boolean,
    default: false,
  },
  lastUpdatedAt: Date,
  createdAt: {
    type: Date,
    required: true,
  },
});

function markdownToHtml(content) {
  const renderer = new marked.Renderer();

  renderer.link = ({ href, title, text }) => {
    const t = title ? ` title="${title}"` : "";

    if (text.startsWith("<code>@#")) {
      return `${text.replace("<code>@#", "<code>@")} `;
    }

    return `
      <a target="_blank" href="${href}" rel="noopener noreferrer"${t}>
        ${text}
      </a>
    `;
  };

  renderer.code = ({ text, lang }) => {
    const language = hljs.getLanguage(lang) ? lang : "plaintext";

    return `<pre><code class="hljs language-${lang}">${hljs.highlight(text, { language }).value}</code></pre>`;
  };

  marked.setOptions({
    renderer,
    breaks: true,
  });

  return marked(he.decode(content));
}

export interface PostDocument extends mongoose.Document {
  createdUserId: string;
  discussionId: string;
  content: string;
  isEdited: boolean;
  lastUpdatedAt: Date;
  createdAt: Date;
}

interface PostModel extends mongoose.Model<PostDocument> {
  getList({ userId, discussionId }: { userId: string; discussionId: string }): Promise<PostDocument[]>;

  add({
    content,
    userId,
    discussionId,
  }: {
    content: string;
    userId: string;
    discussionId: string;
  }): Promise<PostDocument>;

  edit({ content, userId, id }: { content: string; userId: string; id: string }): Promise<PostDocument>;

  delete({ userId, id }: { userId: string; id: string }): Promise<void>;

  checkPermissionAndGetTeamAndDiscussion({
    userId,
    discussionId,
    post,
  }: {
    userId: string;
    discussionId: string;
    post: PostDocument;
  }): Promise<{ TeamDocument; DiscussionDocument }>;
}

class PostClass extends mongoose.Model {
  public static async getList({ userId, discussionId }) {
    await this.checkPermissionAndGetTeamAndDiscussion({ userId, discussionId });

    const filter: any = { discussionId };

    const posts: any[] = await this.find(filter).sort({ createdAt: 1 }).setOptions({ lean: true });

    return posts;
  }

  public static async add({ content, userId, discussionId }) {
    if (!content) {
      throw new Error("Bad data");
    }

    await this.checkPermissionAndGetTeamAndDiscussion({ userId, discussionId });

    const htmlContent = markdownToHtml(content);

    const post = await this.create({
      createdUserId: userId,
      discussionId,
      content,
      htmlContent,
      createdAt: new Date(),
    });

    return post;
  }

  public static async edit({ content, userId, id }) {
    if (!content || !id) {
      throw new Error("Bad data");
    }

    const post = await this.findById(id).select("createdUserId discussionId").setOptions({ lean: true });

    await this.checkPermissionAndGetTeamAndDiscussion({
      userId,
      discussionId: post.discussionId,
      post,
    });

    const htmlContent = markdownToHtml(content);

    const updatedObj = await this.findOneAndUpdate(
      { _id: id },
      { content, htmlContent, isEdited: true, lastUpdatedAt: new Date() },
      { runValidators: true, new: true }
    );

    return updatedObj;
  }

  public static async delete({ userId, id }) {
    if (!id) {
      throw new Error("Bad data");
    }

    const post = await this.findById(id).select("createdUserId discussionId content").setOptions({ lean: true });

    await this.checkPermissionAndGetTeamAndDiscussion({
      userId,
      discussionId: post.discussionId,
      post,
    });

    await this.deleteOne({ _id: id });
  }

  private static async checkPermissionAndGetTeamAndDiscussion({ userId, discussionId, post = null }) {
    if (!userId || !discussionId) {
      throw new Error("Bad data");
    }

    if (post && post.createdUserId !== userId) {
      throw new Error("Permission denied");
    }

    const discussion = await Discussion.findById(discussionId)
      .select("teamId memberIds slug")
      .setOptions({ lean: true });

    if (!discussion) {
      throw new Error("Discussion not found");
    }

    if (discussion.memberIds.indexOf(userId) === -1) {
      throw new Error("Permission denied");
    }

    const team = await Team.findById(discussion.teamId).select("memberIds slug").setOptions({ lean: true });

    if (!team || team.memberIds.indexOf(userId) === -1) {
      throw new Error("Team not found");
    }

    return { team, discussion };
  }
}

mongoSchema.loadClass(PostClass);

const Post = mongoose.model<PostDocument, PostModel>("Post", mongoSchema);

export default Post;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\server\models\Team.ts -----

import * as mongoose from 'mongoose';
import Stripe from 'stripe';

import { cancelSubscription } from '../stripe';
import { generateNumberSlug } from '../utils/slugify';
import User from './User';

const mongoSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
  },
  slug: {
    type: String,
    required: true,
    unique: true,
  },
  avatarUrl: String,
  createdAt: {
    type: Date,
    required: true,
  },
  teamLeaderId: {
    type: String,
    required: true,
  },
  memberIds: [
    {
      type: String,
      required: true,
    },
  ],
  defaultTeam: {
    type: Boolean,
    default: false,
  },
  stripeSubscription: {
    id: String,
    object: String,
    application_fee_percent: Number,
    billing: String,
    cancel_at_period_end: Boolean,
    billing_cycle_anchor: Number,
    canceled_at: Number,
    created: Number,
  },
  isSubscriptionActive: {
    type: Boolean,
    default: false,
  },
  isPaymentFailed: {
    type: Boolean,
    default: false,
  },
});

export interface TeamDocument extends mongoose.Document {
  name: string;
  slug: string;
  avatarUrl: string;
  createdAt: Date;

  teamLeaderId: string;
  memberIds: string[];
  defaultTeam: boolean;

  stripeSubscription: {
    id: string;
    object: string;
    application_fee_percent: number;
    billing: string;
    cancel_at_period_end: boolean;
    billing_cycle_anchor: number;
    canceled_at: number;
    created: number;
  };
  isSubscriptionActive: boolean;
  isPaymentFailed: boolean;
}

interface TeamModel extends mongoose.Model<TeamDocument> {
  addTeam({
    name,
    userId,
  }: {
    userId: string;
    name: string;
    avatarUrl: string;
  }): Promise<TeamDocument>;

  updateTeam({
    userId,
    teamId,
    name,
    avatarUrl,
  }: {
    userId: string;
    teamId: string;
    name: string;
    avatarUrl: string;
  }): Promise<TeamDocument>;

  getAllTeamsForUser(userId: string): Promise<TeamDocument[]>;

  removeMember({
    teamId,
    teamLeaderId,
    userId,
  }: {
    teamId: string;
    teamLeaderId: string;
    userId: string;
  }): Promise<void>;

  subscribeTeam({
    session,
    team,
  }: {
    session: Stripe.Checkout.Session;
    team: TeamDocument;
  }): Promise<void>;

  cancelSubscription({
    teamLeaderId,
    teamId,
  }: {
    teamLeaderId: string;
    teamId: string;
  }): Promise<TeamDocument>;

  cancelSubscriptionAfterFailedPayment({
    subscriptionId,
  }: {
    subscriptionId: string;
  }): Promise<TeamDocument>;
}

class TeamClass extends mongoose.Model {
  public static async addTeam({ userId, name, avatarUrl }) {
    console.log(`Static method: ${name}, ${avatarUrl}`);

    if (!userId || !name || !avatarUrl) {
      throw new Error('Bad data');
    }

    const slug = await generateNumberSlug(this);

    let defaultTeam = false;
    if ((await this.countDocuments({ teamLeaderId: userId })) === 0) {
      await User.findByIdAndUpdate(userId, { $set: { defaultTeamSlug: slug } });
      defaultTeam = true;
    }

    const team = await this.create({
      teamLeaderId: userId,
      name,
      slug,
      avatarUrl,
      memberIds: [userId],
      createdAt: new Date(),
      defaultTeam,
    });

    return team;
  }

  public static async updateTeam({ userId, teamId, name, avatarUrl }) {
    const team = await this.findById(teamId, 'name teamLeaderId');

    if (!team) {
      throw new Error('Team not found');
    }

    if (team.teamLeaderId !== userId) {
      throw new Error('Permission denied');
    }

    const modifier = { name: team.name, avatarUrl };

    if (name !== team.name) {
      modifier.name = name;
    }

    await this.updateOne({ _id: teamId }, { $set: modifier }, { runValidators: true });

    return this.findById(teamId, 'name avatarUrl slug defaultTeam').setOptions({ lean: true });
  }

  public static getAllTeamsForUser(userId: string) {
    console.log(`userId:${userId}`);
    return this.find({ memberIds: userId }).setOptions({ lean: true });
  }

  public static async removeMember({ teamId, teamLeaderId, userId }) {
    const team = await this.findById(teamId).select('memberIds teamLeaderId');

    if (!team) {
      throw new Error('Team does not exist');
    }

    if (team.teamLeaderId !== teamLeaderId || teamLeaderId === userId) {
      throw new Error('Permission denied');
    }

    await this.findByIdAndUpdate(teamId, { $pull: { memberIds: userId } });
  }

  public static async subscribeTeam({
    session,
    team,
  }: {
    session: Stripe.Checkout.Session;
    team: TeamDocument;
  }) {
    if (!session.subscription) {
      throw new Error('Not subscribed');
    }

    if (!team) {
      throw new Error('User not found.');
    }

    if (team.isSubscriptionActive) {
      throw new Error('Team is already subscribed.');
    }

    const stripeSubscription = session.subscription as Stripe.Subscription;
    if (stripeSubscription.canceled_at) {
      throw new Error('Unsubscribed');
    }

    await this.updateOne({ _id: team._id }, { stripeSubscription, isSubscriptionActive: true });
  }

  public static async cancelSubscription({ teamLeaderId, teamId }) {
    const team = await this.findById(teamId).select(
      'teamLeaderId isSubscriptionActive stripeSubscription',
    );

    if (team.teamLeaderId !== teamLeaderId) {
      throw new Error('You do not have permission to subscribe Team.');
    }

    if (!team.isSubscriptionActive) {
      throw new Error('Team is already unsubscribed.');
    }

    const cancelledSubscriptionObj = await cancelSubscription({
      subscriptionId: team.stripeSubscription.id,
    });

    return this.findByIdAndUpdate(
      teamId,
      {
        stripeSubscription: cancelledSubscriptionObj,
        isSubscriptionActive: false,
      },
      { new: true, runValidators: true },
    )
      .select('isSubscriptionActive stripeSubscription')
      .setOptions({ lean: true });
  }

  public static async cancelSubscriptionAfterFailedPayment({ subscriptionId }) {
    const team: any = await this.find({ 'stripeSubscription.id': subscriptionId })
      .select('teamLeaderId isSubscriptionActive stripeSubscription isPaymentFailed')
      .setOptions({ lean: true });
    if (!team.isSubscriptionActive) {
      throw new Error('Team is already unsubscribed.');
    }
    if (team.isPaymentFailed) {
      throw new Error('Team is already unsubscribed after failed payment.');
    }
    const cancelledSubscriptionObj = await cancelSubscription({
      subscriptionId,
    });
    return this.findByIdAndUpdate(
      team._id,
      {
        stripeSubscription: cancelledSubscriptionObj,
        isSubscriptionActive: false,
        isPaymentFailed: true,
      },
      { new: true, runValidators: true },
    )
      .select('isSubscriptionActive stripeSubscription isPaymentFailed')
      .setOptions({ lean: true });
  }
}

mongoSchema.loadClass(TeamClass);

const Team = mongoose.model<TeamDocument, TeamModel>('Team', mongoSchema);

export default Team;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\server\models\User.ts -----

import * as _ from 'lodash';
import * as mongoose from 'mongoose';
import Stripe from 'stripe';

import sendEmail from '../aws-ses';
import { addToMailchimp } from '../mailchimp';
import { generateSlug } from '../utils/slugify';
import getEmailTemplate from './EmailTemplate';
import Team, { TeamDocument } from './Team';

import { getListOfInvoices } from '../stripe';

const mongoSchema = new mongoose.Schema({
  slug: {
    type: String,
    required: true,
    unique: true,
  },
  createdAt: {
    type: Date,
    required: true,
  },
  email: {
    type: String,
    required: true,
    unique: true,
  },
  displayName: String,
  avatarUrl: String,
  googleId: {
    type: String,
    unique: true,
    sparse: true,
  },
  googleToken: {
    accessToken: String,
    refreshToken: String,
  },
  isSignedupViaGoogle: {
    type: Boolean,
    required: true,
    default: false,
  },
  darkTheme: Boolean,
  defaultTeamSlug: {
    type: String,
    default: '',
  },
  stripeCustomer: {
    id: String,
    object: String,
    created: Number,
    currency: String,
    default_source: String,
    description: String,
  },
  stripeCard: {
    id: String,
    object: String,
    brand: String,
    funding: String,
    country: String,
    last4: String,
    exp_month: Number,
    exp_year: Number,
  },
  hasCardInformation: {
    type: Boolean,
    default: false,
  },
  stripeListOfInvoices: {
    object: String,
    has_more: Boolean,
    data: [
      {
        id: String,
        object: String,
        amount_paid: Number,
        created: Number,
        customer: String,
        subscription: String,
        hosted_invoice_url: String,
        billing: String,
        paid: Boolean,
        number: String,
        teamId: String,
        teamName: String,
      },
    ],
  },
});

export interface UserDocument extends mongoose.Document {
  slug: string;
  createdAt: Date;
  email: string;
  displayName: string;
  avatarUrl: string;
  googleId: string;
  googleToken: { accessToken: string; refreshToken: string };
  isSignedupViaGoogle: boolean;
  darkTheme: boolean;
  defaultTeamSlug: string;
  stripeCustomer: {
    id: string;
    default_source: string;
    created: number;
    object: string;
    description: string;
  };
  stripeCard: {
    id: string;
    object: string;
    brand: string;
    country: string;
    last4: string;
    exp_month: number;
    exp_year: number;
    funding: string;
  };
  hasCardInformation: boolean;
  stripeListOfInvoices: {
    object: string;
    has_more: boolean;
    data: [
      {
        id: string;
        object: string;
        amount_paid: number;
        date: number;
        customer: string;
        subscription: string;
        hosted_invoice_url: string;
        billing: string;
        paid: boolean;
        number: string;
        teamId: string;
        teamName: string;
      },
    ];
  };
}

interface UserModel extends mongoose.Model<UserDocument> {
  getUserBySlug({ slug }: { slug: string }): Promise<UserDocument>;

  updateProfile({
    userId,
    name,
    avatarUrl,
  }: {
    userId: string;
    name: string;
    avatarUrl: string;
  }): Promise<UserDocument[]>;

  publicFields(): string[];

  signInOrSignUpViaGoogle({
    googleId,
    email,
    displayName,
    avatarUrl,
    googleToken,
  }: {
    googleId: string;
    email: string;
    displayName: string;
    avatarUrl: string;
    googleToken: { accessToken?: string; refreshToken?: string };
  }): Promise<UserDocument>;

  signInOrSignUpByPasswordless({
    uid,
    email,
  }: {
    uid: string;
    email: string;
  }): Promise<UserDocument>;

  toggleTheme({ userId, darkTheme }: { userId: string; darkTheme: boolean }): Promise<void>;

  getMembersForTeam({
    userId,
    teamId,
  }: {
    userId: string;
    teamId: string;
  }): Promise<UserDocument[]>;

  checkPermissionAndGetTeam({
    userId,
    teamId,
  }: {
    userId: string;
    teamId: string;
  }): Promise<TeamDocument>;

  saveStripeCustomerAndCard({
    user,
    session,
  }: {
    session: Stripe.Checkout.Session;
    user: UserDocument;
  }): Promise<void>;

  changeStripeCard({
    session,
    user,
  }: {
    session: Stripe.Checkout.Session;
    user: UserDocument;
  }): Promise<void>;

  getListOfInvoicesForCustomer({ userId }: { userId: string }): Promise<UserDocument>;
}

class UserClass extends mongoose.Model {
  public static async getUserBySlug({ slug }) {
    console.log('Static method: getUserBySlug');

    return this.findOne({ slug }, 'email displayName avatarUrl').setOptions({ lean: true });
  }

  public static async updateProfile({ userId, name, avatarUrl }) {
    console.log('Static method: updateProfile');

    const user = await this.findById(userId, 'slug displayName');

    const modifier = { displayName: user.displayName, avatarUrl, slug: user.slug };

    console.log(user.slug);

    if (name !== user.displayName) {
      modifier.displayName = name;
      modifier.slug = await generateSlug(this, name);
    }

    return this.findByIdAndUpdate(userId, { $set: modifier }, { new: true, runValidators: true })
      .select('displayName avatarUrl slug')
      .setOptions({ lean: true });
  }

  public static publicFields(): string[] {
    return [
      '_id',
      'id',
      'displayName',
      'email',
      'avatarUrl',
      'slug',
      'isSignedupViaGoogle',
      'darkTheme',
      'defaultTeamSlug',
      'stripeCard',
      'hasCardInformation',
      'stripeListOfInvoices',
    ];
  }

  public static async signInOrSignUpViaGoogle({
    googleId,
    email,
    displayName,
    avatarUrl,
    googleToken,
  }) {
    const user = await this.findOne({ email })
      .select([...this.publicFields(), 'googleId'].join(' '))
      .setOptions({ lean: true });

    if (user) {
      if (_.isEmpty(googleToken) && user.googleId) {
        return user;
      }

      const modifier = { googleId };
      if (googleToken.accessToken) {
        modifier['googleToken.accessToken'] = googleToken.accessToken;
      }

      if (googleToken.refreshToken) {
        modifier['googleToken.refreshToken'] = googleToken.refreshToken;
      }

      await this.updateOne({ email }, { $set: modifier });

      return user;
    }

    const slug = await generateSlug(this, displayName);

    const newUser = await this.create({
      createdAt: new Date(),
      googleId,
      email,
      googleToken,
      displayName,
      avatarUrl,
      slug,
      isSignedupViaGoogle: true,
      defaultTeamSlug: '',
      darkTheme: false,
    });

    const emailTemplate = await getEmailTemplate('welcome', { userName: displayName });

    if (!emailTemplate) {
      throw new Error('Welcome email template not found');
    }

    try {
      await sendEmail({
        from: `Kelly from saas-app.async-await.com <${process.env.EMAIL_SUPPORT_FROM_ADDRESS}>`,
        to: [email],
        subject: emailTemplate.subject,
        body: emailTemplate.message,
      });
    } catch (err) {
      console.error('Email sending error:', err);
    }

    try {
      await addToMailchimp({ email, listName: 'signups' });
    } catch (error) {
      console.error('Mailchimp error:', error);
    }

    return _.pick(newUser, this.publicFields());
  }

  public static async signInOrSignUpByPasswordless({ uid, email }) {
    const user = await this.findOne({ email })
      .select(this.publicFields().join(' '))
      .setOptions({ lean: true });

    if (user) {
      throw Error('User already exists');
    }

    const slug = await generateSlug(this, email);

    const newUser = await this.create({
      _id: uid,
      createdAt: new Date(),
      email,
      slug,
      defaultTeamSlug: '',
    });

    const emailTemplate = await getEmailTemplate('welcome', { userName: email });

    if (!emailTemplate) {
      throw new Error('Email template "welcome" not found in database.');
    }

    try {
      await sendEmail({
        from: `Kelly from saas-app.async-await.com <${process.env.EMAIL_SUPPORT_FROM_ADDRESS}>`,
        to: [email],
        subject: emailTemplate.subject,
        body: emailTemplate.message,
      });
    } catch (err) {
      console.error('Email sending error:', err);
    }

    try {
      await addToMailchimp({ email, listName: 'signups' });
    } catch (error) {
      console.error('Mailchimp error:', error);
    }

    return _.pick(newUser, this.publicFields());
  }

  public static toggleTheme({ userId, darkTheme }) {
    return this.updateOne({ _id: userId }, { darkTheme: !!darkTheme });
  }

  public static async getMembersForTeam({ userId, teamId }) {
    const team = await this.checkPermissionAndGetTeam({ userId, teamId });

    return this.find({ _id: { $in: team.memberIds } })
      .select(this.publicFields().join(' '))
      .setOptions({ lean: true });
  }

  public static async saveStripeCustomerAndCard({
    user,
    session,
  }: {
    session: Stripe.Checkout.Session;
    user: UserDocument;
  }) {
    if (!user) {
      throw new Error('User not found.');
    }

    const stripeSubscription = session.subscription as Stripe.Subscription;

    const stripeCard =
      (stripeSubscription.default_payment_method &&
        (stripeSubscription.default_payment_method as Stripe.PaymentMethod).card) ||
      undefined;

    const hasCardInformation = !!stripeCard;

    await this.updateOne(
      { _id: user._id },
      {
        stripeCustomer: session.customer,
        stripeCard,
        hasCardInformation,
      },
    );
  }

  public static async changeStripeCard({
    session,
    user,
  }: {
    session: Stripe.Checkout.Session;
    user: UserDocument;
  }): Promise<void> {
    if (!user) {
      throw new Error('User not found.');
    }

    const si: Stripe.SetupIntent = session.setup_intent as Stripe.SetupIntent;
    const pm: Stripe.PaymentMethod = si.payment_method as Stripe.PaymentMethod;

    if (!pm.card) {
      throw new Error('No card found.');
    }
    await this.updateOne({ _id: user._id }, { stripeCard: pm.card, hasCardInformation: true });
  }

  public static async getListOfInvoicesForCustomer({ userId }) {
    const user = await this.findById(userId, 'stripeCustomer');

    if (!user.stripeCustomer.id) {
      throw new Error('You are not a customer and you have no payment history.');
    }

    const newListOfInvoices = await getListOfInvoices({
      customerId: user.stripeCustomer.id,
    });

    if (newListOfInvoices.data === undefined || newListOfInvoices.data.length === 0) {
      throw new Error('You are a customer. But there is no payment history.');
    }

    const modifier = {
      stripeListOfInvoices: newListOfInvoices,
    };

    return this.findByIdAndUpdate(userId, { $set: modifier }, { new: true, runValidators: true })
      .select('stripeListOfInvoices')
      .setOptions({ lean: true });
  }

  private static async checkPermissionAndGetTeam({ userId, teamId }) {
    console.log(userId, teamId);

    if (!userId || !teamId) {
      throw new Error('Bad data');
    }

    const team = await Team.findById(teamId).select('memberIds').setOptions({ lean: true });

    if (!team || team.memberIds.indexOf(userId) === -1) {
      throw new Error('Team not found');
    }

    return team;
  }
}

mongoSchema.loadClass(UserClass);

const User = mongoose.model<UserDocument, UserModel>('User', mongoSchema);

export default User;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\server\utils\slugify.ts -----

import * as _ from 'lodash';

const slugify = (text) => _.kebabCase(text);

async function createUniqueSlug(Model, slug, count, filter) {
  const obj = await Model.findOne({ slug: `${slug}-${count}`, ...filter })
    .select('_id')
    .setOptions({ lean: true });

  if (!obj) {
    return `${slug}-${count}`;
  }

  return createUniqueSlug(Model, slug, count + 1, filter);
}

async function generateSlug(Model, name, filter = {}) {
  const origSlug = slugify(name);

  const obj = await Model.findOne({ slug: origSlug, ...filter })
    .select('_id')
    .setOptions({ lean: true });

  if (!obj) {
    return origSlug;
  }

  return createUniqueSlug(Model, origSlug, 1, filter);
}

async function generateNumberSlug(Model, filter = {}, n = 1) {
  const obj = await Model.findOne({ slug: n, ...filter })
    .select('_id')
    .setOptions({ lean: true });

  if (!obj) {
    return `${n}`;
  }

  return generateNumberSlug(Model, filter, ++n);
}

export { generateSlug, generateNumberSlug };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\server\utils\sum.ts -----

function sum(a, b) {
  return a + b;
}

export { sum };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\server\aws-s3.ts -----

import * as url from 'url';
import * as aws from 'aws-sdk';

async function signRequestForUpload({ fileName, fileType, prefix, bucket }) {
  const randomStringForPrefix =
    Math.random().toString(36).substring(2, 12) + Math.random().toString(36).substring(2, 12);

  const key = `${prefix}/${randomStringForPrefix}/${fileName}`;

  const acl = 'public-read';

  const params = {
    Bucket: bucket,
    Key: key,
    Expires: 60,
    ContentType: fileType,
    ACL: acl,
  };

  console.log(key, bucket);

  const s3 = new aws.S3({
    apiVersion: 'latest',
    region: process.env.AWS_REGION,
    accessKeyId: process.env.AWS_ACCESSKEYID,
    secretAccessKey: process.env.AWS_SECRETACCESSKEY,
  });

  return new Promise((resolve, reject) => {
    s3.getSignedUrl('putObject', params, (err, data) => {
      const parsedUrl = url.parse(data);

      const returnData = {
        signedRequest: data,
        url: `${parsedUrl.protocol}//${parsedUrl.hostname}${parsedUrl.pathname}`,
      };

      console.log(returnData);

      if (err) {
        console.error(err);
        reject(err);
      } else {
        resolve(returnData);
      }
    });
  });
}

export { signRequestForUpload };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\server\aws-ses.ts -----

import * as aws from 'aws-sdk';

export default function sendEmail(options) {
  const ses = new aws.SES({
    apiVersion: 'latest',
    region: process.env.AWS_REGION,
    accessKeyId: process.env.AWS_ACCESSKEYID,
    secretAccessKey: process.env.AWS_SECRETACCESSKEY,
  });

  return new Promise((resolve, reject) => {
    ses.sendEmail(
      {
        Source: options.from,
        Destination: {
          CcAddresses: options.cc,
          ToAddresses: options.to,
        },
        Message: {
          Subject: {
            Data: options.subject,
          },
          Body: {
            Html: {
              Data: options.body,
            },
          },
        },
        ReplyToAddresses: options.replyTo,
      },
      (err, info) => {
        if (err) {
          reject(err);
        } else {
          resolve(info);
        }
      },
    );
  });
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\server\google-auth.ts -----

import * as passport from 'passport';
import { OAuth2Strategy as Strategy } from 'passport-google-oauth';

import User, { UserDocument } from './models/User';
import Invitation from './models/Invitation';

function setupGoogle({ server }) {
  if (!process.env.GOOGLE_CLIENTID) {
    return;
  }

  const verify = async (req, accessToken, refreshToken, profile, done) => {
    let email;
    let avatarUrl;

    if (profile.emails) {
      email = profile.emails[0].value;
    }

    if (profile.photos && profile.photos.length > 0) {
      avatarUrl = profile.photos[0].value.replace('sz=50', 'sz=128');
    }

    try {
      const user = await User.signInOrSignUpViaGoogle({
        googleId: profile.id,
        email,
        googleToken: { accessToken, refreshToken },
        displayName: profile.displayName,
        avatarUrl,
      });

      let teamSlugOfInvitedTeam;
      if (user && req.session.invitationToken) {
        teamSlugOfInvitedTeam = await Invitation.addUserToTeam({
          token: req.session.invitationToken,
          user,
        }).catch((err) => console.error(err));
      }

      user.defaultTeamSlug = teamSlugOfInvitedTeam ? teamSlugOfInvitedTeam : user.defaultTeamSlug;

      done(null, user);
    } catch (err) {
      done(err);
      console.error(err);
    }
  };

  passport.use(
    new Strategy(
      {
        clientID: process.env.GOOGLE_CLIENTID,
        clientSecret: process.env.GOOGLE_CLIENTSECRET,
        callbackURL: `${process.env.URL_API}/oauth2callback`,
        passReqToCallback: true,
      },
      verify,
    ),
  );

  passport.serializeUser((user: UserDocument, done) => {
    done(null, user._id);
  });

  passport.deserializeUser((id, done) => {
    User.findById(id, User.publicFields())
      .then((user) => {
        done(null, user);
      })
      .catch((error) => {
        done(error, null);
      });
  });

  server.use(passport.initialize());
  server.use(passport.session());

  server.get('/auth/google', (req, res, next) => {
    const options = {
      scope: ['profile', 'email'],
      prompt: 'select_account',
    };

    if (req.query && req.query.invitationToken) {
      req.session.invitationToken = req.query.invitationToken;
    } else {
      req.session.invitationToken = null;
    }

    passport.authenticate('google', options)(req, res, next);
  });

  server.get(
    '/oauth2callback',
    passport.authenticate('google', {
      failureRedirect: '/login',
    }),
    async (req, res) => {
      let teamSlugOfInvitedTeam;

      if (req.user && req.session.invitationToken) {
        teamSlugOfInvitedTeam = await Invitation.addUserToTeam({
          token: req.session.invitationToken,
          user: req.user,
        }).catch((err) => console.error(err));

        req.session.invitationToken = null;
      }

      let redirectUrlAfterLogin;
      const defaultTeamSlug = req.user && req.user.defaultTeamSlug;

      if (teamSlugOfInvitedTeam || defaultTeamSlug) {
        redirectUrlAfterLogin = `/your-settings`;
      } else {
        redirectUrlAfterLogin = `/create-team`;
      }

      res.redirect(`${process.env.URL_APP}${redirectUrlAfterLogin}`);
    },
  );
}

export { setupGoogle };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\server\mailchimp.ts -----

import fetch, { Response } from 'node-fetch';

// eslint-disable-next-line
require('dotenv').config();

const LIST_IDS = {
  signups: process.env.MAILCHIMP_SAAS_ALL_LIST_ID,
};

function callAPI({ path, method, data }): Promise<Response> {
  const ROOT_URI = `https://${process.env.MAILCHIMP_REGION}.api.mailchimp.com/3.0`;

  return fetch(`${ROOT_URI}${path}`, {
    method,
    headers: {
      Accept: 'application/json',
      Authorization: `Basic ${Buffer.from(`apikey:${process.env.MAILCHIMP_API_KEY}`).toString(
        'base64',
      )}`,
    },
    body: JSON.stringify(data),
  });
}

async function addToMailchimp({ email, listName }) {
  const data = {
    // eslint-disable-next-line
    email_address: email,
    status: 'subscribed',
  };

  const path = `/lists/${LIST_IDS[listName]}/members/`;

  await callAPI({ path, method: 'POST', data });
}

export { addToMailchimp };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\server\passwordless-auth.ts -----

import * as passwordless from 'passwordless';

import sendEmail from './aws-ses';
import getEmailTemplate from './models/EmailTemplate';
import User from './models/User';
import PasswordlessMongoStore from './passwordless-token-mongostore';
import Invitation from './models/Invitation';

function setupPasswordless({ server }) {
  const mongoStore = new PasswordlessMongoStore();

  passwordless.addDelivery(async (tokenToSend, uidToSend, recipient, callback) => {
    try {
      const template = await getEmailTemplate('login', {
        loginURL: `${
          process.env.URL_API
        }/auth/logged_in?token=${tokenToSend}&uid=${encodeURIComponent(uidToSend)}`,
      });

      await sendEmail({
        from: `Kelly from saas-app.async-await.com <${process.env.EMAIL_SUPPORT_FROM_ADDRESS}>`,
        to: [recipient],
        subject: template.subject,
        body: template.message,
      });

      callback();
    } catch (err) {
      console.error('Email sending error:', err);
      callback(err);
    }
  });

  passwordless.init(mongoStore);
  server.use(passwordless.sessionSupport());

  server.use((req, __, next) => {
    if (req.user && typeof req.user === 'string') {
      User.findById(req.user, User.publicFields())
        .then((user) => {
          req.user = user;
          console.log('passwordless middleware');
          next();
        })
        .catch((err) => {
          next(err);
        });
    } else {
      next();
    }
  });

  server.post(
    '/auth/email-login-link',
    passwordless.requestToken(async (email, __, callback) => {
      try {
        const user = await User.findOne({ email }).select('_id').setOptions({ lean: true });

        if (user) {
          callback(null, user._id);
        } else {
          const id = await mongoStore.storeOrUpdateByEmail(email);
          callback(null, id);
        }
      } catch (error) {
        callback(error, null);
      }
    }),
    (req, res) => {
      if (req.query && req.query.invitationToken) {
        req.session.invitationToken = req.query.invitationToken;
      } else {
        req.session.invitationToken = null;
      }

      res.json({ done: 1 });
    },
  );

  server.get(
    '/auth/logged_in',
    passwordless.acceptToken(),
    (req, __, next) => {
      User.findById(req.user, User.publicFields())
        .then((user) => {
          req.user = user;
          next();
        })
        .catch((err) => {
          next(err);
        });
    },
    async (req, res) => {
      let teamSlugOfInvitedTeam;

      if (req.user && req.session.invitationToken) {
        teamSlugOfInvitedTeam = await Invitation.addUserToTeam({
          token: req.session.invitationToken,
          user: req.user,
        }).catch((err) => console.error(err));

        req.session.invitationToken = null;
      }

      let redirectUrlAfterLogin;
      const defaultTeamSlug = req.user && req.user.defaultTeamSlug;

      if (teamSlugOfInvitedTeam || defaultTeamSlug) {
        redirectUrlAfterLogin = `/your-settings`;
      } else {
        redirectUrlAfterLogin = `/create-team`;
      }

      res.redirect(`${process.env.URL_APP}${redirectUrlAfterLogin}`);
    },
  );

  server.get('/logout', (req, res, next) => {
    req.logout((err) => {
      if (err) {
        next(err);
      }

      if (req.query && req.query.invitationToken) {
        res.redirect(`${process.env.URL_APP}/invitation?token=${req.query.invitationToken}`);
      } else {
        res.redirect(`${process.env.URL_APP}/login`);
      }
    });
  });
}

export { setupPasswordless };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\server\passwordless-token-mongostore.ts -----

import * as bcrypt from 'bcrypt';
import * as mongoose from 'mongoose';
import * as TokenStore from 'passwordless-tokenstore';
import * as util from 'util';

import User from './models/User';

interface TokenDocument extends mongoose.Document {
  hashedToken: string;
  uid: string;
  ttl: Date;
  originUrl: string;
  email: string;
}

const mongoSchema = new mongoose.Schema({
  hashedToken: {
    type: String,
    required: true,
  },
  uid: {
    type: String,
    required: true,
    unique: true,
  },
  ttl: {
    type: Date,
    required: true,
    expires: 0,
  },
  originUrl: String,
  email: String,
});

const PasswordlessToken = mongoose.model<TokenDocument>(
  'PasswordlessToken',
  mongoSchema,
  'passwordless-token',
);

function MongoStore(options = {}) {
  TokenStore.call(this);

  this._options = options || {};
}

util.inherits(MongoStore, TokenStore);

MongoStore.prototype.authenticate = async function (token, uid, callback) {
  if (!token || !uid || !callback) {
    throw new Error('TokenStore:authenticate called with invalid parameters');
  }

  try {
    const tokenDoc = await PasswordlessToken.findOne({ uid, ttl: { $gt: new Date() } }).setOptions({
      lean: true,
    });

    if (tokenDoc) {
      const isMatch = await bcrypt.compare(token, tokenDoc.hashedToken);
      if (isMatch) {
        if (tokenDoc.email) {
          await User.signInOrSignUpByPasswordless({ uid, email: tokenDoc.email });
        }

        callback(null, true, tokenDoc.originUrl);
      } else {
        callback(null, false, null);
      }
    } else {
      callback(null, false, null);
    }
  } catch (error) {
    callback(error, false, null);
  }
};

MongoStore.prototype.storeOrUpdate = async function (token, uid, msToLive, originUrl, callback) {
  if (!token || !uid || !msToLive || !callback) {
    throw new Error('TokenStore:storeOrUpdate called with invalid parameters');
  }

  const saltRounds = 10;

  try {
    const hashedToken = await bcrypt.hash(token, saltRounds);
    const newRecord = { hashedToken, uid, ttl: new Date(Date.now() + msToLive), originUrl };

    await PasswordlessToken.updateOne(
      { uid },
      { $set: newRecord },
      { upsert: true, runValidators: true },
    );
    callback();
  } catch (error) {
    callback(error);
  }
};

MongoStore.prototype.invalidateUser = async function (uid, callback) {
  if (!uid || !callback) {
    throw new Error('TokenStore:invalidateUser called with invalid parameters');
  }

  try {
    await PasswordlessToken.deleteOne({ uid });
    callback();
  } catch (error) {
    callback(error);
  }
};

MongoStore.prototype.clear = async function (callback) {
  if (!callback) {
    throw new Error('TokenStore:clear called with invalid parameters');
  }

  try {
    await PasswordlessToken.deleteMany({});
    callback();
  } catch (error) {
    callback(error);
  }
};

MongoStore.prototype.length = function (callback) {
  PasswordlessToken.countDocuments(callback);
};

MongoStore.prototype.storeOrUpdateByEmail = async function addEmail(email: string) {
  if (!email) {
    throw new Error('TokenStore:addEmail called with invalid parameters');
  }

  const obj = await PasswordlessToken.findOne({ email }).select('uid').setOptions({ lean: true });

  if (obj) {
    return obj.uid;
  }

  const uid = new mongoose.Types.ObjectId().toHexString();
  await PasswordlessToken.updateOne({ uid }, { email }, { upsert: true });

  return uid;
};

export default MongoStore;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\server\server.ts -----

// eslint-disable-next-line @typescript-eslint/no-var-requires
const MongoStore = require('connect-mongo');

import * as cors from 'cors';
import * as express from 'express';
import * as session from 'express-session';
import * as httpModule from 'http';
import * as mongoose from 'mongoose';

import api from './api';
import { setupGoogle } from './google-auth';
import { setupPasswordless } from './passwordless-auth';
import { setupSockets } from './sockets';
import { stripeWebhookAndCheckoutCallback } from './stripe';

// eslint-disable-next-line
require('dotenv').config();

mongoose.connect(process.env.MONGO_URL_TEST);

const server = express();

server.use(
  cors({
    origin: process.env.URL_APP,
    methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',
    credentials: true,
  }),
);

stripeWebhookAndCheckoutCallback({ server });

server.use(express.json());

const sessionOptions = {
  name: process.env.SESSION_NAME,
  secret: process.env.SESSION_SECRET,
  resave: false,
  saveUninitialized: false,
  store: MongoStore.create({
    mongoUrl: process.env.MONGO_URL_TEST,
    ttl: 14 * 24 * 60 * 60, // save session 14 days
    autoRemove: 'interval',
    autoRemoveInterval: 1440, // clears every day
  }),
  cookie: {
    httpOnly: true,
    maxAge: 14 * 24 * 60 * 60 * 1000, // expires in 14 days
    secure: false,
  },
};

const sessionMiddleware = session(sessionOptions);
server.use(sessionMiddleware);

setupGoogle({ server });
setupPasswordless({ server });

api(server);

const httpServer = httpModule.createServer(server);
setupSockets({ httpServer, origin: process.env.URL_APP, sessionMiddleware });

server.get('*', (_, res) => {
  res.sendStatus(403);
});

httpServer.listen(process.env.PORT_API, () => {
  console.log(`> Ready on ${process.env.URL_API}`);
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\server\sockets.ts -----

import { Response } from 'express';
import { Server } from 'socket.io';

import { DiscussionDocument } from './models/Discussion';
import { PostDocument } from './models/Post';

let io: Server = null;
// const dev = process.env.NODE_ENV !== 'production';

function setupSockets({ httpServer, origin, sessionMiddleware }) {
  if (io === null) {
    io = new Server(httpServer, {
      cors: {
        origin,
        methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',
        credentials: true,
      },
      cookie: {
        name: 'io',
        httpOnly: true,
        maxAge: 14 * 24 * 60 * 60 * 1000, // expires in 14 days
        domain: 'localhost',
        secure: false,
      },
      serveClient: false,
      transports: ['polling', 'websocket'],
    });

    const wrap = (middleware) => (socket, next) => middleware(socket.request, {} as Response, next);

    io.use(wrap(sessionMiddleware));

    io.on('connection', (socket: any) => {
      if (
        !socket.request.session ||
        ((!socket.request.session.passport || !socket.request.session.passport.user) &&
          !socket.request.session.passwordless)
      ) {
        socket.disconnect(true);
        return;
      }

      socket.on('joinTeamRoom', (teamId) => {
        console.log(`    joinTeamRoom ${teamId}`);
        socket.join(`teamRoom-${teamId}`);
      });

      socket.on('leaveTeamRoom', (teamId) => {
        console.log(`** leaveTeamRoom ${teamId}`);
        socket.leave(`teamRoom-${teamId}`);
      });

      socket.on('joinDiscussionRoom', (discussionId) => {
        console.log(`    joinDiscussionRoom ${discussionId}`);
        socket.join(`discussionRoom-${discussionId}`);
      });

      socket.on('leaveDiscussionRoom', (discussionId) => {
        console.log(`** leaveDiscussionRoom ${discussionId}`);
        socket.leave(`discussionRoom-${discussionId}`);
      });

      socket.on('disconnect', (reason) => {
        console.log(`disconnected`, `reason: ` + reason);
      });
    });
  }
}

function getSocket(socketId?: string) {
  if (!io) {
    return null;
  }

  if (socketId && io.sockets.sockets.get(socketId)) {
    return io.sockets.sockets.get(socketId).broadcast;
  } else {
    return io;
  }
}

function discussionAdded({
  socketId,
  discussion,
}: {
  socketId?: string;
  discussion: DiscussionDocument;
}) {
  const roomName = `teamRoom-${discussion.teamId}`;

  const socket = getSocket(socketId);
  if (socket) {
    socket.to(roomName).emit('discussionEvent', { actionType: 'added', discussion });
  }
}

function discussionEdited({
  socketId,
  discussion,
}: {
  socketId?: string;
  discussion: DiscussionDocument;
}) {
  const roomName = `teamRoom-${discussion.teamId}`;
  const socket = getSocket(socketId);

  if (socket) {
    socket.to(roomName).emit('discussionEvent', {
      actionType: 'edited',
      discussion,
    });
  }
}

function discussionDeleted({
  socketId,
  teamId,
  id,
}: {
  socketId?: string;
  teamId: string;
  id: string;
}) {
  const roomName = `teamRoom-${teamId}`;
  const socket = getSocket(socketId);

  if (socket) {
    socket.to(roomName).emit('discussionEvent', { actionType: 'deleted', id });
  }
}

function postAdded({ socketId, post }: { socketId?: string; post: PostDocument }) {
  const roomName = `discussionRoom-${post.discussionId}`;

  const socket = getSocket(socketId);
  if (socket) {
    socket.to(roomName).emit('postEvent', { actionType: 'added', post });
  }
}

function postEdited({ socketId, post }: { socketId?: string; post: PostDocument }) {
  const roomName = `discussionRoom-${post.discussionId}`;

  const socket = getSocket(socketId);
  if (socket) {
    socket.to(roomName).emit('postEvent', { actionType: 'edited', post });
  }
}

function postDeleted({
  socketId,
  id,
  discussionId,
}: {
  socketId?: string;
  id: string;
  discussionId: string;
}) {
  const roomName = `discussionRoom-${discussionId}`;

  const socket = getSocket(socketId);
  if (socket) {
    socket.to(roomName).emit('postEvent', { actionType: 'deleted', id });
  }
}

export {
  setupSockets,
  postAdded,
  postEdited,
  postDeleted,
  discussionAdded,
  discussionEdited,
  discussionDeleted,
};

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\server\stripe.ts -----

import * as bodyParser from "body-parser";
import Stripe from "stripe";

import Team from "./models/Team";
import User from "./models/User";

const dev = process.env.NODE_ENV !== "production";

const stripeInstance = new Stripe(dev ? process.env.STRIPE_TEST_SECRETKEY : process.env.STRIPE_LIVE_SECRETKEY, {
  apiVersion: "2025-02-24.acacia",
});

function createSession({ userId, teamId, teamSlug, customerId, subscriptionId, userEmail, mode }) {
  const params: Stripe.Checkout.SessionCreateParams = {
    customer_email: customerId ? undefined : userEmail,
    customer: customerId,
    payment_method_types: ["card"],
    mode,
    success_url: `${process.env.URL_API}/stripe/checkout-completed/{CHECKOUT_SESSION_ID}`,
    cancel_url: `${process.env.URL_APP}/team/${teamSlug}/billing?redirectMessage=Checkout%20canceled`,
    metadata: { userId, teamId },
  };

  if (mode === "subscription") {
    params.line_items = [
      {
        price: dev ? process.env.STRIPE_TEST_PRICEID : process.env.STRIPE_LIVE_PRICEID,
        quantity: 1,
      },
    ];
  } else if (mode === "setup") {
    if (!customerId || !subscriptionId) {
      throw new Error("customerId and subscriptionId required");
    }

    params.setup_intent_data = {
      metadata: { customer_id: customerId, subscription_id: subscriptionId },
    };
  }

  return stripeInstance.checkout.sessions.create(params);
}

function retrieveSession({ sessionId }: { sessionId: string }) {
  return stripeInstance.checkout.sessions.retrieve(sessionId, {
    expand: [
      "setup_intent",
      "setup_intent.payment_method",
      "customer",
      "subscription",
      "subscription.default_payment_method",
    ],
  });
}

function updateCustomer(customerId, params: Stripe.CustomerUpdateParams) {
  console.log("updating customer", customerId);
  return stripeInstance.customers.update(customerId, params);
}

function updateSubscription(subscriptionId: string, params: Stripe.SubscriptionUpdateParams) {
  console.log("updating subscription", subscriptionId);
  return stripeInstance.subscriptions.update(subscriptionId, params);
}

function cancelSubscription({ subscriptionId }) {
  console.log("cancel subscription", subscriptionId);
  return stripeInstance.subscriptions.cancel(subscriptionId);
}

function getListOfInvoices({ customerId }) {
  console.log("getting list of invoices for customer", customerId);
  return stripeInstance.invoices.list({ customer: customerId, limit: 100 });
}

function stripeWebhookAndCheckoutCallback({ server }) {
  server.post(
    "/api/v1/public/stripe-invoice-payment-failed",
    bodyParser.raw({ type: "application/json" }),
    async (req, res, next) => {
      try {
        const event = stripeInstance.webhooks.constructEvent(
          req.body,
          req.headers["stripe-signature"],
          dev ? process.env.STRIPE_TEST_ENDPOINTSECRET : process.env.STRIPE_LIVE_ENDPOINTSECRET
        );

        console.log(`${event.id}, ${event.type}`);

        // invoice.payment_failed
        // data.object is an invoice
        // Occurs whenever an invoice payment attempt fails, due either to a declined payment or to the lack of a stored payment method.

        if (event.type === "invoice.payment_failed") {
          const { subscription } = event.data.object;
          console.log(JSON.stringify(subscription));

          await Team.cancelSubscriptionAfterFailedPayment({
            subscriptionId: JSON.stringify(subscription),
          });
        }

        res.sendStatus(200);
      } catch (err) {
        console.log(`Webhook error: ${err.message}`);
        next(err);
      }
    }
  );

  server.get("/stripe/checkout-completed/:sessionId", async (req, res) => {
    const { sessionId } = req.params;

    const session = await retrieveSession({ sessionId });
    if (!session || !session.metadata || !session.metadata.userId || !session.metadata.teamId) {
      throw new Error("Wrong session.");
    }

    const user = await User.findById(
      session.metadata.userId,
      "_id stripeCustomer email displayName isSubscriptionActive stripeSubscription"
    ).setOptions({ lean: true });

    const team = await Team.findById(
      session.metadata.teamId,
      "isSubscriptionActive stripeSubscription teamLeaderId slug"
    ).setOptions({ lean: true });

    if (!user) {
      throw new Error("User not found.");
    }

    if (!team) {
      throw new Error("Team not found.");
    }

    if (team.teamLeaderId !== user._id.toString()) {
      throw new Error("Permission denied");
    }

    try {
      if (session.mode === "setup" && session.setup_intent) {
        const si: Stripe.SetupIntent = session.setup_intent as Stripe.SetupIntent;
        const pm: Stripe.PaymentMethod = si.payment_method as Stripe.PaymentMethod;

        if (user.stripeCustomer) {
          await updateCustomer(user.stripeCustomer.id, {
            invoice_settings: { default_payment_method: pm.id },
          });
        }

        if (team.stripeSubscription) {
          await updateSubscription(team.stripeSubscription.id, { default_payment_method: pm.id });
        }

        await User.changeStripeCard({ session, user });
      } else if (session.mode === "subscription") {
        await User.saveStripeCustomerAndCard({ session, user });
        await Team.subscribeTeam({ session, team });
        await User.getListOfInvoicesForCustomer({ userId: user._id.toString() });
      } else {
        throw new Error("Wrong session.");
      }

      res.redirect(`${process.env.URL_APP}/team/${team.slug}/billing`);
    } catch (err) {
      console.error(err);

      res.redirect(`${process.env.URL_APP}/team/${team.slug}/billing?redirectMessage=${err.message || err.toString()}`);
    }
  });
}

export { createSession, cancelSubscription, getListOfInvoices, stripeWebhookAndCheckoutCallback };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\test\server\utils\slugify.test.ts -----

import * as mongoose from 'mongoose';
import User from '../../../server/models/User';
import { generateSlug } from '../../../server/utils/slugify';

// eslint-disable-next-line
require('dotenv').config();

describe('slugify', () => {
  beforeAll(async () => {
    await mongoose.connect(process.env.MONGO_URL_TEST);

    const mockUsers = [
      {
        slug: 'john',
        email: 'john@example.com',
        createdAt: new Date(),
        displayName: 'abc',
        avatarUrl: 'def',
      },
      {
        slug: 'john-johnson',
        email: 'john-johnson@example.com',
        createdAt: new Date(),
        displayName: 'abc',
        avatarUrl: 'def',
      },
      {
        slug: 'john-johnson-1',
        email: 'john-johnson-1@example.com',
        createdAt: new Date(),
        displayName: 'abc',
        avatarUrl: 'def',
      },
    ];

    await User.insertMany(mockUsers);
  });

  test('not duplicated', async () => {
    expect.assertions(1);

    await expect(generateSlug(User, 'John J Johnson@#$')).resolves.toEqual('john-j-johnson');
  });

  test('one time duplicated', async () => {
    expect.assertions(1);

    await expect(generateSlug(User, ' John@#$')).resolves.toEqual('john-1');
  });

  test('multiple duplicated', async () => {
    expect.assertions(1);

    await expect(generateSlug(User, 'John & Johnson@#$')).resolves.toEqual('john-johnson-2');
  });

  afterAll(async () => {
    await User.deleteMany({ slug: { $in: ['john', 'john-johnson', 'john-johnson-1'] } });
    await mongoose.disconnect();
  });
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\test\server\utils\sum.test.ts -----

import { sum } from '../../../server/utils/sum';

console.log(sum(1, 2));

describe.skip('testing sum function', () => {
  test('adds 1 + 2 to equal 3', () => {
    expect(sum(1, 2)).toBe(3);
  });
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\.eslintrc.js -----

module.exports = {
  parser: "@typescript-eslint/parser",
  extends: ["plugin:@typescript-eslint/recommended", "prettier"],
  env: {
    "es6": true,
    "node": true,
  },
  plugins: ["prettier"],
  rules: {
    'prettier/prettier': [
      'error',
      {
        singleQuote: true,
        trailingComma: 'all',
        arrowParens: 'always',
        printWidth: 100,
        semi: true,
      },
    ],
    '@typescript-eslint/no-unused-vars': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/no-explicit-any': 'off',
    'prefer-arrow-callback': 'error',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
 },
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\nodemon.json -----

{
  "watch": ["server"],
  "exec": "ts-node --project tsconfig.server.json",
  "ext": "ts"
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\package.json -----

{
  "name": "9-end-api",
  "version": "1",
  "license": "MIT",
  "scripts": {
    "dev": "nodemon server/server.ts",
    "lint": "eslint . --ext .ts,.tsx",
    "test": "jest"
  },
  "jest": {
    "preset": "ts-jest",
    "testPathIgnorePatterns": [
      "production-server"
    ],
    "testEnvironment": "node"
  },
  "dependencies": {
    "aws-sdk": "^2.1692.0",
    "bcrypt": "^5.1.1",
    "connect-mongo": "^5.1.0",
    "cors": "^2.8.5",
    "dotenv": "^16.4.7",
    "express": "^4.21.2",
    "express-session": "^1.18.1",
    "he": "^1.2.0",
    "highlight.js": "^11.11.1",
    "lodash": "^4.17.20",
    "marked": "^15.0.7",
    "mongoose": "^8.12.1",
    "node-fetch": "2",
    "passport": "^0.7.0",
    "passport-google-oauth": "^2.0.0",
    "passwordless": "^1.1.3",
    "passwordless-tokenstore": "^0.0.10",
    "socket.io": "^4.8.1",
    "stripe": "^17.7.0",
    "typescript": "^5.8.2"
  },
  "devDependencies": {
    "@types/connect-mongo": "^3.1.6",
    "@types/dotenv": "^8.2.3",
    "@types/express": "^5.0.1",
    "@types/express-session": "^1.18.1",
    "@types/jest": "^29.5.14",
    "@types/lodash": "^4.17.16",
    "@types/mongoose": "^5.5.43",
    "@types/node": "^22.13.11",
    "@types/node-fetch": "^2.6.12",
    "@types/passport": "^1.0.17",
    "@types/socket.io": "^3.0.2",
    "@typescript-eslint/eslint-plugin": "^8.27.0",
    "@typescript-eslint/parser": "^8.27.0",
    "eslint": "^9.22.0",
    "eslint-config-prettier": "^10.1.1",
    "eslint-plugin-prettier": "^5.2.3",
    "jest": "^29.7.0",
    "nodemon": "^3.1.9",
    "prettier": "^3.5.3",
    "ts-jest": "^29.2.6",
    "ts-node": "^10.9.2"
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\tsconfig.json -----

{
  "compileOnSave": false,
  "compilerOptions": {
    "jsx": "preserve",
    "allowJs": true,
    "alwaysStrict": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "removeComments": false,
    "preserveConstEnums": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "sourceMap": true,
    "skipLibCheck": true,
    "baseUrl": ".",
    "experimentalDecorators": true,
    "typeRoots": ["./node_modules/@types"],
    "lib": ["es2015", "es2016"]
  },
  "exclude": ["production-server", "node_modules"]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\api\tsconfig.server.json -----

{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "module": "commonjs",
    "outDir": "production-server/"
  },
  "include": ["./server/**/*.ts"],
  "exclude": ["./server/**/*.test.ts"]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\components\common\Confirmer.tsx -----

import Button from "@mui/material/Button";
import Dialog from "@mui/material/Dialog";
import DialogActions from "@mui/material/DialogActions";
import DialogContent from "@mui/material/DialogContent";
import DialogContentText from "@mui/material/DialogContentText";
import DialogTitle from "@mui/material/DialogTitle";
import React from "react";

export let openConfirmDialogExternal;

type State = {
  open: boolean;
  title: string;
  message: string;
  onAnswer: (answer) => void;
};

class Confirmer extends React.Component<any, State> {
  constructor(props) {
    super(props);

    this.state = {
      open: false,
      title: "Are you sure?",
      message: "",
      onAnswer: null,
    };

    openConfirmDialogExternal = this.openConfirmDialog;
  }

  public render() {
    return (
      <Dialog
        open={this.state.open}
        onClose={this.handleClose}
        aria-labelledby="alert-dialog-title"
        aria-describedby="alert-dialog-description"
      >
        <DialogTitle id="alert-dialog-title">{this.state.title}</DialogTitle>
        <DialogContent>
          <DialogContentText id="alert-dialog-description">{this.state.message}</DialogContentText>
        </DialogContent>
        <DialogActions style={{ padding: "10px" }}>
          <Button onClick={this.handleClose} variant="contained" color="primary" autoFocus>
            Cancel
          </Button>
          <Button onClick={this.handleYes} variant="contained" color="secondary">
            OK
          </Button>
        </DialogActions>
      </Dialog>
    );
  }

  public handleClose = () => {
    this.setState({ open: false });
    this.state.onAnswer(false);
  };

  public handleYes = () => {
    this.setState({ open: false });
    this.state.onAnswer(true);
  };

  public openConfirmDialog = ({ title, message, onAnswer }) => {
    this.setState({ open: true, title, message, onAnswer });
  };
}

export default Confirmer;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\components\common\LoginButton.tsx -----

import Button from "@mui/material/Button";
import TextField from "@mui/material/TextField";
import React from "react";

import { emailLoginLinkApiMethod } from "../../lib/api/public";
import notify from "../../lib/notify";
import { makeQueryString } from "../../lib/api/makeQueryString";

type Props = { invitationToken?: string };
type State = { email: string };

class LoginButton extends React.PureComponent<Props, State> {
  constructor(props) {
    super(props);

    this.state = { email: "" };
  }

  public render() {
    const { invitationToken } = this.props;

    let url = `${process.env.NEXT_PUBLIC_URL_API}/auth/google`;
    const qs = makeQueryString({ invitationToken });

    if (qs) {
      url += `?${qs}`;
    }

    // console.log(url);

    return (
      <React.Fragment>
        <Button variant="contained" color="secondary" href={url}>
          <img src="https://storage.googleapis.com/async-await-all/G.svg" alt="Log in with Google" />
          &nbsp;&nbsp;&nbsp; Log in with Google
        </Button>
        <p />
        <br />
        <hr style={{ width: "60px" }} /> <h4>OR</h4> <hr style={{ width: "60px" }} />
        <p />
        <br />
        <div>
          <form autoComplete="off" onSubmit={this.onSubmit}>
            <TextField
              required
              type="email"
              label="Email address"
              value={this.state.email}
              onChange={(event) => {
                this.setState({ email: event.target.value });
              }}
              style={{ width: "300px" }}
            />
            <p />
            <Button variant="contained" color="primary" type="submit">
              Log in with email
            </Button>
          </form>
          <p />
          <br />
        </div>
      </React.Fragment>
    );
  }

  private onSubmit = async (event) => {
    event.preventDefault();
    const { email } = this.state;
    const { invitationToken } = this.props;

    if (!email) {
      notify("Email is required");
    }

    try {
      await emailLoginLinkApiMethod({ email, invitationToken });
      this.setState({ email: "" });
      notify("SaaS boilerplate emailed you a login link.");
    } catch (error) {
      notify(error);
    }
  };
}

export default LoginButton;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\components\common\MemberChooser.tsx -----

import React from "react";

import Autocomplete from "@mui/material/Autocomplete";
import TextField from "@mui/material/TextField";

import { User } from "../../lib/store/user";

type Props = {
  onChange: (item) => void;
  selectedMemberIds?: string[];
  members: User[];
  label?: string;
  helperText?: string;
};

type State = {
  selectedItems: { label: string; id: string }[];
};

class MemberChooser extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    const suggestions = this.props.members.map((user) => ({
      label: user.displayName || user.email,
      id: user._id,
    }));

    const selectedItems = suggestions.filter((s) => this.props.selectedMemberIds.indexOf(s.id) !== -1);

    this.state = {
      selectedItems: selectedItems || [],
    };
  }

  public render() {
    const suggestions = this.props.members.map((user) => ({
      label: user.displayName || user.email,
      id: user._id,
    }));

    return (
      <Autocomplete
        multiple
        id="tags-standard"
        options={suggestions}
        getOptionLabel={(option) => option.label}
        getOptionSelected={(option, value) => option.id === value.id}
        value={this.state.selectedItems}
        renderInput={(params) => (
          <TextField
            {...params}
            variant="standard"
            label="Find team member by name"
            placeholder="Select participants"
          />
        )}
        onChange={this.handleChange}
        filterSelectedOptions={true}
        noOptionsText="No team members to select from"
      />
    );
  }

  public handleChange = (event, value) => {
    event.preventDefault();

    const selectedItems = value;

    this.setState({ selectedItems });

    this.props.onChange(selectedItems.map((i) => i.id));
  };
}

export default MemberChooser;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\components\common\MenuWithLinks.tsx -----

import Menu from "@mui/material/Menu";
import MenuItem from "@mui/material/MenuItem";
import Link from "next/link";
import { NextRouter, withRouter } from "next/router";
import React from "react";

type Props = {
  options: {
    href: string;
    as: string;
    highlighterSlug: string;
    text: string;
    externalServer: boolean;
    separator: boolean;
  }[];
  router: NextRouter;
  children: any;
};

type State = {
  anchorEl: Element | ((element: Element) => Element);
};

class MenuWithLinks extends React.PureComponent<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      anchorEl: null,
    };
  }

  public render() {
    const { options, children, router } = this.props;
    const { anchorEl } = this.state;

    return (
      <div style={{ textAlign: "center" }}>
        <div
          aria-controls={anchorEl ? "simple-menu" : null}
          aria-haspopup="true"
          onClick={this.handleClick}
          onKeyPress={this.handleClick}
        >
          {children}
        </div>
        <Menu id="simple-menu" anchorEl={anchorEl} open={Boolean(anchorEl)} onClose={this.handleClose} keepMounted>
          {options.map((option, i) =>
            option.separator ? (
              <hr style={{ width: "95%", margin: "10px auto" }} key={`separated-${i}`} />
            ) : option.externalServer ? (
              <MenuItem
                onClick={(event) => {
                  event.preventDefault();
                  window.location.href = option.href;
                  this.handleClose();
                }}
                key={option.href || option.text}
              >
                {option.text}
              </MenuItem>
            ) : (
              <Link key={option.href} href={option.href} as={option.as} passHref>
                <MenuItem
                  key={option.href}
                  style={{
                    fontWeight: router.asPath.includes(option.highlighterSlug) ? 600 : 300,
                    fontSize: "14px",
                  }}
                >
                  {option.text}
                </MenuItem>
              </Link>
            )
          )}
        </Menu>
      </div>
    );
  }

  public handleClick = (event) => {
    this.setState({ anchorEl: event.currentTarget });
  };

  public handleClose = () => {
    this.setState({ anchorEl: null });
  };
}

export default withRouter(MenuWithLinks);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\components\common\MenuWithMenuItems.tsx -----

import Menu from "@mui/material/Menu";
import MenuItem from "@mui/material/MenuItem";
import React from "react";

type Props = {
  menuOptions: any;
  itemOptions: any[];
};

type State = {
  menuElem: Element | ((element: Element) => Element);
};

class MenuWithMenuItems extends React.PureComponent<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      menuElem: null,
    };
  }

  public render() {
    const { menuOptions, itemOptions } = this.props;
    const { menuElem } = this.state;

    return (
      <div style={{ verticalAlign: "middle" }}>
        <i
          aria-controls={menuElem ? menuOptions.id : null}
          data-id={menuOptions.dataId}
          aria-haspopup="true"
          style={{ fontSize: "14px", opacity: 0.7, cursor: "pointer" }}
          className="material-icons"
          onClick={(e) => this.handleClick(e)}
        >
          more_vert
        </i>

        <Menu id={menuOptions.id} anchorEl={menuElem} open={Boolean(menuElem)} onClose={this.handleClose}>
          {itemOptions.map((option, i) => (
            <MenuItem
              key={option.dataId + i}
              data-id={option.dataId}
              data-more-id={option.dataMoreId}
              onClick={(e) => {
                this.setState({ menuElem: null });
                option.onClick(e);
              }}
            >
              {option.text}
            </MenuItem>
          ))}
        </Menu>
      </div>
    );
  }

  public handleClick = (event) => {
    event.preventDefault();
    this.setState({ menuElem: event.currentTarget });
  };

  public handleClose = () => {
    this.setState({ menuElem: null });
  };
}

export default MenuWithMenuItems;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\components\common\Notifier.tsx -----

import Snackbar from "@mui/material/Snackbar";
import React from "react";

export let openSnackbarExternal;

type State = {
  open: boolean;
  message: string;
};

class Notifier extends React.PureComponent<any, State> {
  constructor(props) {
    super(props);
    openSnackbarExternal = this.openSnackbar;

    this.state = {
      open: false,
      message: "",
    };
  }

  public render() {
    const message = <span id="snackbar-message-id" dangerouslySetInnerHTML={{ __html: this.state.message }} />;

    return (
      <Snackbar
        anchorOrigin={{ vertical: "top", horizontal: "right" }}
        message={message}
        autoHideDuration={5000}
        onClose={this.handleSnackbarClose}
        open={this.state.open}
        ContentProps={{
          "aria-describedby": "snackbar-message-id",
        }}
      />
    );
  }

  public handleSnackbarClose = () => {
    this.setState({
      open: false,
      message: "",
    });
  };

  public openSnackbar = ({ message }) => {
    this.setState({ open: true, message });
  };
}

export default Notifier;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\components\discussions\CreateDiscussionForm.tsx -----

import Button from "@mui/material/Button";
import Dialog from "@mui/material/Dialog";
import DialogContent from "@mui/material/DialogContent";
import DialogTitle from "@mui/material/DialogTitle";
import FormControl from "@mui/material/FormControl";
import FormHelperText from "@mui/material/FormHelperText";
import InputLabel from "@mui/material/InputLabel";
import Select from "@mui/material/Select";
import MenuItem from "@mui/material/MenuItem";
import TextField from "@mui/material/TextField";
import { observer } from "mobx-react";
import Head from "next/head";
import Router from "next/router";
import NProgress from "nprogress";
import React from "react";

import notify from "../../lib/notify";
import { Store } from "../../lib/store";
import MemberChooser from "../common/MemberChooser";
import PostEditor from "../posts/PostEditor";

type Props = {
  isMobile: boolean;
  store: Store;
  open: boolean;
  onClose: () => void;
};

type State = {
  name: string;
  memberIds: string[];
  disabled: boolean;
  content: string;
  notificationType: string;
};

class CreateDiscussionForm extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      name: "",
      memberIds: [],
      disabled: false,
      content: "",
      notificationType: "default",
    };
  }

  public render() {
    const { open, isMobile, store } = this.props;
    const { currentTeam, currentUser } = store;

    const membersMinusCreator = Array.from(currentTeam.members.values()).filter((user) => user._id !== currentUser._id);

    return (
      <React.Fragment>
        {open ? (
          <Head>
            <title>New Discussion</title>
            <meta name="description" content="Create new discussion" />
          </Head>
        ) : null}
        <Dialog onClose={this.handleClose} aria-labelledby="simple-dialog-title" open={open} fullScreen={true}>
          <DialogTitle id="simple-dialog-title">Create new Discussion</DialogTitle>
          <DialogContent>
            <br />
            <form style={{ width: "100%", height: "60%" }} onSubmit={this.onSubmit}>
              <p />
              <br />
              <TextField
                autoFocus
                label="Type name of Discussion"
                helperText="Give a short and informative name to new Discussion"
                value={this.state.name}
                onChange={(event) => {
                  this.setState({ name: event.target.value });
                }}
              />
              <br />
              <p />
              <MemberChooser
                helperText="These members will see all posts and be notified about unread posts in this discussion."
                onChange={this.handleMembersChange}
                members={membersMinusCreator}
                selectedMemberIds={this.state.memberIds}
              />
              <p />
              <br />
              <FormControl>
                <InputLabel>Notification type</InputLabel>
                <Select
                  value={this.state.notificationType}
                  onChange={(event: React.ChangeEvent<HTMLSelectElement>) => {
                    this.setState({ notificationType: event.target.value });
                  }}
                  required
                >
                  <MenuItem value="default">Default: without email notification.</MenuItem>
                  <MenuItem value="email">Email: with email notification.</MenuItem>
                </Select>
                <FormHelperText>Choose how to notify members about new Posts inside Discussion.</FormHelperText>
              </FormControl>
              <p />
              <br />
              <div>
                <Button type="submit" variant="contained" color="primary" disabled={this.state.disabled}>
                  Create Discussion
                </Button>
                {isMobile ? <p /> : null}
                <Button
                  variant="outlined"
                  onClick={this.handleClose}
                  disabled={this.state.disabled}
                  style={{ marginLeft: isMobile ? "0px" : "20px" }}
                >
                  Cancel
                </Button>{" "}
              </div>
              <p />
              <PostEditor
                content={this.state.content}
                onChanged={this.onContentChanged}
                members={Array.from(store.currentTeam.members.values())}
                store={store}
                parentComponent="CDF"
              />
              <p />
              <div>
                <Button type="submit" variant="contained" color="primary" disabled={this.state.disabled}>
                  Create Discussion
                </Button>
                {isMobile ? <p /> : null}
                <Button
                  variant="outlined"
                  onClick={this.handleClose}
                  disabled={this.state.disabled}
                  style={{ marginLeft: isMobile ? "0px" : "20px" }}
                >
                  Cancel
                </Button>{" "}
                <p />
                <br />
                <br />
              </div>
            </form>
          </DialogContent>
        </Dialog>
      </React.Fragment>
    );
  }

  public handleMembersChange = (memberIds) => {
    this.setState({ memberIds });
  };

  public handleClose = () => {
    this.setState({
      name: "",
      memberIds: [],
      disabled: false,
      content: "",
      notificationType: "default",
    });
    this.props.onClose();
  };

  private onContentChanged = (content: string) => {
    console.log("onContentChanged", content);
    this.setState({ content });
  };

  private onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();

    const { store } = this.props;
    const { currentTeam } = store;

    if (!currentTeam) {
      notify("Team have not selected");
      return;
    }

    const { name, memberIds, content, notificationType } = this.state;

    if (!name) {
      notify("Name is required");
      return;
    }

    if (!content) {
      notify("Content is required");
      return;
    }

    if (!memberIds || memberIds.length < 1) {
      notify("Please assign at least one person to this Discussion.");
      return;
    }

    if (!notificationType) {
      notify("Please select notification type.");
      return;
    }

    this.setState({ disabled: true });
    NProgress.start();

    try {
      const discussion = await currentTeam.addDiscussion({
        name,
        memberIds,
        notificationType,
      });

      const post = await discussion.addPost(content);

      if (discussion.notificationType === "email") {
        const userIdsForLambda = discussion.memberIds.filter((m) => m !== discussion.createdUserId);

        await discussion.sendDataToLambda({
          discussionName: discussion.name,
          discussionLink: `${process.env.NEXT_PUBLIC_URL_APP}/team/${discussion.team.slug}/discussions/${discussion.slug}`,
          postContent: post.content,
          authorName: post.user.displayName,
          userIds: userIdsForLambda,
        });
      }

      this.setState({ name: "", memberIds: [], content: "", notificationType: "default" });

      notify("You successfully added new Discussion.");

      Router.push(
        `/discussion?teamSlug=${currentTeam.slug}&discussionSlug=${discussion.slug}`,
        `/team/${currentTeam.slug}/discussions/${discussion.slug}`
      );
    } catch (error) {
      console.log(error);
      notify(error);
    } finally {
      this.setState({ disabled: false });
      NProgress.done();
      this.props.onClose();
    }
  };
}

export default observer(CreateDiscussionForm);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\components\discussions\DiscussionActionMenu.tsx -----

import { observer } from 'mobx-react';
import NProgress from 'nprogress';
import React from 'react';

import confirm from '../../lib/confirm';
import notify from '../../lib/notify';
import { Store } from '../../lib/store';
import { Discussion } from '../../lib/store/discussion';

import MenuWithMenuItems from '../common/MenuWithMenuItems';
import EditDiscussionForm from './EditDiscussionForm';

const getMenuOptions = (discussion) => ({
  dataId: discussion._id,
  id: `discussion-menu-${discussion._id}`,
});

const getMenuItemOptionsForCreator = (discussion, component) => [
  {
    text: 'Copy URL',
    dataId: discussion._id,
    onClick: component.handleCopyUrl,
  },
  {
    text: 'Edit',
    dataId: discussion._id,
    onClick: component.editDiscussion,
  },
  {
    text: 'Delete',
    dataId: discussion._id,
    onClick: component.deleteDiscussion,
  },
];

const getMenuItemOptions = (discussion, component) => [
  {
    text: 'Copy URL',
    dataId: discussion._id,
    onClick: component.handleCopyUrl,
  },
];

type Props = {
  discussion: Discussion;
  store: Store;
  isMobile: boolean;
};

type State = {
  discussionFormOpen: boolean;
  selectedDiscussion: Discussion;
};

class DiscussionActionMenu extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      discussionFormOpen: false,
      selectedDiscussion: null,
    };
  }

  public render() {
    const { discussion, store } = this.props;
    const { currentUser } = store;

    const isCreator = currentUser._id === discussion.createdUserId ? true : false;

    return (
      <React.Fragment>
        <MenuWithMenuItems
          menuOptions={getMenuOptions(discussion)}
          itemOptions={
            isCreator
              ? getMenuItemOptionsForCreator(discussion, this)
              : getMenuItemOptions(discussion, this)
          }
        />

        {this.state.discussionFormOpen ? (
          <EditDiscussionForm
            open={true}
            onClose={this.handleDiscussionFormClose}
            discussion={discussion}
            isMobile={this.props.isMobile}
            store={store}
          />
        ) : null}
      </React.Fragment>
    );
  }

  public handleCopyUrl = async (event) => {
    const { store } = this.props;
    const { currentTeam } = store;

    const id = event.currentTarget.dataset.id;
    if (!id) {
      return;
    }

    const selectedDiscussion = currentTeam.discussions.find((d) => d._id === id);
    const discussionUrl = `${process.env.NEXT_PUBLIC_URL_APP}/team/${currentTeam.slug}/discussions/${selectedDiscussion.slug}`;

    try {
      if (window.navigator) {
        await window.navigator.clipboard.writeText(discussionUrl);
        notify('You successfully copied URL.');
      }
    } catch (err) {
      notify(err);
    } finally {
      this.setState({ discussionFormOpen: false, selectedDiscussion: null });
    }
  };

  public editDiscussion = (event) => {
    const { currentTeam } = this.props.store;
    if (!currentTeam) {
      notify('You have not selected Team.');
      return;
    }

    const id = event.currentTarget.dataset.id;
    if (!id) {
      return;
    }

    const selectedDiscussion = currentTeam.discussions.find((d) => d._id === id);

    this.setState({ discussionFormOpen: true, selectedDiscussion });
  };

  public deleteDiscussion = async (event) => {
    const { currentTeam } = this.props.store;
    if (!currentTeam) {
      notify('You have not selected Team.');
      return;
    }

    const id = event.currentTarget.dataset.id;

    confirm({
      title: 'Are you sure?',
      message: '',
      onAnswer: async (answer) => {
        if (!answer) {
          return;
        }

        NProgress.start();

        try {
          await currentTeam.deleteDiscussion(id);

          notify('You successfully deleted Discussion.');
        } catch (error) {
          console.error(error);
          notify(error);
        } finally {
          NProgress.done();
        }
      },
    });
  };

  public handleDiscussionFormClose = () => {
    this.setState({ discussionFormOpen: false, selectedDiscussion: null });
  };
}

export default observer(DiscussionActionMenu);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\components\discussions\DiscussionList.tsx -----

import Tooltip from "@mui/material/Tooltip";
import { observer } from "mobx-react";
import React from "react";

import { Store } from "../../lib/store";
import { Team } from "../../lib/store/team";

import CreateDiscussionForm from "./CreateDiscussionForm";
import DiscussionListItem from "./DiscussionListItem";

import notify from "../../lib/notify";

type Props = { store: Store; team: Team; isMobile: boolean };

type State = { discussionFormOpen: boolean };

class DiscussionList extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      discussionFormOpen: false,
    };
  }

  public componentDidMount() {
    this.props.team.loadDiscussions().catch((err) => notify(err));
  }

  public componentDidUpdate(prevProps: Props) {
    if (this.props.team._id !== prevProps.team._id) {
      this.props.team.loadDiscussions().catch((err) => notify(err));
    }
  }

  public render() {
    const { store, team } = this.props;

    const isThemeDark = store && store.currentUser && store.currentUser.darkTheme === true;

    return (
      <div>
        Discussions
        <Tooltip title="Add Discussion" placement="right" disableFocusListener disableTouchListener>
          <a onClick={this.addDiscussion} style={{ float: "right", padding: "0px 10px" }}>
            <i
              className="material-icons"
              color="action"
              style={{ fontSize: 14, opacity: 0.7, color: isThemeDark ? "#fff" : "#000" }}
            >
              add_circle_outline
            </i>{" "}
          </a>
        </Tooltip>
        <p />
        <ul style={{ listStyle: "none", padding: "0px" }}>
          {team &&
            team.orderedDiscussions.map((d) => {
              return (
                <DiscussionListItem
                  key={d._id}
                  discussion={d}
                  team={team}
                  isMobile={this.props.isMobile}
                  store={this.props.store}
                />
              );
            })}
        </ul>
        <CreateDiscussionForm
          isMobile={this.props.isMobile}
          store={this.props.store}
          open={this.state.discussionFormOpen}
          onClose={this.handleDiscussionFormClose}
        />
      </div>
    );
  }

  public addDiscussion = (event) => {
    event.preventDefault();
    this.setState({ discussionFormOpen: true });
  };

  public handleDiscussionFormClose = () => {
    this.setState({ discussionFormOpen: false });
  };
}

export default observer(DiscussionList);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\components\discussions\DiscussionListItem.tsx -----

import Paper from "@mui/material/Paper";
import { observer } from "mobx-react";
import Link from "next/link";
import React from "react";

import { Store } from "../../lib/store";
import { Discussion } from "../../lib/store/discussion";
import { Team } from "../../lib/store/team";

import DiscussionActionMenu from "./DiscussionActionMenu";

type Props = {
  store: Store;
  discussion: Discussion;
  team: Team;
  isMobile: boolean;
};

class DiscussionListItem extends React.Component<Props> {
  public render() {
    const { store, discussion, team, isMobile } = this.props;
    const trimmingLength = 16;

    const selectedDiscussion = store.currentUrl === `/team/${team.slug}/discussions/${discussion.slug}`;

    console.log(store.currentUrl);

    const isThemeDark = store && store.currentUser && store.currentUser.darkTheme === true;

    const selectedItemBorder = isThemeDark ? "1px rgba(255, 255, 255, 0.75) solid" : "1px rgba(0, 0, 0, 0.75) solid";

    return (
      <Paper
        key={discussion._id}
        style={{
          margin: "10px 10px 5px 0px",
          padding: "8px",
          border: selectedDiscussion ? selectedItemBorder : "none",
        }}
        elevation={selectedDiscussion ? 24 : 1}
      >
        <li key={discussion._id} style={{ whiteSpace: "nowrap", paddingRight: "10px" }}>
          <Link
            scroll={false}
            href={`/discussion?teamSlug=${team.slug}&discussionSlug=${discussion.slug}`}
            as={`/team/${team.slug}/discussions/${discussion.slug}`}
            style={{ fontWeight: 300, color: isThemeDark ? "#fff" : "#000" }}
            key={discussion._id}
          >
            {discussion.name.length > trimmingLength
              ? `${discussion.name.substring(0, trimmingLength)}...`
              : discussion.name}
          </Link>
          <div
            style={{
              float: "right",
              marginRight: "-12px",
            }}
          >
            <DiscussionActionMenu discussion={discussion} isMobile={isMobile} store={store} />
          </div>
        </li>
      </Paper>
    );
  }
}

export default observer(DiscussionListItem);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\components\discussions\EditDiscussionForm.tsx -----

import Button from "@mui/material/Button";
import Dialog from "@mui/material/Dialog";
import DialogActions from "@mui/material/DialogActions";
import DialogContent from "@mui/material/DialogContent";
import DialogContentText from "@mui/material/DialogContentText";
import DialogTitle from "@mui/material/DialogTitle";
import FormControl from "@mui/material/FormControl";
import FormHelperText from "@mui/material/FormHelperText";
import InputLabel from "@mui/material/InputLabel";
import Select from "@mui/material/Select";
import MenuItem from "@mui/material/MenuItem";
import TextField from "@mui/material/TextField";
import { observer } from "mobx-react";
import NProgress from "nprogress";
import React from "react";

import notify from "../../lib/notify";
import { Store } from "../../lib/store";
import { Discussion } from "../../lib/store/discussion";
import MemberChooser from "../common/MemberChooser";

type Props = {
  store: Store;
  onClose: () => void;
  open: boolean;
  discussion: Discussion;
  isMobile: boolean;
};

type State = {
  name: string;
  memberIds: string[];
  disabled: boolean;
  discussionId: string;
  notificationType: string;
};

class EditDiscussionForm extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      name: "",
      memberIds: [],
      disabled: false,
      discussionId: "",
      notificationType: "default",
    };
  }

  public static getDerivedStateFromProps(props: Props, state: State) {
    const { discussion } = props;

    if (state.discussionId === discussion._id) {
      return null;
    }

    return {
      name: (discussion && discussion.name) || "",
      memberIds: (discussion && discussion.memberIds) || [],
      discussionId: discussion._id,
      notificationType: discussion.notificationType || "default",
    };
  }

  public render() {
    const { open, store } = this.props;
    const { currentTeam, currentUser } = store;

    const membersMinusCreator = Array.from(currentTeam.members.values()).filter((user) => user._id !== currentUser._id);

    // console.log(currentTeam.members);

    return (
      <Dialog onClose={this.handleClose} aria-labelledby="simple-dialog-title" open={open}>
        <DialogTitle id="simple-dialog-title">Edit Discussion</DialogTitle>
        <DialogContent>
          <DialogContentText>Edit discussion</DialogContentText>
          <br />
          <form onSubmit={this.onSubmit}>
            <TextField
              label="Type name of Discussion"
              helperText="Give a short and informative name to Discussion"
              value={this.state.name}
              onChange={(event) => {
                this.setState({ name: event.target.value });
              }}
            />
            <br />
            <p />
            <MemberChooser
              helperText="These members will see all posts and be notified about unread posts in this discussion."
              onChange={this.handleMembersChange}
              members={membersMinusCreator}
              selectedMemberIds={this.state.memberIds}
            />
            <p />
            <br />
            <FormControl>
              <InputLabel>Notification type</InputLabel>
              <Select
                value={this.state.notificationType}
                onChange={(event: React.ChangeEvent<HTMLSelectElement>) => {
                  this.setState({ notificationType: event.target.value });
                }}
                required
              >
                <MenuItem value="default">Default: without email notification.</MenuItem>
                <MenuItem value="email">Email: with email notification.</MenuItem>
              </Select>
              <FormHelperText>Choose how to notify members about new Posts inside Discussion.</FormHelperText>
            </FormControl>
            <p />
            <br />
            <DialogActions>
              <Button color="primary" variant="outlined" onClick={this.handleClose} disabled={this.state.disabled}>
                Cancel
              </Button>
              <Button type="submit" variant="contained" color="primary" disabled={this.state.disabled}>
                Update Discussion
              </Button>
            </DialogActions>
          </form>
        </DialogContent>
      </Dialog>
    );
  }

  public handleMembersChange = (memberIds) => {
    this.setState({ memberIds });
  };

  public handleClose = () => {
    this.setState({ name: "", memberIds: [], disabled: false, notificationType: "default" });
    this.props.onClose();
  };

  private onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();

    const { discussion, store } = this.props;
    const { currentTeam } = store;
    const { notificationType } = this.state;

    if (!currentTeam) {
      notify("Team have not selected");
      return;
    }

    const { name, memberIds } = this.state;

    if (!name) {
      notify("Please name this Discussion.");
      return;
    }

    if (memberIds && !memberIds.includes(discussion.store.currentUser._id)) {
      memberIds.push(discussion.store.currentUser._id);
    }

    if (!memberIds || memberIds.length < 1) {
      notify("Please assign at least one person to this Discussion.");
      return;
    }

    if (!notificationType) {
      notify("Please select notification type.");
      return;
    }

    NProgress.start();
    try {
      await discussion.editDiscussion({ name, memberIds, notificationType });

      this.setState({ name: "", memberIds: [], disabled: false, notificationType: "default" });
      notify("You successfully edited Discussion.");
    } catch (error) {
      console.log(error);
      notify(error);
    } finally {
      this.setState({ disabled: false });
      NProgress.done();

      this.props.onClose();
    }
  };
}

export default observer(EditDiscussionForm);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\components\layout\index.tsx -----

import Avatar from "@mui/material/Avatar";
import Button from "@mui/material/Button";
import Grid from "@mui/material/Grid";

import Link from "next/link";
import React from "react";

import MenuWithLinks from "../common/MenuWithLinks";
import Confirmer from "../common/Confirmer";
import Notifier from "../common/Notifier";

import { Store } from "../../lib/store";
import DiscussionList from "../discussions/DiscussionList";

const styleGrid = {
  width: "100%",
  height: "100vh",
  maxWidth: "100%",
  padding: "0px 10px",
  display: "flex",
  overflow: "hidden",
};

const styleGridIsMobile = {
  width: "100%",
  height: "100vh",
  maxWidth: "100%",
  padding: "0px 0px 0px 10px",
  display: "flex",
  overflow: "hidden",
};

function LayoutWrapper({
  children,
  isMobile,
  firstGridItem,
  store,
}: {
  children: React.ReactNode;
  isMobile: boolean;
  firstGridItem: boolean;
  store: Store;
}) {
  const isThemeDark = store.currentUser ? store.currentUser.darkTheme : true;

  return (
    <React.Fragment>
      <Grid
        container
        direction="row"
        justify="flex-start"
        alignItems="stretch"
        style={isMobile ? styleGridIsMobile : styleGrid}
      >
        {firstGridItem ? (
          <Grid
            item
            sm={2}
            xs={12}
            style={{
              borderRight: "1px #707070 solid",
              justifyContent: "center",
              overflow: "hidden",
            }}
          >
            <div style={{ display: "flex", justifyContent: "space-between" }}>
              <svg
                xmlns="http://www.w3.org/2000/svg"
                width="124"
                height="40"
                viewBox="0 0 124 40"
                style={{
                  marginTop: "20px",
                  display: "inline-flex",
                  height: "40px",
                }}
              >
                <g id="async-logo">
                  <g id="async-logo-40">
                    <circle id="Ellipse 2" cx="20" cy="20" r="20" fill="black" />
                    <path
                      id="path-async-logo"
                      d="M7.07825 -0.0960007V16H4.51825V13.088C4.04892 14.0907 3.33425 14.8693 2.37425 15.424C1.43558 15.9573 0.336917 16.224 -0.92175 16.224C-2.35108 16.224 -3.60975 15.8827 -4.69775 15.2C-5.76442 14.5173 -6.59642 13.5573 -7.19375 12.32C-7.76975 11.0613 -8.05775 9.6 -8.05775 7.936C-8.05775 6.272 -7.75908 4.81067 -7.16175 3.552C-6.56442 2.272 -5.73242 1.28 -4.66575 0.576C-3.57775 -0.128 -2.32975 -0.48 -0.92175 -0.48C0.336917 -0.48 1.43558 -0.202666 2.37425 0.352C3.31292 0.906667 4.02758 1.68533 4.51825 2.688V-0.0960007H7.07825ZM-0.40975 14.08C1.16892 14.08 2.38492 13.5467 3.23825 12.48C4.09158 11.392 4.51825 9.856 4.51825 7.872C4.51825 5.888 4.09158 4.36267 3.23825 3.296C2.38492 2.22933 1.16892 1.696 -0.40975 1.696C-1.98842 1.696 -3.22575 2.25067 -4.12175 3.36C-4.99642 4.448 -5.43375 5.97333 -5.43375 7.936C-5.43375 9.89867 -4.99642 11.4133 -4.12175 12.48C-3.24708 13.5467 -2.00975 14.08 -0.40975 14.08Z"
                      transform="translate(19.5938 12)"
                      fill="white"
                    />
                  </g>
                  <path
                    id="path-async-text"
                    d="M22.6251 11.928V24H20.7051V21.816C20.3531 22.568 19.8171 23.152 19.0971 23.568C18.3931 23.968 17.5691 24.168 16.6251 24.168C15.5531 24.168 14.6091 23.912 13.7931 23.4C12.9931 22.888 12.3691 22.168 11.9211 21.24C11.4891 20.296 11.2731 19.2 11.2731 17.952C11.2731 16.704 11.4971 15.608 11.9451 14.664C12.3931 13.704 13.0171 12.96 13.8171 12.432C14.6331 11.904 15.5691 11.64 16.6251 11.64C17.5691 11.64 18.3931 11.848 19.0971 12.264C19.8011 12.68 20.3371 13.264 20.7051 14.016V11.928H22.6251ZM17.0091 22.56C18.1931 22.56 19.1051 22.16 19.7451 21.36C20.3851 20.544 20.7051 19.392 20.7051 17.904C20.7051 16.416 20.3851 15.272 19.7451 14.472C19.1051 13.672 18.1931 13.272 17.0091 13.272C15.8251 13.272 14.8971 13.688 14.2251 14.52C13.5691 15.336 13.2411 16.48 13.2411 17.952C13.2411 19.424 13.5691 20.56 14.2251 21.36C14.8811 22.16 15.8091 22.56 17.0091 22.56ZM30.4637 24.168C28.4317 24.168 26.8237 23.648 25.6397 22.608L26.2877 21.168C26.9437 21.68 27.6077 22.048 28.2797 22.272C28.9517 22.496 29.7037 22.608 30.5357 22.608C31.4477 22.608 32.1357 22.456 32.5997 22.152C33.0797 21.832 33.3197 21.376 33.3197 20.784C33.3197 20.304 33.1597 19.92 32.8397 19.632C32.5197 19.344 31.9917 19.12 31.2557 18.96L29.2157 18.48C28.2077 18.256 27.4237 17.856 26.8637 17.28C26.3197 16.704 26.0477 16.016 26.0477 15.216C26.0477 14.16 26.4717 13.304 27.3197 12.648C28.1677 11.976 29.2877 11.64 30.6797 11.64C31.5277 11.64 32.3277 11.776 33.0797 12.048C33.8317 12.32 34.4637 12.712 34.9757 13.224L34.3277 14.64C33.1917 13.696 31.9757 13.224 30.6797 13.224C29.8157 13.224 29.1437 13.392 28.6637 13.728C28.1997 14.048 27.9677 14.504 27.9677 15.096C27.9677 15.592 28.1117 15.984 28.3997 16.272C28.7037 16.56 29.1837 16.784 29.8397 16.944L31.8797 17.448C32.9997 17.704 33.8317 18.104 34.3757 18.648C34.9197 19.176 35.1917 19.872 35.1917 20.736C35.1917 21.776 34.7677 22.608 33.9197 23.232C33.0717 23.856 31.9197 24.168 30.4637 24.168ZM48.687 11.928L43.047 25.104C42.455 26.48 41.711 27.488 40.815 28.128C39.919 28.768 38.815 29.208 37.503 29.448L37.095 27.936C38.231 27.68 39.087 27.336 39.663 26.904C40.255 26.488 40.743 25.84 41.127 24.96L41.607 23.88L36.495 11.928H38.535L42.615 21.888L46.743 11.928H48.687ZM56.853 11.64C59.749 11.64 61.197 13.232 61.197 16.416V24H59.253V16.512C59.253 15.392 59.029 14.576 58.581 14.064C58.133 13.536 57.429 13.272 56.469 13.272C55.349 13.272 54.453 13.616 53.781 14.304C53.109 14.992 52.773 15.92 52.773 17.088V24H50.829V15.312C50.829 14.064 50.765 12.936 50.637 11.928H52.485L52.677 14.088C53.045 13.304 53.597 12.704 54.333 12.288C55.069 11.856 55.909 11.64 56.853 11.64ZM69.9321 24.168C68.7641 24.168 67.7401 23.912 66.8601 23.4C65.9961 22.888 65.3241 22.168 64.8441 21.24C64.3801 20.296 64.1481 19.2 64.1481 17.952C64.1481 16.704 64.3881 15.608 64.8681 14.664C65.3481 13.704 66.0281 12.96 66.9081 12.432C67.8041 11.904 68.8441 11.64 70.0281 11.64C70.8441 11.64 71.6281 11.784 72.3801 12.072C73.1481 12.344 73.7801 12.728 74.2761 13.224L73.6281 14.664C73.0201 14.184 72.4281 13.832 71.8521 13.608C71.2921 13.384 70.7161 13.272 70.1241 13.272C68.8921 13.272 67.9241 13.688 67.2201 14.52C66.5161 15.336 66.1641 16.48 66.1641 17.952C66.1641 19.408 66.5081 20.544 67.1961 21.36C67.9001 22.16 68.8761 22.56 70.1241 22.56C70.7161 22.56 71.2921 22.448 71.8521 22.224C72.4281 22 73.0201 21.648 73.6281 21.168L74.2761 22.608C73.7641 23.088 73.1161 23.472 72.3321 23.76C71.5641 24.032 70.7641 24.168 69.9321 24.168Z"
                    transform="translate(39 4)"
                    fill={isThemeDark ? "white" : "black"}
                  />
                </g>
              </svg>
              <MenuWithLinks
                options={[
                  {
                    text: "Team Settings",
                    href: `/team-settings?teamSlug=${store.currentTeam.slug}`,
                    as: `/team/${store.currentTeam.slug}/team-settings`,
                    simple: true,
                  },
                  {
                    text: "Billing",
                    href: `/billing?teamSlug=${store.currentTeam.slug}`,
                    as: `/team/${store.currentTeam.slug}/billing`,
                    simple: true,
                  },
                  {
                    text: "Your Settings",
                    href: "/your-settings",
                    highlighterSlug: "/your-settings",
                  },
                  {
                    separator: true,
                  },
                  {
                    text: "Log out",
                    href: `${process.env.NEXT_PUBLIC_URL_API}/logout`,
                    as: `${process.env.NEXT_PUBLIC_URL_API}/logout`,
                    externalServer: true,
                  },
                ]}
              >
                <Avatar
                  src={store.currentUser.avatarUrl}
                  alt="Add username here later in the book"
                  style={{
                    margin: "20px auto",
                    cursor: "pointer",
                    display: "inline-flex",
                    width: "40px",
                    height: "40px",
                  }}
                />

                <i className="material-icons" color="action" style={{ verticalAlign: "super" }}>
                  arrow_drop_down
                </i>
              </MenuWithLinks>
            </div>
            <hr />
            <p />
            <p />
            <DiscussionList store={store} team={store.currentTeam} isMobile={isMobile} />
          </Grid>
        ) : null}

        {children}
      </Grid>
      <Notifier />
      <Confirmer />
    </React.Fragment>
  );
}

type Props = {
  children: React.ReactNode;
  isMobile?: boolean;
  firstGridItem?: boolean;
  store?: Store;
  teamRequired?: boolean;
};

class Layout extends React.Component<Props> {
  public render() {
    const { children, isMobile, firstGridItem, store, teamRequired } = this.props;

    const { currentUser, currentTeam } = store;

    // console.log(this.props.store.currentUser.darkTheme);

    // const isThemeDark = false;

    // console.log(isMobile);

    // console.log(currentTeam);

    if (!currentUser) {
      return (
        <LayoutWrapper firstGridItem={firstGridItem} isMobile={isMobile} store={store}>
          <Grid item sm={12} xs={12}>
            {children}
          </Grid>
        </LayoutWrapper>
      );
    }

    if (!currentTeam) {
      if (teamRequired) {
        return (
          <LayoutWrapper firstGridItem={firstGridItem} isMobile={isMobile} store={store}>
            <Grid item sm={10} xs={12} style={{ padding: "0px 35px", overflow: "auto", height: "auto" }}>
              <div style={{ padding: "20px" }}>
                Select existing team or create a new team.
                <p />
                <Link href="/create-team" as="/create-team">
                  <Button variant="outlined" color="primary">
                    Create new team
                  </Button>
                </Link>
              </div>
            </Grid>
          </LayoutWrapper>
        );
      } else {
        console.log("team not required");
        return (
          <LayoutWrapper firstGridItem={firstGridItem} isMobile={isMobile} store={store}>
            <Grid item sm={10} xs={12} style={{ padding: "0px 35px", overflow: "auto", height: "auto" }}>
              {children}
            </Grid>
          </LayoutWrapper>
        );
      }
    }

    return (
      <LayoutWrapper firstGridItem={firstGridItem} isMobile={isMobile} store={store}>
        <Grid
          item
          sm={firstGridItem ? 10 : 12}
          xs={12}
          style={{ padding: "0px 35px", overflowY: "auto", height: "inherit" }}
        >
          <div>
            {isMobile || store.currentUrl.includes("create-team") ? null : (
              <React.Fragment>
                <i
                  style={{
                    float: "left",
                    margin: "15px 0px 10px 25px",
                    opacity: 0.8,
                    fontSize: "18px",
                    cursor: "pointer",
                    verticalAlign: "top",
                  }}
                  className="material-icons"
                  onClick={async () => {
                    await store.currentUser.toggleTheme(!store.currentUser.darkTheme);
                  }}
                >
                  lens
                </i>
              </React.Fragment>
            )}
            <div style={{ clear: "both" }} />
          </div>
          {children}
        </Grid>
      </LayoutWrapper>
    );
  }
}

export default Layout;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\components\posts\PostContent.tsx -----

import React from 'react';

type Props = { html: string };

class PostContent extends React.Component<Props> {
  public render() {
    const { html } = this.props;

    return (
      <div
        style={{ fontSize: '15px', lineHeight: '2em', fontWeight: 300, wordBreak: 'break-all' }}
        dangerouslySetInnerHTML={{ __html: html }}
      />
    );
  }
}

export default PostContent;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\components\posts\PostDetail.tsx -----

import Avatar from "@mui/material/Avatar";
import Paper from "@mui/material/Paper";
import Tooltip from "@mui/material/Tooltip";
import { observer } from "mobx-react";
import moment from "moment";
import React from "react";

import confirm from "../../lib/confirm";
import notify from "../../lib/notify";
import { Store } from "../../lib/store";
import { Post } from "../../lib/store/post";
import { User } from "../../lib/store/user";

import MenuWithMenuItems from "../common/MenuWithMenuItems";

import PostContent from "./PostContent";

const stylePaper = {
  margin: "10px 0px",
  padding: "20px",
};

const styleLineSeparator = {
  verticalAlign: "text-bottom",
  fontWeight: 300,
  fontSize: "16px",
  margin: "0px 5px",
  opacity: 0.75,
};

const getMenuOptions = (post) => ({
  dataId: post._id,
  id: `post-menu-${post._id}`,
});

const getMenuItemOptions = (post: Post, currentUser: User, component) => {
  const items = [];

  if (post.createdUserId !== currentUser._id) {
    items.push({
      text: "Show Markdown",
      dataId: post._id,
      onClick: component.showMarkdown,
    });
  }

  if (post.createdUserId === currentUser._id) {
    const isFirstPost = post.discussion.posts.indexOf(post) === 0;

    items.push({
      text: "Edit",
      dataId: post._id,
      onClick: component.editPost,
    });

    if (!isFirstPost) {
      items.push({
        text: "Delete",
        dataId: post._id,
        onClick: component.deletePost,
      });
    }
  }

  return items;
};

type Props = {
  post: Post;
  store: Store;
  isMobile: boolean;
  onEditClick: (post) => void;
  onShowMarkdownClick: (post) => void;
};

class PostDetail extends React.Component<Props> {
  public render() {
    const { post, isMobile } = this.props;

    return <Paper style={stylePaper}>{this.renderPostDetail(post, isMobile)}</Paper>;
  }

  public renderPostDetail(post: Post, isMobile) {
    const createdDate = moment(post.createdAt).local().format("MMM Do YYYY");
    const lastUpdatedDate = moment(post.lastUpdatedAt).fromNow();

    return (
      <React.Fragment>
        <div
          style={{
            float: "left",
            margin: "-12px 10px 0px -15px",
            zIndex: 1000,
          }}
        >
          {this.renderMenu()}
        </div>
        <div id={`post-${post._id}`}>
          {post.user && (
            <Tooltip title={post.user.displayName} placement="top" disableFocusListener disableTouchListener>
              <Avatar
                src={post.user.avatarUrl}
                alt={post.user.displayName}
                style={{
                  width: "40px",
                  height: "40px",
                  margin: "0px 10px 0px 5px",
                  cursor: "pointer",
                  float: "left",
                }}
              />
            </Tooltip>
          )}
          <div
            style={{
              margin: isMobile ? "0px" : "0px 20px 0px 70px",
              fontWeight: 300,
              lineHeight: "1em",
            }}
          >
            <span style={{ fontSize: "12px", fontWeight: 400 }}>
              {`By: ${post.user && post.user.displayName}` || "User"}
              <span style={styleLineSeparator}>|</span>
              {`Created: ${post.createdAt && createdDate}` || ""}

              {post.isEdited ? (
                <React.Fragment>
                  <span style={styleLineSeparator}>|</span>
                  Last edited: {lastUpdatedDate}
                </React.Fragment>
              ) : null}
            </span>

            <PostContent html={post.htmlContent} />
          </div>
        </div>
      </React.Fragment>
    );
  }

  public renderMenu() {
    const { post, store } = this.props;
    const { currentUser } = store;

    if (!post.user || !currentUser) {
      return null;
    }

    return (
      <MenuWithMenuItems
        menuOptions={getMenuOptions(post)}
        itemOptions={getMenuItemOptions(post, store.currentUser, this)}
      />
    );
  }

  public showMarkdown = () => {
    const { post, onShowMarkdownClick } = this.props;
    if (onShowMarkdownClick) {
      onShowMarkdownClick(post);
    }
  };

  public editPost = () => {
    const { post, onEditClick } = this.props;
    if (onEditClick) {
      onEditClick(post);
    }
    console.log(`PostDetail: ${post._id}`);
  };

  public deletePost = () => {
    confirm({
      title: "Are you sure?",
      message: "",
      onAnswer: async (answer) => {
        if (answer) {
          const { post } = this.props;
          await post.discussion.deletePost(post);
          notify("You successfully deleted Post.");
        }
      },
    });
  };
}

export default observer(PostDetail);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\components\posts\PostEditor.tsx -----

import Avatar from "@mui/material/Avatar";
import Button from "@mui/material/Button";
import he from "he";
import { marked } from "marked";
import { observer } from "mobx-react";
import NProgress from "nprogress";
import React from "react";
import { Mention, MentionsInput } from "react-mentions";

import {
  getSignedRequestForUploadApiMethod,
  uploadFileUsingSignedPutRequestApiMethod,
} from "../../lib/api/team-member";
import notify from "../../lib/notify";
import { resizeImage } from "../../lib/resizeImage";
import { Store } from "../../lib/store";
import { User } from "../../lib/store/user";

import PostContent from "./PostContent";

function getImageDimension(file): Promise<{ width: number; height: number }> {
  const reader = new FileReader();
  const img = new Image();

  return new Promise((resolve) => {
    reader.readAsDataURL(file);

    reader.onload = (e) => {
      img.onload = () => {
        resolve({ width: img.width, height: img.height });
      };

      img.src = e.target.result.toString();
    };
  });
}

type Props = {
  store: Store;
  onChanged: (content) => void;
  content: string;
  members: User[];
  textareaHeight?: string;
  placeholder?: string;
  parentComponent: string;
};

type State = { htmlContent: string };

class PostEditor extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      htmlContent: "",
    };
  }

  public render() {
    const { htmlContent } = this.state;
    const { content, members, store, parentComponent } = this.props;
    const { currentUser } = store;

    const membersMinusCurrentUser = members.filter((member) => member._id !== currentUser._id);

    const isThemeDark = store && store.currentUser && store.currentUser.darkTheme === true;
    const textareaBackgroundColor = isThemeDark ? "#0d1117" : "#fff";

    return (
      <div style={{ marginTop: "20px" }}>
        <div style={{ display: "inline-flex" }}>
          <Button
            onClick={this.showMarkdownContent}
            variant="text"
            style={{ fontWeight: htmlContent ? 300 : 600, color: "#58a6ff" }}
          >
            Markdown
          </Button>{" "}
          <Button
            onClick={this.showHtmlContent}
            variant="text"
            style={{ fontWeight: htmlContent ? 600 : 300, color: "#58a6ff" }}
          >
            HTML
          </Button>
        </div>

        <div style={{ display: "inline", float: "left" }}>
          <label htmlFor={"upload-file-post-editor-" + parentComponent}>
            <Button component="span">
              <i className="material-icons" style={{ fontSize: "22px", color: "#58a6ff" }}>
                insert_photo
              </i>
            </Button>
          </label>
          <input
            accept="image/*"
            name={"upload-file-post-editor-" + parentComponent}
            id={"upload-file-post-editor-" + parentComponent}
            type="file"
            style={{ display: "none" }}
            onChange={async (event) => {
              const file = event.target.files[0];
              await this.uploadFile(file);
              event.target.value = "";
            }}
          />
        </div>
        <br />
        <div
          style={{
            width: "100%",
            height: "100vh",
            padding: "10px 15px",
            border: isThemeDark ? "1px solid rgba(255, 255, 255, 0.5)" : "1px solid rgba(0, 0, 0, 0.5)",
          }}
        >
          {htmlContent ? (
            <PostContent html={htmlContent} />
          ) : (
            <MentionsInput
              style={{
                input: {
                  border: "none",
                  outline: "none",
                  color: isThemeDark ? "#fff" : "#000",
                  fontWeight: 300,
                  height: "100vh",
                  lineHeight: "1.5em",
                  backgroundColor: content ? textareaBackgroundColor : "transparent",
                },
                suggestions: {
                  list: {
                    backgroundColor: "#222",
                    color: "#fff",
                  },

                  item: {
                    padding: "5px 15px",
                    borderBottom: "1px solid rgba(0,0,0,0.15)",

                    "&focused": {
                      backgroundColor: "rgba(255, 255, 255, 0.1)",
                    },
                  },
                },
              }}
              autoFocus
              value={content}
              placeholder={this.props.placeholder ? this.props.placeholder : "Compose new post"}
              onChange={(event) => {
                this.props.onChanged(event.target.value);
              }}
            >
              <Mention
                trigger="@"
                data={membersMinusCurrentUser.map((u) => ({
                  id: u.avatarUrl,
                  display: u.displayName,
                  // you: u._id === currentUser._id ? true : false,
                }))}
                markup={"[`@#__display__`](__id__)"}
                displayTransform={(_, display) => {
                  return `@${display}`;
                }}
                renderSuggestion={(suggestion) => (
                  <React.Fragment>
                    <Avatar
                      role="presentation"
                      src={suggestion.id}
                      alt={suggestion.display}
                      style={{
                        width: "24px",
                        height: "24px",
                        marginRight: "10px",
                        display: "inline-flex",
                        verticalAlign: "middle",
                      }}
                    />
                    <span style={{ marginRight: "5px" }}>{suggestion.display}</span>
                  </React.Fragment>
                )}
              />
            </MentionsInput>
          )}
        </div>
      </div>
    );
  }

  public showMarkdownContent = () => {
    this.setState({ htmlContent: "" });
  };

  public showHtmlContent = async () => {
    const { content } = this.props;

    function markdownToHtml(postContent) {
      const renderer = new marked.Renderer();

      renderer.link = (href, title, text) => {
        const t = title ? ` title="${title}"` : "";

        if (text.startsWith("<code>@#")) {
          return `${text.replace("<code>@#", "<code>@")} `;
        }

        return `
          <a target="_blank" href="${href}" rel="noopener noreferrer"${t}>
            ${text}
          </a>
        `;
      };

      marked.setOptions({
        renderer,
        breaks: true,
      });

      return marked(he.decode(postContent));
    }

    const htmlContent = content ? markdownToHtml(content) : "<span>Nothing to preview.</span>";
    this.setState({ htmlContent });
  };

  private uploadFile = async (file: File) => {
    if (!file) {
      notify("No file selected.");
      return;
    }

    if (!file.type || (!file.type.startsWith("image/") && file.type !== "application/pdf")) {
      notify("Wrong file.");
      return;
    }

    const { store } = this.props;
    const { currentTeam } = store;

    NProgress.start();

    const bucket = process.env.NEXT_PUBLIC_BUCKET_FOR_POSTS;
    const prefix = `${currentTeam.slug}`;
    const fileName = file.name;
    const fileType = file.type;

    try {
      const responseFromApiServerForUpload = await getSignedRequestForUploadApiMethod({
        fileName,
        fileType,
        prefix,
        bucket,
      });

      let fileHtmlOrMarkdown;
      let fileUrl;

      if (file.type.startsWith("image/")) {
        const { width } = await getImageDimension(file);
        const resizedFile = await resizeImage(file, 1024, 1024);

        await uploadFileUsingSignedPutRequestApiMethod(resizedFile, responseFromApiServerForUpload.signedRequest);

        fileUrl = responseFromApiServerForUpload.url;

        console.log(fileUrl);

        const finalWidth = width > 768 ? "100%" : `${width}px`;

        fileHtmlOrMarkdown = `
          <div>
            <img style="max-width: ${finalWidth}; width:100%" src="${fileUrl}" alt="Async" class="s3-image" />
          </div>`;
      } else {
        await uploadFileUsingSignedPutRequestApiMethod(file, responseFromApiServerForUpload.signedRequest);

        fileUrl = responseFromApiServerForUpload.url;
        fileHtmlOrMarkdown = `[${file.name}](${fileUrl})`;
      }

      const content = `${this.props.content}\n${fileHtmlOrMarkdown.replace(/\s+/g, " ")}`;

      this.props.onChanged(content);

      notify("You successfully uploaded file.");
    } catch (error) {
      console.log(error);
      notify(error);
    } finally {
      NProgress.done();
    }
  };
}

export default observer(PostEditor);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\components\posts\PostForm.tsx -----

import Button from "@mui/material/Button";
import he from "he";
import { marked } from "marked";
import { observer } from "mobx-react";
import NProgress from "nprogress";
import React from "react";

import notify from "../../lib/notify";
import { Store } from "../../lib/store";
import { Discussion } from "../../lib/store/discussion";
import { Post } from "../../lib/store/post";
import { User } from "../../lib/store/user";

import PostEditor from "./PostEditor";

type Props = {
  store: Store;
  isMobile: boolean;
  members: User[];
  post: Post;
  discussion: Discussion;
  showMarkdownToNonCreator?: boolean;
  onFinished?: () => void;
};

type State = {
  postId: string;
  content: string;
  disabled: boolean;
};

class PostForm extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      postId: null,
      content: "",
      disabled: false,
    };
  }

  public static getDerivedStateFromProps(props: Props, state: State) {
    const { post } = props;

    if (!post && !state.postId) {
      return null;
    }

    if (post && post._id === state.postId) {
      return null;
    }

    return {
      postId: (post && post._id) || null,
      content: (post && post.content) || "",
    };
  }

  public render() {
    const { store, members, post, isMobile, showMarkdownToNonCreator } = this.props;
    const isEditingPost = !!post;

    let title = "Add Post";
    if (showMarkdownToNonCreator) {
      title = "Showing Markdown";
    } else if (isEditingPost) {
      title = "Edit Post";
    }

    return (
      <div style={{ height: "100%", margin: "0px 20px" }}>
        <p />
        <br />
        <h3>{title}</h3>
        <form style={{ width: "100%", height: "100%" }} onSubmit={this.onSubmit} autoComplete="off">
          <p />
          <br />
          <div>
            {showMarkdownToNonCreator ? null : (
              <React.Fragment>
                <Button type="submit" variant="contained" color="primary" disabled={this.state.disabled}>
                  {isEditingPost ? "Save changes" : "Publish Post"}
                </Button>
                {isMobile ? <p /> : null}
              </React.Fragment>
            )}
            {isEditingPost ? (
              <Button
                variant="outlined"
                onClick={this.closeForm}
                disabled={this.state.disabled}
                style={{ marginLeft: "10px" }}
              >
                {showMarkdownToNonCreator ? "Go back" : "Cancel"}
              </Button>
            ) : null}
          </div>
          <p />
          <br />
          <PostEditor
            content={this.state.content}
            onChanged={this.onContentChanged}
            members={members}
            store={store}
            textareaHeight="100%"
            parentComponent="PF"
          />
          <p />
          <div style={{ margin: "20px 0px" }}>
            {isEditingPost ? (
              <Button
                variant="outlined"
                onClick={this.closeForm}
                disabled={this.state.disabled}
                style={{ marginLeft: "10px" }}
              >
                {showMarkdownToNonCreator ? "Go back" : "Cancel"}
              </Button>
            ) : null}
          </div>
          <p />
          <br />
        </form>
      </div>
    );
  }

  private onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();

    const { content } = this.state;
    const htmlContent = marked(he.decode(content));
    const { post, onFinished, store, discussion } = this.props;
    const isEditingPost = !!post;

    if (!content) {
      notify("Add content to your Post");
      return;
    }

    if (isEditingPost) {
      this.setState({ disabled: true });
      NProgress.start();
      try {
        await post.editPost({ content, htmlContent });
        notify("You successfully edited Post");
      } catch (error) {
        console.log(error);
        notify(error);
      } finally {
        this.setState({ disabled: false });
        NProgress.done();
      }

      if (onFinished) {
        onFinished();
      }

      return;
    }

    const { currentTeam } = store;
    if (!currentTeam) {
      notify("Team is not selected or does not exist.");
      return;
    }

    NProgress.start();
    this.setState({ disabled: true });

    try {
      const post = await discussion.addPost(content);

      if (discussion.notificationType === "email") {
        const userIdsForLambda = discussion.memberIds.filter((m) => m !== store.currentUser._id);

        await discussion.sendDataToLambda({
          discussionName: discussion.name,
          discussionLink: `${process.env.NEXT_PUBLIC_URL_APP}/team/${discussion.team.slug}/discussions/${discussion.slug}`,
          postContent: post.content,
          authorName: post.user.displayName,
          userIds: userIdsForLambda,
        });
      }

      this.setState({ content: "" });

      notify("You successfully published new Post.");
    } catch (error) {
      console.log(error);
      notify(error);
    } finally {
      this.setState({ disabled: false });
      NProgress.done();
    }

    if (onFinished) {
      onFinished();
    }
  };

  private onContentChanged = (content: string) => {
    this.setState({ content });
  };

  private closeForm = () => {
    this.setState({ postId: null, content: "" });

    const { onFinished } = this.props;
    if (onFinished) {
      onFinished();
    }
  };
}

export default observer(PostForm);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\components\teams\InviteMember.tsx -----

import Button from "@mui/material/Button";
import Dialog from "@mui/material/Dialog";
import DialogContent from "@mui/material/DialogContent";
import DialogTitle from "@mui/material/DialogTitle";
import TextField from "@mui/material/TextField";
import { inject, observer } from "mobx-react";
import NProgress from "nprogress";
import React from "react";

import notify from "../../lib/notify";
import { Store } from "../../lib/store";

type Props = {
  store: Store;
  onClose: () => void;
  open: boolean;
};

type State = {
  email: string;
  disabled: boolean;
};

class InviteMember extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      email: "",
      disabled: false,
    };
  }

  public render() {
    const { open } = this.props;

    return (
      <Dialog onClose={this.handleClose} aria-labelledby="invite-member-dialog-title" open={open}>
        <DialogTitle id="invite-member-dialog-title">Invite member</DialogTitle>
        <DialogContent>
          <form onSubmit={this.onSubmit} style={{ padding: "20px" }}>
            <TextField
              autoComplete="off"
              value={this.state.email}
              placeholder="Email"
              onChange={(event) => {
                this.setState({ email: event.target.value });
              }}
            />
            <p />
            <br />
            <Button variant="outlined" onClick={this.handleClose} disabled={this.state.disabled}>
              Cancel
            </Button>{" "}
            <Button type="submit" variant="contained" color="primary" disabled={this.state.disabled}>
              Invite
            </Button>
          </form>
        </DialogContent>
      </Dialog>
    );
  }

  private handleClose = () => {
    this.setState({ email: "", disabled: false });
    this.props.onClose();
  };

  private onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();

    const { store } = this.props;

    if (!store.currentTeam) {
      notify("Team have not selected");
      return;
    }

    const { email } = this.state;

    if (!email) {
      notify("Email is required");
      return;
    }

    NProgress.start();
    try {
      this.setState({ disabled: true });
      await store.currentTeam.inviteMember(email);

      this.setState({ email: "" });
      notify("You successfully sent invitation.");
      NProgress.done();
    } catch (error) {
      console.log(error);
      notify(error);
    } finally {
      this.props.onClose();
      this.setState({ disabled: false });
      NProgress.done();
    }
  };
}

export default inject("store")(observer(InviteMember));

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\lib\api\makeQueryString.ts -----

function makeQueryString(params) {
  const query = Object.keys(params)
    .filter((k) => !!params[k])
    .map((k) => `${encodeURIComponent(k)}=${encodeURIComponent(params[k])}`)
    .join('&');

  return query;
}

export { makeQueryString };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\lib\api\public.ts -----

import sendRequestAndGetResponse from './sendRequestAndGetResponse';

const BASE_PATH = '/api/v1/public';

export const getUserApiMethod = (request) =>
  sendRequestAndGetResponse(`${BASE_PATH}/get-user`, {
    request,
    method: 'GET',
  });

export const getUserBySlugApiMethod = (slug) =>
  sendRequestAndGetResponse(`${BASE_PATH}/get-user-by-slug`, {
    body: JSON.stringify({ slug }),
  });

export const emailLoginLinkApiMethod = ({
  email,
  invitationToken,
}: {
  email: string;
  invitationToken?: string;
}) =>
  sendRequestAndGetResponse('/auth/email-login-link', {
    qs: { invitationToken },
    body: JSON.stringify({ user: email }),
  });

export const getTeamByTokenApiMethod = (token: string, request) =>
  sendRequestAndGetResponse(`${BASE_PATH}/invitations/get-team-by-token`, {
    request,
    method: 'GET',
    qs: { token },
  });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\lib\api\sendRequestAndGetResponse.ts -----

import 'isomorphic-unfetch';

import { makeQueryString } from './makeQueryString';

export default async function sendRequestAndGetResponse(path, opts: any = {}) {
  const headers = Object.assign(
    {},
    opts.headers || {},
    opts.externalServer
      ? {}
      : {
          'Content-type': 'application/json; charset=UTF-8',
        },
  );

  const { request } = opts;

  if (request && request.headers && request.headers.cookie) {
    headers.cookie = request.headers.cookie;
  }

  // const qs = opts.qs || '';

  const qs = (opts.qs && `?${makeQueryString(opts.qs)}`) || '';

  // console.log(`before: ${process.env.NEXT_PUBLIC_URL_API}${path}${qs}`);

  const response = await fetch(
    opts.externalServer ? `${path}${qs}` : `${process.env.NEXT_PUBLIC_URL_API}${path}${qs}`,
    Object.assign({ method: 'POST', credentials: 'include' }, opts, { headers }),
  );

  // console.log(`after: ${process.env.NEXT_PUBLIC_URL_API}${path}${qs}`);

  // console.log(response.status);
  // console.log(response.statusText);

  const text = await response.text();

  if (response.status >= 400) {
    console.error(text);
    throw new Error(response.status.toString());
  }

  try {
    const data = JSON.parse(text);

    return data;
  } catch (err) {
    if (err instanceof SyntaxError) {
      return text;
    }

    throw err;
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\lib\api\team-leader.ts -----

import sendRequestAndGetResponse from './sendRequestAndGetResponse';

const BASE_PATH = '/api/v1/team-leader';

export const addTeamApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams/add`, {
    body: JSON.stringify(data),
  });

export const updateTeamApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams/update`, {
    body: JSON.stringify(data),
  });

export const getTeamInvitationsApiMethod = (teamId: string) =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams/get-invitations-for-team`, {
    method: 'GET',
    qs: { teamId },
  });

export const inviteMemberApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams/invite-member`, {
    body: JSON.stringify(data),
  });

export const removeMemberApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams/remove-member`, {
    body: JSON.stringify(data),
  });

export const fetchCheckoutSessionApiMethod = ({ mode, teamId }: { mode: string; teamId: string }) =>
  sendRequestAndGetResponse(`${BASE_PATH}/stripe/fetch-checkout-session`, {
    body: JSON.stringify({ mode, teamId }),
  });

export const cancelSubscriptionApiMethod = ({ teamId }: { teamId: string }) =>
  sendRequestAndGetResponse(`${BASE_PATH}/cancel-subscription`, {
    body: JSON.stringify({ teamId }),
  });

export const getListOfInvoicesApiMethod = () =>
  sendRequestAndGetResponse(`${BASE_PATH}/get-list-of-invoices-for-customer`, {
    method: 'GET',
  });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\lib\api\team-member.ts -----

import sendRequestAndGetResponse from './sendRequestAndGetResponse';

const BASE_PATH = '/api/v1/team-member';

export const getSignedRequestForUploadApiMethod = ({ fileName, fileType, prefix, bucket }) =>
  sendRequestAndGetResponse(`${BASE_PATH}/aws/get-signed-request-for-upload-to-s3`, {
    body: JSON.stringify({ fileName, fileType, prefix, bucket }),
  });

export const uploadFileUsingSignedPutRequestApiMethod = (file, signedRequest, headers = {}) =>
  sendRequestAndGetResponse(signedRequest, {
    externalServer: true,
    method: 'PUT',
    body: file,
    headers,
  });

export const updateProfileApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/user/update-profile`, {
    body: JSON.stringify(data),
  });

export const toggleThemeApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/user/toggle-theme`, {
    body: JSON.stringify(data),
  });

export const getInitialDataApiMethod = (options: any = {}) =>
  sendRequestAndGetResponse(
    `${BASE_PATH}/get-initial-data`,
    Object.assign(
      {
        body: JSON.stringify(options.data || {}),
      },
      options,
    ),
  );

export const getTeamListApiMethod = () =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams`, {
    method: 'GET',
  });

export const getTeamMembersApiMethod = (teamId: string) =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams/get-members`, {
    method: 'GET',
    qs: { teamId },
  });

// Discussion and Post

export const getDiscussionListApiMethod = (params): Promise<{ discussions: any[] }> =>
  sendRequestAndGetResponse(`${BASE_PATH}/discussions/list`, {
    method: 'GET',
    qs: params,
  });

export const addDiscussionApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/discussions/add`, {
    body: JSON.stringify(data),
  });

export const editDiscussionApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/discussions/edit`, {
    body: JSON.stringify(data),
  });

export const deleteDiscussionApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/discussions/delete`, {
    body: JSON.stringify(data),
  });

export const getPostListApiMethod = (discussionId: string) =>
  sendRequestAndGetResponse(`${BASE_PATH}/posts/list`, {
    method: 'GET',
    qs: { discussionId },
  });

export const addPostApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/posts/add`, {
    body: JSON.stringify(data),
  });

export const editPostApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/posts/edit`, {
    body: JSON.stringify(data),
  });

export const deletePostApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/posts/delete`, {
    body: JSON.stringify(data),
  });

export const sendDataToLambdaApiMethod = (data) =>
  sendRequestAndGetResponse(`${process.env.NEXT_PUBLIC_API_GATEWAY_ENDPOINT}/`, {
    externalServer: true,
    body: JSON.stringify(data),
  });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\lib\store\discussion.ts -----

import { action, decorate, IObservableArray, observable, runInAction, computed } from 'mobx';

import {
  addPostApiMethod,
  deletePostApiMethod,
  editDiscussionApiMethod,
  getPostListApiMethod,
  sendDataToLambdaApiMethod,
} from '../api/team-member';
import { Store } from './index';
import { Team } from './team';
import { Post } from './post';

class Discussion {
  public _id: string;
  public createdUserId: string;
  public store: Store;
  public team: Team;

  public name: string;
  public slug: string;
  public memberIds: IObservableArray<string> = observable([]);
  public posts: IObservableArray<Post> = observable([]);
  public isLoadingPosts = false;

  public notificationType: string;

  constructor(params) {
    this._id = params._id;
    this.createdUserId = params.createdUserId;
    this.store = params.store;
    this.team = params.team;

    this.name = params.name;
    this.slug = params.slug;
    this.memberIds.replace(params.memberIds || []);

    this.notificationType = params.notificationType;

    if (params.initialPosts) {
      this.setInitialPosts(params.initialPosts);
      console.log(params.initialPosts[0]);
    } else {
      this.loadPosts();
    }
  }

  public async editDiscussion(data) {
    try {
      await editDiscussionApiMethod({
        id: this._id,
        ...data,
        socketId: (this.store.socket && this.store.socket.id) || null,
      });

      runInAction(() => {
        this.changeLocalCache(data);
      });
    } catch (error) {
      console.error(error);
      throw error;
    }
  }

  public changeLocalCache(data) {
    this.name = data.name;
    this.memberIds.replace(data.memberIds || []);
  }

  get members() {
    return this.memberIds.map((id) => this.team.members.get(id)).filter((u) => !!u);
  }

  public setInitialPosts(posts) {
    const postObjs = posts.map((p) => new Post({ discussion: this, store: this.store, ...p }));
    this.posts.replace(postObjs);
  }

  public async loadPosts() {
    if (this.store.isServer || this.isLoadingPosts) {
      return;
    }

    this.isLoadingPosts = true;

    try {
      const { posts = [] } = await getPostListApiMethod(this._id);

      runInAction(() => {
        const postObjs = posts.map((t) => new Post({ discussion: this, store: this.store, ...t }));
        this.posts.replace(postObjs);
      });
    } finally {
      runInAction(() => {
        this.isLoadingPosts = false;
      });
    }
  }

  public async addPost(content: string): Promise<Post> {
    const { post } = await addPostApiMethod({
      discussionId: this._id,
      content,
      socketId: (this.store.socket && this.store.socket.id) || null,
    });

    return new Promise<Post>((resolve) => {
      runInAction(() => {
        const obj = this.addPostToLocalCache(post);
        resolve(obj);
      });
    });
  }

  public addPostToLocalCache(data) {
    const postObj = new Post({ discussion: this, store: this.store, ...data });

    this.posts.push(postObj);

    return postObj;
  }

  public async deletePost(post: Post) {
    await deletePostApiMethod({
      id: post._id,
      discussionId: this._id,
      socketId: (this.store.socket && this.store.socket.id) || null,
    });

    runInAction(() => {
      this.posts.remove(post);
    });
  }

  public joinSocketRooms() {
    if (this.store.socket) {
      console.log('joining socket discussion room', this.name);
      this.store.socket.emit('joinTeamRoom', this.team._id);
      this.store.socket.emit('joinDiscussionRoom', this._id);
    }
  }

  public leaveSocketRooms() {
    if (this.store.socket) {
      console.log('leaving socket discussion room', this.name);
      this.store.socket.emit('leaveTeamRoom', this.team._id);
      this.store.socket.emit('leaveDiscussionRoom', this._id);
    }
  }

  public handleDiscussionRealtimeEvent = (data) => {
    console.log('discussion realtime event', data);
    const { actionType } = data;

    if (actionType === 'added') {
      this.addDiscussionToLocalCache(data.discussion);
    } else if (actionType === 'edited') {
      this.editDiscussionFromLocalCache(data.discussion);
    } else if (actionType === 'deleted') {
      this.deleteDiscussionFromLocalCache(data.id);
    }
  };

  public addDiscussionToLocalCache(data): Discussion {
    const obj = new Discussion({ team: this.team, store: this.store, ...data });

    if (obj.memberIds.includes(this.store.currentUser._id)) {
      this.team.discussions.push(obj);
    }

    return obj;
  }

  public editDiscussionFromLocalCache(data) {
    const discussion = this.team.discussions.find((item) => item._id === data._id);
    if (discussion) {
      if (data.memberIds && data.memberIds.includes(this.store.currentUser._id)) {
        discussion.changeLocalCache(data);
      } else {
        this.deleteDiscussionFromLocalCache(data._id);
      }
    } else if (data.memberIds && data.memberIds.includes(this.store.currentUser._id)) {
      this.addDiscussionToLocalCache(data);
    }
  }

  public deleteDiscussionFromLocalCache(discussionId: string) {
    const discussion = this.team.discussions.find((item) => item._id === discussionId);
    this.team.discussions.remove(discussion);
  }

  public handlePostRealtimeEvent(data) {
    const { actionType } = data;

    if (actionType === 'added') {
      this.addPostToLocalCache(data.post);
    } else if (actionType === 'edited') {
      this.editPostFromLocalCache(data.post);
    } else if (actionType === 'deleted') {
      this.deletePostFromLocalCache(data.id);
    }
  }

  public editPostFromLocalCache(data) {
    const post = this.posts.find((t) => t._id === data._id);
    if (post) {
      post.changeLocalCache(data);
    }
  }

  public deletePostFromLocalCache(postId) {
    const post = this.posts.find((t) => t._id === postId);
    this.posts.remove(post);
  }

  public async sendDataToLambda({
    discussionName,
    discussionLink,
    postContent,
    authorName,
    userIds,
  }) {
    console.log(discussionName, discussionLink, authorName, postContent, userIds);
    try {
      await sendDataToLambdaApiMethod({
        discussionName,
        discussionLink,
        postContent,
        authorName,
        userIds,
      });
    } catch (error) {
      console.error(error);
      throw error;
    }
  }
}

decorate(Discussion, {
  name: observable,
  slug: observable,
  memberIds: observable,
  posts: observable,
  isLoadingPosts: observable,

  editDiscussion: action,
  changeLocalCache: action,

  setInitialPosts: action,
  loadPosts: action,
  addPost: action,
  addPostToLocalCache: action,
  deletePost: action,

  addDiscussionToLocalCache: action,
  editDiscussionFromLocalCache: action,
  deleteDiscussionFromLocalCache: action,
  editPostFromLocalCache: action,
  deletePostFromLocalCache: action,

  members: computed,
});

export { Discussion };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\lib\store\index.ts -----

import * as mobx from 'mobx';
import { action, decorate, IObservableArray, observable } from 'mobx';
import { useStaticRendering } from 'mobx-react';
// @ts-expect-error no exported member io socket.io-client
import { io } from 'socket.io-client';

import { addTeamApiMethod, getTeamInvitationsApiMethod } from '../api/team-leader';
import { getTeamListApiMethod, getTeamMembersApiMethod } from '../api/team-member';

import { User } from './user';
import { Team } from './team';

useStaticRendering(typeof window === 'undefined');

mobx.configure({ enforceActions: 'observed' });

class Store {
  public isServer: boolean;

  public currentUser?: User = null;
  public currentUrl = '';

  public currentTeam?: Team;

  public teams: IObservableArray<Team> = observable([]);

  public socket: SocketIOClient.Socket;

  constructor({
    initialState = {},
    isServer,
    socket = null,
  }: {
    initialState?: any;
    isServer: boolean;
    socket?: SocketIOClient.Socket;
  }) {
    this.isServer = !!isServer;

    this.setCurrentUser(initialState.user);

    this.currentUrl = initialState.currentUrl || '';

    // console.log(initialState.user);

    if (initialState.teamSlug || (initialState.user && initialState.user.defaultTeamSlug)) {
      this.setCurrentTeam(
        initialState.teamSlug || initialState.user.defaultTeamSlug,
        initialState.teams,
      );
    }

    if (initialState.teams && initialState.teams.length > 0) {
      this.setInitialTeamsStoreMethod(initialState.teams);
    }

    this.socket = socket;

    if (socket) {
      socket.on('disconnect', () => {
        console.log('socket: ## disconnected');
      });

      socket.on('reconnect', (attemptNumber) => {
        console.log('socket: $$ reconnected', attemptNumber);
      });
    }
  }

  public changeCurrentUrl(url: string) {
    this.currentUrl = url;
  }

  public async setCurrentUser(user) {
    if (user) {
      this.currentUser = new User({ store: this, ...user });
    } else {
      this.currentUser = null;
    }
  }

  public async addTeam({ name, avatarUrl }: { name: string; avatarUrl: string }): Promise<Team> {
    const data = await addTeamApiMethod({ name, avatarUrl });
    const team = new Team({ store: this, ...data });

    return team;
  }

  public async setCurrentTeam(slug: string, initialTeams: any[]) {
    if (this.currentTeam) {
      if (this.currentTeam.slug === slug) {
        return;
      }
    }

    let found = false;

    const teams = initialTeams || (await getTeamListApiMethod()).teams;

    for (const team of teams) {
      if (team.slug === slug) {
        found = true;
        this.currentTeam = new Team({ ...team, store: this });

        const users =
          team.initialMembers || (await getTeamMembersApiMethod(this.currentTeam._id)).users;

        const invitations =
          team.initialInvitations ||
          (await getTeamInvitationsApiMethod(this.currentTeam._id)).invitations;

        this.currentTeam.setInitialMembersAndInvitations(users, invitations);

        break;
      }
    }

    if (!found) {
      this.currentTeam = null;
    }
  }

  private setInitialTeamsStoreMethod(teams: any[]) {
    // console.log(initialTeams);

    const teamObjs = teams.map((t) => new Team({ store: this, ...t }));

    this.teams.replace(teamObjs);
  }
}

decorate(Store, {
  currentUser: observable,
  currentUrl: observable,
  currentTeam: observable,

  changeCurrentUrl: action,
  setCurrentUser: action,
  setCurrentTeam: action,
});

let store: Store = null;

function initializeStore(initialState = {}) {
  const isServer = typeof window === 'undefined';

  const socket = isServer
    ? null
    : io(process.env.NEXT_PUBLIC_URL_API, {
        reconnection: true,
        autoConnect: true,
        transports: ['polling', 'websocket'],
        withCredentials: true,
      });

  const _store =
    store !== null && store !== undefined ? store : new Store({ initialState, isServer, socket });

  // For SSG and SSR always create a new store
  if (typeof window === 'undefined') {
    return _store;
  }
  // Create the store once in the client
  if (!store) {
    store = _store;
  }

  // console.log(_store);

  return _store;
}

function getStore() {
  return store;
}

export { Store, initializeStore, getStore };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\lib\store\invitation.ts -----

class Invitation {
  public _id: string;
  public teamId: string;
  public email: string;
  public createdAt: Date;

  constructor(params) {
    Object.assign(this, params);
  }
}

export { Invitation };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\lib\store\post.ts -----

import { action, computed, decorate, observable, runInAction } from 'mobx';

import { editPostApiMethod } from '../api/team-member';

import { Store } from './index';
import { User } from './user';
import { Discussion } from './discussion';

export class Post {
  public _id: string;
  public createdUserId: string;
  public createdAt: Date;
  public discussionId: string;

  public discussion: Discussion;
  public store: Store;

  public content: string;
  public htmlContent: string;

  public isEdited: boolean;
  public lastUpdatedAt: Date;

  constructor(params) {
    this._id = params._id;
    this.createdUserId = params.createdUserId;
    this.createdAt = params.createdAt;
    this.discussionId = params.discussionId;

    this.content = params.content;
    this.htmlContent = params.htmlContent;

    this.discussion = params.discussion;
    this.store = params.store;

    this.isEdited = params.isEdited;
    this.lastUpdatedAt = params.lastUpdatedAt;
  }

  public async editPost(data) {
    try {
      await editPostApiMethod({
        id: this._id,
        content: data.content,
        socketId: (this.store.socket && this.store.socket.id) || null,
      });

      runInAction(() => {
        this.changeLocalCache(data);
      });
    } catch (error) {
      console.error(error);
      throw error;
    }
  }

  public changeLocalCache(data) {
    this.content = data.content;
    this.htmlContent = data.htmlContent;
    this.isEdited = true;
    this.lastUpdatedAt = data.lastUpdatedAt;
  }

  get user(): User {
    return this.discussion.team.members.get(this.createdUserId) || null;
  }
}

decorate(Post, {
  content: observable,
  htmlContent: observable,
  isEdited: observable,
  lastUpdatedAt: observable,

  editPost: action,
  changeLocalCache: action,

  user: computed,
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\lib\store\team.ts -----

import { action, computed, decorate, IObservableArray, observable, runInAction } from 'mobx';
import Router from 'next/router';
import {
  cancelSubscriptionApiMethod,
  inviteMemberApiMethod,
  removeMemberApiMethod,
  updateTeamApiMethod,
} from '../api/team-leader';
import {
  addDiscussionApiMethod,
  deleteDiscussionApiMethod,
  getDiscussionListApiMethod,
} from '../api/team-member';
import { Store } from './index';
import { User } from './user';
import { Invitation } from './invitation';
import { Discussion } from './discussion';

class Team {
  public store: Store;

  public _id: string;
  public teamLeaderId: string;

  public name: string;
  public slug: string;
  public avatarUrl: string;
  public memberIds: IObservableArray<string> = observable([]);
  public members: Map<string, User> = new Map();
  public invitations: Map<string, Invitation> = new Map();

  public currentDiscussion?: Discussion;
  public currentDiscussionSlug?: string;
  public discussions: IObservableArray<Discussion> = observable([]);
  public isLoadingDiscussions = false;

  public stripeSubscription: {
    id: string;
    object: string;
    application_fee_percent: number;
    billing: string;
    cancel_at_period_end: boolean;
    billing_cycle_anchor: number;
    canceled_at: number;
    created: number;
  };
  public isSubscriptionActive: boolean;
  public isPaymentFailed: boolean;

  constructor(params) {
    this._id = params._id;
    this.teamLeaderId = params.teamLeaderId;
    this.slug = params.slug;
    this.name = params.name;
    this.avatarUrl = params.avatarUrl;
    this.memberIds.replace(params.memberIds || []);
    this.currentDiscussionSlug = params.currentDiscussionSlug || null;

    this.stripeSubscription = params.stripeSubscription;
    this.isSubscriptionActive = params.isSubscriptionActive;
    this.isPaymentFailed = params.isPaymentFailed;

    this.store = params.store;

    if (params.initialDiscussions) {
      this.setInitialDiscussions(params.initialDiscussions);
    } else {
      this.loadDiscussions();
    }
  }

  public setInitialMembersAndInvitations(users, invitations) {
    this.members.clear();
    this.invitations.clear();

    for (const user of users) {
      if (this.store.currentUser && this.store.currentUser._id === user._id) {
        this.members.set(user._id, this.store.currentUser);
      } else {
        this.members.set(user._id, new User(user));
      }
    }

    for (const invitation of invitations || []) {
      this.invitations.set(invitation._id, new Invitation(invitation));
    }

    // console.log(this.members);
  }

  public async updateTheme({ name, avatarUrl }: { name: string; avatarUrl: string }) {
    try {
      const { slug } = await updateTeamApiMethod({
        teamId: this._id,
        name,
        avatarUrl,
      });

      runInAction(() => {
        this.name = name;
        this.avatarUrl = avatarUrl;
        this.slug = slug;
      });
    } catch (error) {
      console.error(error);
      throw error;
    }
  }

  public async inviteMember(email: string) {
    try {
      const { newInvitation } = await inviteMemberApiMethod({ teamId: this._id, email });

      runInAction(() => {
        this.invitations.set(newInvitation._id, new Invitation(newInvitation));
      });
    } catch (error) {
      console.error(error);
      throw error;
    }
  }

  public async removeMember(userId: string) {
    try {
      await removeMemberApiMethod({ teamId: this._id, userId });

      runInAction(() => {
        this.members.delete(userId);
        this.memberIds.remove(userId);
      });
    } catch (error) {
      console.error(error);
      throw error;
    }
  }

  public setCurrentDiscussion({ slug }: { slug: string }) {
    this.currentDiscussionSlug = slug;
    for (const discussion of this.discussions) {
      if (discussion && discussion.slug === slug) {
        this.currentDiscussion = discussion;
        break;
      }
    }
  }

  public setInitialDiscussions(discussions) {
    const discussionObjs = discussions.map(
      (d) => new Discussion({ team: this, store: this.store, ...d }),
    );

    this.discussions.replace(discussionObjs);

    if (!this.currentDiscussionSlug && this.discussions.length > 0) {
      this.currentDiscussionSlug = this.orderedDiscussions[0].slug;
    }

    if (this.currentDiscussionSlug) {
      this.setCurrentDiscussion({ slug: this.currentDiscussionSlug });
    }
  }

  public async loadDiscussions() {
    if (this.store.isServer || this.isLoadingDiscussions) {
      return;
    }

    this.isLoadingDiscussions = true;

    try {
      const { discussions = [] } = await getDiscussionListApiMethod({
        teamId: this._id,
      });
      const newList: Discussion[] = [];

      runInAction(() => {
        discussions.forEach((d) => {
          const disObj = this.discussions.find((obj) => obj._id === d._id);
          if (disObj) {
            disObj.changeLocalCache(d);
            newList.push(disObj);
          } else {
            newList.push(new Discussion({ team: this, store: this.store, ...d }));
          }
        });

        this.discussions.replace(newList);
      });
    } finally {
      runInAction(() => {
        this.isLoadingDiscussions = false;
      });
    }
  }

  public changeLocalCache(data) {
    this.name = data.name;
    this.memberIds.replace(data.memberIds || []);
  }

  public async addDiscussion(data): Promise<Discussion> {
    const { discussion } = await addDiscussionApiMethod({
      teamId: this._id,
      socketId: (this.store.socket && this.store.socket.id) || null,
      ...data,
    });

    return new Promise<Discussion>((resolve) => {
      runInAction(() => {
        const obj = this.addDiscussionToLocalCache(discussion);
        resolve(obj);
      });
    });
  }

  public addDiscussionToLocalCache(data): Discussion {
    const obj = new Discussion({ team: this, store: this.store, ...data });

    if (obj.memberIds.includes(this.store.currentUser._id)) {
      this.discussions.push(obj);
    }

    return obj;
  }

  public async deleteDiscussion(id: string) {
    await deleteDiscussionApiMethod({
      id,
      socketId: (this.store.socket && this.store.socket.id) || null,
    });

    runInAction(() => {
      this.deleteDiscussionFromLocalCache(id);

      const discussion = this.discussions.find((d) => d._id === id);

      if (this.currentDiscussion === discussion) {
        this.currentDiscussion = null;
        this.currentDiscussionSlug = null;

        if (this.discussions.length > 0) {
          const d = this.discussions[0];

          Router.push(
            `/discussion?teamSlug=${this.slug}&discussionSlug=${d.slug}`,
            `/team/${this.slug}/discussions/${d.slug}`,
          );
        } else {
          Router.push(`/discussion?teamSlug=${this.slug}`, `/team/${this.slug}/discussions`);
        }
      }
    });
  }

  public deleteDiscussionFromLocalCache(discussionId: string) {
    const discussion = this.discussions.find((item) => item._id === discussionId);
    this.discussions.remove(discussion);
  }

  public getDiscussionBySlug(slug: string): Discussion {
    return this.discussions.find((d) => d.slug === slug);
  }

  public async cancelSubscription({ teamId }: { teamId: string }) {
    try {
      const { isSubscriptionActive } = await cancelSubscriptionApiMethod({ teamId });

      runInAction(() => {
        this.isSubscriptionActive = isSubscriptionActive;
      });
    } catch (error) {
      console.error(error);
      throw error;
    }
  }

  public async checkIfTeamLeaderMustBeCustomer() {
    let ifTeamLeaderMustBeCustomerOnClient: boolean;

    if (this && this.memberIds.length < 2) {
      ifTeamLeaderMustBeCustomerOnClient = false;
    } else if (this && this.memberIds.length >= 2 && this.isSubscriptionActive) {
      ifTeamLeaderMustBeCustomerOnClient = false;
    } else if (this && this.memberIds.length >= 2 && !this.isSubscriptionActive) {
      ifTeamLeaderMustBeCustomerOnClient = true;
    }

    return ifTeamLeaderMustBeCustomerOnClient;
  }

  get orderedDiscussions() {
    return this.discussions.slice().sort();
  }
}

decorate(Team, {
  name: observable,
  slug: observable,
  avatarUrl: observable,
  memberIds: observable,
  members: observable,
  invitations: observable,
  currentDiscussion: observable,
  currentDiscussionSlug: observable,
  isLoadingDiscussions: observable,
  discussions: observable,

  setInitialMembersAndInvitations: action,
  updateTheme: action,
  inviteMember: action,
  removeMember: action,
  setInitialDiscussions: action,
  loadDiscussions: action,
  addDiscussion: action,
  addDiscussionToLocalCache: action,
  deleteDiscussion: action,
  deleteDiscussionFromLocalCache: action,
  getDiscussionBySlug: action,

  orderedDiscussions: computed,
});

export { Team };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\lib\store\user.ts -----

import { action, decorate, observable, runInAction } from 'mobx';

import * as NProgress from 'nprogress';

import { getListOfInvoicesApiMethod } from '../api/team-leader';
import { toggleThemeApiMethod, updateProfileApiMethod } from '../api/team-member';
import { Store } from './index';

class User {
  public store: Store;

  public _id: string;
  public slug: string;
  public email: string | null;
  public displayName: string | null;
  public avatarUrl: string | null;
  public isSignedupViaGoogle: boolean;

  public darkTheme = false;
  public defaultTeamSlug: string;

  public stripeCard: {
    brand: string;
    funding: string;
    last4: string;
    exp_month: number;
    exp_year: number;
  };
  public hasCardInformation: boolean;
  public stripeListOfInvoices: {
    object: string;
    data: [
      {
        amount_paid: number;
        teamName: string;
        created: number;
        hosted_invoice_url: string;
      },
    ];
    has_more: boolean;
  };

  constructor(params) {
    this.store = params.store;
    this._id = params._id;
    this.slug = params.slug;
    this.email = params.email;
    this.displayName = params.displayName;
    this.avatarUrl = params.avatarUrl;
    this.isSignedupViaGoogle = !!params.isSignedupViaGoogle;
    this.darkTheme = !!params.darkTheme;
    this.defaultTeamSlug = params.defaultTeamSlug;

    this.stripeCard = params.stripeCard;
    this.hasCardInformation = params.hasCardInformation;
    this.stripeListOfInvoices = params.stripeListOfInvoices;
  }

  public async updateProfile({ name, avatarUrl }: { name: string; avatarUrl: string }) {
    const { updatedUser } = await updateProfileApiMethod({
      name,
      avatarUrl,
    });

    runInAction(() => {
      this.displayName = updatedUser.displayName;
      this.avatarUrl = updatedUser.avatarUrl;
      this.slug = updatedUser.slug;
    });
  }

  public async toggleTheme(darkTheme: boolean) {
    await toggleThemeApiMethod({ darkTheme });
    runInAction(() => {
      this.darkTheme = darkTheme;
    });
    NProgress.start();
    NProgress.set(0.5);
    window.location.reload();
  }

  public async getListOfInvoices() {
    try {
      const { stripeListOfInvoices } = await getListOfInvoicesApiMethod();
      runInAction(() => {
        this.stripeListOfInvoices = stripeListOfInvoices;
      });
    } catch (error) {
      console.error(error);
      throw error;
    }
  }
}

decorate(User, {
  slug: observable,
  email: observable,
  displayName: observable,
  avatarUrl: observable,
  // darkTheme: observable,
  defaultTeamSlug: observable,
  stripeCard: observable,
  stripeListOfInvoices: observable,

  updateProfile: action,
  toggleTheme: action,
  getListOfInvoices: action,
});

export { User };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\lib\confirm.ts -----

import { openConfirmDialogExternal } from '../components/common/Confirmer';

export default function confirm({
  title,
  message,
  onAnswer,
}: {
  title: string;
  message: string;
  onAnswer: (answer) => void;
}) {
  openConfirmDialogExternal({ title, message, onAnswer });
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\lib\isMobile.ts -----

const mobileRE = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i;

export function isMobile(opts) {
  if (!opts) {
    opts = {};
  }

  let ua = opts.ua;

  if (!ua && typeof navigator !== 'undefined') {
    ua = navigator.userAgent;
  }

  if (!ua && opts.req && opts.req.headers && typeof opts.req.headers['user-agent'] === 'string') {
    ua = opts.req.headers['user-agent'];
    // console.log(ua);
  }

  if (typeof ua !== 'string') {
    return false;
  }

  return mobileRE.test(ua);
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\lib\notify.ts -----

import { openSnackbarExternal } from '../components/common/Notifier';

export default function notify(obj) {
  openSnackbarExternal({ message: obj.message || obj.toString() });
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\lib\resizeImage.ts -----

function resizeImage(file: File, MAX_WIDTH, MAX_HEIGHT) {
  const image = document.createElement('img');

  const resize = (resolve) => () => {
    let isResizeNeeded = false;
    let width = image.width;
    let height = image.height;

    if (width > height) {
      if (width > MAX_WIDTH) {
        isResizeNeeded = true;
        height *= MAX_WIDTH / width;
        width = MAX_WIDTH;
      }
    } else {
      if (height > MAX_HEIGHT) {
        isResizeNeeded = true;
        width *= MAX_HEIGHT / height;
        height = MAX_HEIGHT;
      }
    }

    if (isResizeNeeded) {
      const canvas = document.createElement('canvas');

      canvas.width = width;
      canvas.height = height;

      console.log(width, height);

      const ctx = canvas.getContext('2d');
      ctx.drawImage(image, 0, 0, width, height);

      canvas.toBlob((blob) => {
        resolve(blob);
      }, file.type);
    } else {
      resolve(file);
    }
  };

  return new Promise((resolve) => {
    const reader = new FileReader();

    console.log(`before ${image.src}`);

    reader.readAsDataURL(file);

    reader.onload = (e) => {
      image.src = e.target.result.toString();

      image.onload = resize(resolve);

      console.log(`after ${image.src}`);
    };
  });
}

export { resizeImage };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\lib\sharedStyles.ts -----

const styleBigAvatar = {
  width: '80px',
  height: '80px',
  margin: '0px auto 15px',
};

const styleRaisedButton = {
  margin: '15px',
  font: '14px Roboto',
};

const styleToolbar = {
  background: '#FFF',
  height: '64px',
  paddingRight: '20px',
};

const styleTextField = {
  font: '15px Roboto',
  color: '#222',
  fontWeight: '300',
};

const styleForm = {
  margin: '7% auto',
  width: '360px',
};

export { styleBigAvatar, styleRaisedButton, styleToolbar, styleTextField, styleForm };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\lib\theme.ts -----

import { createMuiTheme } from "@mui/material/styles";

const themeDark = createMuiTheme({
  palette: {
    primary: { main: "#238636" },
    secondary: { main: "#b62324" },
    type: "dark",
    background: { default: "#0d1117" },
    text: {
      primary: "#c9d1d9",
    },
  },
  typography: {
    button: {
      textTransform: "none",
    },
  },
});

const themeLight = createMuiTheme({
  palette: {
    primary: { main: "#238636" },
    secondary: { main: "#b62324" },
    type: "light",
    background: { default: "#fff" },
    text: {
      primary: "#222",
    },
  },
  typography: {
    button: {
      textTransform: "none",
    },
  },
});

export { themeDark, themeLight };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\lib\withAuth.tsx -----

import { observer } from 'mobx-react';
import Router from 'next/router';
import React from 'react';

import * as NProgress from 'nprogress';

import { Store, getStore } from './store';

Router.events.on('routeChangeStart', () => {
  NProgress.start();
});

Router.events.on('routeChangeComplete', (url) => {
  const store = getStore();
  if (store) {
    store.changeCurrentUrl(url);
  }

  NProgress.done();
});

Router.events.on('routeChangeError', () => NProgress.done());

export default function withAuth(Component, { loginRequired = true, logoutRequired = false } = {}) {
  class WithAuth extends React.Component<{ store: Store }> {
    public static async getInitialProps(ctx) {
      console.log('WithAuth.getInitialProps');

      const { req } = ctx;

      let pageComponentProps = {};

      if (Component.getInitialProps) {
        pageComponentProps = await Component.getInitialProps(ctx);
      }

      return {
        ...pageComponentProps,
        isServer: !!req,
      };
    }

    public componentDidMount() {
      console.log('WithAuth.componentDidMount');

      const { store } = this.props;
      const user = store.currentUser;

      if (loginRequired && !logoutRequired && !user) {
        Router.push('/login');
        return;
      }

      let redirectUrl = '/login';
      let asUrl = '/login';
      if (user) {
        if (!user.defaultTeamSlug) {
          redirectUrl = '/create-team';
          asUrl = '/create-team';
        } else {
          redirectUrl = `/your-settings`;
          asUrl = `/your-settings`;
        }
      }

      if (logoutRequired && user) {
        Router.push(redirectUrl, asUrl);
      }
    }

    public render() {
      const { store } = this.props;
      const user = store.currentUser;

      if (loginRequired && !logoutRequired && !user) {
        return null;
      }

      if (logoutRequired && user) {
        return null;
      }

      return <Component {...this.props} />;
    }
  }

  return observer(WithAuth);
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\pages\billing.tsx -----

import { observer } from "mobx-react";
import moment from "moment";
import Head from "next/head";
import * as React from "react";
import { loadStripe } from "@stripe/stripe-js";
import Button from "@mui/material/Button";
import NProgress from "nprogress";

import Layout from "../components/layout";
import notify from "../lib/notify";
import { Store } from "../lib/store";
import withAuth from "../lib/withAuth";
import { fetchCheckoutSessionApiMethod } from "../lib/api/team-leader";

const dev = process.env && process.env.NODE_ENV && process.env.NODE_ENV !== "production";

const stripePromise = loadStripe(
  dev ? process.env.NEXT_PUBLIC_STRIPE_TEST_PUBLISHABLEKEY : process.env.NEXT_PUBLIC_STRIPE_LIVE_PUBLISHABLEKEY
);

type Props = {
  store: Store;
  isMobile: boolean;
  teamSlug: string;
  redirectMessage?: string;
};

type State = { disabled: boolean; showInvoices: boolean };

class Billing extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = { disabled: false, showInvoices: false };
  }

  public render() {
    const { store, isMobile } = this.props;
    const { currentTeam, currentUser } = store;
    const isTeamLeader = currentTeam && currentUser && currentUser._id === currentTeam.teamLeaderId;

    if (!currentTeam || currentTeam.slug !== this.props.teamSlug) {
      return (
        <Layout {...this.props}>
          <div style={{ padding: isMobile ? "0px" : "0px 30px" }}>
            <p>You did not select any team.</p>
            <p>To access this page, please select existing team or create new team if you have no teams.</p>
          </div>
        </Layout>
      );
    }

    if (!isTeamLeader) {
      return (
        <Layout {...this.props}>
          <div style={{ padding: isMobile ? "0px" : "0px 30px" }}>
            <p>Only the Team Leader can access this page.</p>
            <p>Create your own team to become a Team Leader.</p>
          </div>
        </Layout>
      );
    }

    return (
      <Layout {...this.props}>
        <Head>
          <title>Your Billing</title>
        </Head>
        <div style={{ padding: isMobile ? "0px" : "0px 30px" }}>
          <h3>Your Billing</h3>
          <p />
          <h4 style={{ marginTop: "40px" }}>Paid plan</h4>
          {this.renderSubscriptionButton()}
          <p />
          <br />
          <h4>Card information</h4>
          {this.renderCardInfo()}
          <p />
          <br />
          <h4>Payment history</h4>
          <Button
            variant="outlined"
            color="primary"
            onClick={this.showListOfInvoicesOnClick}
            disabled={this.state.disabled}
          >
            Show payment history
          </Button>
          <p />
          {this.renderInvoices()}
          <p />
          <br />
        </div>
      </Layout>
    );
  }

  public async componentDidMount() {
    if (this.props.redirectMessage) {
      notify(this.props.redirectMessage);
    }
  }

  private renderSubscriptionButton() {
    const { currentTeam } = this.props.store;

    let subscriptionDate;
    let billingDay;
    if (currentTeam && currentTeam.stripeSubscription) {
      subscriptionDate = moment(currentTeam.stripeSubscription.billing_cycle_anchor * 1000).format("MMM Do YYYY");
      billingDay = moment(currentTeam.stripeSubscription.billing_cycle_anchor * 1000).format("Do");
    }

    if (currentTeam && !currentTeam.isSubscriptionActive && currentTeam.isPaymentFailed) {
      return (
        <>
          <p>You are not a paying customer.</p>
          <Button
            variant="contained"
            color="primary"
            onClick={() => this.handleCheckoutClick("subscription")}
            disabled={this.state.disabled}
          >
            Buy subscription
          </Button>
          <p />
          <p>
            Team was automatically unsubscribed due to failed payment. You will be prompt to update card information if
            you choose to re-subscribe Team.
          </p>
        </>
      );
    } else if (currentTeam && !currentTeam.isSubscriptionActive && !currentTeam.isPaymentFailed) {
      return (
        <React.Fragment>
          <p>You are not a paying customer.</p>
          <p>Buy subscription using your current card, see below section for current card information.</p>
          <Button
            variant="contained"
            color="primary"
            onClick={() => this.handleCheckoutClick("subscription")}
            disabled={this.state.disabled}
          >
            Buy subscription
          </Button>
        </React.Fragment>
      );
    } else {
      return (
        <React.Fragment>
          <span>
            {" "}
            <i className="material-icons" color="action" style={{ verticalAlign: "text-bottom" }}>
              done
            </i>{" "}
            Subscription is active.
            <p>
              You subscribed <b>{currentTeam.name}</b> on <b>{subscriptionDate}</b>.
            </p>
            <p>
              You will be billed $50 on <b>{billingDay} day</b> of each month unless you cancel subscription or
              subscription is cancelled automatically due to failed payment.
            </p>
          </span>
          <p />
          <Button
            variant="outlined"
            color="primary"
            onClick={this.cancelSubscriptionOnClick}
            disabled={this.state.disabled}
          >
            Unsubscribe Team
          </Button>
          <br />
        </React.Fragment>
      );
    }
  }

  private handleCheckoutClick = async (mode: "subscription" | "setup") => {
    try {
      const { currentTeam } = this.props.store;

      NProgress.start();
      this.setState({ disabled: true });

      const { sessionId } = await fetchCheckoutSessionApiMethod({ mode, teamId: currentTeam._id });

      // When the customer clicks on the button, redirect them to Checkout.
      const stripe = await stripePromise;
      const { error } = await stripe.redirectToCheckout({ sessionId });

      if (error) {
        notify(error);
        console.error(error);
      }
    } catch (err) {
      notify(err);
      console.error(err);
    } finally {
      this.setState({ disabled: false });
      NProgress.done();
    }
  };

  private cancelSubscriptionOnClick = async () => {
    const { currentTeam } = this.props.store;

    NProgress.start();
    this.setState({ disabled: true });

    try {
      await currentTeam.cancelSubscription({ teamId: currentTeam._id });
      notify("Success!");
    } catch (err) {
      notify(err);
    } finally {
      this.setState({ disabled: false });
      NProgress.done();
    }
  };

  private renderCardInfo() {
    const { currentUser } = this.props.store;

    if (currentUser && currentUser.hasCardInformation) {
      return (
        <span>
          {" "}
          <i className="material-icons" color="action" style={{ verticalAlign: "text-bottom" }}>
            done
          </i>{" "}
          Your default payment method:
          <li>
            {currentUser.stripeCard.brand}, {currentUser.stripeCard.funding} card
          </li>
          <li>Last 4 digits: *{currentUser.stripeCard.last4}</li>
          <li>
            Expiration: {currentUser.stripeCard.exp_month}/{currentUser.stripeCard.exp_year}
          </li>
          <p />
          <Button
            variant="outlined"
            color="primary"
            onClick={() => this.handleCheckoutClick("setup")}
            disabled={this.state.disabled}
          >
            Update card
          </Button>
        </span>
      );
    } else {
      return "You have not added a card.";
    }
  }

  private renderInvoices() {
    const { currentUser } = this.props.store;
    const { showInvoices } = this.state;

    if (!showInvoices) {
      return null;
    }

    if (currentUser && currentUser.stripeCard) {
      return (
        <React.Fragment>
          {currentUser.stripeListOfInvoices.data.map((invoice, i) => (
            <React.Fragment key={i}>
              <p>Your history of payments:</p>
              <li>
                ${invoice.amount_paid / 100} was paid on {moment(invoice.created * 1000).format("MMM Do YYYY")} for Team
                '{invoice.teamName}' -{" "}
                <a href={invoice.hosted_invoice_url} target="_blank" rel="noopener noreferrer">
                  See invoice
                </a>
              </li>
            </React.Fragment>
          ))}
        </React.Fragment>
      );
    } else {
      return "You have no history of payments.";
    }
  }

  private showListOfInvoicesOnClick = async () => {
    const { currentUser } = this.props.store;
    NProgress.start();
    this.setState({ disabled: true });
    try {
      await currentUser.getListOfInvoices();
      this.setState({ showInvoices: true });
    } catch (err) {
      notify(err);
    } finally {
      this.setState({ disabled: false });
      NProgress.done();
    }
  };
}

export default withAuth(observer(Billing));

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\pages\create-team.tsx -----

import { inject, observer } from "mobx-react";
import * as React from "react";

import Avatar from "@mui/material/Avatar";
import Button from "@mui/material/Button";
import Grid from "@mui/material/Grid";
import TextField from "@mui/material/TextField";
import Head from "next/head";
import Router from "next/router";

import { getSignedRequestForUploadApiMethod, uploadFileUsingSignedPutRequestApiMethod } from "../lib/api/team-member";
import notify from "../lib/notify";
import { resizeImage } from "../lib/resizeImage";
import { Store } from "../lib/store";
import withAuth from "../lib/withAuth";

import Layout from "../components/layout";

const styleGrid = {
  height: "100%",
};

type Props = { store: Store; isMobile: boolean; teamRequired: boolean };

type State = { newName: string; newAvatarUrl: string; disabled: boolean };

class CreateTeam extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      newName: "",
      newAvatarUrl: "https://storage.googleapis.com/async-await/default-user.png?v=1",
      disabled: false,
    };
  }

  public render() {
    const { newAvatarUrl } = this.state;

    console.log(this.props.store);

    return (
      <Layout {...this.props}>
        <Head>
          <title>Create Team</title>
          <meta name="description" content="Create a new Team at SaaS Boilerplate" />
        </Head>
        <div style={{ padding: "0px", fontSize: "14px", height: "100%" }}>
          <Grid container style={styleGrid}>
            <Grid item sm={12} xs={12} style={{ padding: this.props.isMobile ? "0px" : "0px 30px" }}>
              <h3>Create team</h3>
              <p />
              <form onSubmit={this.onSubmit}>
                <h4>Team name</h4>
                <TextField
                  value={this.state.newName}
                  label="Type your team's name."
                  helperText="Team name as seen by your team members."
                  onChange={(event) => {
                    this.setState({ newName: event.target.value });
                  }}
                />
                <p />
                <h4 style={{ marginTop: "40px" }}>Team logo (optional)</h4>
                <Avatar
                  src={newAvatarUrl}
                  style={{
                    display: "inline-flex",
                    verticalAlign: "middle",
                    marginRight: 20,
                    width: 60,
                    height: 60,
                  }}
                />
                <label htmlFor="upload-file">
                  <Button variant="outlined" color="primary" component="span">
                    Select team logo
                  </Button>
                </label>
                <input
                  accept="image/*"
                  name="upload-file"
                  id="upload-file"
                  type="file"
                  style={{ display: "none" }}
                  onChange={this.previewTeamLogo}
                />
                <p />
                <br />
                <br />
                <Button variant="contained" color="primary" type="submit" disabled={this.state.disabled}>
                  Create new team
                </Button>
              </form>
            </Grid>
          </Grid>
          <br />
        </div>
      </Layout>
    );
  }

  private onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();

    const { newName } = this.state;

    const { store } = this.props;

    if (!newName) {
      notify("Team name is required.");
      return;
    }

    const file = (document.getElementById("upload-file") as HTMLFormElement).files[0];

    try {
      this.setState({ disabled: true });

      const defaultAvatarUrl = "https://storage.googleapis.com/async-await/default-user.png?v=1";
      const team = await store.addTeam({
        name: newName,
        avatarUrl: defaultAvatarUrl,
      });

      console.log(`Returned to client: ${team._id}, ${team.name}, ${team.slug}`);

      if (file == null) {
        Router.push(`/team/${team.slug}/team-settings`);
        notify("You successfully created Team.<p />Redirecting...");
        return;
      }

      const fileName = file.name;
      const fileType = file.type;
      const bucket = process.env.NEXT_PUBLIC_BUCKET_FOR_TEAM_LOGOS;
      const prefix = team.slug;

      const responseFromApiServerForUpload = await getSignedRequestForUploadApiMethod({
        fileName,
        fileType,
        prefix,
        bucket,
      });

      const resizedFile = await resizeImage(file, 128, 128);

      await uploadFileUsingSignedPutRequestApiMethod(resizedFile, responseFromApiServerForUpload.signedRequest, {
        "Cache-Control": "max-age=2592000",
      });

      const uploadedAvatarUrl = responseFromApiServerForUpload.url;

      await team.updateTheme({ name: team.name, avatarUrl: uploadedAvatarUrl });

      this.setState({
        newName: "",
        newAvatarUrl: "https://storage.googleapis.com/async-await/default-user.png?v=1",
      });

      (document.getElementById("upload-file") as HTMLFormElement).value = "";

      Router.push(`/team/${team.slug}/team-settings`);

      notify("You successfully created Team. Redirecting ...");
    } catch (error) {
      console.log(error);
      notify(error);
    } finally {
      this.setState({ disabled: false });
    }
  };

  private previewTeamLogo = () => {
    const file = (document.getElementById("upload-file") as HTMLFormElement).files[0];
    if (!file) {
      return;
    }

    const reader = new FileReader();

    reader.readAsDataURL(file);

    reader.onload = (e) => {
      this.setState({ newAvatarUrl: e.target.result as string });
    };
  };
}

export default withAuth(inject("store")(observer(CreateTeam)));

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\pages\discussion.tsx -----

import Avatar from "@mui/material/Avatar";
import Tooltip from "@mui/material/Tooltip";
import Head from "next/head";
import Router from "next/router";
import * as React from "react";

import { observer } from "mobx-react";

import Layout from "../components/layout";
import PostDetail from "../components/posts/PostDetail";
import PostForm from "../components/posts/PostForm";
import notify from "../lib/notify";
import { Store } from "../lib/store";
import { Discussion } from "../lib/store/discussion";
import withAuth from "../lib/withAuth";
import { Post } from "lib/store/post";

type Props = {
  store: Store;
  teamSlug: string;
  discussionSlug: string;
  isServer: boolean;
  isMobile: boolean;
  teamRequired: boolean;
};

type State = {
  selectedPost: Post;
  showMarkdownClicked: boolean;
};

class DiscussionPageComp extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      selectedPost: null,
      showMarkdownClicked: false,
    };
  }

  public render() {
    const { store, isMobile, discussionSlug } = this.props;
    const { currentTeam } = store;
    const { selectedPost } = this.state;

    if (!currentTeam || currentTeam.slug !== this.props.teamSlug) {
      return (
        <Layout {...this.props}>
          <Head>
            <title>No Team is found.</title>
          </Head>
          <div style={{ padding: isMobile ? "0px" : "0px 30px" }}>No Team is found.</div>
        </Layout>
      );
    }

    const discussion = this.getDiscussion(discussionSlug);

    if (!discussion) {
      if (currentTeam.isLoadingDiscussions) {
        return (
          <Layout {...this.props}>
            <Head>
              <title>Loading...</title>
            </Head>
            <div style={{ padding: isMobile ? "0px" : "0px 30px" }}>
              <p>Loading Discussions...</p>
            </div>
          </Layout>
        );
      } else {
        return (
          <Layout {...this.props}>
            <Head>
              <title>No Discussion is found.</title>
            </Head>
            <div style={{ padding: isMobile ? "0px" : "0px 30px" }}>
              <p>No Discussion is found.</p>
            </div>
          </Layout>
        );
      }
    }

    const title = discussion ? `${discussion.name}  Discussion` : "Discussions";

    return (
      <Layout {...this.props}>
        <Head>
          <title>{title}</title>
        </Head>
        <div style={{ padding: isMobile ? "0px" : "0px 30px", height: "100vh" }}>
          <h4>
            <span style={{ fontWeight: 300 }}>Discussion : </span>
            {(discussion && discussion.name) || "No Discussion is found."}
          </h4>{" "}
          Visible to :{" "}
          {discussion
            ? discussion.members.map((m) => (
                <Tooltip title={m.displayName} placement="right" disableFocusListener disableTouchListener key={m._id}>
                  <Avatar
                    role="presentation"
                    src={m.avatarUrl}
                    alt={m.avatarUrl}
                    key={m._id}
                    style={{
                      margin: "0px 5px",
                      display: "inline-flex",
                      width: "30px",
                      height: "30px",
                      verticalAlign: "middle",
                    }}
                  />
                </Tooltip>
              ))
            : null}
          <p />
          {this.renderPosts()}
          {discussion && !discussion.isLoadingPosts ? (
            <React.Fragment>
              {selectedPost ? null : (
                <PostForm
                  post={null}
                  discussion={discussion}
                  members={discussion.members}
                  isMobile={this.props.isMobile}
                  store={store}
                />
              )}
            </React.Fragment>
          ) : null}
          <p />
          <br />
        </div>
      </Layout>
    );
  }

  public getDiscussion(slug: string): Discussion {
    const { store, teamSlug } = this.props;
    const { currentTeam } = store;

    if (!currentTeam) {
      return;
    }

    if (!slug && currentTeam.discussions.length > 0) {
      Router.replace(
        `/discussion?teamSlug=${teamSlug}&discussionSlug=${currentTeam.orderedDiscussions[0].slug}`,
        `/team/${teamSlug}/discussions/${currentTeam.orderedDiscussions[0].slug}`
      );
      return;
    }

    if (slug && currentTeam) {
      return currentTeam.getDiscussionBySlug(slug);
    }

    return null;
  }

  public renderPosts() {
    const { isServer, store, isMobile } = this.props;
    const { selectedPost, showMarkdownClicked } = this.state;
    const discussion = this.getDiscussion(this.props.discussionSlug);

    if (!discussion.isLoadingPosts && discussion.posts.length === 0) {
      return <p>Empty Discussion.</p>;
    }

    let loading = "loading Posts ...";
    if (discussion.posts.length > 0) {
      loading = "checking for newer Posts ...";
    }

    return (
      <React.Fragment>
        {discussion
          ? discussion.posts.map((p) =>
              selectedPost && selectedPost._id === p._id ? (
                <PostForm
                  store={store}
                  isMobile={isMobile}
                  key={p._id}
                  post={p}
                  showMarkdownToNonCreator={showMarkdownClicked}
                  discussion={discussion}
                  members={discussion.members}
                  onFinished={() => {
                    this.setState({
                      selectedPost: null,
                      showMarkdownClicked: false,
                    });
                  }}
                />
              ) : (
                <PostDetail
                  key={p._id}
                  post={p}
                  onEditClick={this.onEditClickCallback}
                  onShowMarkdownClick={this.onSnowMarkdownClickCallback}
                  isMobile={this.props.isMobile}
                  store={store}
                />
              )
            )
          : null}

        {discussion && discussion.isLoadingPosts && !isServer ? <p>{loading}</p> : null}
      </React.Fragment>
    );
  }

  public onEditClickCallback = (post) => {
    this.setState({ selectedPost: post, showMarkdownClicked: false });
  };

  public onSnowMarkdownClickCallback = (post) => {
    this.setState({ selectedPost: post, showMarkdownClicked: true });
  };

  public componentDidMount() {
    const { discussionSlug, store, isServer } = this.props;

    if (store.currentTeam && (!isServer || !discussionSlug)) {
      store.currentTeam.loadDiscussions().catch((err) => notify(err));
    }

    const discussion = this.getDiscussion(discussionSlug);

    if (discussion) {
      discussion.joinSocketRooms();
    }

    console.log(store.socket);

    store.socket.on("discussionEvent", this.handleDiscussionEvent);
    store.socket.on("postEvent", this.handlePostEvent);
    store.socket.on("reconnect", this.handleSocketReconnect);
  }

  public componentWillUnmount() {
    const { discussionSlug, store } = this.props;

    const discussion = this.getDiscussion(discussionSlug);

    if (discussion) {
      discussion.leaveSocketRooms();
    }

    store.socket.off("discussionEvent", this.handleDiscussionEvent);
    store.socket.off("postEvent", this.handlePostEvent);
    store.socket.off("reconnect", this.handleSocketReconnect);
  }

  public componentDidUpdate(prevProps: Props) {
    const { discussionSlug, isServer } = this.props;

    if (prevProps.discussionSlug !== discussionSlug) {
      if (prevProps.discussionSlug) {
        const prevDiscussion = this.getDiscussion(prevProps.discussionSlug);
        if (prevDiscussion) {
          prevDiscussion.leaveSocketRooms();
        }
      }

      const discussion = this.getDiscussion(discussionSlug);

      if (!isServer && discussion) {
        discussion.loadPosts().catch((err) => notify(err));
      }

      if (discussion) {
        discussion.joinSocketRooms();
      }
    }
  }

  private handleDiscussionEvent = (data) => {
    console.log("discussion realtime event", data);

    const discussion = this.getDiscussion(this.props.discussionSlug);
    if (discussion) {
      discussion.handleDiscussionRealtimeEvent(data);
    }
  };

  private handlePostEvent = (data) => {
    console.log("post realtime event", data);

    const discussion = this.getDiscussion(this.props.discussionSlug);
    if (discussion) {
      discussion.handlePostRealtimeEvent(data);
    }
  };

  private handleSocketReconnect = () => {
    console.log("pages/discussion.tsx: socket re-connected");

    const discussion = this.getDiscussion(this.props.discussionSlug);
    if (discussion) {
      discussion.loadPosts().catch((err) => notify(err));
      discussion.joinSocketRooms();
    }
  };
}

export default withAuth(observer(DiscussionPageComp));

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\pages\invitation.tsx -----

import Avatar from "@mui/material/Avatar";
import { observer } from "mobx-react";
import Error from "next/error";
import Head from "next/head";
import Router from "next/router";
// import { NextPageContext } from 'next';
import React from "react";

import LoginButton from "../components/common/LoginButton";
import Layout from "../components/layout";
import { getTeamByTokenApiMethod } from "../lib/api/public";
import { Team } from "../lib/store/team";
import { Store } from "../lib/store";
import withAuth from "../lib/withAuth";

class InvitationPageComp extends React.Component<{ store: Store; team: Team; token: string }> {
  public static async getInitialProps(ctx) {
    const { token } = ctx.query;
    if (!token) {
      return {};
    }

    try {
      const { team } = await getTeamByTokenApiMethod(token, ctx.req);

      return { team, token };
    } catch (error) {
      console.log(error);
      return {};
    }
  }

  public render() {
    const { team, token, store } = this.props;

    if (!team) {
      return <Error statusCode={404} />;
    }

    const user = store.currentUser;

    if (user) {
      return null;
    }

    return (
      <Layout {...this.props}>
        <Head>
          <title>Invitation to {team.name}</title>
          <meta name="description" content={`Invitation to join ${team.name}`} />
        </Head>
        <div style={{ textAlign: "center", margin: "0 20px" }}>
          <br />
          <Avatar
            src={`${team.avatarUrl || "https://storage.googleapis.com/async-await/default-user.png?v=1"}`}
            alt="Team logo"
            style={{
              verticalAlign: "middle",
              display: "inline-flex",
            }}
          />{" "}
          <h2>{team.name}</h2>
          <p>
            Join <b>{team.name}</b> by logging in or signing up.
          </p>
          <br />
          <LoginButton invitationToken={token} />
        </div>
      </Layout>
    );
  }

  public async componentDidMount() {
    const { store, team, token } = this.props;

    const user = store.currentUser;

    if (user && team) {
      Router.push(
        `${process.env.NEXT_PUBLIC_URL_API}/logout?invitationToken=${token}`,
        `${process.env.NEXT_PUBLIC_URL_API}/logout`
      );
    }
  }
}

// export async function getServerSideProps(context: NextPageContext) {
//   const { token } = context.query;

//   try {
//     const { team } = await getTeamByTokenApiMethod(token as string, context.req);

//     if (team && token) {
//       return { props: { team, token } };
//     } else {
//       return { props: {} };
//     }
//   } catch (error) {
//     console.log(error);
//     return { props: {} };
//   }
// }

// see our explanation for not using getServerSideProps at this time: https://github.com/async-labs/saas/issues/193

export default withAuth(observer(InvitationPageComp), { loginRequired: false });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\pages\login.tsx -----

import Head from 'next/head';
import React from 'react';
import LoginButton from '../components/common/LoginButton';
import Layout from '../components/layout';
import withAuth from '../lib/withAuth';

class Login extends React.Component {
  public render() {
    return (
      <Layout {...this.props}>
        <div style={{ textAlign: 'center', margin: '0 20px' }}>
          <Head>
            <title>Log in to SaaS boilerplate by Async</title>
            <meta
              name="description"
              content="Login and signup page for SaaS boilerplate demo by Async"
            />
          </Head>
          <br />
          <p style={{ margin: '45px auto', fontSize: '44px', fontWeight: 400 }}>Log in</p>
          <p>Youll be logged in for 14 days unless you log out manually.</p>
          <br />

          <LoginButton />
        </div>
      </Layout>
    );
  }
}

export default withAuth(Login, { logoutRequired: true });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\pages\team-settings.tsx -----

import Avatar from "@mui/material/Avatar";
import Button from "@mui/material/Button";
import Hidden from "@mui/material/Hidden";
import TextField from "@mui/material/TextField";
import { inject, observer } from "mobx-react";
import Head from "next/head";
import NProgress from "nprogress";
import * as React from "react";
import Table from "@mui/material/Table";
import TableBody from "@mui/material/TableBody";
import TableCell from "@mui/material/TableCell";
import TableContainer from "@mui/material/TableContainer";
import TableHead from "@mui/material/TableHead";
import TableRow from "@mui/material/TableRow";

import Layout from "../components/layout";
import InviteMember from "../components/teams/InviteMember";
import { getSignedRequestForUploadApiMethod, uploadFileUsingSignedPutRequestApiMethod } from "../lib/api/team-member";
import confirm from "../lib/confirm";
import notify from "../lib/notify";
import { resizeImage } from "../lib/resizeImage";
import { Store } from "../lib/store";
import withAuth from "../lib/withAuth";

type Props = { isMobile: boolean; store: Store; teamSlug: string };

type State = {
  newName: string;
  newAvatarUrl: string;
  disabled: boolean;
  inviteMemberOpen: boolean;
};

class TeamSettings extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      newName: this.props.store.currentTeam.name,
      newAvatarUrl: this.props.store.currentTeam.avatarUrl,
      disabled: false,
      inviteMemberOpen: false,
    };
  }

  public render() {
    const { store, isMobile } = this.props;
    const { currentTeam, currentUser } = store;
    const { newName, newAvatarUrl } = this.state;
    const isTeamLeader = currentTeam && currentUser && currentUser._id === currentTeam.teamLeaderId;

    // console.log(this.props.firstGridItem);

    if (!currentTeam || currentTeam.slug !== this.props.teamSlug) {
      return (
        <Layout {...this.props}>
          <div style={{ padding: isMobile ? "0px" : "0px 30px" }}>
            <p>You did not select any team.</p>
            <p>To access this page, please select existing team or create new team if you have no teams.</p>
          </div>
        </Layout>
      );
    }

    if (!isTeamLeader) {
      return (
        <Layout {...this.props}>
          <div style={{ padding: isMobile ? "0px" : "0px 30px" }}>
            <p>Only the Team Leader can access this page.</p>
            <p>Create your own team to become a Team Leader.</p>
          </div>
        </Layout>
      );
    }

    return (
      <Layout {...this.props}>
        <Head>
          <title>Team Settings</title>
        </Head>
        <div style={{ padding: isMobile ? "0px" : "0px 30px", fontSize: "15px", height: "100%" }}>
          <h3>Team Settings</h3>
          <p />
          <br />
          <form onSubmit={this.onSubmit}>
            <h4>Team name</h4>
            <TextField
              value={newName}
              helperText="Team name as seen by your team members"
              onChange={(event) => {
                this.setState({ newName: event.target.value });
              }}
            />
            <br />
            <br />
            <Button variant="contained" color="primary" type="submit" disabled={this.state.disabled}>
              Update username
            </Button>
          </form>
          <p />
          <br />
          <h4>Team logo</h4>
          <Avatar
            src={newAvatarUrl}
            style={{
              display: "inline-flex",
              verticalAlign: "middle",
              marginRight: 20,
              width: 60,
              height: 60,
            }}
          />
          <label htmlFor="upload-file-team-logo">
            <Button variant="contained" color="primary" component="span" disabled={this.state.disabled}>
              Update logo
            </Button>
          </label>
          <input
            accept="image/*"
            name="upload-file-team-logo"
            id="upload-file-team-logo"
            type="file"
            style={{ display: "none" }}
            onChange={this.uploadFile}
          />
          <p />
          <br />
          <br />
          <h4 style={{ marginRight: 20, display: "inline" }}>
            Team Members ( {Array.from(currentTeam.members.values()).length} / 20 )
          </h4>
          <Button
            onClick={this.openInviteMember}
            variant="contained"
            color="primary"
            style={{ float: "right", marginTop: "-20px" }}
            disabled={this.state.disabled}
          >
            Invite member
          </Button>
          <p />
          <TableContainer>
            <Table>
              <TableHead>
                <TableRow>
                  <TableCell>Person</TableCell>
                  <TableCell>Role</TableCell>
                  <TableCell>Action</TableCell>
                </TableRow>
              </TableHead>

              <TableBody>
                {currentTeam.memberIds
                  .map((userId) => currentTeam.members.get(userId))
                  .map((m) => (
                    <TableRow key={m._id}>
                      <TableCell style={{ width: "300px" }}>
                        <Hidden smDown>
                          <Avatar
                            role="presentation"
                            src={m.avatarUrl}
                            alt={(m.displayName || m.email)[0]}
                            key={m._id}
                            style={{
                              margin: "0px 5px",
                              display: "inline-flex",
                              width: "30px",
                              height: "30px",
                              verticalAlign: "middle",
                            }}
                          />
                        </Hidden>
                        {m.email}
                      </TableCell>
                      <TableCell>{isTeamLeader && m._id !== currentUser._id ? "Team Member" : "Team Leader"}</TableCell>
                      <TableCell>
                        {isTeamLeader && m._id !== currentUser._id ? (
                          <i
                            color="action"
                            data-id={m._id}
                            onClick={this.removeMember}
                            style={{
                              marginLeft: "20px",
                              fontSize: "16px",
                              opacity: 0.6,
                              cursor: "pointer",
                              verticalAlign: "middle",
                            }}
                            className="material-icons"
                          >
                            delete
                          </i>
                        ) : null}
                      </TableCell>
                    </TableRow>
                  ))}
              </TableBody>
            </Table>
          </TableContainer>

          <p />
          <br />

          {Array.from(currentTeam.invitations.values()).length > 0 ? (
            <React.Fragment>
              <h4>Invited users</h4>
              <p />
              <TableContainer>
                <Table>
                  <TableHead>
                    <TableRow>
                      <TableCell>Email</TableCell>
                      <TableCell>Status</TableCell>
                    </TableRow>
                  </TableHead>

                  <TableBody>
                    {Array.from(currentTeam.invitations.values()).map((i) => (
                      <TableRow key={i._id}>
                        <TableCell style={{ width: "300px" }}>{i.email}</TableCell>
                        <TableCell>Sent</TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              </TableContainer>
            </React.Fragment>
          ) : null}
          <p />
          <br />
          <InviteMember
            open={this.state.inviteMemberOpen}
            onClose={this.handleInviteMemberClose}
            store={this.props.store}
          />
          <br />
        </div>
      </Layout>
    );
  }

  private onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    const { newName, newAvatarUrl } = this.state;
    const { currentTeam } = this.props.store;

    if (!newName) {
      notify("Team name is required");
      return;
    }

    NProgress.start();

    try {
      this.setState({ disabled: true });

      await currentTeam.updateTheme({ name: newName, avatarUrl: newAvatarUrl });

      notify("You successfully updated Team name.");
    } catch (error) {
      notify(error);
    } finally {
      this.setState({ disabled: false });
      NProgress.done();
    }
  };

  private uploadFile = async () => {
    const { store } = this.props;
    const { currentTeam } = store;

    const fileElement = document.getElementById("upload-file-team-logo") as HTMLFormElement;
    const file = fileElement.files[0];

    if (file == null) {
      notify("No file selected for upload.");
      return;
    }

    const fileName = file.name;
    const fileType = file.type;

    NProgress.start();
    this.setState({ disabled: true });

    const bucket = process.env.NEXT_PUBLIC_BUCKET_FOR_TEAM_LOGOS;
    const prefix = `${currentTeam.slug}`;

    console.log(bucket);

    try {
      const responseFromApiServerForUpload = await getSignedRequestForUploadApiMethod({
        fileName,
        fileType,
        prefix,
        bucket,
      });

      const resizedFile = await resizeImage(file, 128, 128);

      await uploadFileUsingSignedPutRequestApiMethod(resizedFile, responseFromApiServerForUpload.signedRequest, {
        "Cache-Control": "max-age=2592000",
      });

      this.setState({
        newAvatarUrl: responseFromApiServerForUpload.url,
      });

      await currentTeam.updateTheme({
        name: this.state.newName,
        avatarUrl: this.state.newAvatarUrl,
      });

      notify("You successfully uploaded new Team logo.");
    } catch (error) {
      notify(error);
    } finally {
      this.setState({ disabled: false });
      NProgress.done();
    }
  };

  private openInviteMember = async () => {
    const { currentTeam } = this.props.store;
    if (!currentTeam) {
      notify("You have not selected a Team.");
      return;
    }

    const ifTeamLeaderMustBeCustomer = await currentTeam.checkIfTeamLeaderMustBeCustomer();

    if (ifTeamLeaderMustBeCustomer) {
      notify(
        "To add a third team member, you have to become a paid customer." +
          "<p />" +
          " To become a paid customer," +
          " navigate to Billing page."
      );
      return;
    }

    this.setState({ inviteMemberOpen: true });
  };

  private handleInviteMemberClose = () => {
    this.setState({ inviteMemberOpen: false });
  };

  private removeMember = (event) => {
    const { currentTeam } = this.props.store;
    if (!currentTeam) {
      notify("You have not selected a Team.");
      return;
    }

    const userId = event.currentTarget.dataset.id;
    if (!userId) {
      notify("Select user.");
      return;
    }

    confirm({
      title: "Are you sure?",
      message: "",
      onAnswer: async (answer) => {
        if (answer) {
          try {
            await currentTeam.removeMember(userId);
          } catch (error) {
            notify(error);
          }
        }
      },
    });
  };
}

export default withAuth(inject("store")(observer(TeamSettings)));

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\pages\your-settings.tsx -----

import Avatar from "@mui/material/Avatar";
import Button from "@mui/material/Button";
import TextField from "@mui/material/TextField";
import { inject, observer } from "mobx-react";
import Head from "next/head";
import NProgress from "nprogress";
import * as React from "react";

import Layout from "../components/layout";

import { getSignedRequestForUploadApiMethod, uploadFileUsingSignedPutRequestApiMethod } from "../lib/api/team-member";

import notify from "../lib/notify";
import { resizeImage } from "../lib/resizeImage";
import { Store } from "../lib/store";
import withAuth from "../lib/withAuth";

type Props = { isMobile: boolean; store: Store };

type State = { newName: string; newAvatarUrl: string; disabled: boolean };

class YourSettings extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      newName: this.props.store.currentUser.displayName,
      newAvatarUrl: this.props.store.currentUser.avatarUrl,
      disabled: false,
    };
  }

  public render() {
    const { currentUser } = this.props.store;
    const { newName, newAvatarUrl } = this.state;

    return (
      <Layout {...this.props}>
        <Head>
          <title>Your Settings at Async</title>
        </Head>
        <div
          style={{
            padding: this.props.isMobile ? "0px" : "0px 30px",
            fontSize: "15px",
            height: "100%",
          }}
        >
          <h3>Your Settings</h3>
          <h4 style={{ marginTop: "40px" }}>Your account</h4>
          <div>
            <i className="material-icons" color="action" style={{ verticalAlign: "text-bottom" }}>
              done
            </i>{" "}
            {currentUser.isSignedupViaGoogle
              ? "You signed up on Async using your Google account."
              : "You signed up on Async using your email."}
            <p />
            <li>
              Your email: <b>{currentUser.email}</b>
            </li>
            <li>
              Your username: <b>{currentUser.displayName}</b>
            </li>
          </div>
          <form onSubmit={this.onSubmit} autoComplete="off">
            <h4>Your username</h4>
            <TextField
              autoComplete="off"
              value={newName}
              helperText="Your username as seen by your team members"
              onChange={(event) => {
                this.setState({ newName: event.target.value });
              }}
            />
            <br />
            <br />
            <Button variant="contained" color="primary" type="submit" disabled={this.state.disabled}>
              Update username
            </Button>
          </form>

          <br />
          <h4>Your photo</h4>
          <Avatar
            src={newAvatarUrl}
            style={{
              display: "inline-flex",
              verticalAlign: "middle",
              marginRight: 20,
              width: 60,
              height: 60,
            }}
          />
          <label htmlFor="upload-file-user-avatar">
            <Button variant="outlined" color="primary" component="span" disabled={this.state.disabled}>
              Update avatar
            </Button>
          </label>
          <input
            accept="image/*"
            name="upload-file-user-avatar"
            id="upload-file-user-avatar"
            type="file"
            style={{ display: "none" }}
            onChange={this.uploadFile}
          />
          <p />
          <br />
        </div>
      </Layout>
    );
  }

  private onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();

    const { currentUser } = this.props.store;

    const { newName, newAvatarUrl } = this.state;

    console.log(newName);

    if (!newName) {
      notify("Name is required");
      return;
    }

    NProgress.start();
    this.setState({ disabled: true });

    try {
      await currentUser.updateProfile({ name: newName, avatarUrl: newAvatarUrl });

      notify("You successfully updated your profile.");
    } catch (error) {
      notify(error);
    } finally {
      this.setState({ disabled: false });
      NProgress.done();
    }
  };

  private uploadFile = async () => {
    const fileElement = document.getElementById("upload-file-user-avatar") as HTMLFormElement;
    const file = fileElement.files[0];

    const { currentUser } = this.props.store;

    if (file == null) {
      notify("No file selected for upload.");
      return;
    }

    const fileName = file.name;
    const fileType = file.type;

    NProgress.start();
    this.setState({ disabled: true });

    const bucket = process.env.NEXT_PUBLIC_BUCKET_FOR_AVATARS;

    const prefix = `${currentUser.slug}`;

    try {
      const responseFromApiServerForUpload = await getSignedRequestForUploadApiMethod({
        fileName,
        fileType,
        prefix,
        bucket,
      });

      const resizedFile = await resizeImage(file, 128, 128);

      console.log(file);
      console.log(resizedFile);

      await uploadFileUsingSignedPutRequestApiMethod(resizedFile, responseFromApiServerForUpload.signedRequest, {
        "Cache-Control": "max-age=2592000",
      });

      this.setState({
        newAvatarUrl: responseFromApiServerForUpload.url,
      });

      await currentUser.updateProfile({
        name: this.state.newName,
        avatarUrl: this.state.newAvatarUrl,
      });

      notify("You successfully uploaded new avatar.");
    } catch (error) {
      notify(error);
    } finally {
      fileElement.value = "";
      this.setState({ disabled: false });
      NProgress.done();
    }
  };
}

export default withAuth(inject("store")(observer(YourSettings)));

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\pages\_app.tsx -----

import CssBaseline from "@mui/material/CssBaseline";
import { ThemeProvider } from "@mui/material";
import { Provider } from "mobx-react";
import App from "next/app";
import Head from "next/head";
import React from "react";

import { themeDark, themeLight } from "../lib/theme";
import { getUserApiMethod } from "../lib/api/public";
import { getInitialDataApiMethod } from "../lib/api/team-member";
import { isMobile } from "../lib/isMobile";
import { getStore, initializeStore, Store } from "../lib/store";

class MyApp extends App {
  public static async getInitialProps({ Component, ctx }) {
    let firstGridItem = true;
    let teamRequired = false;

    if (
      ctx.pathname.includes("/login") ||
      ctx.pathname.includes("/create-team") ||
      ctx.pathname.includes("/invitation")
    ) {
      firstGridItem = false;
    }

    if (
      ctx.pathname.includes("/team-settings") ||
      ctx.pathname.includes("/discussion") ||
      ctx.pathname.includes("/billing")
    ) {
      teamRequired = true;
    }

    const { teamSlug, discussionSlug, redirectMessage } = ctx.query;

    const pageProps = {
      isMobile: isMobile({ req: ctx.req }),
      firstGridItem,
      teamRequired,
      teamSlug,
      discussionSlug,
      redirectMessage,
    };

    if (Component.getInitialProps) {
      Object.assign(pageProps, await Component.getInitialProps(ctx));
    }

    const appProps = { pageProps };

    const store = getStore();
    if (store) {
      return appProps;
    }

    let userObj = null;
    try {
      const { user } = await getUserApiMethod(ctx.req);
      userObj = user;
    } catch (error) {
      console.log(error);
    }

    let initialData = {};

    if (userObj) {
      try {
        initialData = await getInitialDataApiMethod({
          request: ctx.req,
          data: { teamSlug, discussionSlug },
        });
      } catch (error) {
        console.error(error);
      }
    }

    // console.log(initialData);

    // console.log(teamSlug);

    return {
      ...appProps,
      initialState: { user: userObj, currentUrl: ctx.asPath, teamSlug, ...initialData },
    };
  }

  public componentDidMount() {
    // Remove the server-side injected CSS.
    const jssStyles = document.querySelector("#jss-server-side");
    if (jssStyles && jssStyles.parentNode) {
      jssStyles.parentNode.removeChild(jssStyles);
    }
  }

  private store: Store;

  constructor(props) {
    super(props);

    console.log("MyApp.constructor");

    this.store = initializeStore(props.initialState);
  }

  public render() {
    const { Component, pageProps } = this.props;
    const store = this.store;

    const isThemeDark = store.currentUser ? store.currentUser.darkTheme : true;

    return (
      <ThemeProvider theme={isThemeDark ? themeDark : themeLight}>
        <Head>
          <meta name="viewport" content="width=device-width, initial-scale=1.0" />

          <link
            rel="stylesheet"
            href={
              isThemeDark
                ? "https://storage.googleapis.com/async-await/nprogress-light.min.css?v=1"
                : "https://storage.googleapis.com/async-await/nprogress-dark.min.css?v=1"
            }
          />
        </Head>
        <CssBaseline />
        <Provider store={store}>
          <Component {...pageProps} store={store} />
        </Provider>
      </ThemeProvider>
    );
  }
}

export default MyApp;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\pages\_document.tsx -----

import Document, { Head, Html, Main, NextScript } from "next/document";
import React from "react";

class MyDocument extends Document {
  public static getInitialProps = async (ctx) => {
    const initialProps = await Document.getInitialProps(ctx);

    return {
      ...initialProps,
    };
  };

  public render() {
    // console.log('rendered on the server');

    const isThemeDark = this.props.__NEXT_DATA__.props.initialState.user
      ? this.props.__NEXT_DATA__.props.initialState.user.darkTheme
      : true;

    return (
      <Html lang="en">
        <Head>
          <meta charSet="utf-8" />
          <meta name="google" content="notranslate" />
          <meta name="theme-color" content="#303030" />

          <link rel="shortcut icon" href="https://storage.googleapis.com/async-await/async-favicon32.png" />

          <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons" />

          <link
            rel="stylesheet"
            href={
              isThemeDark
                ? "https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/a11y-dark.min.css"
                : "https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/a11y-light.min.css"
            }
          />

          <style>
            {`
              #__next {
                width: 100%;
                height: 100%;
              }
              a {
                font-weight: 400;
                color: #58a6ff;
                text-decoration: none;
                outline: none;
              }
              hr {
                border: 0.5px #707070 solid;
                color: #000;
              }
              blockquote {
                padding: 0 0.5em;
                margin: 20px 1em;
                border-left: 0.25em solid #dfe2e5;
                color: #000;
              }
              pre {
                display: block;
                overflow-x: auto;
                padding: 0.5em;
                background: #d0d0d0;
                border: 1px solid #ddd;
                font-size: 14px;
                color: #000;
              }
              pre code {
                font-size: 13px;
                background: #d0d0d0;
                padding: 0px;
                color: #000;
              }
              code {
                font-size: 13px;
                background: #d0d0d0;
                padding: 3px 5px;
                color: #000;
              }
              mark {
                background-color: #ffff0060;
              }
              summary:focus {
                outline: none;
              }
              table {
                border-collapse: collapse;
                margin: 15px 0px;
              }
              table, th, td {
                border: 1px solid #a1a1a1;
              }
              th, td {
                line-height: 1.5em;
                padding: 10px;
              }
            `}
          </style>
        </Head>
        <body>
          <Main />
          <NextScript />
        </body>
      </Html>
    );
  }
}

export default MyDocument;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\server\server.ts -----

import express from 'express';
import next from 'next';

const NODE_ENV = process.env.NODE_ENV || 'development';
const IS_DEV = NODE_ENV !== 'production';

const app = next({ dev: IS_DEV });
const handle = app.getRequestHandler();

app.prepare().then(() => {
  const server = express();

  // give all Nextjs's request to Nextjs before anything else
  server.get('/_next/*', (req, res) => {
    // console.log('next server, page');
    handle(req, res);
  });

  server.use(express.json());

  // server.get('/api/v1/public/get-user', (_, res) => {
  //   res.json({ user: { email: 'team@builderbook.org' } });
  // });

  server.get('/team/:teamSlug/team-settings', (req, res) => {
    const { teamSlug } = req.params;
    app.render(req, res, '/team-settings', { teamSlug });
  });

  server.get('/team/:teamSlug/discussions/:discussionSlug', (req, res) => {
    const { teamSlug, discussionSlug } = req.params;
    app.render(req, res, '/discussion', { teamSlug, discussionSlug });
  });

  server.get('/team/:teamSlug/discussions', (req, res) => {
    const { teamSlug } = req.params;
    app.render(req, res, '/discussion', { teamSlug });
  });

  server.get('/team/:teamSlug/billing', (req, res) => {
    const { teamSlug } = req.params;
    app.render(req, res, '/billing', { teamSlug, ...(req.query || {}) });
  });

  server.get('/invitation', (req, res) => {
    app.render(req, res, '/invitation', { token: req.query.token as string });
  });

  server.all('*', (req, res) => {
    handle(req, res);
  });

  server.listen(process.env.NEXT_PUBLIC_PORT_APP, () => {
    console.log(`> Ready on ${process.env.NEXT_PUBLIC_URL_APP}`);
  });
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\.eslintrc.js -----

module.exports = {
  settings: {
    react: { version: 'detect' },
  },
  parser: '@typescript-eslint/parser',
  extends: ['plugin:react/recommended', 'plugin:@typescript-eslint/recommended', 'prettier'],
  env: {
    es6: true,
    node: true,
  },
  plugins: ['prettier', 'react'],
  rules: {
    'prettier/prettier': [
      'error',
      {
        singleQuote: true,
        trailingComma: 'all',
        arrowParens: 'always',
        printWidth: 100,
        semi: true,
      },
    ],
    '@typescript-eslint/camelcase': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    'react/no-unescaped-entities': 'off',
    'react/jsx-filename-extension': ['error', { extensions: ['.tsx'] }],
    '@typescript-eslint/no-explicit-any': 'off',
    'prefer-arrow-callback': 'error',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
  },
};

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\next-env.d.ts -----

/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/pages/api-reference/config/typescript for more information.

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\next.config.js -----

module.exports = {
  poweredByHeader: false,
  webpack5: true,
  typescript: {
    ignoreBuildErrors: true,
  },
};

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\nodemon.json -----

{
  "watch": ["server"],
  "exec": "ts-node --project tsconfig.server.json",
  "ext": "ts"
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\package.json -----

{
  "name": "9-end-app",
  "version": "1",
  "license": "MIT",
  "scripts": {
    "dev": "nodemon server/server.ts",
    "build": "next build",
    "lint": "eslint . --ext .ts,.tsx"
  },
  "dependencies": {
    "@emotion/react": "^11.14.0",
    "@emotion/styled": "^11.14.0",
    "@material-ui/lab": "^4.0.0-alpha.56",
    "@mui/material": "^6.4.8",
    "@mui/system": "^6.4.8",
    "@stripe/stripe-js": "^6.1.0",
    "dotenv": "^16.4.7",
    "express": "^4.21.2",
    "he": "^1.2.0",
    "isomorphic-unfetch": "^4.0.2",
    "keycode": "^2.2.0",
    "marked": "^15.0.7",
    "mobx": "5.15.7",
    "mobx-react": "6.3.1",
    "moment": "^2.30.1",
    "next": "^15.2.3",
    "nprogress": "^0.2.0",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-mentions": "^4.4.10",
    "socket.io-client": "^4.8.1",
    "typescript": "^5.8.2"
  },
  "devDependencies": {
    "@types/express": "^5.0.1",
    "@types/he": "^1.2.3",
    "@types/marked": "^6.0.0",
    "@types/node": "^22.13.11",
    "@types/react": "^19.0.12",
    "@types/react-dom": "^19.0.4",
    "@types/socket.io-client": "^3.0.0",
    "@typescript-eslint/eslint-plugin": "^8.27.0",
    "@typescript-eslint/parser": "^8.27.0",
    "eslint": "^9.22.0",
    "eslint-config-prettier": "^10.1.1",
    "eslint-plugin-prettier": "^5.2.3",
    "eslint-plugin-react": "^7.37.4",
    "nodemon": "^3.1.9",
    "prettier": "^3.5.3",
    "ts-node": "^10.9.2"
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\tsconfig.json -----

{
  "compileOnSave": false,
  "compilerOptions": {
    "target": "esnext",
    "module": "esnext",
    "jsx": "preserve",
    "allowJs": true,
    "alwaysStrict": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "removeComments": true,
    "preserveConstEnums": true,
    "sourceMap": false,
    "skipLibCheck": true,
    "baseUrl": ".",
    "typeRoots": [
      "./node_modules/@types"
    ],
    "lib": [
      "dom",
      "es2017"
    ],
    "strict": false,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "incremental": true
  },
  "include": [
    "next-env.d.ts",
    "./**/*.tsx",
    "./**/*.ts"
  ],
  "exclude": [
    "dist",
    "production-server",
    ".next",
    "out",
    "next.config.js",
    "node_modules"
  ]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\app\tsconfig.server.json -----

{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "module": "commonjs",
    "outDir": "production-server/",
    "target": "es2017",
    "isolatedModules": false,
    "noEmit": false
  },
  "exclude": ["./server/types.d.ts"],
  "include": ["./server/**/*.ts"],
  "typeRoots": ["./node_modules/@types", "./server/types.d.ts"]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\lambda\.eslintrc.js -----

module.exports = {
  parser: "@typescript-eslint/parser",
  extends: ["plugin:@typescript-eslint/recommended", "prettier"],
  env: {
    "es6": true,
    "node": true,
  },
  rules: {
    'prettier/prettier': [
      'error',
      {
        singleQuote: true,
        trailingComma: 'all',
        arrowParens: 'always',
        printWidth: 100,
        semi: true,
      },
    ],
    '@typescript-eslint/no-unused-vars': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    'prefer-arrow-callback': 'error',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
 },
  plugins: [
    "prettier"
  ]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\lambda\handler.ts -----

import * as mongoose from 'mongoose';

import sendEmail from './api/server/aws-ses';
import getEmailTemplate from './api/server/models/EmailTemplate';
import User from './api/server/models/User';

export const sendEmailForNewPost = async (event) => {
  console.log('Received event (request representation):', JSON.stringify(event));

  const reqBody = JSON.parse(event.body);

  const { discussionName, discussionLink, postContent, authorName, userIds } = reqBody;

  if (
    discussionName === undefined ||
    discussionLink === undefined ||
    postContent === undefined ||
    authorName === undefined ||
    userIds === undefined
  ) {
    throw new Error('Missing data');
  }

  console.log(discussionName, discussionLink, postContent, authorName, userIds);

  await mongoose.connect(process.env.MONGO_URL);

  try {
    const emailTemplate = await getEmailTemplate('newPost', {
      discussionName,
      discussionLink,
      postContent,
      authorName,
    });

    if (!emailTemplate) {
      throw new Error('newPost Email template not found');
    }

    const usersToNotify = await User.find({ _id: { $in: userIds } })
      .select('email')
      .setOptions({ lean: true });

    console.log('usersToNotify', usersToNotify);

    const jobs = usersToNotify
      .filter((user) => !!user.email)
      .map(async (user) => {
        try {
          await sendEmail({
            from: `From async-await.com <${process.env.EMAIL_SUPPORT_FROM_ADDRESS}>`,
            to: [user.email],
            subject: emailTemplate.subject,
            body: emailTemplate.message,
          });
          console.log('email is sent');
        } catch (err) {
          console.error(err.stack);
        }
      });

    await Promise.all(jobs);
  } catch (error) {
    console.error(error.stack);
    return { error: error.message, event };
  } finally {
    await mongoose.disconnect();
  }

  // const dev = process.env.NODE_ENV !== 'production';

  const response = {
    statusCode: 200,
    headers: {
      'Access-Control-Allow-Headers': 'Content-Type',
      'Access-Control-Allow-Origin': 'http://localhost:3000',
      'Access-Control-Allow-Methods': 'OPTIONS,POST,GET',
      'Access-Control-Allow-Credentials': true,
    },
    body: JSON.stringify({
      message: 'Email notification was sent!',
      input: event,
    }),
  };

  return response;
};

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\lambda\package.json -----

{
  "name": "lambda",
  "version": "1",
  "license": "MIT",
  "scripts": {
    "lint": "eslint . --ext .ts,.tsx",
    "trigger": "ts-node handler.ts"
  },
  "dependencies": {
    "aws-sdk": "^2.1512.0",
    "bcrypt": "^5.1.1",
    "connect-mongo": "^5.1.0",
    "cors": "^2.8.5",
    "dotenv": "^16.3.1",
    "express": "^4.18.2",
    "express-session": "^1.17.3",
    "he": "^1.2.0",
    "highlight.js": "^11.9.0",
    "lodash": "^4.17.21",
    "marked": "^11.0.0",
    "mongoose": "^8.0.2",
    "node-fetch": "2.6.1",
    "passport": "^0.7.0",
    "passport-google-oauth": "^2.0.0",
    "passwordless": "^1.1.3",
    "passwordless-tokenstore": "^0.0.10",
    "socket.io": "^4.7.2",
    "stripe": "^14.7.0",
    "typescript": "^5.3.2"
  },
  "devDependencies": {
    "@types/connect-mongo": "^3.1.3",
    "@types/dotenv": "^8.2.0",
    "@types/express": "^4.17.21",
    "@types/express-session": "^1.17.10",
    "@types/jest": "^29.5.11",
    "@types/lodash": "^4.14.202",
    "@types/mongoose": "^5.11.97",
    "@types/node": "^20.10.3",
    "@types/node-fetch": "^2.6.9",
    "@types/passport": "^1.0.16",
    "@types/socket.io": "^3.0.2",
    "@typescript-eslint/eslint-plugin": "^6.13.2",
    "@typescript-eslint/parser": "^6.13.2",
    "eslint": "^8.55.0",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-prettier": "^5.0.1",
    "jest": "^29.7.0",
    "prettier": "^3.1.0",
    "serverless-dotenv-plugin": "^6.0.0",
    "serverless-plugin-typescript": "^2.1.5",
    "ts-jest": "^29.1.1",
    "ts-node-dev": "^2.0.0"
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\9-end\lambda\tsconfig.json -----

{
  "compileOnSave": false,
  "compilerOptions": {
    "jsx": "preserve",
    "allowJs": true,
    "alwaysStrict": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "removeComments": false,
    "preserveConstEnums": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "sourceMap": true,
    "skipLibCheck": true,
    "baseUrl": ".",
    "experimentalDecorators": true,
    "typeRoots": ["./node_modules/@types"],
    "lib": ["es2015", "es2016"],
    "module": "commonjs",
    "outDir": ".build/",
    "rootDir": "./"
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\book\package.json -----

{
  "name": "book",
  "version": "0.0.1",
  "license": "MIT",
  "scripts": {
    "remove-package": "cross-env PACKAGE=typescript yarn remove-all",
    "remove-all": "yarn remove-1 && yarn remove-2 && yarn remove-3 && yarn remove-4 && yarn remove-5 && yarn remove-6 && yarn remove-7 && yarn remove-8  && yarn remove-9  && yarn remove-10",
    "remove-1": "cross-env-shell && cd 1-end/app && yarn remove $PACKAGE && cd -",
    "remove-2": "cross-env-shell && cd 2-begin/app && yarn remove $PACKAGE && cd - && cd 2-end/app && yarn remove $PACKAGE && cd -",
    "remove-3": "cross-env-shell && cd 3-begin/app && yarn remove $PACKAGE && cd - && cd 3-end/app && yarn remove $PACKAGE && cd - && cd 3-end/api && yarn remove $PACKAGE && cd -",
    "remove-4": "cross-env-shell && cd 4-begin/app && yarn remove $PACKAGE && cd - && cd 4-begin/api && yarn remove $PACKAGE && cd - && cd 4-end/app && yarn remove $PACKAGE && cd - && cd 4-end/api && yarn remove $PACKAGE && cd -",
    "remove-5": "cross-env-shell && cd 5-begin/app && yarn remove $PACKAGE && cd - && cd 5-begin/api && yarn remove $PACKAGE && cd - && cd 5-end/app && yarn remove $PACKAGE && cd - && cd 5-end/api && yarn remove $PACKAGE && cd -",
    "remove-6": "cross-env-shell && cd 6-begin/app && yarn remove $PACKAGE && cd - && cd 6-begin/api && yarn remove $PACKAGE && cd - && cd 6-end/app && yarn remove $PACKAGE && cd - && cd 6-end/api && yarn remove $PACKAGE && cd -",
    "remove-7": "cross-env-shell && cd 7-begin/app && yarn remove $PACKAGE && cd - && cd 7-begin/api && yarn remove $PACKAGE && cd - && cd 7-end/app && yarn remove $PACKAGE && cd - && cd 7-end/api && yarn remove $PACKAGE && cd -",
    "remove-8": "cross-env-shell && cd 8-begin/app && yarn remove $PACKAGE && cd - && cd 8-begin/api && yarn remove $PACKAGE && cd - && cd 8-end/app && yarn remove $PACKAGE && cd - && cd 8-end/api && yarn remove $PACKAGE && cd -",
    "remove-9": "cross-env-shell && cd 9-begin/app && yarn remove $PACKAGE && cd - && cd 9-begin/api && yarn remove $PACKAGE && cd - && cd 9-end/app && yarn remove $PACKAGE && cd - && cd 9-end/api && yarn remove $PACKAGE && cd -",
    "remove-10": "cross-env-shell && cd 10-begin/app && yarn remove $PACKAGE && cd - && cd 10-begin/api && yarn remove $PACKAGE && cd - && cd 10-end/app && yarn remove $PACKAGE && cd - && cd 10-end/api && yarn remove $PACKAGE && cd -",
    "add-package": "cross-env PACKAGE=typescript@^4.1.3 yarn add-all",
    "add-all": "yarn add-1 && yarn add-2 && yarn add-3 && yarn add-4 && yarn add-5 && yarn add-6 && yarn add-7 && yarn add-8 && yarn add-9 && yarn add-10",
    "add-1": "cross-env-shell && cd 1-end/app && yarn add $PACKAGE && cd -",
    "add-2": "cross-env-shell && cd 2-begin/app && yarn add $PACKAGE && cd - && cd 2-end/app && yarn add $PACKAGE && cd -",
    "add-3": "cross-env-shell && cd 3-begin/app && yarn add $PACKAGE && cd - && cd 3-end/app && yarn add $PACKAGE && cd - && cd 3-end/api && yarn add $PACKAGE && cd -",
    "add-4": "cross-env-shell && cd 4-begin/app && yarn add $PACKAGE && cd - && cd 4-begin/api && yarn add $PACKAGE && cd - && cd 4-end/app && yarn add $PACKAGE && cd - && cd 4-end/api && yarn add $PACKAGE && cd -",
    "add-5": "cross-env-shell && cd 5-begin/app && yarn add $PACKAGE && cd - && cd 5-begin/api && yarn add $PACKAGE && cd - && cd 5-end/app && yarn add $PACKAGE && cd - && cd 5-end/api && yarn add $PACKAGE && cd -",
    "add-6": "cross-env-shell && cd 6-begin/app && yarn add $PACKAGE && cd - && cd 6-begin/api && yarn add $PACKAGE && cd - && cd 6-end/app && yarn add $PACKAGE && cd - && cd 6-end/api && yarn add $PACKAGE && cd -",
    "add-7": "cross-env-shell && cd 7-begin/app && yarn add $PACKAGE && cd - && cd 7-begin/api && yarn add $PACKAGE && cd - && cd 7-end/app && yarn add $PACKAGE && cd - && cd 7-end/api && yarn add $PACKAGE && cd -",
    "add-8": "cross-env-shell && cd 8-begin/app && yarn add $PACKAGE && cd - && cd 8-begin/api && yarn add $PACKAGE && cd - && cd 8-end/app && yarn add $PACKAGE && cd - && cd 8-end/api && yarn add $PACKAGE && cd -",
    "add-9": "cross-env-shell && cd 9-begin/app && yarn add $PACKAGE && cd - && cd 9-begin/api && yarn add $PACKAGE && cd - && cd 9-end/app && yarn add $PACKAGE && cd - && cd 9-end/api && yarn add $PACKAGE && cd -",
    "add-10": "cross-env-shell && cd 10-begin/app && yarn add $PACKAGE && cd - && cd 10-begin/api && yarn add $PACKAGE && cd - && cd 10-end/app && yarn add $PACKAGE && cd - && cd 10-end/api && yarn add $PACKAGE && cd -",
    "yarn-all": "yarn yarn-1 && yarn yarn-2 && yarn yarn-3 && yarn yarn-4 && yarn yarn-5 && yarn yarn-6 && yarn yarn-7 && yarn yarn-8 && yarn yarn-9",
    "yarn-1": "cross-env-shell && cd 1-end/app && yarn && cd .. && cd ..",
    "yarn-2": "cross-env-shell && cd 2-begin/app && yarn && cd .. && cd .. && cd 2-end/app && yarn && cd .. && cd ..",
    "yarn-3": "cross-env-shell && cd 3-begin/app && yarn && cd .. && cd .. && cd 3-end/app && yarn && cd .. && cd .. && cd 3-end/api && yarn && cd .. && cd ..",
    "yarn-4": "cross-env-shell && cd 4-begin/app && yarn && cd .. && cd .. && cd 4-begin/api && yarn && cd .. && cd .. && cd 4-end/app && yarn && cd .. && cd .. && cd 4-end/api && yarn && cd .. && cd ..",
    "yarn-5": "cross-env-shell && cd 5-begin/app && yarn && cd .. && cd .. && cd 5-begin/api && yarn && cd .. && cd .. && cd 5-end/app && yarn && cd .. && cd .. && cd 5-end/api && yarn && cd .. && cd ..",
    "yarn-6": "cross-env-shell && cd 6-begin/app && yarn && cd .. && cd .. && cd 6-begin/api && yarn && cd .. && cd .. && cd 6-end/app && yarn && cd .. && cd .. && cd 6-end/api && yarn && cd .. && cd ..",
    "yarn-7": "cross-env-shell && cd 7-begin/app && yarn && cd .. && cd .. && cd 7-begin/api && yarn && cd .. && cd .. && cd 7-end/app && yarn && cd .. && cd .. && cd 7-end/api && yarn && cd .. && cd ..",
    "yarn-8": "cross-env-shell && cd 8-begin/app && yarn && cd .. && cd .. && cd 8-begin/api && yarn && cd .. && cd .. && cd 8-end/app && yarn && cd .. && cd .. && cd 8-end/api && yarn && cd .. && cd ..",
    "yarn-9": "cross-env-shell && cd 9-begin/app && yarn && cd .. && cd .. && cd 9-begin/api && yarn && cd .. && cd .. && cd 9-end/app && yarn && cd .. && cd .. && cd 9-end/api && yarn && cd .. && cd ..",
    "yarn-10": "cross-env-shell && cd 10-begin/app && yarn && cd .. && cd .. && cd 10-begin/api && yarn && cd .. && cd .. && cd 10-end/app && yarn && cd .. && cd .. && cd 10-end/api && yarn && cd .. && cd .."
  },
  "devDependencies": {
    "@types/he": "^0.5.29",
    "@types/marked": "^0.3.0",
    "@types/socket.io-client": "^1.4.33",
    "cross-env": "5.2.0"
  },
  "dependencies": {
    "he": "^1.2.0",
    "keycode": "^2.2.0",
    "marked": "^1.2.7",
    "moment": "^2.29.1",
    "react-mentions": "^4.0.0",
    "socket.io-client": "^2.3.0"
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\server\api\index.ts -----

import * as express from 'express';

import publicExpressRoutes from './public';
import teamMemberExpressRoutes from './team-member';
import teamLeaderApi from './team-leader';

function handleError(err, _, res, __) {
  console.error(err.stack);

  res.json({ error: err.message || err.toString() });
}

export default function api(server: express.Express) {
  server.use('/api/v1/public', publicExpressRoutes, handleError);
  server.use('/api/v1/team-member', teamMemberExpressRoutes, handleError);
  server.use('/api/v1/team-leader', teamLeaderApi, handleError);
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\server\api\public.ts -----

import * as express from 'express';

import User from '../models/User';
import Invitation from '../models/Invitation';

const router = express.Router();

router.get('/get-user', (req, res) => {
  // console.log(req.user);
  res.json({ user: req.user || null });
});

router.post('/get-user-by-slug', async (req, res, next) => {
  console.log('Express route: /get-user-by-slug');

  // req.session.foo = 'bar';

  try {
    const { slug } = req.body;

    const user = await User.getUserBySlug({ slug });

    res.json({ user });
  } catch (err) {
    next(err);
  }
});

router.get('/invitations/get-team-by-token', async (req, res, next) => {
  const token = req.query.token as string;

  try {
    const team = await Invitation.getTeamByToken({ token });

    res.json({ team });
  } catch (err) {
    next(err);
  }
});

export default router;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\server\api\team-leader.ts -----

import * as express from 'express';

import Invitation from '../models/Invitation';
import Team from '../models/Team';
import User from '../models/User';
import { createSession } from '../stripe';

const router = express.Router();

router.use((req, res, next) => {
  console.log('team leader API', req.path);

  if (!req.user) {
    res.status(401).json({ error: 'Unauthorized' });
    return;
  }

  next();
});

router.post('/teams/add', async (req: any, res, next) => {
  try {
    const { name, avatarUrl } = req.body;

    console.log(`Express route: ${name}, ${avatarUrl}`);

    const team = await Team.addTeam({ userId: req.user.id, name, avatarUrl });

    res.json(team);
  } catch (err) {
    next(err);
  }
});

router.post('/teams/update', async (req: any, res, next) => {
  try {
    const { teamId, name, avatarUrl } = req.body;

    // console.log(req.user.id, typeof req.user.id);
    // console.log(req.user._id, typeof req.user._id);

    const team = await Team.updateTeam({
      userId: req.user.id,
      teamId,
      name,
      avatarUrl,
    });

    res.json(team);
  } catch (err) {
    next(err);
  }
});

router.get('/teams/get-invitations-for-team', async (req: any, res, next) => {
  try {
    const invitations = await Invitation.getTeamInvitations({
      userId: req.user.id,
      teamId: req.query.teamId as string,
    });

    res.json({ invitations });
  } catch (err) {
    next(err);
  }
});

router.post('/teams/invite-member', async (req: any, res, next) => {
  try {
    const { teamId, email } = req.body;

    const newInvitation = await Invitation.add({ userId: req.user.id, teamId, email });

    res.json({ newInvitation });
  } catch (err) {
    next(err);
  }
});

router.post('/teams/remove-member', async (req: any, res, next) => {
  try {
    const { teamId, userId } = req.body;

    await Team.removeMember({ teamLeaderId: req.user.id, teamId, userId });

    res.json({ done: 1 });
  } catch (err) {
    next(err);
  }
});

router.post('/stripe/fetch-checkout-session', async (req: any, res, next) => {
  try {
    const { mode, teamId } = req.body;

    const user = await User.findById(req.user.id)
      .select(['stripeCustomer', 'email'])
      .setOptions({ lean: true });

    const team = await Team.findById(teamId)
      .select(['stripeSubscription', 'slug', 'teamLeaderId'])
      .setOptions({ lean: true });

    if (!user || !team || team.teamLeaderId !== req.user.id) {
      throw new Error('Permission denied');
    }

    const session = await createSession({
      mode,
      userId: user._id.toString(),
      userEmail: user.email,
      teamId,
      teamSlug: team.slug,
      customerId: (user.stripeCustomer && user.stripeCustomer.id) || undefined,
      subscriptionId: (team.stripeSubscription && team.stripeSubscription.id) || undefined,
    });

    res.json({ sessionId: session.id });
  } catch (err) {
    next(err);
  }
});

router.post('/cancel-subscription', async (req: any, res, next) => {
  const { teamId } = req.body;

  try {
    const { isSubscriptionActive } = await Team.cancelSubscription({
      teamLeaderId: req.user.id,
      teamId,
    });

    res.json({ isSubscriptionActive });
  } catch (err) {
    next(err);
  }
});

router.get('/get-list-of-invoices-for-customer', async (req: any, res, next) => {
  try {
    const { stripeListOfInvoices } = await User.getListOfInvoicesForCustomer({
      userId: req.user.id,
    });
    res.json({ stripeListOfInvoices });
  } catch (err) {
    next(err);
  }
});

export default router;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\server\api\team-member.ts -----

import * as express from 'express';

import { signRequestForUpload } from '../aws-s3';

import User from '../models/User';
import Team from '../models/Team';
import Invitation from '../models/Invitation';
import Discussion from '../models/Discussion';
import Post from '../models/Post';

import {
  discussionAdded,
  discussionDeleted,
  discussionEdited,
  postAdded,
  postDeleted,
  postEdited,
} from '../sockets';

const router = express.Router();

router.use((req, res, next) => {
  console.log('team member API', req.path);
  if (!req.user) {
    res.status(401).json({ error: 'Unauthorized' });
    return;
  }

  next();
});

// Get signed request from AWS S3 server
router.post('/aws/get-signed-request-for-upload-to-s3', async (req, res, next) => {
  try {
    const { fileName, fileType, prefix, bucket } = req.body;

    const returnData = await signRequestForUpload({
      fileName,
      fileType,
      prefix,
      bucket,
    });

    console.log(bucket);

    res.json(returnData);
  } catch (err) {
    next(err);
  }
});

router.post('/user/update-profile', async (req: any, res, next) => {
  try {
    const { name, avatarUrl } = req.body;

    const updatedUser = await User.updateProfile({
      userId: req.user.id,
      name,
      avatarUrl,
    });

    res.json({ updatedUser });
  } catch (err) {
    next(err);
  }
});

router.post('/user/toggle-theme', async (req: any, res, next) => {
  try {
    const { darkTheme } = req.body;

    await User.toggleTheme({ userId: req.user.id, darkTheme });

    res.json({ done: 1 });
  } catch (err) {
    next(err);
  }
});

async function loadDiscussionsData(team, userId, body) {
  const { discussionSlug } = body;

  if (!discussionSlug) {
    return [];
  }

  const { discussions } = await Discussion.getList({
    userId,
    teamId: team._id,
  });

  for (const discussion of discussions) {
    if (discussion.slug === discussionSlug) {
      Object.assign(discussion, {
        initialPosts: await Post.getList({
          userId,
          discussionId: discussion._id,
        }),
      });

      break;
    }
  }

  return discussions;
}

async function loadTeamData(team, userId, body) {
  const initialMembers = await User.getMembersForTeam({
    userId,
    teamId: team._id,
  });

  let initialInvitations = [];
  if (userId === team.teamLeaderId) {
    initialInvitations = await Invitation.getTeamInvitations({
      userId,
      teamId: team._id,
    });
  }

  console.log(`initialMembers:${initialMembers}`);

  const initialDiscussions = await loadDiscussionsData(team, userId, body);

  const data: any = { initialMembers, initialInvitations, initialDiscussions };

  // console.log(`Express route:${data.initialPosts}`);

  return data;
}

router.post('/get-initial-data', async (req: any, res, next) => {
  try {
    const teams = await Team.getAllTeamsForUser(req.user.id);

    let selectedTeamSlug = req.body.teamSlug;
    if (!selectedTeamSlug && teams && teams.length > 0) {
      selectedTeamSlug = teams[0].slug;
    }

    for (const team of teams) {
      if (team.slug === selectedTeamSlug) {
        Object.assign(team, await loadTeamData(team, req.user.id, req.body));
        break;
      }
    }

    // console.log(teams.length, teams);

    res.json({ teams });
  } catch (err) {
    next(err);
  }
});

// router.get('/teams', async (req, res, next) => {
//   try {
//     const teams = await Team.getAllTeamsForUser(req.user.id);

//     console.log(teams);

//     res.json({ teams });
//   } catch (err) {
//     next(err);
//   }
// });

router.get('/teams/get-members', async (req: any, res, next) => {
  try {
    const users = await User.getMembersForTeam({
      userId: req.user.id,
      teamId: req.query.teamId as string,
    });

    res.json({ users });
  } catch (err) {
    next(err);
  }
});

router.post('/discussions/add', async (req: any, res, next) => {
  try {
    const { name, teamId, memberIds = [], socketId, notificationType } = req.body;

    const discussion = await Discussion.add({
      userId: req.user.id,
      name,
      teamId,
      memberIds,
      notificationType,
    });

    discussionAdded({ socketId, discussion });

    res.json({ discussion });
  } catch (err) {
    next(err);
  }
});

router.post('/discussions/edit', async (req: any, res, next) => {
  try {
    const { name, id, memberIds = [], socketId, notificationType } = req.body;

    const updatedDiscussion = await Discussion.edit({
      userId: req.user.id,
      name,
      id,
      memberIds,
      notificationType,
    });

    discussionEdited({ socketId, discussion: updatedDiscussion });

    res.json({ done: 1 });
  } catch (err) {
    next(err);
  }
});

router.post('/discussions/delete', async (req: any, res, next) => {
  try {
    const { id, socketId } = req.body;

    const { teamId } = await Discussion.delete({ userId: req.user.id, id });

    discussionDeleted({ socketId, teamId, id });

    res.json({ done: 1 });
  } catch (err) {
    next(err);
  }
});

router.get('/discussions/list', async (req: any, res, next) => {
  try {
    const { discussions } = await Discussion.getList({
      userId: req.user.id,
      teamId: req.query.teamId as string,
    });

    res.json({ discussions });
  } catch (err) {
    next(err);
  }
});

router.get('/posts/list', async (req: any, res, next) => {
  try {
    const posts = await Post.getList({
      userId: req.user.id,
      discussionId: req.query.discussionId as string,
    });

    res.json({ posts });
  } catch (err) {
    next(err);
  }
});

router.post('/posts/add', async (req: any, res, next) => {
  try {
    const { content, discussionId, socketId } = req.body;

    const post = await Post.add({ userId: req.user.id, content, discussionId });

    postAdded({ socketId, post });

    res.json({ post });
  } catch (err) {
    next(err);
  }
});

router.post('/posts/edit', async (req: any, res, next) => {
  try {
    const { content, id, socketId } = req.body;

    const updatedPost = await Post.edit({ userId: req.user.id, content, id });

    postEdited({ socketId, post: updatedPost });

    res.json({ done: 1 });
  } catch (err) {
    next(err);
  }
});

router.post('/posts/delete', async (req: any, res, next) => {
  try {
    const { id, discussionId, socketId } = req.body;

    await Post.delete({ userId: req.user.id, id });

    postDeleted({ socketId, id, discussionId });

    res.json({ done: 1 });
  } catch (err) {
    next(err);
  }
});

export default router;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\server\models\Discussion.ts -----

import { uniq } from 'lodash';
import * as mongoose from 'mongoose';

import { generateRandomSlug } from '../utils/slugify';
import Team, { TeamDocument } from './Team';
import Post from './Post';

const mongoSchema = new mongoose.Schema({
  createdUserId: {
    type: String,
    required: true,
  },
  teamId: {
    type: String,
    required: true,
  },
  name: {
    type: String,
    required: true,
  },
  slug: {
    type: String,
    required: true,
  },
  memberIds: [
    {
      type: String,
    },
  ],
  createdAt: {
    type: Date,
    required: true,
    default: Date.now,
  },
  notificationType: {
    type: String,
    enum: ['default', 'email'],
    required: true,
    default: 'default',
  },
});

export interface DiscussionDocument extends mongoose.Document {
  createdUserId: string;
  teamId: string;
  name: string;
  slug: string;
  memberIds: string[];
  createdAt: Date;
  notificationType: string;
}

interface DiscussionModel extends mongoose.Model<DiscussionDocument> {
  getList({
    userId,
    teamId,
  }: {
    userId: string;
    teamId: string;
  }): Promise<{ discussions: DiscussionDocument[] }>;

  add({
    name,
    userId,
    teamId,
    memberIds,
    notificationType,
  }: {
    name: string;
    userId: string;
    teamId: string;
    memberIds: string[];
    notificationType: string;
  }): Promise<DiscussionDocument>;

  edit({
    userId,
    id,
    name,
    memberIds,
    notificationType,
  }: {
    userId: string;
    id: string;
    name: string;
    memberIds: string[];
    notificationType: string;
  }): Promise<DiscussionDocument>;

  delete({ userId, id }: { userId: string; id: string }): Promise<{ teamId: string }>;

  checkPermissionAndGetTeam({
    userId,
    teamId,
    memberIds,
  }: {
    userId: string;
    teamId: string;
    memberIds: string[];
  }): Promise<TeamDocument>;
}

class DiscussionClass extends mongoose.Model {
  public static async getList({ userId, teamId }) {
    await this.checkPermissionAndGetTeam({ userId, teamId });

    const filter: any = { teamId, memberIds: userId };

    const discussions: any[] = await this.find(filter).setOptions({ lean: true });

    return { discussions };
  }

  public static async add({ name, userId, teamId, memberIds = [], notificationType }) {
    if (!name) {
      throw new Error('Bad data');
    }

    await this.checkPermissionAndGetTeam({ userId, teamId, memberIds });

    const slug = await generateRandomSlug(this, { teamId });

    return this.create({
      createdUserId: userId,
      teamId,
      name,
      slug,
      memberIds: uniq([userId, ...memberIds]),
      createdAt: new Date(),
      notificationType,
    });
  }

  public static async edit({ userId, id, name, memberIds = [], notificationType }) {
    if (!id) {
      throw new Error('Bad data');
    }

    const discussion = await this.findById(id)
      .select('teamId createdUserId')
      .setOptions({ lean: true });

    const team = await this.checkPermissionAndGetTeam({
      userId,
      teamId: discussion.teamId,
      memberIds,
    });

    if (discussion.createdUserId !== userId && team.teamLeaderId !== userId) {
      throw new Error('Permission denied. Only author or team leader can edit Discussion.');
    }

    const updatedObj = await this.findOneAndUpdate(
      { _id: id },
      {
        name,
        memberIds: uniq([userId, ...memberIds]),
        notificationType,
      },
      { runValidators: true, new: true },
    );

    return updatedObj;
  }

  public static async delete({ userId, id }) {
    if (!id) {
      throw new Error('Bad data');
    }

    const discussion = await this.findById(id).select('teamId').setOptions({ lean: true });

    await this.checkPermissionAndGetTeam({ userId, teamId: discussion.teamId });

    await Post.deleteMany({ discussionId: id });

    await this.deleteOne({ _id: id });

    return { teamId: discussion.teamId };
  }

  private static async checkPermissionAndGetTeam({ userId, teamId, memberIds = [] }) {
    if (!userId || !teamId) {
      throw new Error('Bad data');
    }

    const team = await Team.findById(teamId)
      .select('memberIds teamLeaderId')
      .setOptions({ lean: true });

    if (!team || team.memberIds.indexOf(userId) === -1) {
      throw new Error('Team not found');
    }

    for (const id of memberIds) {
      if (team.memberIds.indexOf(id) === -1) {
        throw new Error('Permission denied');
      }
    }

    return team;
  }
}

mongoSchema.loadClass(DiscussionClass);

const Discussion = mongoose.model<DiscussionDocument, DiscussionModel>('Discussion', mongoSchema);

export default Discussion;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\server\models\EmailTemplate.ts -----

import * as _ from 'lodash';
import * as mongoose from 'mongoose';

interface EmailTemplateDocument extends mongoose.Document {
  name: string;
  subject: string;
  message: string;
}

const EmailTemplate = mongoose.model<EmailTemplateDocument>(
  'EmailTemplate',
  new mongoose.Schema({
    name: {
      type: String,
      required: true,
      unique: true,
    },
    subject: {
      type: String,
      required: true,
    },
    message: {
      type: String,
      required: true,
    },
  }),
);

export async function insertTemplates() {
  const templates = [
    {
      name: 'welcome',
      subject: 'Welcome to SaaS boilerplate (demo)',
      message: `Welcome <%= userName %>,
        <p>
          Thanks for signing up on our demo!
        </p>
        <p>
          If you are learning how to code and/or build a SaaS web application, check out our two books:
           <a href="https://builderbook.org" target="blank">Builder Book</a>
           and
           <a href="https://builderbook.org/book" target="blank">SaaS Boilerplate</a>.
        </p>
        <p>
          Also check out our other projects built with SaaS boilerplate:
          <a href="https://async-await.com" target="blank"> Async</a>, 
          <a href="https://async-labs.com" target="blank"> Async Labs</a>, and
          <a href="https://workinbiotech.com" target="blank"> Work in biotech</a>.
        </p>
        Kelly & Timur, Team Async Labs
      `,
    },
    {
      name: 'login',
      subject: 'Login link for saas-app.async-await.com',
      message: `
        <p>Log into your account by clicking on this link: <a href="<%= loginURL %>"><%= loginURL %></a>.</p>`,
    },
    {
      name: 'invitation',
      subject: 'You are invited to join a team at saas-app.async-await.com',
      message: `You've been invited to join <b><%= teamName%></b>.
        <br/>Click here to accept the invitation: <%= invitationURL%>
      `,
    },
    {
      name: 'newPost',
      subject: 'New Post was created in Discussion: <%= discussionName %>',
      message: `<p>New Post in Discussion: "<%= discussionName%>" by <%= authorName%></p>
        New Post: "<%= postContent %>"
        <p>---</p>
        <p>View it at <a href="<%= discussionLink %>"><%= discussionLink %></a>.</p>
      `,
    },
  ];

  for (const t of templates) {
    const et = await EmailTemplate.findOne({ name: t.name }).setOptions({ lean: true });
    const message = t.message.replace(/\n/g, '').replace(/[ ]+/g, ' ').trim();

    if (!et) {
      EmailTemplate.create(Object.assign({}, t, { message }));
    } else if (et.subject !== t.subject || et.message !== message) {
      EmailTemplate.updateOne({ _id: et._id }, { $set: { message, subject: t.subject } }).exec();
    }
  }
}

export default async function getEmailTemplate(name: string, params: any) {
  await insertTemplates();

  const et = await EmailTemplate.findOne({ name }).setOptions({ lean: true });

  if (!et) {
    throw new Error('Email Template is not found in database.');
  }

  return {
    message: _.template(et.message)(params),
    subject: _.template(et.subject)(params),
  };
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\server\models\Invitation.ts -----

import * as mongoose from 'mongoose';

import sendEmail from '../aws-ses';
import getEmailTemplate from './EmailTemplate';
import Team from './Team';
import User, { UserDocument } from './User';

const mongoSchema = new mongoose.Schema({
  teamId: {
    type: String,
    required: true,
  },
  email: {
    type: String,
    required: true,
  },
  createdAt: {
    type: Date,
    required: true,
    default: Date.now,
    expires: 60 * 60 * 24, // delete doc after 24 hours
  },
  token: {
    type: String,
    required: true,
    unique: true,
  },
});

mongoSchema.index({ teamId: 1, email: 1 }, { unique: true });

interface InvitationDocument extends mongoose.Document {
  teamId: string;
  email: string;
  createdAt: Date;
  token: string;
}

interface InvitationModel extends mongoose.Model<InvitationDocument> {
  add({
    userId,
    teamId,
    email,
  }: {
    userId: string;
    teamId: string;
    email: string;
  }): InvitationDocument;

  getTeamInvitations({ userId, teamId }: { userId: string; teamId: string });
  getTeamByToken({ token }: { token: string });
  addUserToTeam({ token, user }: { token: string; user: UserDocument });
}

function generateToken() {
  const gen = () =>
    Math.random().toString(36).substring(2, 12) + Math.random().toString(36).substring(2, 12);

  return `${gen()}`;
}

class InvitationClass extends mongoose.Model {
  public static async add({ userId, teamId, email }) {
    if (!teamId || !email) {
      throw new Error('Bad data');
    }

    const team = await Team.findById(teamId).setOptions({ lean: true });
    if (!team || team.teamLeaderId !== userId) {
      throw new Error('Team does not exist or you have no permission');
    }

    const registeredUser = await User.findOne({ email }).setOptions({ lean: true });

    if (registeredUser && team.memberIds.includes(registeredUser._id.toString())) {
      throw new Error('This user is already Team Member.');
    }

    let token;
    const invitation = await this.findOne({ teamId, email })
      .select('token')
      .setOptions({ lean: true });

    if (invitation) {
      token = invitation.token;
    } else {
      token = generateToken();
      while ((await this.countDocuments({ token })) > 0) {
        token = generateToken();
      }

      await this.create({
        teamId,
        email,
        token,
      });
    }

    const dev = process.env.NODE_ENV !== 'production';

    const emailTemplate = await getEmailTemplate('invitation', {
      teamName: team.name,
      invitationURL: `${
        dev ? process.env.URL_APP : process.env.PRODUCTION_URL_APP
      }/invitation?token=${token}`,
    });

    if (!emailTemplate) {
      throw new Error('Invitation email template not found');
    }

    try {
      await sendEmail({
        from: `Kelly from saas-app.async-await.com <${process.env.EMAIL_SUPPORT_FROM_ADDRESS}>`,
        to: [email],
        subject: emailTemplate.subject,
        body: emailTemplate.message,
      });
    } catch (err) {
      console.log('Email sending error:', err);
    }

    return await this.findOne({ teamId, email }).setOptions({ lean: true });
  }

  public static async getTeamInvitations({ userId, teamId }) {
    const team = await Team.findOne({ _id: teamId })
      .select('teamLeaderId')
      .setOptions({ lean: true });

    if (userId !== team.teamLeaderId) {
      throw new Error('You have no permission.');
    }

    return this.find({ teamId }).select('email').setOptions({ lean: true });
  }

  public static async getTeamByToken({ token }) {
    if (!token) {
      throw new Error('Bad data');
    }

    const invitation = await this.findOne({ token }).setOptions({ lean: true });

    if (!invitation) {
      throw new Error('Invitation not found');
    }

    const team = await Team.findById(invitation.teamId)
      .select('name slug avatarUrl memberIds')
      .setOptions({ lean: true });

    if (!team) {
      throw new Error('Team does not exist');
    }

    return team;
  }

  public static async addUserToTeam({ token, user }) {
    if (!token || !user) {
      throw new Error('Bad data');
    }

    const invitation = await this.findOne({ token }).setOptions({ lean: true });

    if (!invitation || invitation.email !== user.email) {
      throw new Error('Invitation not found');
    }

    await this.deleteOne({ token });

    const team = await Team.findById(invitation.teamId)
      .select('memberIds slug teamLeaderId')
      .setOptions({ lean: true });

    if (!team) {
      throw new Error('Team does not exist');
    }

    if (team && !team.memberIds.includes(user._id)) {
      await Team.updateOne({ _id: team._id }, { $addToSet: { memberIds: user._id } });

      if (user._id !== team.teamLeaderId) {
        await User.findByIdAndUpdate(user._id, { $set: { defaultTeamSlug: team.slug } });
      }
    }

    return team.slug;
  }
}

mongoSchema.loadClass(InvitationClass);

const Invitation = mongoose.model<InvitationDocument, InvitationModel>('Invitation', mongoSchema);

export default Invitation;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\server\models\Post.ts -----

import * as mongoose from 'mongoose';

import * as he from 'he';
import hljs from 'highlight.js';
import { marked } from 'marked';

import Discussion from './Discussion';
import Team from './Team';

const mongoSchema = new mongoose.Schema({
  createdUserId: {
    type: String,
    required: true,
  },
  discussionId: {
    type: String,
    required: true,
  },
  content: {
    type: String,
    required: true,
  },
  htmlContent: {
    type: String,
    required: true,
  },
  isEdited: {
    type: Boolean,
    default: false,
  },
  lastUpdatedAt: Date,
  createdAt: {
    type: Date,
    required: true,
  },
});

function markdownToHtml(content) {
  const renderer = new marked.Renderer();

  renderer.link = (href, title, text) => {
    const t = title ? ` title="${title}"` : '';

    if (text.startsWith('<code>@#')) {
      return `${text.replace('<code>@#', '<code>@')} `;
    }

    return `
      <a target="_blank" href="${href}" rel="noopener noreferrer"${t}>
        ${text}
      </a>
    `;
  };

  renderer.code = (code, infostring: string) => {
    const [lang] = infostring.split(' | ');

    const language = hljs.getLanguage(lang) ? lang : 'plaintext';

    return `<pre><code class="hljs language-${lang}">${
      hljs.highlight(code, { language }).value
    }</code></pre>`;
  };

  marked.setOptions({
    renderer,
    breaks: true,
  });

  return marked(he.decode(content));
}

export interface PostDocument extends mongoose.Document {
  createdUserId: string;
  discussionId: string;
  content: string;
  isEdited: boolean;
  lastUpdatedAt: Date;
  createdAt: Date;
}

interface PostModel extends mongoose.Model<PostDocument> {
  getList({
    userId,
    discussionId,
  }: {
    userId: string;
    discussionId: string;
  }): Promise<PostDocument[]>;

  add({
    content,
    userId,
    discussionId,
  }: {
    content: string;
    userId: string;
    discussionId: string;
  }): Promise<PostDocument>;

  edit({
    content,
    userId,
    id,
  }: {
    content: string;
    userId: string;
    id: string;
  }): Promise<PostDocument>;

  delete({ userId, id }: { userId: string; id: string }): Promise<void>;

  checkPermissionAndGetTeamAndDiscussion({
    userId,
    discussionId,
    post,
  }: {
    userId: string;
    discussionId: string;
    post: PostDocument;
  }): Promise<{ TeamDocument; DiscussionDocument }>;
}

class PostClass extends mongoose.Model {
  public static async getList({ userId, discussionId }) {
    await this.checkPermissionAndGetTeamAndDiscussion({ userId, discussionId });

    const filter: any = { discussionId };

    const posts: any[] = await this.find(filter).sort({ createdAt: 1 }).setOptions({ lean: true });

    return posts;
  }

  public static async add({ content, userId, discussionId }) {
    if (!content) {
      throw new Error('Bad data');
    }

    await this.checkPermissionAndGetTeamAndDiscussion({ userId, discussionId });

    const htmlContent = markdownToHtml(content);

    const post = await this.create({
      createdUserId: userId,
      discussionId,
      content,
      htmlContent,
      createdAt: new Date(),
    });

    return post;
  }

  public static async edit({ content, userId, id }) {
    if (!content || !id) {
      throw new Error('Bad data');
    }

    const post = await this.findById(id)
      .select('createdUserId discussionId')
      .setOptions({ lean: true });

    await this.checkPermissionAndGetTeamAndDiscussion({
      userId,
      discussionId: post.discussionId,
      post,
    });

    const htmlContent = markdownToHtml(content);

    const updatedObj = await this.findOneAndUpdate(
      { _id: id },
      { content, htmlContent, isEdited: true, lastUpdatedAt: new Date() },
      { runValidators: true, new: true },
    );

    return updatedObj;
  }

  public static async delete({ userId, id }) {
    if (!id) {
      throw new Error('Bad data');
    }

    const post = await this.findById(id)
      .select('createdUserId discussionId content')
      .setOptions({ lean: true });

    await this.checkPermissionAndGetTeamAndDiscussion({
      userId,
      discussionId: post.discussionId,
      post,
    });

    await this.deleteOne({ _id: id });
  }

  private static async checkPermissionAndGetTeamAndDiscussion({
    userId,
    discussionId,
    post = null,
  }) {
    if (!userId || !discussionId) {
      throw new Error('Bad data');
    }

    if (post && post.createdUserId !== userId) {
      throw new Error('Permission denied');
    }

    const discussion = await Discussion.findById(discussionId)
      .select('teamId memberIds slug')
      .setOptions({ lean: true });

    if (!discussion) {
      throw new Error('Discussion not found');
    }

    if (discussion.memberIds.indexOf(userId) === -1) {
      throw new Error('Permission denied');
    }

    const team = await Team.findById(discussion.teamId)
      .select('memberIds slug')
      .setOptions({ lean: true });

    if (!team || team.memberIds.indexOf(userId) === -1) {
      throw new Error('Team not found');
    }

    return { team, discussion };
  }
}

mongoSchema.loadClass(PostClass);

const Post = mongoose.model<PostDocument, PostModel>('Post', mongoSchema);

export default Post;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\server\models\Team.ts -----

import * as mongoose from 'mongoose';
import Stripe from 'stripe';

import { cancelSubscription } from '../stripe';
import { generateRandomSlug } from '../utils/slugify';
import User from './User';

const mongoSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
  },
  slug: {
    type: String,
    required: true,
    unique: true,
  },
  avatarUrl: String,
  createdAt: {
    type: Date,
    required: true,
  },
  teamLeaderId: {
    type: String,
    required: true,
  },
  memberIds: [
    {
      type: String,
      required: true,
    },
  ],
  defaultTeam: {
    type: Boolean,
    default: false,
  },
  stripeSubscription: {
    id: String,
    object: String,
    application_fee_percent: Number,
    billing: String,
    cancel_at_period_end: Boolean,
    billing_cycle_anchor: Number,
    canceled_at: Number,
    created: Number,
  },
  isSubscriptionActive: {
    type: Boolean,
    default: false,
  },
  isPaymentFailed: {
    type: Boolean,
    default: false,
  },
});

export interface TeamDocument extends mongoose.Document {
  name: string;
  slug: string;
  avatarUrl: string;
  createdAt: Date;

  teamLeaderId: string;
  memberIds: string[];
  defaultTeam: boolean;

  stripeSubscription: {
    id: string;
    object: string;
    application_fee_percent: number;
    billing: string;
    cancel_at_period_end: boolean;
    billing_cycle_anchor: number;
    canceled_at: number;
    created: number;
  };
  isSubscriptionActive: boolean;
  isPaymentFailed: boolean;
}

interface TeamModel extends mongoose.Model<TeamDocument> {
  addTeam({
    name,
    userId,
  }: {
    userId: string;
    name: string;
    avatarUrl: string;
  }): Promise<TeamDocument>;

  updateTeam({
    userId,
    teamId,
    name,
    avatarUrl,
  }: {
    userId: string;
    teamId: string;
    name: string;
    avatarUrl: string;
  }): Promise<TeamDocument>;

  getAllTeamsForUser(userId: string): Promise<TeamDocument[]>;

  removeMember({
    teamId,
    teamLeaderId,
    userId,
  }: {
    teamId: string;
    teamLeaderId: string;
    userId: string;
  }): Promise<void>;

  subscribeTeam({
    session,
    team,
  }: {
    session: Stripe.Checkout.Session;
    team: TeamDocument;
  }): Promise<void>;

  cancelSubscription({
    teamLeaderId,
    teamId,
  }: {
    teamLeaderId: string;
    teamId: string;
  }): Promise<TeamDocument>;

  cancelSubscriptionAfterFailedPayment({
    subscriptionId,
  }: {
    subscriptionId: string;
  }): Promise<TeamDocument>;
}

class TeamClass extends mongoose.Model {
  public static async addTeam({ userId, name, avatarUrl }) {
    console.log(`Static method: ${name}, ${avatarUrl}`);

    if (!userId || !name || !avatarUrl) {
      throw new Error('Bad data');
    }

    const slug = await generateRandomSlug(this);

    let defaultTeam = false;
    if ((await this.countDocuments({ teamLeaderId: userId })) === 0) {
      await User.findByIdAndUpdate(userId, { $set: { defaultTeamSlug: slug } });
      defaultTeam = true;
    }

    const team = await this.create({
      teamLeaderId: userId,
      name,
      slug,
      avatarUrl,
      memberIds: [userId],
      createdAt: new Date(),
      defaultTeam,
    });

    return team;
  }

  public static async updateTeam({ userId, teamId, name, avatarUrl }) {
    const team = await this.findById(teamId, 'name teamLeaderId');

    if (!team) {
      throw new Error('Team not found');
    }

    if (team.teamLeaderId !== userId) {
      throw new Error('Permission denied');
    }

    const modifier = { name: team.name, avatarUrl };

    if (name !== team.name) {
      modifier.name = name;
    }

    await this.updateOne({ _id: teamId }, { $set: modifier }, { runValidators: true });

    return this.findById(teamId, 'name avatarUrl slug defaultTeam').setOptions({ lean: true });
  }

  public static getAllTeamsForUser(userId: string) {
    return this.find({ memberIds: userId }).setOptions({ lean: true });
  }

  public static async removeMember({ teamId, teamLeaderId, userId }) {
    const team = await this.findById(teamId).select('memberIds teamLeaderId');

    if (!team) {
      throw new Error('Team does not exist');
    }

    if (team.teamLeaderId !== teamLeaderId || teamLeaderId === userId) {
      throw new Error('Permission denied');
    }

    await this.findByIdAndUpdate(teamId, { $pull: { memberIds: userId } });
  }

  public static async subscribeTeam({
    session,
    team,
  }: {
    session: Stripe.Checkout.Session;
    team: TeamDocument;
  }) {
    if (!session.subscription) {
      throw new Error('Not subscribed');
    }

    if (!team) {
      throw new Error('User not found.');
    }

    if (team.isSubscriptionActive) {
      throw new Error('Team is already subscribed.');
    }

    const stripeSubscription = session.subscription as Stripe.Subscription;
    if (stripeSubscription.canceled_at) {
      throw new Error('Unsubscribed');
    }

    await this.updateOne({ _id: team._id }, { stripeSubscription, isSubscriptionActive: true });
  }

  public static async cancelSubscription({ teamLeaderId, teamId }) {
    const team = await this.findById(teamId).select(
      'teamLeaderId isSubscriptionActive stripeSubscription',
    );

    if (team.teamLeaderId !== teamLeaderId) {
      throw new Error('You do not have permission to subscribe Team.');
    }

    if (!team.isSubscriptionActive) {
      throw new Error('Team is already unsubscribed.');
    }

    const cancelledSubscriptionObj = await cancelSubscription({
      subscriptionId: team.stripeSubscription.id,
    });

    return this.findByIdAndUpdate(
      teamId,
      {
        stripeSubscription: cancelledSubscriptionObj,
        isSubscriptionActive: false,
      },
      { new: true, runValidators: true },
    )
      .select('isSubscriptionActive stripeSubscription')
      .setOptions({ lean: true });
  }

  public static async cancelSubscriptionAfterFailedPayment({ subscriptionId }) {
    const team: any = await this.find({ 'stripeSubscription.id': subscriptionId })
      .select('teamLeaderId isSubscriptionActive stripeSubscription isPaymentFailed')
      .setOptions({ lean: true });
    if (!team.isSubscriptionActive) {
      throw new Error('Team is already unsubscribed.');
    }
    if (team.isPaymentFailed) {
      throw new Error('Team is already unsubscribed after failed payment.');
    }
    const cancelledSubscriptionObj = await cancelSubscription({
      subscriptionId,
    });
    return this.findByIdAndUpdate(
      team._id,
      {
        stripeSubscription: cancelledSubscriptionObj,
        isSubscriptionActive: false,
        isPaymentFailed: true,
      },
      { new: true, runValidators: true },
    )
      .select('isSubscriptionActive stripeSubscription isPaymentFailed')
      .setOptions({ lean: true });
  }
}

mongoSchema.loadClass(TeamClass);

const Team = mongoose.model<TeamDocument, TeamModel>('Team', mongoSchema);

export default Team;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\server\models\User.ts -----

import * as _ from 'lodash';
import * as mongoose from 'mongoose';
import Stripe from 'stripe';

import sendEmail from '../aws-ses';
import { addToMailchimp } from '../mailchimp';
import { generateSlug } from '../utils/slugify';
import getEmailTemplate from './EmailTemplate';
import Team, { TeamDocument } from './Team';

import { getListOfInvoices } from '../stripe';

const mongoSchema = new mongoose.Schema({
  slug: {
    type: String,
    required: true,
    unique: true,
  },
  createdAt: {
    type: Date,
    required: true,
  },
  email: {
    type: String,
    required: true,
    unique: true,
  },
  displayName: String,
  avatarUrl: String,
  googleId: {
    type: String,
    unique: true,
    sparse: true,
  },
  googleToken: {
    accessToken: String,
    refreshToken: String,
  },
  isSignedupViaGoogle: {
    type: Boolean,
    required: true,
    default: false,
  },
  darkTheme: Boolean,
  defaultTeamSlug: {
    type: String,
    default: '',
  },
  stripeCustomer: {
    id: String,
    object: String,
    created: Number,
    currency: String,
    default_source: String,
    description: String,
  },
  stripeCard: {
    id: String,
    object: String,
    brand: String,
    funding: String,
    country: String,
    last4: String,
    exp_month: Number,
    exp_year: Number,
  },
  hasCardInformation: {
    type: Boolean,
    default: false,
  },
  stripeListOfInvoices: {
    object: String,
    has_more: Boolean,
    data: [
      {
        id: String,
        object: String,
        amount_paid: Number,
        created: Number,
        customer: String,
        subscription: String,
        hosted_invoice_url: String,
        billing: String,
        paid: Boolean,
        number: String,
        teamId: String,
        teamName: String,
      },
    ],
  },
});

export interface UserDocument extends mongoose.Document {
  slug: string;
  createdAt: Date;
  email: string;
  displayName: string;
  avatarUrl: string;
  googleId: string;
  googleToken: { accessToken: string; refreshToken: string };
  isSignedupViaGoogle: boolean;
  darkTheme: boolean;
  defaultTeamSlug: string;
  stripeCustomer: {
    id: string;
    default_source: string;
    created: number;
    object: string;
    description: string;
  };
  stripeCard: {
    id: string;
    object: string;
    brand: string;
    country: string;
    last4: string;
    exp_month: number;
    exp_year: number;
    funding: string;
  };
  hasCardInformation: boolean;
  stripeListOfInvoices: {
    object: string;
    has_more: boolean;
    data: [
      {
        id: string;
        object: string;
        amount_paid: number;
        date: number;
        customer: string;
        subscription: string;
        hosted_invoice_url: string;
        billing: string;
        paid: boolean;
        number: string;
        teamId: string;
        teamName: string;
      },
    ];
  };
}

interface UserModel extends mongoose.Model<UserDocument> {
  getUserBySlug({ slug }: { slug: string }): Promise<UserDocument>;

  updateProfile({
    userId,
    name,
    avatarUrl,
  }: {
    userId: string;
    name: string;
    avatarUrl: string;
  }): Promise<UserDocument[]>;

  publicFields(): string[];

  signInOrSignUpViaGoogle({
    googleId,
    email,
    displayName,
    avatarUrl,
    googleToken,
  }: {
    googleId: string;
    email: string;
    displayName: string;
    avatarUrl: string;
    googleToken: { accessToken?: string; refreshToken?: string };
  }): Promise<UserDocument>;

  signInOrSignUpByPasswordless({
    uid,
    email,
  }: {
    uid: string;
    email: string;
  }): Promise<UserDocument>;

  toggleTheme({ userId, darkTheme }: { userId: string; darkTheme: boolean }): Promise<void>;

  getMembersForTeam({
    userId,
    teamId,
  }: {
    userId: string;
    teamId: string;
  }): Promise<UserDocument[]>;

  checkPermissionAndGetTeam({
    userId,
    teamId,
  }: {
    userId: string;
    teamId: string;
  }): Promise<TeamDocument>;

  saveStripeCustomerAndCard({
    user,
    session,
  }: {
    session: Stripe.Checkout.Session;
    user: UserDocument;
  }): Promise<void>;

  changeStripeCard({
    session,
    user,
  }: {
    session: Stripe.Checkout.Session;
    user: UserDocument;
  }): Promise<void>;

  getListOfInvoicesForCustomer({ userId }: { userId: string }): Promise<UserDocument>;
}

class UserClass extends mongoose.Model {
  public static async getUserBySlug({ slug }) {
    console.log('Static method: getUserBySlug');

    return this.findOne({ slug }, 'email displayName avatarUrl');
  }

  public static async updateProfile({ userId, name, avatarUrl }) {
    console.log('Static method: updateProfile');

    const user = await this.findById(userId, 'slug displayName');

    const modifier = { displayName: user.displayName, avatarUrl, slug: user.slug };

    console.log(user.slug);

    if (name !== user.displayName) {
      modifier.displayName = name;
      modifier.slug = await generateSlug(this, name);
    }

    return this.findByIdAndUpdate(userId, { $set: modifier }, { new: true, runValidators: true })
      .select('displayName avatarUrl slug')
      .setOptions({ lean: true });
  }

  public static publicFields(): string[] {
    return [
      '_id',
      'id',
      'displayName',
      'email',
      'avatarUrl',
      'slug',
      'isSignedupViaGoogle',
      'darkTheme',
      'defaultTeamSlug',
      'stripeCard',
      'hasCardInformation',
      'stripeListOfInvoices',
    ];
  }

  public static async signInOrSignUpViaGoogle({
    googleId,
    email,
    displayName,
    avatarUrl,
    googleToken,
  }) {
    const user = await this.findOne({ email })
      .select([...this.publicFields(), 'googleId'].join(' '))
      .setOptions({ lean: true });

    if (user) {
      if (_.isEmpty(googleToken) && user.googleId) {
        return user;
      }

      const modifier = { googleId };
      if (googleToken.accessToken) {
        modifier['googleToken.accessToken'] = googleToken.accessToken;
      }

      if (googleToken.refreshToken) {
        modifier['googleToken.refreshToken'] = googleToken.refreshToken;
      }

      await this.updateOne({ email }, { $set: modifier });

      return user;
    }

    const slug = await generateSlug(this, displayName);

    const newUser = await this.create({
      createdAt: new Date(),
      googleId,
      email,
      googleToken,
      displayName,
      avatarUrl,
      slug,
      isSignedupViaGoogle: true,
      defaultTeamSlug: '',
      darkTheme: false,
    });

    const emailTemplate = await getEmailTemplate('welcome', { userName: displayName });

    if (!emailTemplate) {
      throw new Error('Welcome email template not found');
    }

    try {
      await sendEmail({
        from: `Kelly from saas-app.async-await.com <${process.env.EMAIL_SUPPORT_FROM_ADDRESS}>`,
        to: [email],
        subject: emailTemplate.subject,
        body: emailTemplate.message,
      });
    } catch (err) {
      console.error('Email sending error:', err);
    }

    try {
      await addToMailchimp({ email, listName: 'signups' });
    } catch (error) {
      console.error('Mailchimp error:', error);
    }

    return _.pick(newUser, this.publicFields());
  }

  public static async signInOrSignUpByPasswordless({ uid, email }) {
    const user = await this.findOne({ email })
      .select(this.publicFields().join(' '))
      .setOptions({ lean: true });

    if (user) {
      throw Error('User already exists');
    }

    const slug = await generateSlug(this, email);

    const newUser = await this.create({
      _id: uid,
      createdAt: new Date(),
      email,
      slug,
      defaultTeamSlug: '',
    });

    const emailTemplate = await getEmailTemplate('welcome', { userName: email });

    if (!emailTemplate) {
      throw new Error('Email template "welcome" not found in database.');
    }

    try {
      await sendEmail({
        from: `Kelly from saas-app.async-await.com <${process.env.EMAIL_SUPPORT_FROM_ADDRESS}>`,
        to: [email],
        subject: emailTemplate.subject,
        body: emailTemplate.message,
      });
    } catch (err) {
      console.error('Email sending error:', err);
    }

    try {
      await addToMailchimp({ email, listName: 'signups' });
    } catch (error) {
      console.error('Mailchimp error:', error);
    }

    return _.pick(newUser, this.publicFields());
  }

  // try private instead of public, run `yarn build`
  public static toggleTheme({ userId, darkTheme }) {
    return this.updateOne({ _id: userId }, { darkTheme: !!darkTheme });
  }

  public static async getMembersForTeam({ userId, teamId }) {
    const team = await this.checkPermissionAndGetTeam({ userId, teamId });

    return this.find({ _id: { $in: team.memberIds } })
      .select(this.publicFields().join(' '))
      .setOptions({ lean: true });
  }

  public static async saveStripeCustomerAndCard({
    user,
    session,
  }: {
    session: Stripe.Checkout.Session;
    user: UserDocument;
  }) {
    if (!user) {
      throw new Error('User not found.');
    }

    const stripeSubscription = session.subscription as Stripe.Subscription;

    const stripeCard =
      (stripeSubscription.default_payment_method &&
        (stripeSubscription.default_payment_method as Stripe.PaymentMethod).card) ||
      undefined;

    const hasCardInformation = !!stripeCard;

    await this.updateOne(
      { _id: user._id },
      {
        stripeCustomer: session.customer,
        stripeCard,
        hasCardInformation,
      },
    );
  }

  public static async changeStripeCard({
    session,
    user,
  }: {
    session: Stripe.Checkout.Session;
    user: UserDocument;
  }): Promise<void> {
    if (!user) {
      throw new Error('User not found.');
    }

    const si: Stripe.SetupIntent = session.setup_intent as Stripe.SetupIntent;
    const pm: Stripe.PaymentMethod = si.payment_method as Stripe.PaymentMethod;

    if (!pm.card) {
      throw new Error('No card found.');
    }
    await this.updateOne({ _id: user._id }, { stripeCard: pm.card, hasCardInformation: true });
  }

  public static async getListOfInvoicesForCustomer({ userId }) {
    const user = await this.findById(userId, 'stripeCustomer');

    if (!user.stripeCustomer.id) {
      throw new Error('You are not a customer and you have no payment history.');
    }

    const newListOfInvoices = await getListOfInvoices({
      customerId: user.stripeCustomer.id,
    });

    if (newListOfInvoices.data === undefined || newListOfInvoices.data.length === 0) {
      throw new Error('You are a customer. But there is no payment history.');
    }

    const modifier = {
      stripeListOfInvoices: newListOfInvoices,
    };

    return this.findByIdAndUpdate(userId, { $set: modifier }, { new: true, runValidators: true })
      .select('stripeListOfInvoices')
      .setOptions({ lean: true });
  }

  private static async checkPermissionAndGetTeam({ userId, teamId }) {
    console.log(userId, teamId);

    if (!userId || !teamId) {
      throw new Error('Bad data');
    }

    const team = await Team.findById(teamId).select('memberIds').setOptions({ lean: true });

    if (!team || team.memberIds.indexOf(userId) === -1) {
      throw new Error('Team not found');
    }

    return team;
  }
}

mongoSchema.loadClass(UserClass);

const User = mongoose.model<UserDocument, UserModel>('User', mongoSchema);

export default User;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\server\utils\slugify.ts -----

import * as _ from 'lodash';

const slugify = (text) => _.kebabCase(text);

async function createUniqueSlug(Model, slug, count, filter) {
  const obj = await Model.findOne({ slug: `${slug}-${count}`, ...filter })
    .select('_id')
    .setOptions({ lean: true });

  if (!obj) {
    return `${slug}-${count}`;
  }

  return createUniqueSlug(Model, slug, count + 1, filter);
}

async function generateSlug(Model, name, filter = {}) {
  const origSlug = slugify(name);

  const obj = await Model.findOne({ slug: origSlug, ...filter })
    .select('_id')
    .setOptions({ lean: true });

  if (!obj) {
    return origSlug;
  }

  return createUniqueSlug(Model, origSlug, 1, filter);
}

async function generateRandomSlug(Model, filter = {}) {
  const randomString12 =
    Math.random().toString(36).substring(2, 8) + Math.random().toString(36).substring(2, 8);

  const obj = await Model.findOne({ slug: randomString12, ...filter })
    .select('_id')
    .setOptions({ lean: true });

  if (!obj) {
    return randomString12;
  }

  return generateRandomSlug(Model, filter);
}

export { generateSlug, generateRandomSlug };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\server\utils\sum.ts -----

function sum(a, b) {
  return a + b;
}

export { sum };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\server\aws-s3.ts -----

import * as url from 'url';
import * as aws from 'aws-sdk';

async function signRequestForUpload({
  fileName,
  fileType,
  prefix,
  bucket,
}: {
  fileName: string;
  fileType: string;
  prefix: string;
  bucket: string;
}) {
  const randomStringForPrefix =
    Math.random().toString(36).substring(2, 12) + Math.random().toString(36).substring(2, 12);

  const key = `${prefix}/${randomStringForPrefix}/${fileName}`;

  const acl = 'public-read';

  const params = {
    Bucket: bucket,
    Key: key,
    Expires: 60,
    ContentType: fileType,
    ACL: acl,
  };

  console.log(key, bucket);

  const s3 = new aws.S3({
    apiVersion: 'latest',
    region: process.env.AWS_REGION,
    accessKeyId: process.env.AWS_ACCESSKEYID,
    secretAccessKey: process.env.AWS_SECRETACCESSKEY,
  });

  return new Promise((resolve, reject) => {
    s3.getSignedUrl('putObject', params, (err, data) => {
      const parsedUrl = url.parse(data);

      const returnData = {
        signedRequest: data,
        url: `${parsedUrl.protocol}//${parsedUrl.hostname}${parsedUrl.pathname}`,
      };

      console.log(returnData);

      if (err) {
        console.error(err);
        reject(err);
      } else {
        resolve(returnData);
      }
    });
  });
}

export { signRequestForUpload };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\server\aws-ses.ts -----

import * as aws from 'aws-sdk';

export default function sendEmail(options) {
  const ses = new aws.SES({
    apiVersion: 'latest',
    region: process.env.AWS_REGION,
    accessKeyId: process.env.AWS_ACCESSKEYID,
    secretAccessKey: process.env.AWS_SECRETACCESSKEY,
  });

  return new Promise((resolve, reject) => {
    ses.sendEmail(
      {
        Source: options.from,
        Destination: {
          CcAddresses: options.cc,
          ToAddresses: options.to,
        },
        Message: {
          Subject: {
            Data: options.subject,
          },
          Body: {
            Html: {
              Data: options.body,
            },
          },
        },
        ReplyToAddresses: options.replyTo,
      },
      (err, info) => {
        if (err) {
          reject(err);
        } else {
          resolve(info);
        }
      },
    );
  });
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\server\google-auth.ts -----

import * as passport from 'passport';
import { OAuth2Strategy as Strategy } from 'passport-google-oauth';

import User, { UserDocument } from './models/User';
import Invitation from './models/Invitation';

const dev = process.env.NODE_ENV !== 'production';

function setupGoogle({ server }) {
  if (!process.env.GOOGLE_CLIENTID) {
    return;
  }

  const verify = async (req, accessToken, refreshToken, profile, done) => {
    let email;
    let avatarUrl;

    if (profile.emails) {
      email = profile.emails[0].value;
    }

    if (profile.photos && profile.photos.length > 0) {
      avatarUrl = profile.photos[0].value.replace('sz=50', 'sz=128');
    }

    try {
      const user = await User.signInOrSignUpViaGoogle({
        googleId: profile.id,
        email,
        googleToken: { accessToken, refreshToken },
        displayName: profile.displayName,
        avatarUrl,
      });

      let teamSlugOfInvitedTeam;
      if (user && req.session.invitationToken) {
        teamSlugOfInvitedTeam = await Invitation.addUserToTeam({
          token: req.session.invitationToken,
          user,
        }).catch((err) => console.error(err));
      }

      user.defaultTeamSlug = teamSlugOfInvitedTeam ? teamSlugOfInvitedTeam : user.defaultTeamSlug;

      done(null, user);
    } catch (err) {
      done(err);
      console.error(err);
    }
  };

  passport.use(
    new Strategy(
      {
        clientID: process.env.GOOGLE_CLIENTID,
        clientSecret: process.env.GOOGLE_CLIENTSECRET,
        callbackURL: `${dev ? process.env.URL_API : process.env.PRODUCTION_URL_API}/oauth2callback`,
        passReqToCallback: true,
      },
      verify,
    ),
  );

  passport.serializeUser((user: UserDocument, done) => {
    done(null, user._id);
  });

  passport.deserializeUser((id, done) => {
    User.findById(id, User.publicFields())
      .then((user) => {
        done(null, user);
      })
      .catch((error) => {
        done(error, null);
      });
  });

  server.use(passport.initialize());
  server.use(passport.session());

  server.get('/auth/google', (req, res, next) => {
    const options = {
      scope: ['profile', 'email'],
      prompt: 'select_account',
    };

    if (req.query && req.query.invitationToken) {
      req.session.invitationToken = req.query.invitationToken;
    } else {
      req.session.invitationToken = null;
    }

    passport.authenticate('google', options)(req, res, next);
  });

  server.get(
    '/oauth2callback',
    passport.authenticate('google', {
      failureRedirect: '/login',
    }),
    async (req, res) => {
      let teamSlugOfInvitedTeam;

      if (req.user && req.session.invitationToken) {
        teamSlugOfInvitedTeam = await Invitation.addUserToTeam({
          token: req.session.invitationToken,
          user: req.user,
        }).catch((err) => console.error(err));

        req.session.invitationToken = null;
      }

      let redirectUrlAfterLogin;
      const defaultTeamSlug = req.user && req.user.defaultTeamSlug;

      if (teamSlugOfInvitedTeam || defaultTeamSlug) {
        redirectUrlAfterLogin = `/your-settings`;
      } else {
        redirectUrlAfterLogin = `/create-team`;
      }

      res.redirect(
        `${dev ? process.env.URL_APP : process.env.PRODUCTION_URL_APP}${redirectUrlAfterLogin}`,
      );
    },
  );
}

export { setupGoogle };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\server\logger.ts -----

import * as winston from 'winston';

const dev = process.env.NODE_ENV !== 'production';

const logger = winston.createLogger({
  format: winston.format.simple(),
  level: dev ? 'debug' : 'info',
  transports: [new winston.transports.Console()],
});

export default logger;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\server\mailchimp.ts -----

import fetch, { Response } from 'node-fetch';

const LIST_IDS = {
  signups: process.env.MAILCHIMP_SAAS_ALL_LIST_ID,
};

function callAPI({
  path,
  method,
  data,
}: {
  path: string;
  method: string;
  data: {
    email_address: string;
    status: string;
  };
}): Promise<Response> {
  const ROOT_URI = `https://${process.env.MAILCHIMP_REGION}.api.mailchimp.com/3.0`;

  return fetch(`${ROOT_URI}${path}`, {
    method,
    headers: {
      Accept: 'application/json',
      Authorization: `Basic ${Buffer.from(`apikey:${process.env.MAILCHIMP_API_KEY}`).toString(
        'base64',
      )}`,
    },
    body: JSON.stringify(data),
  });
}

async function addToMailchimp({ email, listName }: { email: string; listName: string }) {
  const data = {
    email_address: email,
    status: 'subscribed',
  };

  const path = `/lists/${LIST_IDS[listName]}/members/`;

  await callAPI({ path, method: 'POST', data });
}

export { addToMailchimp };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\server\passwordless-auth.ts -----

import * as passwordless from 'passwordless';

import sendEmail from './aws-ses';
import getEmailTemplate from './models/EmailTemplate';
import User from './models/User';
import PasswordlessMongoStore from './passwordless-token-mongostore';
import Invitation from './models/Invitation';

function setupPasswordless({ server }) {
  const mongoStore = new PasswordlessMongoStore();

  const dev = process.env.NODE_ENV !== 'production';

  passwordless.addDelivery(async (tokenToSend, uidToSend, recipient, callback) => {
    try {
      const template = await getEmailTemplate('login', {
        loginURL: `${
          dev ? process.env.URL_API : process.env.PRODUCTION_URL_API
        }/auth/logged_in?token=${tokenToSend}&uid=${encodeURIComponent(uidToSend)}`,
      });

      await sendEmail({
        from: `Kelly from saas-app.async-await.com <${process.env.EMAIL_SUPPORT_FROM_ADDRESS}>`,
        to: [recipient],
        subject: template.subject,
        body: template.message,
      });

      callback();
    } catch (err) {
      console.error('Email sending error:', err);
      callback(err);
    }
  });

  passwordless.init(mongoStore);
  server.use(passwordless.sessionSupport());

  server.use((req, __, next) => {
    if (req.user && typeof req.user === 'string') {
      User.findById(req.user, User.publicFields())
        .then((user) => {
          req.user = user;
          console.log('passwordless middleware');
          next();
        })
        .catch((err) => {
          next(err);
        });
    } else {
      next();
    }
  });

  server.post(
    '/auth/email-login-link',
    passwordless.requestToken(async (email, __, callback) => {
      try {
        const user = await User.findOne({ email }).select('_id').setOptions({ lean: true });

        if (user) {
          callback(null, user._id);
        } else {
          const id = await mongoStore.storeOrUpdateByEmail(email);
          callback(null, id);
        }
      } catch (error) {
        callback(error, null);
      }
    }),
    (req, res) => {
      if (req.query && req.query.invitationToken) {
        req.session.invitationToken = req.query.invitationToken;
      } else {
        req.session.invitationToken = null;
      }

      res.json({ done: 1 });
    },
  );

  server.get(
    '/auth/logged_in',
    passwordless.acceptToken(),
    (req, __, next) => {
      if (req.user && typeof req.user === 'string') {
        User.findById(req.user, User.publicFields())
          .then((user) => {
            req.user = user;
            next();
          })
          .catch((err) => {
            next(err);
          });
      } else {
        next();
      }
    },
    async (req, res) => {
      let teamSlugOfInvitedTeam;

      if (req.user && req.session.invitationToken) {
        teamSlugOfInvitedTeam = await Invitation.addUserToTeam({
          token: req.session.invitationToken,
          user: req.user,
        }).catch((err) => console.error(err));

        req.session.invitationToken = null;
      }

      let redirectUrlAfterLogin;
      const defaultTeamSlug = req.user && req.user.defaultTeamSlug;

      if (teamSlugOfInvitedTeam || defaultTeamSlug) {
        redirectUrlAfterLogin = `/your-settings`;
      } else {
        redirectUrlAfterLogin = `/create-team`;
      }

      res.redirect(
        `${dev ? process.env.URL_APP : process.env.PRODUCTION_URL_APP}${redirectUrlAfterLogin}`,
      );
    },
  );

  server.get('/logout', (req, res, next) => {
    req.logout((err) => {
      if (err) {
        next(err);
      }

      if (req.query && req.query.invitationToken) {
        res.redirect(
          `${dev ? process.env.URL_APP : process.env.PRODUCTION_URL_APP}/invitation?token=${
            req.query.invitationToken
          }`,
        );
      } else {
        res.redirect(`${dev ? process.env.URL_APP : process.env.PRODUCTION_URL_APP}/login`);
      }
    });
  });
}

export { setupPasswordless };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\server\passwordless-token-mongostore.ts -----

import * as bcrypt from 'bcryptjs';
import * as mongoose from 'mongoose';
import * as TokenStore from 'passwordless-tokenstore';
import * as util from 'util';

import User from './models/User';

interface TokenDocument extends mongoose.Document {
  hashedToken: string;
  uid: string;
  ttl: Date;
  originUrl: string;
  email: string;
}

const mongoSchema = new mongoose.Schema({
  hashedToken: {
    type: String,
    required: true,
  },
  uid: {
    type: String,
    required: true,
    unique: true,
  },
  ttl: {
    type: Date,
    required: true,
    expires: 0,
  },
  originUrl: String,
  email: String,
});

const PasswordlessToken = mongoose.model<TokenDocument>(
  'PasswordlessToken',
  mongoSchema,
  'passwordless-token',
);

function MongoStore(options = {}) {
  TokenStore.call(this);

  this._options = options || {};
}

util.inherits(MongoStore, TokenStore);

MongoStore.prototype.authenticate = async function (token, uid, callback) {
  if (!token || !uid || !callback) {
    throw new Error('TokenStore:authenticate called with invalid parameters');
  }

  try {
    const tokenDoc = await PasswordlessToken.findOne({ uid, ttl: { $gt: new Date() } }).setOptions({
      lean: true,
    });

    if (tokenDoc) {
      const isMatch = await bcrypt.compare(token, tokenDoc.hashedToken);
      if (isMatch) {
        if (tokenDoc.email) {
          await User.signInOrSignUpByPasswordless({ uid, email: tokenDoc.email });
        }

        callback(null, true, tokenDoc.originUrl);
      } else {
        callback(null, false, null);
      }
    } else {
      callback(null, false, null);
    }
  } catch (error) {
    callback(error, false, null);
  }
};

MongoStore.prototype.storeOrUpdate = async function (token, uid, msToLive, originUrl, callback) {
  if (!token || !uid || !msToLive || !callback) {
    throw new Error('TokenStore:storeOrUpdate called with invalid parameters');
  }

  const saltRounds = 10;

  try {
    const hashedToken = await bcrypt.hash(token, saltRounds);
    const newRecord = { hashedToken, uid, ttl: new Date(Date.now() + msToLive), originUrl };

    await PasswordlessToken.updateOne(
      { uid },
      { $set: newRecord },
      { upsert: true, runValidators: true },
    );
    callback();
  } catch (error) {
    callback(error);
  }
};

MongoStore.prototype.invalidateUser = async function (uid, callback) {
  if (!uid || !callback) {
    throw new Error('TokenStore:invalidateUser called with invalid parameters');
  }

  try {
    await PasswordlessToken.deleteOne({ uid });
    callback();
  } catch (error) {
    callback(error);
  }
};

MongoStore.prototype.clear = async function (callback) {
  if (!callback) {
    throw new Error('TokenStore:clear called with invalid parameters');
  }

  try {
    await PasswordlessToken.deleteMany({});
    callback();
  } catch (error) {
    callback(error);
  }
};

MongoStore.prototype.length = function (callback) {
  PasswordlessToken.countDocuments(callback);
};

MongoStore.prototype.storeOrUpdateByEmail = async function addEmail(email: string) {
  if (!email) {
    throw new Error('TokenStore:addEmail called with invalid parameters');
  }

  const obj = await PasswordlessToken.findOne({ email }).select('uid').setOptions({ lean: true });

  if (obj) {
    return obj.uid;
  }

  const uid = new mongoose.Types.ObjectId().toHexString();
  await PasswordlessToken.updateOne({ uid }, { email }, { upsert: true });

  return uid;
};

export default MongoStore;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\server\server.ts -----

import * as cors from 'cors';
import * as express from 'express';
import * as session from 'express-session';
import * as httpModule from 'http';
import * as mongoose from 'mongoose';

import mongoSessionStore = require('connect-mongo');

import api from './api';
import { setupGoogle } from './google-auth';
import { setupPasswordless } from './passwordless-auth';
import { setupSockets } from './sockets';
import { stripeWebhookAndCheckoutCallback } from './stripe';

import logger from './logger';

import * as compression from 'compression';
import helmet from 'helmet';

// eslint-disable-next-line
require('dotenv').config();

const dev = process.env.NODE_ENV !== 'production';
const port = process.env.PORT || 8000;
const MONGO_URL = dev ? process.env.MONGO_URL_TEST : process.env.MONGO_URL;

// check connection
(async () => {
  try {
    mongoose.set('strictQuery', false);
    await mongoose.connect(MONGO_URL);
    logger.info('connected to db');

    // async tasks, for ex, inserting email templates to db
    // logger.info('finished async tasks');
  } catch (err) {
    console.log('error: ' + err);
  }
})();

const server = express();

server.use(
  cors({
    origin: dev ? process.env.URL_APP : process.env.PRODUCTION_URL_APP,
    methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',
    credentials: true,
  }),
);

server.use(helmet());
server.use(compression());

stripeWebhookAndCheckoutCallback({ server });

server.use(express.json());

const sessionOptions = {
  name: process.env.SESSION_NAME,
  secret: process.env.SESSION_SECRET,
  store: mongoSessionStore.create({
    mongoUrl: MONGO_URL,
    ttl: 14 * 24 * 60 * 60, // save session 14 days
  }),
  resave: false,
  saveUninitialized: false,
  cookie: {
    httpOnly: true,
    maxAge: 14 * 24 * 60 * 60 * 1000, // expires in 14 days
    domain: dev ? 'localhost' : process.env.COOKIE_DOMAIN,
  } as any,
};

if (!dev) {
  server.set('trust proxy', 1); // sets req.hostname, req.ip
  sessionOptions.cookie.secure = true; // sets cookie over HTTPS only
}

const sessionMiddleware = session(sessionOptions);
server.use(sessionMiddleware);

setupGoogle({ server });
setupPasswordless({ server });

api(server);

const httpServer = httpModule.createServer(server);
setupSockets({
  httpServer,
  origin: dev ? process.env.URL_APP : process.env.PRODUCTION_URL_APP,
  sessionMiddleware,
});

server.get('*', (_, res) => {
  res.sendStatus(403);
});

httpServer.listen(port, () => {
  logger.debug('debug right before info');
  logger.info(`> Ready on ${dev ? process.env.URL_API : process.env.PRODUCTION_URL_API}`);
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\server\sockets.ts -----

import { Response } from 'express';
import * as express from 'express';
import { Server } from 'socket.io';
import * as httpModule from 'http';

import { DiscussionDocument } from './models/Discussion';
import { PostDocument } from './models/Post';

let io: Server = null;

const dev = process.env.NODE_ENV !== 'production';

function setupSockets({
  httpServer,
  origin,
  sessionMiddleware,
}: {
  httpServer: httpModule.Server;
  origin: string | boolean | RegExp | (string | RegExp)[];
  sessionMiddleware: express.RequestHandler;
}) {
  if (io === null) {
    io = new Server(httpServer, {
      cors: {
        origin,
        methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',
        credentials: true,
      },
      cookie: {
        name: 'saas-socket-cookie',
        httpOnly: true,
        maxAge: 14 * 24 * 60 * 60 * 1000, // expires in 14 days
        domain: dev ? 'localhost' : '.async-await.com',
        secure: dev ? false : true,
      },
      serveClient: false,
      transports: ['polling', 'websocket'],
    });

    const wrap = (middleware) => (socket, next) => middleware(socket.request, {} as Response, next);

    io.use(wrap(sessionMiddleware));

    io.on('connection', (socket: any) => {
      if (
        !socket.request.session ||
        ((!socket.request.session.passport || !socket.request.session.passport.user) &&
          !socket.request.session.passwordless)
      ) {
        socket.disconnect(true);
        return;
      }

      socket.on('joinTeamRoom', (teamId) => {
        console.log(`    joinTeamRoom ${teamId}`);
        socket.join(`teamRoom-${teamId}`);
      });

      socket.on('leaveTeamRoom', (teamId) => {
        console.log(`** leaveTeamRoom ${teamId}`);
        socket.leave(`teamRoom-${teamId}`);
      });

      socket.on('joinDiscussionRoom', (discussionId) => {
        console.log(`    joinDiscussionRoom ${discussionId}`);
        socket.join(`discussionRoom-${discussionId}`);
      });

      socket.on('leaveDiscussionRoom', (discussionId) => {
        console.log(`** leaveDiscussionRoom ${discussionId}`);
        socket.leave(`discussionRoom-${discussionId}`);
      });

      socket.on('disconnect', (reason) => {
        console.log(`disconnected`, `reason: ` + reason);
      });
    });
  }
}

function getSocket(socketId?: string) {
  if (!io) {
    return null;
  }

  if (socketId && io.sockets.sockets.get(socketId)) {
    return io.sockets.sockets.get(socketId).broadcast;
  } else {
    return io;
  }
}

function discussionAdded({
  socketId,
  discussion,
}: {
  socketId?: string;
  discussion: DiscussionDocument;
}) {
  const roomName = `teamRoom-${discussion.teamId}`;

  const socket = getSocket(socketId);
  if (socket) {
    socket.to(roomName).emit('discussionEvent', { actionType: 'added', discussion });
  }
}

function discussionEdited({
  socketId,
  discussion,
}: {
  socketId?: string;
  discussion: DiscussionDocument;
}) {
  const roomName = `teamRoom-${discussion.teamId}`;
  const socket = getSocket(socketId);

  if (socket) {
    socket.to(roomName).emit('discussionEvent', {
      actionType: 'edited',
      discussion,
    });
  }
}

function discussionDeleted({
  socketId,
  teamId,
  id,
}: {
  socketId?: string;
  teamId: string;
  id: string;
}) {
  const roomName = `teamRoom-${teamId}`;
  const socket = getSocket(socketId);

  if (socket) {
    socket.to(roomName).emit('discussionEvent', { actionType: 'deleted', id });
  }
}

function postAdded({ socketId, post }: { socketId?: string; post: PostDocument }) {
  const roomName = `discussionRoom-${post.discussionId}`;

  const socket = getSocket(socketId);
  if (socket) {
    socket.to(roomName).emit('postEvent', { actionType: 'added', post });
  }
}

function postEdited({ socketId, post }: { socketId?: string; post: PostDocument }) {
  const roomName = `discussionRoom-${post.discussionId}`;

  const socket = getSocket(socketId);
  if (socket) {
    socket.to(roomName).emit('postEvent', { actionType: 'edited', post });
  }
}

function postDeleted({
  socketId,
  id,
  discussionId,
}: {
  socketId?: string;
  id: string;
  discussionId: string;
}) {
  const roomName = `discussionRoom-${discussionId}`;

  const socket = getSocket(socketId);
  if (socket) {
    socket.to(roomName).emit('postEvent', { actionType: 'deleted', id });
  }
}

export {
  setupSockets,
  postAdded,
  postEdited,
  postDeleted,
  discussionAdded,
  discussionEdited,
  discussionDeleted,
};

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\server\stripe.ts -----

import * as dotenv from 'dotenv';
import * as express from 'express';
import Stripe from 'stripe';

import Team from './models/Team';
import User from './models/User';

import logger from './logger';

dotenv.config();

const dev = process.env.NODE_ENV !== 'production';

const stripeInstance = new Stripe(
  dev ? process.env.STRIPE_TEST_SECRETKEY : process.env.STRIPE_LIVE_SECRETKEY,
  { apiVersion: '2023-10-16' },
);

function createSession({
  userId,
  teamId,
  teamSlug,
  customerId,
  subscriptionId,
  userEmail,
  mode,
}: {
  userId: string;
  teamId: string;
  teamSlug: string;
  customerId: string;
  subscriptionId: string;
  userEmail: string;
  mode: Stripe.Checkout.SessionCreateParams.Mode;
}) {
  const params: Stripe.Checkout.SessionCreateParams = {
    customer_email: customerId ? undefined : userEmail,
    customer: customerId,
    payment_method_types: ['card'],
    mode,
    success_url: `${
      dev ? process.env.URL_API : process.env.PRODUCTION_URL_API
    }/stripe/checkout-completed/{CHECKOUT_SESSION_ID}`,
    cancel_url: `${
      dev ? process.env.URL_APP : process.env.PRODUCTION_URL_APP
    }/teams/${teamSlug}/billing?redirectMessage=Checkout%20canceled`,
    metadata: { userId, teamId },
  };

  console.log(process.env.STRIPE_TEST_SECRETKEY, process.env.STRIPE_TEST_PRICEID);

  if (mode === 'subscription') {
    params.line_items = [
      {
        price: dev ? process.env.STRIPE_TEST_PRICEID : process.env.STRIPE_LIVE_PRICEID,
        quantity: 1,
      },
    ];
  } else if (mode === 'setup') {
    if (!customerId || !subscriptionId) {
      throw new Error('customerId and subscriptionId required');
    }

    params.setup_intent_data = {
      metadata: { customer_id: customerId, subscription_id: subscriptionId },
    };
  }

  return stripeInstance.checkout.sessions.create(params);
}

function retrieveSession({ sessionId }: { sessionId: string }) {
  return stripeInstance.checkout.sessions.retrieve(sessionId, {
    expand: [
      'setup_intent',
      'setup_intent.payment_method',
      'customer',
      'subscription',
      'subscription.default_payment_method',
    ],
  });
}

function updateCustomer(customerId, params: Stripe.CustomerUpdateParams) {
  logger.debug('updating customer', customerId);
  return stripeInstance.customers.update(customerId, params);
}

function updateSubscription(subscriptionId: string, params: Stripe.SubscriptionUpdateParams) {
  logger.debug('updating subscription', subscriptionId);
  return stripeInstance.subscriptions.update(subscriptionId, params);
}

function cancelSubscription({ subscriptionId }: { subscriptionId: string }) {
  logger.debug('cancel subscription', subscriptionId);
  return stripeInstance.subscriptions.cancel(subscriptionId);
}

function getListOfInvoices({ customerId }: { customerId: string }) {
  logger.debug('getting list of invoices for customer', customerId);
  return stripeInstance.invoices.list({ customer: customerId, limit: 100 });
}

function stripeWebhookAndCheckoutCallback({ server }: { server: express.Application }) {
  server.post(
    '/api/v1/public/stripe-invoice-payment-failed',
    express.raw({ type: 'application/json' }),
    async (req, res, next) => {
      try {
        const event = stripeInstance.webhooks.constructEvent(
          req.body,
          req.headers['stripe-signature'],
          dev ? process.env.STRIPE_TEST_ENDPOINTSECRET : process.env.STRIPE_LIVE_ENDPOINTSECRET,
        );

        logger.debug(`${event.id}, ${event.type}`);

        // invoice.payment_failed
        // data.object is an invoice
        // Occurs whenever an invoice payment attempt fails, due either to a declined payment or to the lack of a stored payment method.

        if (event.type === 'invoice.payment_failed') {
          const { subscription } = event.data.object;
          logger.debug(JSON.stringify(subscription));

          await Team.cancelSubscriptionAfterFailedPayment({
            subscriptionId: JSON.stringify(subscription),
          });
        }

        res.sendStatus(200);
      } catch (err) {
        console.error(`Webhook error: ${err.message}`);
        next(err);
      }
    },
  );

  server.get('/stripe/checkout-completed/:sessionId', async (req, res) => {
    const { sessionId } = req.params;

    const session = await retrieveSession({ sessionId });
    if (!session || !session.metadata || !session.metadata.userId || !session.metadata.teamId) {
      throw new Error('Wrong session.');
    }

    const user = await User.findById(
      session.metadata.userId,
      '_id stripeCustomer email displayName isSubscriptionActive stripeSubscription',
    ).setOptions({ lean: true });

    const team = await Team.findById(
      session.metadata.teamId,
      'isSubscriptionActive stripeSubscription teamLeaderId slug',
    ).setOptions({ lean: true });

    if (!user) {
      throw new Error('User not found.');
    }

    if (!team) {
      throw new Error('Team not found.');
    }

    if (team.teamLeaderId !== user._id.toString()) {
      throw new Error('Permission denied');
    }

    try {
      if (session.mode === 'setup' && session.setup_intent) {
        const si: Stripe.SetupIntent = session.setup_intent as Stripe.SetupIntent;
        const pm: Stripe.PaymentMethod = si.payment_method as Stripe.PaymentMethod;

        if (user.stripeCustomer) {
          await updateCustomer(user.stripeCustomer.id, {
            invoice_settings: { default_payment_method: pm.id },
          });
        }

        if (team.stripeSubscription) {
          await updateSubscription(team.stripeSubscription.id, { default_payment_method: pm.id });
        }

        await User.changeStripeCard({ session, user });
      } else if (session.mode === 'subscription') {
        await User.saveStripeCustomerAndCard({ session, user });
        await Team.subscribeTeam({ session, team });
        await User.getListOfInvoicesForCustomer({ userId: user._id });
      } else {
        throw new Error('Wrong session.');
      }

      res.redirect(
        `${dev ? process.env.URL_APP : process.env.PRODUCTION_URL_APP}/teams/${team.slug}/billing`,
      );
    } catch (err) {
      console.error(err);

      res.redirect(
        `${dev ? process.env.URL_APP : process.env.PRODUCTION_URL_APP}/teams/${
          team.slug
        }/billing?redirectMessage=${err.message || err.toString()}`,
      );
    }
  });
}

export { createSession, cancelSubscription, getListOfInvoices, stripeWebhookAndCheckoutCallback };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\test\server\utils\slugify.test.ts -----

import * as mongoose from 'mongoose';
import User from '../../../server/models/User';
import { generateSlug } from '../../../server/utils/slugify';

// eslint-disable-next-line
require('dotenv').config();

describe('slugify', () => {
  beforeAll(async (done) => {
    await mongoose.connect(process.env.MONGO_URL_TEST);

    const mockUsers = [
      {
        slug: 'john',
        email: 'john@example.com',
        createdAt: new Date(),
        displayName: 'abc',
        avatarUrl: 'def',
      },
      {
        slug: 'john-johnson',
        email: 'john-johnson@example.com',
        createdAt: new Date(),
        displayName: 'abc',
        avatarUrl: 'def',
      },
      {
        slug: 'john-johnson-1',
        email: 'john-johnson-1@example.com',
        createdAt: new Date(),
        displayName: 'abc',
        avatarUrl: 'def',
      },
    ];

    await User.insertMany(mockUsers);

    done();
  });

  test('not duplicated', async () => {
    expect.assertions(1);

    await expect(generateSlug(User, 'John J Johnson@#$')).resolves.toEqual('john-j-johnson');
  });

  test('one time duplicated', async () => {
    expect.assertions(1);

    await expect(generateSlug(User, ' John@#$')).resolves.toEqual('john-1');
  });

  test('multiple duplicated', async () => {
    expect.assertions(1);

    await expect(generateSlug(User, 'John & Johnson@#$')).resolves.toEqual('john-johnson-2');
  });

  afterAll(async (done) => {
    await User.deleteMany({ slug: { $in: ['john', 'john-johnson', 'john-johnson-1'] } });
    await mongoose.disconnect();

    done();
  });
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\test\server\utils\sum.test.ts -----

import { sum } from '../../../server/utils/sum';

console.log(sum(1, 2));

describe.skip('testing sum function', () => {
  test('adds 1 + 2 to equal 3', () => {
    expect(sum(1, 2)).toBe(3);
  });
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\.eslintrc.js -----

module.exports = {
  parser: "@typescript-eslint/parser",
  extends: ["plugin:@typescript-eslint/recommended", "prettier"],
  env: {
    "es6": true,
    "node": true,
  },
  plugins: ["prettier"],
  rules: {
    'prettier/prettier': [
      'error',
      {
        singleQuote: true,
        trailingComma: 'all',
        arrowParens: 'always',
        printWidth: 100,
        semi: true,
      },
    ],
    '@typescript-eslint/no-unused-vars': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/no-explicit-any': 'off',
    'prefer-arrow-callback': 'error',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
 },
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\nodemon.json -----

{
  "watch": ["server"],
  "exec": "ts-node --project tsconfig.json",
  "ext": "ts"
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\package.json -----

{
  "name": "api-same-as-10-end-api",
  "version": "1.0.0",
  "license": "MIT",
  "engines": {
    "node": "18.17.0",
    "yarn": "1.22.19"
  },
  "scripts": {
    "dev": "nodemon server/server.ts",
    "lint": "eslint . --ext .ts,.tsx",
    "test": "jest",
    "postinstall": "rm -rf production-server/",
    "build": "tsc --project tsconfig.json",
    "start": "node production-server/server.js"
  },
  "jest": {
    "preset": "ts-jest",
    "testPathIgnorePatterns": [
      "production-server"
    ],
    "testEnvironment": "node"
  },
  "dependencies": {
    "aws-sdk": "^2.1514.0",
    "bcryptjs": "^2.4.3",
    "compression": "^1.7.4",
    "connect-mongo": "^5.1.0",
    "cors": "^2.8.5",
    "dotenv": "^16.3.1",
    "express": "^4.18.2",
    "express-session": "^1.17.3",
    "he": "^1.2.0",
    "helmet": "7.1.0",
    "highlight.js": "^11.9.0",
    "lodash": "^4.17.21",
    "marked": "^11.0.0",
    "mongoose": "^8.0.3",
    "node-fetch": "2.6.1",
    "passport": "^0.7.0",
    "passport-google-oauth": "^2.0.0",
    "passwordless": "^1.1.3",
    "passwordless-tokenstore": "^0.0.10",
    "socket.io": "^4.7.2",
    "stripe": "^14.8.0",
    "typescript": "^5.3.3",
    "winston": "^3.11.0"
  },
  "devDependencies": {
    "@types/connect-mongo": "^3.1.3",
    "@types/dotenv": "^8.2.0",
    "@types/express": "^4.17.21",
    "@types/express-session": "^1.17.10",
    "@types/jest": "^29.5.11",
    "@types/lodash": "^4.14.202",
    "@types/mongoose": "^5.11.97",
    "@types/node": "^20.10.4",
    "@types/node-fetch": "^2.6.9",
    "@types/passport": "^1.0.16",
    "@types/socket.io": "^3.0.2",
    "@typescript-eslint/eslint-plugin": "^6.13.2",
    "@typescript-eslint/parser": "^6.13.2",
    "eslint": "^8.55.0",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-prettier": "^5.0.1",
    "jest": "^29.7.0",
    "nodemon": "^3.0.2",
    "prettier": "^3.1.0",
    "ts-jest": "^29.1.1",
    "ts-node": "^10.9.1"
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\api\tsconfig.json -----

{
  "compileOnSave": false,
  "compilerOptions": {
    "jsx": "preserve",
    "allowJs": true,
    "alwaysStrict": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "removeComments": false,
    "preserveConstEnums": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "sourceMap": true,
    "skipLibCheck": true,
    "baseUrl": ".",
    "experimentalDecorators": true,
    "typeRoots": ["./node_modules/@types"],
    "target": "es2020",
    "lib": ["es2020"],
    "module": "commonjs",
    "outDir": "production-server/",
    "downlevelIteration": true,
  },
  "include": ["./server/**/*.ts"]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\components\common\Confirmer.tsx -----

import Button from '@mui/material/Button';
import Dialog from '@mui/material/Dialog';
import DialogActions from '@mui/material/DialogActions';
import DialogContent from '@mui/material/DialogContent';
import DialogContentText from '@mui/material/DialogContentText';
import DialogTitle from '@mui/material/DialogTitle';
import React from 'react';

export let openConfirmDialogExternal;

type State = {
  open: boolean;
  title: string;
  message: string;
  onAnswer: (answer) => void;
};

class Confirmer extends React.Component<any, State> {
  constructor(props) {
    super(props);

    this.state = {
      open: false,
      title: 'Are you sure?',
      message: '',
      onAnswer: null,
    };

    openConfirmDialogExternal = this.openConfirmDialog;
  }

  public render() {
    return (
      <Dialog
        open={this.state.open}
        onClose={this.handleClose}
        aria-labelledby="alert-dialog-title"
        aria-describedby="alert-dialog-description"
      >
        <DialogTitle id="alert-dialog-title">{this.state.title}</DialogTitle>
        <DialogContent>
          <DialogContentText id="alert-dialog-description">{this.state.message}</DialogContentText>
        </DialogContent>
        <DialogActions style={{ padding: '10px' }}>
          <Button onClick={this.handleClose} variant="contained" color="primary" autoFocus>
            Cancel
          </Button>
          <Button onClick={this.handleYes} variant="contained" color="secondary">
            OK
          </Button>
        </DialogActions>
      </Dialog>
    );
  }

  public handleClose = () => {
    this.setState({ open: false });
    this.state.onAnswer(false);
  };

  public handleYes = () => {
    this.setState({ open: false });
    this.state.onAnswer(true);
  };

  public openConfirmDialog = ({ title, message, onAnswer }) => {
    this.setState({ open: true, title, message, onAnswer });
  };
}

export default Confirmer;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\components\common\LoginButton.tsx -----

import Button from '@mui/material/Button';
import TextField from '@mui/material/TextField';
import React from 'react';

import { emailLoginLinkApiMethod } from '../../lib/api/public';
import notify from '../../lib/notify';
import { makeQueryString } from '../../lib/api/makeQueryString';

const dev = process.env.NODE_ENV !== 'production';

type Props = { invitationToken?: string };
type State = { email: string };

class LoginButton extends React.PureComponent<Props, State> {
  constructor(props) {
    super(props);

    this.state = { email: '' };
  }

  public render() {
    const { invitationToken } = this.props;

    let url = `${
      dev ? process.env.NEXT_PUBLIC_URL_API : process.env.NEXT_PUBLIC_PRODUCTION_URL_API
    }/auth/google`;
    const qs = makeQueryString({ invitationToken });

    if (qs) {
      url += `?${qs}`;
    }

    // console.log(url);

    return (
      <React.Fragment>
        <Button variant="contained" color="secondary" href={url}>
          <img
            src="https://storage.googleapis.com/async-await-all/G.svg"
            alt="Log in with Google"
          />
          &nbsp;&nbsp;&nbsp; Log in with Google
        </Button>
        <p />
        <br />
        <hr style={{ width: '60px' }} /> <h4>OR</h4> <hr style={{ width: '60px' }} />
        <p />
        <br />
        <div>
          <form autoComplete="off" onSubmit={this.onSubmit}>
            <TextField
              disabled
              required
              type="email"
              label="Email address"
              value={this.state.email}
              onChange={(event) => {
                this.setState({ email: event.target.value });
              }}
              style={{ width: '300px' }}
            />
            <p>Disabled in this demo due to high bounce rate (people submitting fake emails)</p>
            <Button disabled variant="contained" color="primary" type="submit">
              Log in with email
            </Button>
          </form>
          <p />
          <br />
        </div>
      </React.Fragment>
    );
  }

  private onSubmit = async (event) => {
    event.preventDefault();
    const { email } = this.state;
    const { invitationToken } = this.props;

    if (!email) {
      notify('Email is required');
      return;
    }

    try {
      await emailLoginLinkApiMethod({ email, invitationToken });
      this.setState({ email: '' });
      notify('SaaS boilerplate emailed you a login link.');
    } catch (error) {
      notify(error);
    }
  };
}

export default LoginButton;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\components\common\MemberChooser.tsx -----

import React from 'react';

import Autocomplete from '@mui/material/Autocomplete';
import TextField from '@mui/material/TextField';

import { User } from '../../lib/store/user';

type Props = {
  onChange: (item) => void;
  selectedMemberIds?: string[];
  members: User[];
  label?: string;
  helperText?: string;
};

type State = {
  selectedItems: { label: string; id: string }[];
};

class MemberChooser extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    const suggestions = this.props.members.map((user) => ({
      label: user.displayName || user.email,
      id: user._id,
    }));

    const selectedItems = suggestions.filter(
      (s) => this.props.selectedMemberIds.indexOf(s.id) !== -1,
    );

    this.state = {
      selectedItems: selectedItems || [],
    };
  }

  public render() {
    const suggestions = this.props.members.map((user) => ({
      label: user.displayName || user.email,
      id: user._id,
    }));

    return (
      <Autocomplete
        multiple
        id="tags-standard"
        options={suggestions}
        getOptionLabel={(option) => option.label}
        isOptionEqualToValue={(option, value) => option.id === value.id}
        value={this.state.selectedItems}
        renderInput={(params) => (
          <TextField
            {...params}
            variant="standard"
            label="Find team member by name"
            placeholder="Select participants"
          />
        )}
        onChange={this.handleChange}
        filterSelectedOptions={true}
        noOptionsText="No team members to select from"
      />
    );
  }

  public handleChange = (event, value) => {
    event.preventDefault();

    const selectedItems = value;

    this.setState({ selectedItems });

    this.props.onChange(selectedItems.map((i) => i.id));
  };
}

export default MemberChooser;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\components\common\MenuWithLinks.tsx -----

import Menu from '@mui/material/Menu';
import MenuItem from '@mui/material/MenuItem';
import Router, { NextRouter, withRouter } from 'next/router';
import React from 'react';

type Props = {
  options: {
    href: string;
    as: string;
    highlighterSlug: string;
    text: string;
    externalServer: boolean;
    separator: boolean;
  }[];
  router: NextRouter;
  children: any;
};

type State = {
  anchorEl: Element | ((element: Element) => Element);
};

class MenuWithLinks extends React.PureComponent<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      anchorEl: null,
    };
  }

  public render() {
    const { options, children, router } = this.props;
    const { anchorEl } = this.state;

    return (
      <div style={{ textAlign: 'center' }}>
        <div
          aria-controls={anchorEl ? 'simple-menu' : null}
          aria-haspopup="true"
          onClick={this.handleClick}
          onKeyPress={this.handleClick}
        >
          {children}
        </div>
        <Menu
          id="simple-menu"
          anchorEl={anchorEl}
          open={Boolean(anchorEl)}
          onClose={this.handleClose}
          keepMounted
        >
          {options.map((option, i) =>
            option.separator ? (
              <hr style={{ width: '95%', margin: '10px auto' }} key={`separated-${i}`} />
            ) : option.externalServer ? (
              <MenuItem
                onClick={(event) => {
                  event.preventDefault();
                  window.location.href = option.href;
                  this.handleClose();
                }}
                key={option.href || option.text}
              >
                {option.text}
              </MenuItem>
            ) : (
              <MenuItem
                key={option.href}
                style={{
                  fontWeight: router.asPath.includes(option.highlighterSlug) ? 600 : 300,
                  fontSize: '14px',
                }}
                onClick={() => Router.push(option.href, option.as)}
              >
                {option.text}
              </MenuItem>
            ),
          )}
        </Menu>
      </div>
    );
  }

  public handleClick = (event) => {
    this.setState({ anchorEl: event.currentTarget });
  };

  public handleClose = () => {
    this.setState({ anchorEl: null });
  };
}

export default withRouter(MenuWithLinks);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\components\common\MenuWithMenuItems.tsx -----

import Menu from '@mui/material/Menu';
import MenuItem from '@mui/material/MenuItem';
import MoreVertIcon from '@mui/icons-material/MoreVert';
import React from 'react';

type Props = {
  menuOptions: any;
  itemOptions: any[];
};

type State = {
  menuElem: Element | ((element: Element) => Element);
};

class MenuWithMenuItems extends React.PureComponent<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      menuElem: null,
    };
  }

  public render() {
    const { menuOptions, itemOptions } = this.props;
    const { menuElem } = this.state;

    return (
      <div style={{ verticalAlign: 'middle' }}>
        <MoreVertIcon
          aria-controls={menuElem ? menuOptions.id : null}
          data-id={menuOptions.dataId}
          aria-haspopup="true"
          style={{ fontSize: '14px', opacity: 0.7, cursor: 'pointer' }}
          onClick={(e) => this.handleClick(e)}
        />

        <Menu
          id={menuOptions.id}
          anchorEl={menuElem}
          open={Boolean(menuElem)}
          onClose={this.handleClose}
        >
          {itemOptions.map((option, i) => (
            <MenuItem
              key={option.dataId + i}
              data-id={option.dataId}
              data-more-id={option.dataMoreId}
              onClick={(e) => {
                this.setState({ menuElem: null });
                option.onClick(e);
              }}
            >
              {option.text}
            </MenuItem>
          ))}
        </Menu>
      </div>
    );
  }

  public handleClick = (event) => {
    event.preventDefault();
    this.setState({ menuElem: event.currentTarget });
  };

  public handleClose = () => {
    this.setState({ menuElem: null });
  };
}

export default MenuWithMenuItems;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\components\common\Notifier.tsx -----

import Snackbar from '@mui/material/Snackbar';
import React from 'react';

export let openSnackbarExternal;

type State = {
  open: boolean;
  message: string;
};

class Notifier extends React.PureComponent<any, State> {
  constructor(props) {
    super(props);
    openSnackbarExternal = this.openSnackbar;

    this.state = {
      open: false,
      message: '',
    };
  }

  public render() {
    const message = (
      <span id="snackbar-message-id" dangerouslySetInnerHTML={{ __html: this.state.message }} />
    );

    return (
      <Snackbar
        anchorOrigin={{ vertical: 'top', horizontal: 'right' }}
        message={message}
        autoHideDuration={5000}
        onClose={this.handleSnackbarClose}
        open={this.state.open}
        ContentProps={{
          'aria-describedby': 'snackbar-message-id',
        }}
      />
    );
  }

  public handleSnackbarClose = () => {
    this.setState({
      open: false,
      message: '',
    });
  };

  public openSnackbar = ({ message }) => {
    this.setState({ open: true, message });
  };
}

export default Notifier;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\components\discussions\CreateDiscussionForm.tsx -----

import Button from '@mui/material/Button';
import Dialog from '@mui/material/Dialog';
import DialogContent from '@mui/material/DialogContent';
import DialogTitle from '@mui/material/DialogTitle';
import FormControl from '@mui/material/FormControl';
import FormHelperText from '@mui/material/FormHelperText';
import Select from '@mui/material/Select';
import MenuItem from '@mui/material/MenuItem';
import TextField from '@mui/material/TextField';
import { observer } from 'mobx-react';
import Head from 'next/head';
import Router from 'next/router';
import NProgress from 'nprogress';
import React from 'react';

import notify from '../../lib/notify';
import { Store } from '../../lib/store';
import MemberChooser from '../common/MemberChooser';
import PostEditor from '../posts/PostEditor';

type Props = {
  isMobile: boolean;
  store: Store;
  open: boolean;
  onClose: () => void;
};

type State = {
  name: string;
  memberIds: string[];
  disabled: boolean;
  content: string;
  notificationType: string;
};

class CreateDiscussionForm extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      name: '',
      memberIds: [],
      disabled: false,
      content: '',
      notificationType: 'default',
    };
  }
  public render() {
    const { open, isMobile, store } = this.props;
    const { currentTeam, currentUser } = store;

    const membersMinusCreator = Array.from(currentTeam.members.values()).filter(
      (user) => user._id !== currentUser._id,
    );

    return (
      <React.Fragment>
        {open ? (
          <Head>
            <title>New Discussion</title>
            <meta name="description" content="Create new discussion" />
          </Head>
        ) : null}
        <Dialog
          onClose={this.handleClose}
          aria-labelledby="simple-dialog-title"
          open={open}
          fullScreen={true}
        >
          <DialogTitle id="simple-dialog-title">Create new Discussion</DialogTitle>
          <DialogContent>
            <br />
            <form style={{ width: '100%', height: '60%' }} onSubmit={this.onSubmit}>
              <p />
              <br />
              <TextField
                autoFocus
                label="Type name of Discussion"
                helperText="Give a short and informative name to new Discussion"
                value={this.state.name}
                onChange={(event) => {
                  this.setState({ name: event.target.value });
                }}
              />
              <br />
              <p />
              <MemberChooser
                helperText="These members will see all posts and be notified about unread posts in this discussion."
                onChange={this.handleMembersChange}
                members={membersMinusCreator}
                selectedMemberIds={this.state.memberIds}
              />
              <p />
              <br />
              <FormControl>
                <Select
                  value={this.state.notificationType}
                  onChange={(event) => {
                    event.stopPropagation();
                    this.setState({ notificationType: event.target.value });
                  }}
                  required
                >
                  <MenuItem value="default">Default: without email notification.</MenuItem>
                  <MenuItem value="email">Email: with email notification.</MenuItem>
                </Select>
                <FormHelperText>
                  Choose how to notify members about new Posts inside Discussion.
                </FormHelperText>
              </FormControl>
              <p />
              <br />
              <div>
                <Button
                  type="submit"
                  variant="contained"
                  color="primary"
                  disabled={this.state.disabled}
                >
                  Create Discussion
                </Button>
                {isMobile ? <p /> : null}
                <Button
                  variant="outlined"
                  onClick={this.handleClose}
                  disabled={this.state.disabled}
                  style={{ marginLeft: isMobile ? '0px' : '20px' }}
                >
                  Cancel
                </Button>{' '}
              </div>
              <p />
              <PostEditor
                content={this.state.content}
                onChanged={this.onContentChanged}
                members={Array.from(store.currentTeam.members.values())}
                store={store}
                parentComponent="CDF"
              />
              <p />
              <div>
                <Button
                  type="submit"
                  variant="contained"
                  color="primary"
                  disabled={this.state.disabled}
                >
                  Create Discussion
                </Button>
                {isMobile ? <p /> : null}
                <Button
                  variant="outlined"
                  onClick={this.handleClose}
                  disabled={this.state.disabled}
                  style={{ marginLeft: isMobile ? '0px' : '20px' }}
                >
                  Cancel
                </Button>{' '}
                <p />
                <br />
                <br />
              </div>
            </form>
          </DialogContent>
        </Dialog>
      </React.Fragment>
    );
  }

  public handleMembersChange = (memberIds) => {
    this.setState({ memberIds });
  };

  public handleClose = () => {
    this.setState({
      name: '',
      memberIds: [],
      disabled: false,
      content: '',
      notificationType: 'default',
    });
    this.props.onClose();
  };

  private onContentChanged = (content: string) => {
    console.log('onContentChanged', content);
    this.setState({ content });
  };

  private onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();

    const { store } = this.props;
    const { currentTeam } = store;

    if (!currentTeam) {
      notify('Team have not selected');
      return;
    }

    const { name, memberIds, content, notificationType } = this.state;

    if (!name) {
      notify('Name is required');
      return;
    }

    if (!content) {
      notify('Content is required');
      return;
    }

    // if (!memberIds || memberIds.length < 1) {
    //   notify('Please assign at least one person to this Discussion.');
    //   return;
    // }

    if (!notificationType) {
      notify('Please select notification type.');
      return;
    }

    this.setState({ disabled: true });
    NProgress.start();

    // console.log(notificationType);

    try {
      const discussion = await currentTeam.addDiscussion({
        name,
        memberIds,
        notificationType,
      });

      const post = await discussion.addPost(content);

      const dev = process.env.NODE_ENV !== 'production';

      if (discussion.notificationType === 'email') {
        const userIdsForLambda = discussion.memberIds.filter((m) => m !== discussion.createdUserId);

        await discussion.sendDataToLambda({
          discussionName: discussion.name,
          discussionLink: `${
            dev ? process.env.NEXT_PUBLIC_URL_APP : process.env.NEXT_PUBLIC_PRODUCTION_URL_APP
          }/teams/${discussion.team.slug}/discussions/${discussion.slug}`,
          postContent: post.content,
          authorName: post.user.displayName,
          userIds: userIdsForLambda,
        });
      }

      this.setState({ name: '', memberIds: [], content: '', notificationType: 'default' });

      notify('You successfully added new Discussion.');

      Router.push(
        `/discussion?teamSlug=${currentTeam.slug}&discussionSlug=${discussion.slug}`,
        `/teams/${currentTeam.slug}/discussions/${discussion.slug}`,
      );
    } catch (error) {
      console.log(error);
      notify(error);
    } finally {
      this.setState({ disabled: false });
      NProgress.done();
      this.props.onClose();
    }
  };
}

export default observer(CreateDiscussionForm);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\components\discussions\DiscussionActionMenu.tsx -----

import { observer } from 'mobx-react';
import NProgress from 'nprogress';
import React from 'react';

import confirm from '../../lib/confirm';
import notify from '../../lib/notify';
import { Store } from '../../lib/store';
import { Discussion } from '../../lib/store/discussion';

import MenuWithMenuItems from '../common/MenuWithMenuItems';
import EditDiscussionForm from './EditDiscussionForm';

const dev = process.env.NODE_ENV !== 'production';

const getMenuOptions = (discussion) => ({
  dataId: discussion._id,
  id: `discussion-menu-${discussion._id}`,
});

const getMenuItemOptionsForCreator = (discussion, component) => [
  {
    text: 'Copy URL',
    dataId: discussion._id,
    onClick: component.handleCopyUrl,
  },
  {
    text: 'Edit',
    dataId: discussion._id,
    onClick: component.editDiscussion,
  },
  {
    text: 'Delete',
    dataId: discussion._id,
    onClick: component.deleteDiscussion,
  },
];

const getMenuItemOptions = (discussion, component) => [
  {
    text: 'Copy URL',
    dataId: discussion._id,
    onClick: component.handleCopyUrl,
  },
];

type Props = {
  discussion: Discussion;
  store: Store;
  isMobile: boolean;
};

type State = {
  discussionFormOpen: boolean;
  selectedDiscussion: Discussion;
};

class DiscussionActionMenu extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      discussionFormOpen: false,
      selectedDiscussion: null,
    };
  }

  public render() {
    const { discussion, store } = this.props;
    const { currentUser } = store;

    const isCreator = currentUser._id === discussion.createdUserId ? true : false;

    return (
      <React.Fragment>
        <MenuWithMenuItems
          menuOptions={getMenuOptions(discussion)}
          itemOptions={
            isCreator
              ? getMenuItemOptionsForCreator(discussion, this)
              : getMenuItemOptions(discussion, this)
          }
        />

        {this.state.discussionFormOpen ? (
          <EditDiscussionForm
            open={true}
            onClose={this.handleDiscussionFormClose}
            discussion={discussion}
            isMobile={this.props.isMobile}
            store={store}
          />
        ) : null}
      </React.Fragment>
    );
  }

  public handleCopyUrl = async (event) => {
    const { store } = this.props;
    const { currentTeam } = store;

    const id = event.currentTarget.dataset.id;
    if (!id) {
      return;
    }

    const selectedDiscussion = currentTeam.discussions.find((d) => d._id === id);

    const discussionUrl = `${
      dev ? process.env.NEXT_PUBLIC_URL_APP : process.env.NEXT_PUBLIC_PRODUCTION_URL_APP
    }/teams/${currentTeam.slug}/discussions/${selectedDiscussion.slug}`;

    try {
      if (window.navigator) {
        await window.navigator.clipboard.writeText(discussionUrl);
        notify('You successfully copied URL.');
      }
    } catch (err) {
      notify(err);
    } finally {
      this.setState({ discussionFormOpen: false, selectedDiscussion: null });
    }
  };

  public editDiscussion = (event) => {
    const { currentTeam } = this.props.store;
    if (!currentTeam) {
      notify('You have not selected Team.');
      return;
    }

    const id = event.currentTarget.dataset.id;
    if (!id) {
      return;
    }

    const selectedDiscussion = currentTeam.discussions.find((d) => d._id === id);

    this.setState({ discussionFormOpen: true, selectedDiscussion });
  };

  public deleteDiscussion = async (event) => {
    const { currentTeam } = this.props.store;
    if (!currentTeam) {
      notify('You have not selected Team.');
      return;
    }

    const id = event.currentTarget.dataset.id;

    confirm({
      title: 'Are you sure?',
      message: '',
      onAnswer: async (answer) => {
        if (!answer) {
          return;
        }

        NProgress.start();

        try {
          await currentTeam.deleteDiscussion(id);

          notify('You successfully deleted Discussion.');
        } catch (error) {
          console.error(error);
          notify(error);
        } finally {
          NProgress.done();
        }
      },
    });
  };

  public handleDiscussionFormClose = () => {
    this.setState({ discussionFormOpen: false, selectedDiscussion: null });
  };
}

export default observer(DiscussionActionMenu);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\components\discussions\DiscussionList.tsx -----

import Tooltip from '@mui/material/Tooltip';
import AddCircleOutlineIcon from '@mui/icons-material/AddCircleOutline';
import { observer } from 'mobx-react';
import React from 'react';

import { Store } from '../../lib/store';
import { Team } from '../../lib/store/team';

import CreateDiscussionForm from './CreateDiscussionForm';
import DiscussionListItem from './DiscussionListItem';

import notify from '../../lib/notify';

type Props = { store: Store; team: Team; isMobile: boolean };

type State = { discussionFormOpen: boolean };

class DiscussionList extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      discussionFormOpen: false,
    };
  }

  public componentDidMount() {
    this.props.team.loadDiscussions().catch((err) => notify(err));
  }

  public componentDidUpdate(prevProps: Props) {
    if (this.props.team._id !== prevProps.team._id) {
      this.props.team.loadDiscussions().catch((err) => notify(err));
    }
  }

  public render() {
    const { store, team } = this.props;

    const isThemeDark = store && store.currentUser && store.currentUser.darkTheme === true;

    return (
      <div>
        Discussions
        <Tooltip title="Add Discussion" placement="right" disableFocusListener disableTouchListener>
          <a onClick={this.addDiscussion} style={{ float: 'right', padding: '0px 10px' }}>
            <AddCircleOutlineIcon
              color="action"
              style={{ fontSize: 14, opacity: 0.7, color: isThemeDark ? '#fff' : '#000' }}
            />{' '}
          </a>
        </Tooltip>
        <p />
        <ul style={{ listStyle: 'none', padding: '0px' }}>
          {team &&
            team.orderedDiscussions.map((d) => {
              return (
                <DiscussionListItem
                  key={d._id}
                  discussion={d}
                  team={team}
                  isMobile={this.props.isMobile}
                  store={this.props.store}
                />
              );
            })}
        </ul>
        <CreateDiscussionForm
          isMobile={this.props.isMobile}
          store={this.props.store}
          open={this.state.discussionFormOpen}
          onClose={this.handleDiscussionFormClose}
        />
      </div>
    );
  }

  public addDiscussion = (event) => {
    event.preventDefault();
    this.setState({ discussionFormOpen: true });
  };

  public handleDiscussionFormClose = () => {
    this.setState({ discussionFormOpen: false });
  };
}

export default observer(DiscussionList);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\components\discussions\DiscussionListItem.tsx -----

import Paper from '@mui/material/Paper';
import { observer } from 'mobx-react';
import Link from 'next/link';
import React from 'react';

import { Store } from '../../lib/store';
import { Discussion } from '../../lib/store/discussion';
import { Team } from '../../lib/store/team';

import DiscussionActionMenu from './DiscussionActionMenu';

type Props = {
  store: Store;
  discussion: Discussion;
  team: Team;
  isMobile: boolean;
};

class DiscussionListItem extends React.Component<Props> {
  public render() {
    const { store, discussion, team, isMobile } = this.props;
    const trimmingLength = 16;

    const selectedDiscussion =
      store.currentUrl === `/teams/${team.slug}/discussions/${discussion.slug}`;

    // console.log(store.currentUrl);

    const isThemeDark = store && store.currentUser && store.currentUser.darkTheme === true;

    const selectedItemBorder = isThemeDark
      ? '1px rgba(255, 255, 255, 0.75) solid'
      : '1px rgba(0, 0, 0, 0.75) solid';

    return (
      <Paper
        key={discussion._id}
        style={{
          margin: '10px 10px 5px 0px',
          padding: '8px',
          border: selectedDiscussion ? selectedItemBorder : 'none',
        }}
        elevation={selectedDiscussion ? 24 : 1}
      >
        <li key={discussion._id} style={{ whiteSpace: 'nowrap', paddingRight: '10px' }}>
          <Link
            scroll={false}
            href={`/discussion?teamSlug=${team.slug}&discussionSlug=${discussion.slug}`}
            as={`/teams/${team.slug}/discussions/${discussion.slug}`}
            style={{ fontWeight: 300, color: isThemeDark ? '#fff' : '#000' }}
            key={discussion._id}
          >
            {discussion.name.length > trimmingLength
              ? `${discussion.name.substring(0, trimmingLength)}...`
              : discussion.name}
          </Link>
          <div
            style={{
              float: 'right',
              marginRight: '-12px',
            }}
          >
            <DiscussionActionMenu discussion={discussion} isMobile={isMobile} store={store} />
          </div>
        </li>
      </Paper>
    );
  }
}

export default observer(DiscussionListItem);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\components\discussions\EditDiscussionForm.tsx -----

import Button from '@mui/material/Button';
import Dialog from '@mui/material/Dialog';
import DialogActions from '@mui/material/DialogActions';
import DialogContent from '@mui/material/DialogContent';
import DialogContentText from '@mui/material/DialogContentText';
import DialogTitle from '@mui/material/DialogTitle';
import FormControl from '@mui/material/FormControl';
import FormHelperText from '@mui/material/FormHelperText';
import Select from '@mui/material/Select';
import MenuItem from '@mui/material/MenuItem';
import TextField from '@mui/material/TextField';
import { observer } from 'mobx-react';
import NProgress from 'nprogress';
import React from 'react';

import notify from '../../lib/notify';
import { Store } from '../../lib/store';
import { Discussion } from '../../lib/store/discussion';
import MemberChooser from '../common/MemberChooser';

type Props = {
  store: Store;
  onClose: () => void;
  open: boolean;
  discussion: Discussion;
  isMobile: boolean;
};

type State = {
  name: string;
  memberIds: string[];
  disabled: boolean;
  discussionId: string;
  notificationType: string;
};

class EditDiscussionForm extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      name: '',
      memberIds: [],
      disabled: false,
      discussionId: '',
      notificationType: 'default',
    };
  }

  public static getDerivedStateFromProps(props: Props, state: State) {
    const { discussion } = props;

    if (state.discussionId === discussion._id) {
      return null;
    }

    return {
      name: (discussion && discussion.name) || '',
      memberIds: (discussion && discussion.memberIds) || [],
      discussionId: discussion._id,
      notificationType: discussion.notificationType || 'default',
    };
  }

  public render() {
    const { open, store } = this.props;
    const { currentTeam, currentUser } = store;

    const membersMinusCreator = Array.from(currentTeam.members.values()).filter(
      (user) => user._id !== currentUser._id,
    );

    // console.log(currentTeam.members);

    return (
      <Dialog onClose={this.handleClose} aria-labelledby="simple-dialog-title" open={open}>
        <DialogTitle id="simple-dialog-title">Edit Discussion</DialogTitle>
        <DialogContent>
          <DialogContentText>Edit discussion</DialogContentText>
          <br />
          <form onSubmit={this.onSubmit}>
            <TextField
              label="Type name of Discussion"
              helperText="Give a short and informative name to Discussion"
              value={this.state.name}
              onChange={(event) => {
                this.setState({ name: event.target.value });
              }}
            />
            <br />
            <p />
            <MemberChooser
              helperText="These members will see all posts and be notified about unread posts in this discussion."
              onChange={this.handleMembersChange}
              members={membersMinusCreator}
              selectedMemberIds={this.state.memberIds}
            />
            <p />
            <br />
            <FormControl>
              <Select
                value={this.state.notificationType}
                onChange={(event) => {
                  event.stopPropagation();
                  this.setState({ notificationType: event.target.value });
                }}
                required
              >
                <MenuItem value="default">Default: without email notification.</MenuItem>
                <MenuItem value="email">Email: with email notification.</MenuItem>
              </Select>
              <FormHelperText>
                Choose how to notify members about new Posts inside Discussion.
              </FormHelperText>
            </FormControl>
            <p />
            <br />
            <DialogActions>
              <Button
                color="primary"
                variant="outlined"
                onClick={this.handleClose}
                disabled={this.state.disabled}
              >
                Cancel
              </Button>
              <Button
                type="submit"
                variant="contained"
                color="primary"
                disabled={this.state.disabled}
              >
                Update Discussion
              </Button>
            </DialogActions>
          </form>
        </DialogContent>
      </Dialog>
    );
  }

  public handleMembersChange = (memberIds) => {
    this.setState({ memberIds });
  };

  public handleClose = () => {
    this.setState({ name: '', memberIds: [], disabled: false, notificationType: 'default' });
    this.props.onClose();
  };

  private onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();

    const { discussion, store } = this.props;
    const { currentTeam } = store;
    const { notificationType } = this.state;

    if (!currentTeam) {
      notify('Team have not selected');
      return;
    }

    const { name, memberIds } = this.state;

    if (!name) {
      notify('Please name this Discussion.');
      return;
    }

    if (memberIds && !memberIds.includes(discussion.store.currentUser._id)) {
      memberIds.push(discussion.store.currentUser._id);
    }

    // if (!memberIds || memberIds.length < 1) {
    //   notify('Please assign at least one person to this Discussion.');
    //   return;
    // }

    if (!notificationType) {
      notify('Please select notification type.');
      return;
    }

    NProgress.start();
    try {
      await discussion.editDiscussion({ name, memberIds, notificationType });

      this.setState({ name: '', memberIds: [], disabled: false, notificationType: 'default' });
      notify('You successfully edited Discussion.');
    } catch (error) {
      console.log(error);
      notify(error);
    } finally {
      this.setState({ disabled: false });
      NProgress.done();

      this.props.onClose();
    }
  };
}

export default observer(EditDiscussionForm);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\components\layout\index.tsx -----

import Avatar from '@mui/material/Avatar';
import Button from '@mui/material/Button';
import Grid from '@mui/material/Grid';
import ArrowDropDownIcon from '@mui/icons-material/ArrowDropDown';
import LensIcon from '@mui/icons-material/Lens';

import Link from 'next/link';
import React from 'react';

import MenuWithLinks from '../common/MenuWithLinks';
import Confirmer from '../common/Confirmer';
import Notifier from '../common/Notifier';

import { Store } from '../../lib/store';
import DiscussionList from '../discussions/DiscussionList';

const dev = process.env.NODE_ENV !== 'production';

const styleGrid = {
  width: '100%',
  height: '100vh',
  maxWidth: '100%',
  padding: '0px 10px',
  display: 'flex',
  overflow: 'hidden',
};

const styleGridIsMobile = {
  width: '100%',
  height: '100vh',
  maxWidth: '100%',
  padding: '0px 0px 0px 10px',
  display: 'flex',
  overflow: 'hidden',
};

function LayoutWrapper({
  children,
  isMobile,
  firstGridItem,
  store,
}: {
  children: React.ReactNode;
  isMobile: boolean;
  firstGridItem: boolean;
  store: Store;
}) {
  const isThemeDark = store.currentUser ? store.currentUser.darkTheme : true;

  return (
    <React.Fragment>
      <Grid
        container
        direction="row"
        justifyContent="flex-start"
        alignItems="stretch"
        style={isMobile ? styleGridIsMobile : styleGrid}
      >
        {firstGridItem ? (
          <Grid
            item
            sm={2}
            xs={12}
            style={{
              borderRight: '1px #707070 solid',
              justifyContent: 'center',
              height: '100%',
              overflow: 'hidden',
            }}
          >
            <div style={{ display: 'flex', justifyContent: 'space-between' }}>
              <svg
                xmlns="http://www.w3.org/2000/svg"
                width="124"
                height="40"
                viewBox="0 0 124 40"
                style={{
                  marginTop: '20px',
                  display: 'inline-flex',
                  height: '40px',
                }}
              >
                <g id="async-logo">
                  <g id="async-logo-40">
                    <circle id="Ellipse 2" cx="20" cy="20" r="20" fill="black" />
                    <path
                      id="path-async-logo"
                      d="M7.07825 -0.0960007V16H4.51825V13.088C4.04892 14.0907 3.33425 14.8693 2.37425 15.424C1.43558 15.9573 0.336917 16.224 -0.92175 16.224C-2.35108 16.224 -3.60975 15.8827 -4.69775 15.2C-5.76442 14.5173 -6.59642 13.5573 -7.19375 12.32C-7.76975 11.0613 -8.05775 9.6 -8.05775 7.936C-8.05775 6.272 -7.75908 4.81067 -7.16175 3.552C-6.56442 2.272 -5.73242 1.28 -4.66575 0.576C-3.57775 -0.128 -2.32975 -0.48 -0.92175 -0.48C0.336917 -0.48 1.43558 -0.202666 2.37425 0.352C3.31292 0.906667 4.02758 1.68533 4.51825 2.688V-0.0960007H7.07825ZM-0.40975 14.08C1.16892 14.08 2.38492 13.5467 3.23825 12.48C4.09158 11.392 4.51825 9.856 4.51825 7.872C4.51825 5.888 4.09158 4.36267 3.23825 3.296C2.38492 2.22933 1.16892 1.696 -0.40975 1.696C-1.98842 1.696 -3.22575 2.25067 -4.12175 3.36C-4.99642 4.448 -5.43375 5.97333 -5.43375 7.936C-5.43375 9.89867 -4.99642 11.4133 -4.12175 12.48C-3.24708 13.5467 -2.00975 14.08 -0.40975 14.08Z"
                      transform="translate(19.5938 12)"
                      fill="white"
                    />
                  </g>
                  <path
                    id="path-async-text"
                    d="M22.6251 11.928V24H20.7051V21.816C20.3531 22.568 19.8171 23.152 19.0971 23.568C18.3931 23.968 17.5691 24.168 16.6251 24.168C15.5531 24.168 14.6091 23.912 13.7931 23.4C12.9931 22.888 12.3691 22.168 11.9211 21.24C11.4891 20.296 11.2731 19.2 11.2731 17.952C11.2731 16.704 11.4971 15.608 11.9451 14.664C12.3931 13.704 13.0171 12.96 13.8171 12.432C14.6331 11.904 15.5691 11.64 16.6251 11.64C17.5691 11.64 18.3931 11.848 19.0971 12.264C19.8011 12.68 20.3371 13.264 20.7051 14.016V11.928H22.6251ZM17.0091 22.56C18.1931 22.56 19.1051 22.16 19.7451 21.36C20.3851 20.544 20.7051 19.392 20.7051 17.904C20.7051 16.416 20.3851 15.272 19.7451 14.472C19.1051 13.672 18.1931 13.272 17.0091 13.272C15.8251 13.272 14.8971 13.688 14.2251 14.52C13.5691 15.336 13.2411 16.48 13.2411 17.952C13.2411 19.424 13.5691 20.56 14.2251 21.36C14.8811 22.16 15.8091 22.56 17.0091 22.56ZM30.4637 24.168C28.4317 24.168 26.8237 23.648 25.6397 22.608L26.2877 21.168C26.9437 21.68 27.6077 22.048 28.2797 22.272C28.9517 22.496 29.7037 22.608 30.5357 22.608C31.4477 22.608 32.1357 22.456 32.5997 22.152C33.0797 21.832 33.3197 21.376 33.3197 20.784C33.3197 20.304 33.1597 19.92 32.8397 19.632C32.5197 19.344 31.9917 19.12 31.2557 18.96L29.2157 18.48C28.2077 18.256 27.4237 17.856 26.8637 17.28C26.3197 16.704 26.0477 16.016 26.0477 15.216C26.0477 14.16 26.4717 13.304 27.3197 12.648C28.1677 11.976 29.2877 11.64 30.6797 11.64C31.5277 11.64 32.3277 11.776 33.0797 12.048C33.8317 12.32 34.4637 12.712 34.9757 13.224L34.3277 14.64C33.1917 13.696 31.9757 13.224 30.6797 13.224C29.8157 13.224 29.1437 13.392 28.6637 13.728C28.1997 14.048 27.9677 14.504 27.9677 15.096C27.9677 15.592 28.1117 15.984 28.3997 16.272C28.7037 16.56 29.1837 16.784 29.8397 16.944L31.8797 17.448C32.9997 17.704 33.8317 18.104 34.3757 18.648C34.9197 19.176 35.1917 19.872 35.1917 20.736C35.1917 21.776 34.7677 22.608 33.9197 23.232C33.0717 23.856 31.9197 24.168 30.4637 24.168ZM48.687 11.928L43.047 25.104C42.455 26.48 41.711 27.488 40.815 28.128C39.919 28.768 38.815 29.208 37.503 29.448L37.095 27.936C38.231 27.68 39.087 27.336 39.663 26.904C40.255 26.488 40.743 25.84 41.127 24.96L41.607 23.88L36.495 11.928H38.535L42.615 21.888L46.743 11.928H48.687ZM56.853 11.64C59.749 11.64 61.197 13.232 61.197 16.416V24H59.253V16.512C59.253 15.392 59.029 14.576 58.581 14.064C58.133 13.536 57.429 13.272 56.469 13.272C55.349 13.272 54.453 13.616 53.781 14.304C53.109 14.992 52.773 15.92 52.773 17.088V24H50.829V15.312C50.829 14.064 50.765 12.936 50.637 11.928H52.485L52.677 14.088C53.045 13.304 53.597 12.704 54.333 12.288C55.069 11.856 55.909 11.64 56.853 11.64ZM69.9321 24.168C68.7641 24.168 67.7401 23.912 66.8601 23.4C65.9961 22.888 65.3241 22.168 64.8441 21.24C64.3801 20.296 64.1481 19.2 64.1481 17.952C64.1481 16.704 64.3881 15.608 64.8681 14.664C65.3481 13.704 66.0281 12.96 66.9081 12.432C67.8041 11.904 68.8441 11.64 70.0281 11.64C70.8441 11.64 71.6281 11.784 72.3801 12.072C73.1481 12.344 73.7801 12.728 74.2761 13.224L73.6281 14.664C73.0201 14.184 72.4281 13.832 71.8521 13.608C71.2921 13.384 70.7161 13.272 70.1241 13.272C68.8921 13.272 67.9241 13.688 67.2201 14.52C66.5161 15.336 66.1641 16.48 66.1641 17.952C66.1641 19.408 66.5081 20.544 67.1961 21.36C67.9001 22.16 68.8761 22.56 70.1241 22.56C70.7161 22.56 71.2921 22.448 71.8521 22.224C72.4281 22 73.0201 21.648 73.6281 21.168L74.2761 22.608C73.7641 23.088 73.1161 23.472 72.3321 23.76C71.5641 24.032 70.7641 24.168 69.9321 24.168Z"
                    transform="translate(39 4)"
                    fill={isThemeDark ? 'white' : 'black'}
                  />
                </g>
              </svg>
              <MenuWithLinks
                options={[
                  {
                    text: 'Your Settings',
                    href: `/your-settings?teamSlug=${store.currentTeam.slug}`,
                    as: `/teams/${store.currentTeam.slug}/your-settings`,
                    highlighterSlug: '/your-settings',
                  },
                  {
                    text: 'Team Settings',
                    href: `/team-settings?teamSlug=${store.currentTeam.slug}`,
                    as: `/teams/${store.currentTeam.slug}/team-settings`,
                    highlighterSlug: '/team-settings',
                  },
                  {
                    text: 'Billing',
                    href: `/billing?teamSlug=${store.currentTeam.slug}`,
                    as: `/teams/${store.currentTeam.slug}/billing`,
                    highlighterSlug: '/billing',
                  },
                  {
                    separator: true,
                  },
                  {
                    text: 'Log out',
                    href: `${
                      dev
                        ? process.env.NEXT_PUBLIC_URL_API
                        : process.env.NEXT_PUBLIC_PRODUCTION_URL_API
                    }/logout`,
                    as: `${
                      dev
                        ? process.env.NEXT_PUBLIC_URL_API
                        : process.env.NEXT_PUBLIC_PRODUCTION_URL_API
                    }/logout`,
                    externalServer: true,
                  },
                ]}
              >
                <Avatar
                  src={store.currentUser.avatarUrl}
                  alt="Add username here later in the book"
                  style={{
                    margin: '20px auto',
                    cursor: 'pointer',
                    display: 'inline-flex',
                    width: '40px',
                    height: '40px',
                  }}
                />

                <ArrowDropDownIcon color="action" style={{ verticalAlign: 'super' }} />
              </MenuWithLinks>
            </div>
            <hr />
            <p />
            <p />
            <DiscussionList store={store} team={store.currentTeam} isMobile={isMobile} />
          </Grid>
        ) : null}

        {children}
      </Grid>
      <Notifier />
      <Confirmer />
    </React.Fragment>
  );
}

type Props = {
  children: React.ReactNode;
  store?: Store;
  isMobile?: boolean;
  firstGridItem?: boolean;
  teamRequired?: boolean;
};

class Layout extends React.Component<Props> {
  public render() {
    const { children, isMobile, firstGridItem, store, teamRequired } = this.props;

    const { currentUser, currentTeam } = store;

    // console.log(this.props.store.currentUser.darkTheme);

    // const isThemeDark = false;

    // console.log(isMobile);

    // console.log(store, currentUser, currentTeam);

    if (!currentUser) {
      return (
        <LayoutWrapper firstGridItem={firstGridItem} isMobile={isMobile} store={store}>
          <Grid item sm={12} xs={12}>
            {children}
          </Grid>
        </LayoutWrapper>
      );
    }

    if (!currentTeam) {
      if (teamRequired) {
        return (
          <LayoutWrapper firstGridItem={firstGridItem} isMobile={isMobile} store={store}>
            <Grid
              item
              sm={10}
              xs={12}
              style={{ padding: '0px 35px', overflow: 'auto', height: 'auto' }}
            >
              <div style={{ padding: '20px' }}>
                Select existing team or create a new team.
                <p />
                <Link href="/create-team" as="/create-team">
                  <Button variant="contained" color="primary">
                    Create new team
                  </Button>
                </Link>
              </div>
            </Grid>
          </LayoutWrapper>
        );
      } else {
        // console.log('team not required');
        return (
          <LayoutWrapper firstGridItem={firstGridItem} isMobile={isMobile} store={store}>
            <Grid
              item
              sm={10}
              xs={12}
              style={{ padding: '0px 35px', overflow: 'auto', height: 'auto' }}
            >
              {children}
            </Grid>
          </LayoutWrapper>
        );
      }
    }

    return (
      <LayoutWrapper firstGridItem={firstGridItem} isMobile={isMobile} store={store}>
        <Grid
          item
          sm={firstGridItem ? 10 : 12}
          xs={12}
          style={{ padding: '0px 35px', overflowY: 'auto', height: 'inherit' }}
        >
          <div>
            {isMobile || store.currentUrl.includes('create-team') ? null : (
              <React.Fragment>
                <LensIcon
                  style={{
                    margin: '15px 0px 10px 25px',
                    opacity: 0.8,
                    fontSize: '18px',
                    cursor: 'pointer',
                  }}
                  onClick={async () => {
                    await store.currentUser.toggleTheme(!store.currentUser.darkTheme);
                  }}
                />
                <span
                  style={{
                    float: 'right',
                    margin: '15px 0px 10px 25px',
                    fontSize: '11px',
                  }}
                >
                  Check up our latest project (share with your biotech friends):{' '}
                  <a
                    style={{
                      fontWeight: 600,
                    }}
                    target="_blank"
                    href="https://workinbiotech.com"
                    rel="noopener noreferrer"
                  >
                    Work in biotech
                  </a>
                </span>
                <h4
                  style={{
                    margin: '15px 0px 10px 30px',
                    fontWeight: 300,
                  }}
                >
                  Current team: <b>{store.currentTeam.name}</b>
                </h4>
              </React.Fragment>
            )}
            <div style={{ clear: 'both' }} />
          </div>
          {children}
        </Grid>
      </LayoutWrapper>
    );
  }
}

export default Layout;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\components\posts\PostContent.tsx -----

import React from 'react';

type Props = { html: string };

class PostContent extends React.Component<Props> {
  public render() {
    const { html } = this.props;

    return (
      <div
        style={{
          fontSize: '15px',
          lineHeight: '2em',
          fontFamily: 'Roboto, sans-serif',
          wordBreak: 'break-all',
        }}
        dangerouslySetInnerHTML={{ __html: html }}
      />
    );
  }
}

export default PostContent;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\components\posts\PostDetail.tsx -----

import Avatar from '@mui/material/Avatar';
import Paper from '@mui/material/Paper';
import Tooltip from '@mui/material/Tooltip';
import { observer } from 'mobx-react';
import moment from 'moment';
import React from 'react';

import confirm from '../../lib/confirm';
import notify from '../../lib/notify';
import { Store } from '../../lib/store';
import { Post } from '../../lib/store/post';
import { User } from '../../lib/store/user';

import MenuWithMenuItems from '../common/MenuWithMenuItems';

import PostContent from './PostContent';

const stylePaper = {
  margin: '10px 0px',
  padding: '20px',
};

const styleLineSeparator = {
  verticalAlign: 'text-bottom',
  fontWeight: 300,
  fontSize: '16px',
  margin: '0px 5px',
  opacity: 0.75,
};

const getMenuOptions = (post) => ({
  dataId: post._id,
  id: `post-menu-${post._id}`,
});

const getMenuItemOptions = (post: Post, currentUser: User, component) => {
  const items = [];

  if (post.createdUserId !== currentUser._id) {
    items.push({
      text: 'Show Markdown',
      dataId: post._id,
      onClick: component.showMarkdown,
    });
  }

  if (post.createdUserId === currentUser._id) {
    const isFirstPost = post.discussion.posts.indexOf(post) === 0;

    items.push({
      text: 'Edit',
      dataId: post._id,
      onClick: component.editPost,
    });

    if (!isFirstPost) {
      items.push({
        text: 'Delete',
        dataId: post._id,
        onClick: component.deletePost,
      });
    }
  }

  return items;
};

type Props = {
  post: Post;
  store: Store;
  isMobile: boolean;
  onEditClick: (post) => void;
  onShowMarkdownClick: (post) => void;
};

class PostDetail extends React.Component<Props> {
  public render() {
    const { post, isMobile } = this.props;

    return <Paper style={stylePaper}>{this.renderPostDetail(post, isMobile)}</Paper>;
  }

  public renderPostDetail(post: Post, isMobile) {
    const createdDate = moment(post.createdAt).local().format('MMM Do YYYY');
    const lastUpdatedDate = moment(post.lastUpdatedAt).fromNow();

    return (
      <React.Fragment>
        <div
          style={{
            float: 'left',
            margin: '-12px 10px 0px -15px',
            zIndex: 1000,
          }}
        >
          {this.renderMenu()}
        </div>
        <div id={`post-${post._id}`}>
          {post.user && (
            <Tooltip
              title={post.user.displayName}
              placement="top"
              disableFocusListener
              disableTouchListener
            >
              <Avatar
                src={post.user.avatarUrl}
                alt={post.user.displayName}
                style={{
                  width: '40px',
                  height: '40px',
                  margin: '0px 10px 0px 5px',
                  cursor: 'pointer',
                  float: 'left',
                }}
              />
            </Tooltip>
          )}
          <div
            style={{
              margin: isMobile ? '0px' : '0px 20px 0px 70px',
              fontWeight: 300,
              lineHeight: '1em',
            }}
          >
            <span style={{ fontSize: '12px', fontWeight: 400 }}>
              {`By: ${post.user && post.user.displayName}` || 'User'}
              <span style={styleLineSeparator}>|</span>
              {`Created: ${post.createdAt && createdDate}` || ''}

              {post.isEdited ? (
                <React.Fragment>
                  <span style={styleLineSeparator}>|</span>
                  Last edited: {lastUpdatedDate}
                </React.Fragment>
              ) : null}
            </span>

            <PostContent html={post.htmlContent} />
          </div>
        </div>
      </React.Fragment>
    );
  }

  public renderMenu() {
    const { post, store } = this.props;
    const { currentUser } = store;

    if (!post.user || !currentUser) {
      return null;
    }

    return (
      <MenuWithMenuItems
        menuOptions={getMenuOptions(post)}
        itemOptions={getMenuItemOptions(post, store.currentUser, this)}
      />
    );
  }

  public showMarkdown = () => {
    const { post, onShowMarkdownClick } = this.props;
    if (onShowMarkdownClick) {
      onShowMarkdownClick(post);
    }
  };

  public editPost = () => {
    const { post, onEditClick } = this.props;
    if (onEditClick) {
      onEditClick(post);
    }
    // console.log(`PostDetail: ${post._id}`);
  };

  public deletePost = () => {
    confirm({
      title: 'Are you sure?',
      message: '',
      onAnswer: async (answer) => {
        if (answer) {
          const { post } = this.props;
          await post.discussion.deletePost(post);
          notify('You successfully deleted Post.');
        }
      },
    });
  };
}

export default observer(PostDetail);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\components\posts\PostEditor.tsx -----

import Avatar from '@mui/material/Avatar';
import Button from '@mui/material/Button';
import InsertPhotoIcon from '@mui/icons-material/InsertPhoto';
import he from 'he';
import { marked } from 'marked';
import { observer } from 'mobx-react';
import NProgress from 'nprogress';
import React from 'react';
import { Mention, MentionsInput } from 'react-mentions';

import {
  getSignedRequestForUploadApiMethod,
  uploadFileUsingSignedPutRequestApiMethod,
} from '../../lib/api/team-member';
import notify from '../../lib/notify';
import { resizeImage } from '../../lib/resizeImage';
import { Store } from '../../lib/store';
import { User } from '../../lib/store/user';

import PostContent from './PostContent';

function getImageDimension(file): Promise<{ width: number; height: number }> {
  const reader = new FileReader();
  const img = new Image();

  return new Promise((resolve) => {
    reader.readAsDataURL(file);

    reader.onload = (e) => {
      img.onload = () => {
        resolve({ width: img.width, height: img.height });
      };

      img.src = e.target.result.toString();
    };
  });
}

type Props = {
  store: Store;
  onChanged: (content) => void;
  content: string;
  members: User[];
  textareaHeight?: string;
  placeholder?: string;
  parentComponent: string;
};

type State = { htmlContent: string };

class PostEditor extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      htmlContent: '',
    };
  }

  public render() {
    const { htmlContent } = this.state;
    const { content, members, store, parentComponent } = this.props;
    const { currentUser } = store;

    const membersMinusCurrentUser = members.filter((member) => member._id !== currentUser._id);

    const isThemeDark = store && store.currentUser && store.currentUser.darkTheme === true;
    const textareaBackgroundColor = isThemeDark ? '#0d1117' : '#fff';

    return (
      <div style={{ marginTop: '20px' }}>
        <div style={{ display: 'inline-flex' }}>
          <Button
            onClick={this.showMarkdownContent}
            variant="text"
            style={{ fontWeight: htmlContent ? 300 : 600, color: '#58a6ff' }}
          >
            Markdown
          </Button>{' '}
          <Button
            onClick={this.showHtmlContent}
            variant="text"
            style={{ fontWeight: htmlContent ? 600 : 300, color: '#58a6ff' }}
          >
            HTML
          </Button>
        </div>

        <div style={{ display: 'inline', float: 'left' }}>
          <label htmlFor={'upload-file-post-editor-' + parentComponent}>
            <Button component="span" style={{ color: '#58a6ff' }}>
              <InsertPhotoIcon style={{ fontSize: '22px' }} />
            </Button>
          </label>
          <input
            accept="image/*"
            name={'upload-file-post-editor-' + parentComponent}
            id={'upload-file-post-editor-' + parentComponent}
            type="file"
            style={{ display: 'none' }}
            onChange={async (event) => {
              const file = event.target.files[0];
              await this.uploadFile(file);
              event.target.value = '';
            }}
          />
        </div>
        <br />
        <div
          style={{
            padding: '10px 15px',
            border: isThemeDark
              ? '1px solid rgba(255, 255, 255, 0.5)'
              : '1px solid rgba(0, 0, 0, 0.5)',
          }}
        >
          {htmlContent ? (
            <PostContent html={htmlContent} />
          ) : (
            <MentionsInput
              style={{
                input: {
                  border: 'none',
                  outline: 'none',
                  color: isThemeDark ? '#fff' : '#000',
                  fontFamily: 'Roboto, sans-serif',
                  lineHeight: '1.5em',
                  backgroundColor: content ? textareaBackgroundColor : 'transparent',
                },

                '&multiLine': {
                  control: {
                    fontFamily: 'Roboto, sans-serif',
                    minHeight: 100,
                  },
                },
                suggestions: {
                  list: {
                    backgroundColor: '#222',
                    color: '#fff',
                  },

                  item: {
                    padding: '5px 15px',
                    borderBottom: '1px solid rgba(0,0,0,0.15)',

                    '&focused': {
                      backgroundColor: 'rgba(255, 255, 255, 0.1)',
                    },
                  },
                },
              }}
              autoFocus
              value={content}
              placeholder={this.props.placeholder ? this.props.placeholder : 'Compose new post'}
              onChange={(event) => {
                this.props.onChanged(event.target.value);
              }}
            >
              <Mention
                trigger="@"
                data={membersMinusCurrentUser.map((u) => ({
                  id: u.avatarUrl,
                  display: u.displayName,
                  // you: u._id === currentUser._id ? true : false,
                }))}
                markup={'[`@#__display__`](__id__)'}
                displayTransform={(_, display) => {
                  return `@${display}`;
                }}
                renderSuggestion={(suggestion) => (
                  <React.Fragment>
                    <Avatar
                      role="presentation"
                      src={suggestion.id}
                      alt={suggestion.display}
                      style={{
                        width: '24px',
                        height: '24px',
                        marginRight: '10px',
                        display: 'inline-flex',
                        verticalAlign: 'middle',
                      }}
                    />
                    <span style={{ marginRight: '5px' }}>{suggestion.display}</span>
                  </React.Fragment>
                )}
              />
            </MentionsInput>
          )}
        </div>
      </div>
    );
  }

  public showMarkdownContent = () => {
    this.setState({ htmlContent: '' });
  };

  public showHtmlContent = async () => {
    const { content } = this.props;

    function markdownToHtml(postContent) {
      const renderer = new marked.Renderer();

      renderer.link = (href, title, text) => {
        const t = title ? ` title="${title}"` : '';

        if (text.startsWith('<code>@#')) {
          return `${text.replace('<code>@#', '<code>@')} `;
        }

        return `
          <a target="_blank" href="${href}" rel="noopener noreferrer"${t}>
            ${text}
          </a>
        `;
      };

      marked.setOptions({
        renderer,
        breaks: true,
      });

      return marked(he.decode(postContent));
    }

    const htmlContent = content ? markdownToHtml(content) : '<span>Nothing to preview.</span>';
    this.setState({ htmlContent });
  };

  private uploadFile = async (file: File) => {
    if (!file) {
      notify('No file selected.');
      return;
    }

    if (!file.type || (!file.type.startsWith('image/') && file.type !== 'application/pdf')) {
      notify('Wrong file.');
      return;
    }

    const { store } = this.props;
    const { currentTeam } = store;

    NProgress.start();

    const bucket = process.env.NEXT_PUBLIC_BUCKET_FOR_POSTS;
    const prefix = `${currentTeam.slug}`;
    const fileName = file.name;
    const fileType = file.type;

    try {
      const responseFromApiServerForUpload = await getSignedRequestForUploadApiMethod({
        fileName,
        fileType,
        prefix,
        bucket,
      });

      let fileHtmlOrMarkdown;
      let fileUrl;

      if (file.type.startsWith('image/')) {
        const { width } = await getImageDimension(file);
        const resizedFile = await resizeImage(file, 1024, 1024);

        await uploadFileUsingSignedPutRequestApiMethod(
          resizedFile,
          responseFromApiServerForUpload.signedRequest,
        );

        fileUrl = responseFromApiServerForUpload.url;

        // console.log(fileUrl);

        const finalWidth = width > 768 ? '100%' : `${width}px`;

        fileHtmlOrMarkdown = `
          <div>
            <img style="max-width: ${finalWidth}; width:100%" src="${fileUrl}" alt="Async" class="s3-image" />
          </div>`;
      } else {
        await uploadFileUsingSignedPutRequestApiMethod(
          file,
          responseFromApiServerForUpload.signedRequest,
        );

        fileUrl = responseFromApiServerForUpload.url;
        fileHtmlOrMarkdown = `[${file.name}](${fileUrl})`;
      }

      const content = `${this.props.content}\n${fileHtmlOrMarkdown.replace(/\s+/g, ' ')}`;

      this.props.onChanged(content);

      notify('You successfully uploaded file.');
    } catch (error) {
      console.log(error);
      notify(error);
    } finally {
      NProgress.done();
    }
  };
}

export default observer(PostEditor);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\components\posts\PostForm.tsx -----

import Button from '@mui/material/Button';
import he from 'he';
import { marked } from 'marked';
import { observer } from 'mobx-react';
import NProgress from 'nprogress';
import React from 'react';

import notify from '../../lib/notify';
import { Store } from '../../lib/store';
import { Discussion } from '../../lib/store/discussion';
import { Post } from '../../lib/store/post';
import { User } from '../../lib/store/user';

import PostEditor from './PostEditor';

const dev = process.env.NODE_ENV !== 'production';

type Props = {
  store: Store;
  isMobile: boolean;
  members: User[];
  post: Post;
  discussion: Discussion;
  showMarkdownToNonCreator?: boolean;
  onFinished?: () => void;
};

type State = {
  postId: string;
  content: string;
  disabled: boolean;
};

class PostForm extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      postId: null,
      content: '',
      disabled: false,
    };
  }

  public static getDerivedStateFromProps(props: Props, state: State) {
    const { post } = props;

    if (!post && !state.postId) {
      return null;
    }

    if (post && post._id === state.postId) {
      return null;
    }

    return {
      postId: (post && post._id) || null,
      content: (post && post.content) || '',
    };
  }

  public render() {
    const { store, members, post, isMobile, showMarkdownToNonCreator } = this.props;
    const isEditingPost = !!post;

    let title = 'Add Post';
    if (showMarkdownToNonCreator) {
      title = 'Showing Markdown';
    } else if (isEditingPost) {
      title = 'Edit Post';
    }

    return (
      <div style={{ height: '100%', margin: '0px 20px' }}>
        <p />
        <br />
        <h3>{title}</h3>
        <form style={{ width: '100%', height: '100%' }} onSubmit={this.onSubmit} autoComplete="off">
          <p />
          <br />
          <div>
            {showMarkdownToNonCreator ? null : (
              <React.Fragment>
                <Button
                  type="submit"
                  variant="contained"
                  color="primary"
                  disabled={this.state.disabled}
                >
                  {isEditingPost ? 'Save changes' : 'Publish Post'}
                </Button>
                {isMobile ? <p /> : null}
              </React.Fragment>
            )}
            {isEditingPost ? (
              <Button
                variant="outlined"
                onClick={this.closeForm}
                disabled={this.state.disabled}
                style={{ marginLeft: '10px' }}
              >
                {showMarkdownToNonCreator ? 'Go back' : 'Cancel'}
              </Button>
            ) : null}
          </div>
          <p />
          <PostEditor
            content={this.state.content}
            onChanged={this.onContentChanged}
            members={members}
            store={store}
            textareaHeight="100%"
            parentComponent="PF"
          />
          <p />
          <div style={{ margin: '20px 0px' }}>
            {isEditingPost ? (
              <Button
                variant="outlined"
                onClick={this.closeForm}
                disabled={this.state.disabled}
                style={{ marginLeft: '10px' }}
              >
                {showMarkdownToNonCreator ? 'Go back' : 'Cancel'}
              </Button>
            ) : null}
          </div>
          <p />
          <br />
        </form>
      </div>
    );
  }

  private onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();

    const { content } = this.state;
    const htmlContent = marked(he.decode(content));
    const { post, onFinished, store, discussion } = this.props;
    const isEditingPost = !!post;

    if (!content) {
      notify('Add content to your Post');
      return;
    }

    if (isEditingPost) {
      this.setState({ disabled: true });
      NProgress.start();
      try {
        await post.editPost({ content, htmlContent });
        notify('You successfully edited Post');
      } catch (error) {
        console.log(error);
        notify(error);
      } finally {
        this.setState({ disabled: false });
        NProgress.done();
      }

      if (onFinished) {
        onFinished();
      }

      return;
    }

    const { currentTeam } = store;
    if (!currentTeam) {
      notify('Team is not selected or does not exist.');
      return;
    }

    NProgress.start();
    this.setState({ disabled: true });

    try {
      const post = await discussion.addPost(content);

      if (discussion.notificationType === 'email') {
        const userIdsForLambda = discussion.memberIds.filter((m) => m !== store.currentUser._id);

        await discussion.sendDataToLambda({
          discussionName: discussion.name,
          discussionLink: `${
            dev ? process.env.NEXT_PUBLIC_URL_APP : process.env.NEXT_PUBLIC_PRODUCTION_URL_APP
          }/teams/${discussion.team.slug}/discussions/${discussion.slug}`,
          postContent: post.content,
          authorName: post.user.displayName,
          userIds: userIdsForLambda,
        });
      }

      this.setState({ content: '' });

      notify('You successfully published new Post.');
    } catch (error) {
      console.log(error);
      notify(error);
    } finally {
      this.setState({ disabled: false });
      NProgress.done();
    }

    if (onFinished) {
      onFinished();
    }
  };

  private onContentChanged = (content: string) => {
    this.setState({ content });
  };

  private closeForm = () => {
    this.setState({ postId: null, content: '' });

    const { onFinished } = this.props;
    if (onFinished) {
      onFinished();
    }
  };
}

export default observer(PostForm);

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\components\teams\InviteMember.tsx -----

import Button from '@mui/material/Button';
import Dialog from '@mui/material/Dialog';
import DialogContent from '@mui/material/DialogContent';
import DialogTitle from '@mui/material/DialogTitle';
import TextField from '@mui/material/TextField';
import { inject, observer } from 'mobx-react';
import NProgress from 'nprogress';
import React from 'react';

import notify from '../../lib/notify';
import { Store } from '../../lib/store';

type Props = {
  store: Store;
  onClose: () => void;
  open: boolean;
};

type State = {
  email: string;
  disabled: boolean;
};

class InviteMember extends React.Component<Props, State> {
  constructor(props) {
    super(props);

    this.state = {
      email: '',
      disabled: false,
    };
  }

  public render() {
    const { open } = this.props;

    return (
      <Dialog onClose={this.handleClose} aria-labelledby="invite-member-dialog-title" open={open}>
        <DialogTitle id="invite-member-dialog-title">Invite member</DialogTitle>
        <DialogContent>
          <form onSubmit={this.onSubmit} style={{ padding: '20px' }}>
            <TextField
              disabled
              autoComplete="off"
              value={this.state.email}
              placeholder="Email"
              onChange={(event) => {
                this.setState({ email: event.target.value });
              }}
            />
            <p>Disabled in this demo due to high bounce rate (people submitting fake emails)</p>
            <br />
            <Button variant="outlined" onClick={this.handleClose} disabled={this.state.disabled}>
              Cancel
            </Button>{' '}
            <Button disabled type="submit" variant="contained" color="primary">
              Invite
            </Button>
          </form>
        </DialogContent>
      </Dialog>
    );
  }

  private handleClose = () => {
    this.setState({ email: '', disabled: false });
    this.props.onClose();
  };

  private onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();

    const { store } = this.props;

    if (!store.currentTeam) {
      notify('Team have not selected');
      return;
    }

    const { email } = this.state;

    if (!email) {
      notify('Email is required');
      return;
    }

    NProgress.start();
    try {
      this.setState({ disabled: true });
      await store.currentTeam.inviteMember(email);

      this.setState({ email: '' });
      notify('You successfully sent invitation.');
      NProgress.done();
    } catch (error) {
      console.log(error);
      notify(error);
    } finally {
      this.props.onClose();
      this.setState({ disabled: false });
      NProgress.done();
    }
  };
}

export default inject('store')(observer(InviteMember));

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\lib\api\makeQueryString.ts -----

function makeQueryString(params) {
  const query = Object.keys(params)
    .filter((k) => !!params[k])
    .map((k) => `${encodeURIComponent(k)}=${encodeURIComponent(params[k])}`)
    .join('&');

  return query;
}

export { makeQueryString };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\lib\api\public.ts -----

import sendRequestAndGetResponse from './sendRequestAndGetResponse';

const BASE_PATH = '/api/v1/public';

export const getUserApiMethod = (request) =>
  sendRequestAndGetResponse(`${BASE_PATH}/get-user`, {
    request,
    method: 'GET',
  });

export const getUserBySlugApiMethod = (slug) =>
  sendRequestAndGetResponse(`${BASE_PATH}/get-user-by-slug`, {
    body: JSON.stringify({ slug }),
  });

export const emailLoginLinkApiMethod = ({
  email,
  invitationToken,
}: {
  email: string;
  invitationToken?: string;
}) =>
  sendRequestAndGetResponse('/auth/email-login-link', {
    qs: { invitationToken },
    body: JSON.stringify({ user: email }),
  });

export const getTeamByTokenApiMethod = (token: string, request) =>
  sendRequestAndGetResponse(`${BASE_PATH}/invitations/get-team-by-token`, {
    request,
    method: 'GET',
    qs: { token },
  });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\lib\api\sendRequestAndGetResponse.ts -----

import 'isomorphic-unfetch';

import { makeQueryString } from './makeQueryString';

const dev = process.env.NODE_ENV !== 'production';

export default async function sendRequestAndGetResponse(path, opts: any = {}) {
  const headers = Object.assign(
    {},
    opts.headers || {},
    opts.externalServer
      ? {}
      : {
          'Content-type': 'application/json; charset=UTF-8',
        },
  );

  const { request } = opts;

  if (request && request.headers && request.headers.cookie) {
    headers.cookie = request.headers.cookie;
  }

  // const qs = opts.qs || '';

  const qs = (opts.qs && `?${makeQueryString(opts.qs)}`) || '';

  // console.log(`before: ${process.env.NEXT_PUBLIC_URL_API}${path}${qs}`);

  const response = await fetch(
    opts.externalServer
      ? `${path}${qs}`
      : `${
          dev ? process.env.NEXT_PUBLIC_URL_API : process.env.NEXT_PUBLIC_PRODUCTION_URL_API
        }${path}${qs}`,
    Object.assign({ method: 'POST', credentials: 'include' }, opts, { headers }),
  );

  // console.log(`after: ${process.env.NEXT_PUBLIC_URL_API}${path}${qs}`);

  // console.log(response.status);
  // console.log(response.statusText);

  const text = await response.text();

  if (response.status >= 400) {
    console.error(text);
    throw new Error(response.status.toString());
  }

  try {
    const data = JSON.parse(text);

    return data;
  } catch (err) {
    if (err instanceof SyntaxError) {
      return text;
    }

    throw err;
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\lib\api\team-leader.ts -----

import sendRequestAndGetResponse from './sendRequestAndGetResponse';

const BASE_PATH = '/api/v1/team-leader';

export const addTeamApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams/add`, {
    body: JSON.stringify(data),
  });

export const updateTeamApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams/update`, {
    body: JSON.stringify(data),
  });

export const getTeamInvitationsApiMethod = (teamId: string) =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams/get-invitations-for-team`, {
    method: 'GET',
    qs: { teamId },
  });

export const inviteMemberApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams/invite-member`, {
    body: JSON.stringify(data),
  });

export const removeMemberApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams/remove-member`, {
    body: JSON.stringify(data),
  });

export const fetchCheckoutSessionApiMethod = ({ mode, teamId }: { mode: string; teamId: string }) =>
  sendRequestAndGetResponse(`${BASE_PATH}/stripe/fetch-checkout-session`, {
    body: JSON.stringify({ mode, teamId }),
  });

export const cancelSubscriptionApiMethod = ({ teamId }: { teamId: string }) =>
  sendRequestAndGetResponse(`${BASE_PATH}/cancel-subscription`, {
    body: JSON.stringify({ teamId }),
  });

export const getListOfInvoicesApiMethod = () =>
  sendRequestAndGetResponse(`${BASE_PATH}/get-list-of-invoices-for-customer`, {
    method: 'GET',
  });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\lib\api\team-member.ts -----

import sendRequestAndGetResponse from './sendRequestAndGetResponse';

const BASE_PATH = '/api/v1/team-member';

export const getSignedRequestForUploadApiMethod = ({ fileName, fileType, prefix, bucket }) =>
  sendRequestAndGetResponse(`${BASE_PATH}/aws/get-signed-request-for-upload-to-s3`, {
    body: JSON.stringify({ fileName, fileType, prefix, bucket }),
  });

export const uploadFileUsingSignedPutRequestApiMethod = (file, signedRequest, headers = {}) =>
  sendRequestAndGetResponse(signedRequest, {
    externalServer: true,
    method: 'PUT',
    body: file,
    headers,
  });

export const updateProfileApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/user/update-profile`, {
    body: JSON.stringify(data),
  });

export const toggleThemeApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/user/toggle-theme`, {
    body: JSON.stringify(data),
  });

export const getInitialDataApiMethod = (options: any = {}) =>
  sendRequestAndGetResponse(
    `${BASE_PATH}/get-initial-data`,
    Object.assign(
      {
        body: JSON.stringify(options.data || {}),
      },
      options,
    ),
  );

// export const getTeamListApiMethod = () =>
//   sendRequestAndGetResponse(`${BASE_PATH}/teams`, {
//     method: 'GET',
//   });

export const getTeamMembersApiMethod = (teamId: string) =>
  sendRequestAndGetResponse(`${BASE_PATH}/teams/get-members`, {
    method: 'GET',
    qs: { teamId },
  });

// Discussion and Post

export const getDiscussionListApiMethod = (params): Promise<{ discussions: any[] }> =>
  sendRequestAndGetResponse(`${BASE_PATH}/discussions/list`, {
    method: 'GET',
    qs: params,
  });

export const addDiscussionApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/discussions/add`, {
    body: JSON.stringify(data),
  });

export const editDiscussionApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/discussions/edit`, {
    body: JSON.stringify(data),
  });

export const deleteDiscussionApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/discussions/delete`, {
    body: JSON.stringify(data),
  });

export const getPostListApiMethod = (discussionId: string) =>
  sendRequestAndGetResponse(`${BASE_PATH}/posts/list`, {
    method: 'GET',
    qs: { discussionId },
  });

export const addPostApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/posts/add`, {
    body: JSON.stringify(data),
  });

export const editPostApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/posts/edit`, {
    body: JSON.stringify(data),
  });

export const deletePostApiMethod = (data) =>
  sendRequestAndGetResponse(`${BASE_PATH}/posts/delete`, {
    body: JSON.stringify(data),
  });

export const sendDataToLambdaApiMethod = (data) =>
  sendRequestAndGetResponse(`${process.env.NEXT_PUBLIC_API_GATEWAY_ENDPOINT}/`, {
    externalServer: true,
    body: JSON.stringify(data),
  });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\lib\store\discussion.ts -----

import { action, IObservableArray, observable, runInAction, computed, makeObservable } from 'mobx';

import {
  addPostApiMethod,
  deletePostApiMethod,
  editDiscussionApiMethod,
  getPostListApiMethod,
  sendDataToLambdaApiMethod,
} from '../api/team-member';
import { Store } from './index';
import { Team } from './team';
import { Post } from './post';

class Discussion {
  public _id: string;
  public createdUserId: string;
  public store: Store;
  public team: Team;

  public name: string;
  public slug: string;
  public memberIds: IObservableArray<string> = observable([]);
  public posts: IObservableArray<Post> = observable([]);
  public isLoadingPosts = false;

  public notificationType: string;

  constructor(params) {
    makeObservable(this, {
      name: observable,
      slug: observable,
      memberIds: observable,
      posts: observable,
      isLoadingPosts: observable,

      editDiscussion: action,
      changeLocalCache: action,

      setInitialPosts: action,
      loadPosts: action,
      addPost: action,
      addPostToLocalCache: action,
      deletePost: action,

      addDiscussionToLocalCache: action,
      editDiscussionFromLocalCache: action,
      deleteDiscussionFromLocalCache: action,
      editPostFromLocalCache: action,
      deletePostFromLocalCache: action,

      members: computed,
    });

    this._id = params._id;
    this.createdUserId = params.createdUserId;
    this.store = params.store;
    this.team = params.team;

    this.name = params.name;
    this.slug = params.slug;
    this.memberIds.replace(params.memberIds || []);

    this.notificationType = params.notificationType;

    if (params.initialPosts) {
      this.setInitialPosts(params.initialPosts);
      // console.log(params.initialPosts[0]);
    } else {
      this.loadPosts();
    }
  }

  public async editDiscussion(data) {
    try {
      await editDiscussionApiMethod({
        id: this._id,
        ...data,
        socketId: (this.store.socket && this.store.socket.id) || null,
      });

      runInAction(() => {
        this.changeLocalCache(data);
      });
    } catch (error) {
      console.error(error);
      throw error;
    }
  }

  public changeLocalCache(data) {
    this.name = data.name;
    this.memberIds.replace(data.memberIds || []);
  }

  get members() {
    return this.memberIds.map((id) => this.team.members.get(id)).filter((u) => !!u);
  }

  public setInitialPosts(posts) {
    const postObjs = posts.map((p) => new Post({ discussion: this, store: this.store, ...p }));
    this.posts.replace(postObjs);
  }

  public async loadPosts() {
    if (this.store.isServer || this.isLoadingPosts) {
      return;
    }

    this.isLoadingPosts = true;

    try {
      const { posts = [] } = await getPostListApiMethod(this._id);

      runInAction(() => {
        const postObjs = posts.map((t) => new Post({ discussion: this, store: this.store, ...t }));
        this.posts.replace(postObjs);
      });
    } finally {
      runInAction(() => {
        this.isLoadingPosts = false;
      });
    }
  }

  public async addPost(content: string): Promise<Post> {
    const { post } = await addPostApiMethod({
      discussionId: this._id,
      content,
      socketId: (this.store.socket && this.store.socket.id) || null,
    });

    return new Promise<Post>((resolve) => {
      runInAction(() => {
        const obj = this.addPostToLocalCache(post);
        resolve(obj);
      });
    });
  }

  public addPostToLocalCache(data) {
    const postObj = new Post({ discussion: this, store: this.store, ...data });

    this.posts.push(postObj);

    return postObj;
  }

  public async deletePost(post: Post) {
    await deletePostApiMethod({
      id: post._id,
      discussionId: this._id,
      socketId: (this.store.socket && this.store.socket.id) || null,
    });

    runInAction(() => {
      this.posts.remove(post);
    });
  }

  public joinSocketRooms() {
    if (this.store.socket) {
      console.log('joining socket discussion room', this.name);
      this.store.socket.emit('joinTeamRoom', this.team._id);
      this.store.socket.emit('joinDiscussionRoom', this._id);
    }
  }

  public leaveSocketRooms() {
    if (this.store.socket) {
      console.log('leaving socket discussion room', this.name);
      this.store.socket.emit('leaveTeamRoom', this.team._id);
      this.store.socket.emit('leaveDiscussionRoom', this._id);
    }
  }

  public handleDiscussionRealtimeEvent = (data) => {
    console.log('discussion realtime event', data);
    const { actionType } = data;

    if (actionType === 'added') {
      this.addDiscussionToLocalCache(data.discussion);
    } else if (actionType === 'edited') {
      this.editDiscussionFromLocalCache(data.discussion);
    } else if (actionType === 'deleted') {
      this.deleteDiscussionFromLocalCache(data.id);
    }
  };

  public addDiscussionToLocalCache(data): Discussion {
    const obj = new Discussion({ team: this.team, store: this.store, ...data });

    if (obj.memberIds.includes(this.store.currentUser._id)) {
      this.team.discussions.push(obj);
    }

    return obj;
  }

  public editDiscussionFromLocalCache(data) {
    const discussion = this.team.discussions.find((item) => item._id === data._id);
    if (discussion) {
      if (data.memberIds && data.memberIds.includes(this.store.currentUser._id)) {
        discussion.changeLocalCache(data);
      } else {
        this.deleteDiscussionFromLocalCache(data._id);
      }
    } else if (data.memberIds && data.memberIds.includes(this.store.currentUser._id)) {
      this.addDiscussionToLocalCache(data);
    }
  }

  public deleteDiscussionFromLocalCache(discussionId: string) {
    const discussion = this.team.discussions.find((item) => item._id === discussionId);
    this.team.discussions.remove(discussion);
  }

  public handlePostRealtimeEvent(data) {
    const { actionType } = data;

    if (actionType === 'added') {
      this.addPostToLocalCache(data.post);
    } else if (actionType === 'edited') {
      this.editPostFromLocalCache(data.post);
    } else if (actionType === 'deleted') {
      this.deletePostFromLocalCache(data.id);
    }
  }

  public editPostFromLocalCache(data) {
    const post = this.posts.find((t) => t._id === data._id);
    if (post) {
      post.changeLocalCache(data);
    }
  }

  public deletePostFromLocalCache(postId) {
    const post = this.posts.find((t) => t._id === postId);
    this.posts.remove(post);
  }

  public async sendDataToLambda({
    discussionName,
    discussionLink,
    postContent,
    authorName,
    userIds,
  }) {
    console.log(discussionName, discussionLink, authorName, postContent, userIds);
    try {
      await sendDataToLambdaApiMethod({
        discussionName,
        discussionLink,
        postContent,
        authorName,
        userIds,
      });
    } catch (error) {
      console.error(error);
      throw error;
    }
  }
}

export { Discussion };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\lib\store\index.ts -----

import { action, configure, IObservableArray, observable, makeObservable } from 'mobx';
import { enableStaticRendering } from 'mobx-react';
import { io, Socket } from 'socket.io-client';

import { addTeamApiMethod, getTeamInvitationsApiMethod } from '../api/team-leader';
import { getTeamMembersApiMethod } from '../api/team-member';

import { User } from './user';
import { Team } from './team';

const dev = process.env.NODE_ENV !== 'production';

enableStaticRendering(typeof window === 'undefined');

configure({ enforceActions: 'observed' });

class Store {
  public isServer: boolean;

  public currentUser?: User = null;
  public currentUrl = '';

  public currentTeam?: Team = null;

  public teams: IObservableArray<Team> = observable([]);

  public socket: Socket;

  constructor({
    initialState = {},
    isServer,
    socket = null,
  }: {
    initialState?: any;
    isServer: boolean;
    socket?: Socket;
  }) {
    makeObservable(this, {
      currentUser: observable,
      currentUrl: observable,
      currentTeam: observable,

      changeCurrentUrl: action,
      setCurrentUser: action,
      setCurrentTeam: action,
    });

    this.isServer = !!isServer;

    // console.log('initialState.user', initialState.user);

    this.setCurrentUser(initialState.user);

    this.currentUrl = initialState.currentUrl || '';

    // console.log(initialState);

    this.setCurrentTeam(initialState.team);

    if (initialState.teams && initialState.teams.length > 0) {
      this.setInitialTeamsStoreMethod(initialState.teams);
    }

    this.socket = socket;

    if (socket) {
      socket.on('disconnect', () => {
        console.log('socket: ## disconnected');
      });

      socket.on('reconnect', (attemptNumber) => {
        console.log('socket: $$ reconnected', attemptNumber);
      });
    }
  }

  public changeCurrentUrl(url: string) {
    this.currentUrl = url;
  }

  public async setCurrentUser(user) {
    if (user) {
      this.currentUser = new User({ store: this, ...user });
    } else {
      this.currentUser = null;
    }
  }

  public async addTeam({ name, avatarUrl }: { name: string; avatarUrl: string }): Promise<Team> {
    const data = await addTeamApiMethod({ name, avatarUrl });
    const team = new Team({ store: this, ...data });

    return team;
  }

  public async setCurrentTeam(team) {
    if (this.currentTeam) {
      if (this.currentTeam.slug === team.slug) {
        return;
      }
    }

    if (team) {
      this.currentTeam = new Team({ ...team, store: this });

      const users =
        team.initialMembers || (await getTeamMembersApiMethod(this.currentTeam._id)).users;

      const invitations =
        team.initialInvitations ||
        (await getTeamInvitationsApiMethod(this.currentTeam._id)).invitations;

      this.currentTeam.setInitialMembersAndInvitations(users, invitations);
    } else {
      this.currentTeam = null;
    }
  }

  private setInitialTeamsStoreMethod(teams: any[]) {
    // console.log(initialTeams);

    const teamObjs = teams.map((t) => new Team({ store: this, ...t }));

    this.teams.replace(teamObjs);
  }
}

let store: Store = null;

function initializeStore(initialState = {}) {
  const isServer = typeof window === 'undefined';

  const socket = isServer
    ? null
    : io(dev ? process.env.NEXT_PUBLIC_URL_API : process.env.NEXT_PUBLIC_PRODUCTION_URL_API, {
        reconnection: true,
        autoConnect: true,
        transports: ['polling', 'websocket'],
        withCredentials: true,
      });

  const _store =
    store !== null && store !== undefined ? store : new Store({ initialState, isServer, socket });

  // For SSG and SSR always create a new store
  if (typeof window === 'undefined') {
    return _store;
  }
  // Create the store once in the client
  if (!store) {
    store = _store;
  }

  // console.log(_store);

  return _store;
}

function getStore() {
  return store;
}

export { Store, initializeStore, getStore };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\lib\store\invitation.ts -----

class Invitation {
  public _id: string;
  public teamId: string;
  public email: string;
  public createdAt: Date;

  constructor(params) {
    Object.assign(this, params);
  }
}

export { Invitation };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\lib\store\post.ts -----

import { action, computed, observable, runInAction, makeObservable } from 'mobx';

import { editPostApiMethod } from '../api/team-member';

import { Store } from './index';
import { User } from './user';
import { Discussion } from './discussion';

export class Post {
  public _id: string;
  public createdUserId: string;
  public createdAt: Date;
  public discussionId: string;

  public discussion: Discussion;
  public store: Store;

  public content: string;
  public htmlContent: string;

  public isEdited: boolean;
  public lastUpdatedAt: Date;

  constructor(params) {
    makeObservable(this, {
      content: observable,
      htmlContent: observable,
      isEdited: observable,
      lastUpdatedAt: observable,

      editPost: action,
      changeLocalCache: action,

      user: computed,
    });

    this._id = params._id;
    this.createdUserId = params.createdUserId;
    this.createdAt = params.createdAt;
    this.discussionId = params.discussionId;

    this.content = params.content;
    this.htmlContent = params.htmlContent;

    this.discussion = params.discussion;
    this.store = params.store;

    this.isEdited = params.isEdited;
    this.lastUpdatedAt = params.lastUpdatedAt;
  }

  public async editPost(data) {
    try {
      await editPostApiMethod({
        id: this._id,
        content: data.content,
        socketId: (this.store.socket && this.store.socket.id) || null,
      });

      runInAction(() => {
        this.changeLocalCache(data);
      });
    } catch (error) {
      console.error(error);
      throw error;
    }
  }

  public changeLocalCache(data) {
    this.content = data.content;
    this.htmlContent = data.htmlContent;
    this.isEdited = true;
    this.lastUpdatedAt = data.lastUpdatedAt;
  }

  get user(): User {
    return this.discussion.team.members.get(this.createdUserId) || null;
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\lib\store\team.ts -----

import { action, computed, IObservableArray, observable, runInAction, makeObservable } from 'mobx';
import Router from 'next/router';
import {
  cancelSubscriptionApiMethod,
  inviteMemberApiMethod,
  removeMemberApiMethod,
  updateTeamApiMethod,
} from '../api/team-leader';
import {
  addDiscussionApiMethod,
  deleteDiscussionApiMethod,
  getDiscussionListApiMethod,
} from '../api/team-member';
import { Store } from './index';
import { User } from './user';
import { Invitation } from './invitation';
import { Discussion } from './discussion';

class Team {
  public store: Store;

  public _id: string;
  public teamLeaderId: string;

  public name: string;
  public slug: string;
  public avatarUrl: string;
  public memberIds: IObservableArray<string> = observable([]);
  public members: Map<string, User> = new Map();
  public invitations: Map<string, Invitation> = new Map();

  public currentDiscussion?: Discussion;
  public currentDiscussionSlug?: string;
  public discussions: IObservableArray<Discussion> = observable([]);
  public isLoadingDiscussions = false;

  public stripeSubscription: {
    id: string;
    object: string;
    application_fee_percent: number;
    billing: string;
    cancel_at_period_end: boolean;
    billing_cycle_anchor: number;
    canceled_at: number;
    created: number;
  };
  public isSubscriptionActive: boolean;
  public isPaymentFailed: boolean;

  constructor(params) {
    makeObservable(this, {
      name: observable,
      slug: observable,
      avatarUrl: observable,
      memberIds: observable,
      members: observable,
      invitations: observable,
      currentDiscussion: observable,
      currentDiscussionSlug: observable,
      isLoadingDiscussions: observable,
      discussions: observable,

      setInitialMembersAndInvitations: action,
      updateTheme: action,
      inviteMember: action,
      removeMember: action,
      setInitialDiscussions: action,
      loadDiscussions: action,
      addDiscussion: action,
      addDiscussionToLocalCache: action,
      deleteDiscussion: action,
      deleteDiscussionFromLocalCache: action,
      getDiscussionBySlug: action,

      orderedDiscussions: computed,
    });

    this._id = params._id;
    this.teamLeaderId = params.teamLeaderId;
    this.slug = params.slug;
    this.name = params.name;
    this.avatarUrl = params.avatarUrl;
    this.memberIds.replace(params.memberIds || []);
    this.currentDiscussionSlug = params.currentDiscussionSlug || null;

    this.stripeSubscription = params.stripeSubscription;
    this.isSubscriptionActive = params.isSubscriptionActive;
    this.isPaymentFailed = params.isPaymentFailed;

    this.store = params.store;

    if (params.initialDiscussions) {
      this.setInitialDiscussions(params.initialDiscussions);
    } else {
      this.loadDiscussions();
    }
  }

  public setInitialMembersAndInvitations(users, invitations) {
    this.members.clear();
    this.invitations.clear();

    for (const user of users) {
      if (this.store.currentUser && this.store.currentUser._id === user._id) {
        this.members.set(user._id, this.store.currentUser);
      } else {
        this.members.set(user._id, new User(user));
      }
    }

    for (const invitation of invitations) {
      this.invitations.set(invitation._id, new Invitation(invitation));
    }

    // console.log(this.members);
  }

  public async updateTheme({ name, avatarUrl }: { name: string; avatarUrl: string }) {
    try {
      const { slug } = await updateTeamApiMethod({
        teamId: this._id,
        name,
        avatarUrl,
      });

      runInAction(() => {
        this.name = name;
        this.avatarUrl = avatarUrl;
        this.slug = slug;
      });
    } catch (error) {
      console.error(error);
      throw error;
    }
  }

  public async inviteMember(email: string) {
    try {
      const { newInvitation } = await inviteMemberApiMethod({ teamId: this._id, email });

      runInAction(() => {
        this.invitations.set(newInvitation._id, new Invitation(newInvitation));
      });
    } catch (error) {
      console.error(error);
      throw error;
    }
  }

  public async removeMember(userId: string) {
    try {
      await removeMemberApiMethod({ teamId: this._id, userId });

      runInAction(() => {
        this.members.delete(userId);
        this.memberIds.remove(userId);
      });
    } catch (error) {
      console.error(error);
      throw error;
    }
  }

  public setCurrentDiscussion({ slug }: { slug: string }) {
    this.currentDiscussionSlug = slug;
    for (const discussion of this.discussions) {
      if (discussion && discussion.slug === slug) {
        this.currentDiscussion = discussion;
        break;
      }
    }
  }

  public setInitialDiscussions(discussions) {
    const discussionObjs = discussions.map(
      (d) => new Discussion({ team: this, store: this.store, ...d }),
    );

    this.discussions.replace(discussionObjs);

    if (!this.currentDiscussionSlug && this.discussions.length > 0) {
      this.currentDiscussionSlug = this.orderedDiscussions[0].slug;
    }

    if (this.currentDiscussionSlug) {
      this.setCurrentDiscussion({ slug: this.currentDiscussionSlug });
    }
  }

  public async loadDiscussions() {
    if (this.store.isServer || this.isLoadingDiscussions) {
      return;
    }

    this.isLoadingDiscussions = true;

    try {
      const { discussions = [] } = await getDiscussionListApiMethod({
        teamId: this._id,
      });
      const newList: Discussion[] = [];

      runInAction(() => {
        discussions.forEach((d) => {
          const disObj = this.discussions.find((obj) => obj._id === d._id);
          if (disObj) {
            disObj.changeLocalCache(d);
            newList.push(disObj);
          } else {
            newList.push(new Discussion({ team: this, store: this.store, ...d }));
          }
        });

        this.discussions.replace(newList);
      });
    } finally {
      runInAction(() => {
        this.isLoadingDiscussions = false;
      });
    }
  }

  public changeLocalCache(data) {
    this.name = data.name;
    this.memberIds.replace(data.memberIds || []);
  }

  public async addDiscussion(data): Promise<Discussion> {
    const { discussion } = await addDiscussionApiMethod({
      teamId: this._id,
      socketId: (this.store.socket && this.store.socket.id) || null,
      ...data,
    });

    return new Promise<Discussion>((resolve) => {
      runInAction(() => {
        const obj = this.addDiscussionToLocalCache(discussion);
        resolve(obj);
      });
    });
  }

  public addDiscussionToLocalCache(data): Discussion {
    const obj = new Discussion({ team: this, store: this.store, ...data });

    if (obj.memberIds.includes(this.store.currentUser._id)) {
      this.discussions.push(obj);
    }

    return obj;
  }

  public async deleteDiscussion(id: string) {
    await deleteDiscussionApiMethod({
      id,
      socketId: (this.store.socket && this.store.socket.id) || null,
    });

    runInAction(() => {
      this.deleteDiscussionFromLocalCache(id);

      const discussion = this.discussions.find((d) => d._id === id);

      if (this.currentDiscussion === discussion) {
        this.currentDiscussion = null;
        this.currentDiscussionSlug = null;

        if (this.discussions.length > 0) {
          const d = this.discussions[0];

          Router.push(
            `/discussion?teamSlug=${this.slug}&discussionSlug=${d.slug}`,
            `/teams/${this.slug}/discussions/${d.slug}`,
          );
        } else {
          Router.push(`/discussion?teamSlug=${this.slug}`, `/teams/${this.slug}/discussions`);
        }
      }
    });
  }

  public deleteDiscussionFromLocalCache(discussionId: string) {
    const discussion = this.discussions.find((item) => item._id === discussionId);
    this.discussions.remove(discussion);
  }

  public getDiscussionBySlug(slug: string): Discussion {
    return this.discussions.find((d) => d.slug === slug);
  }

  public async cancelSubscription({ teamId }: { teamId: string }) {
    try {
      const { isSubscriptionActive } = await cancelSubscriptionApiMethod({ teamId });

      runInAction(() => {
        this.isSubscriptionActive = isSubscriptionActive;
      });
    } catch (error) {
      console.error(error);
      throw error;
    }
  }

  public async checkIfTeamLeaderMustBeCustomer() {
    let ifTeamLeaderMustBeCustomerOnClient: boolean;

    if (this && this.memberIds.length < 2) {
      ifTeamLeaderMustBeCustomerOnClient = false;
    } else if (this && this.memberIds.length >= 2 && this.isSubscriptionActive) {
      ifTeamLeaderMustBeCustomerOnClient = false;
    } else if (this && this.memberIds.length >= 2 && !this.isSubscriptionActive) {
      ifTeamLeaderMustBeCustomerOnClient = true;
    }

    return ifTeamLeaderMustBeCustomerOnClient;
  }

  get orderedDiscussions() {
    return this.discussions.slice().sort();
  }
}

export { Team };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\lib\store\user.ts -----

import { action, observable, runInAction, makeObservable } from 'mobx';

import * as NProgress from 'nprogress';

import { getListOfInvoicesApiMethod } from '../api/team-leader';
import { toggleThemeApiMethod, updateProfileApiMethod } from '../api/team-member';
import { Store } from './index';

class User {
  public store: Store;

  public _id: string;
  public slug: string;
  public email: string | null;
  public displayName: string | null;
  public avatarUrl: string | null;
  public isSignedupViaGoogle: boolean;

  public darkTheme = false;
  public defaultTeamSlug: string;

  public stripeCard: {
    brand: string;
    funding: string;
    last4: string;
    exp_month: number;
    exp_year: number;
  };
  public hasCardInformation: boolean;
  public stripeListOfInvoices: {
    object: string;
    data: [
      {
        amount_paid: number;
        teamName: string;
        created: number;
        hosted_invoice_url: string;
      },
    ];
    has_more: boolean;
  };

  constructor(params) {
    makeObservable(this, {
      slug: observable,
      email: observable,
      displayName: observable,
      avatarUrl: observable,
      // darkTheme: observable,
      defaultTeamSlug: observable,
      stripeCard: observable,
      stripeListOfInvoices: observable,

      updateProfile: action,
      toggleTheme: action,
      getListOfInvoices: action,
    });

    this.store = params.store;
    this._id = params._id;
    this.slug = params.slug;
    this.email = params.email;
    this.displayName = params.displayName;
    this.avatarUrl = params.avatarUrl;
    this.isSignedupViaGoogle = !!params.isSignedupViaGoogle;
    this.darkTheme = !!params.darkTheme;
    this.defaultTeamSlug = params.defaultTeamSlug;

    this.stripeCard = params.stripeCard;
    this.hasCardInformation = params.hasCardInformation;
    this.stripeListOfInvoices = params.stripeListOfInvoices;
  }

  public async updateProfile({ name, avatarUrl }: { name: string; avatarUrl: string }) {
    const { updatedUser } = await updateProfileApiMethod({
      name,
      avatarUrl,
    });

    runInAction(() => {
      this.displayName = updatedUser.displayName;
      this.avatarUrl = updatedUser.avatarUrl;
      this.slug = updatedUser.slug;
    });
  }

  public async toggleTheme(darkTheme: boolean) {
    await toggleThemeApiMethod({ darkTheme });
    runInAction(() => {
      this.darkTheme = darkTheme;
    });
    NProgress.start();
    NProgress.set(0.5);
    window.location.reload();
  }

  public async getListOfInvoices() {
    try {
      const { stripeListOfInvoices } = await getListOfInvoicesApiMethod();
      runInAction(() => {
        this.stripeListOfInvoices = stripeListOfInvoices;
      });
    } catch (error) {
      console.error(error);
      throw error;
    }
  }
}

export { User };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\lib\confirm.ts -----

import { openConfirmDialogExternal } from '../components/common/Confirmer';

export default function confirm({
  title,
  message,
  onAnswer,
}: {
  title: string;
  message: string;
  onAnswer: (answer) => void;
}) {
  openConfirmDialogExternal({ title, message, onAnswer });
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\lib\gtag.ts -----

const { NEXT_PUBLIC_GA_MEASUREMENT_ID } = process.env;

// https://developers.google.com/analytics/devguides/collection/gtagjs/pages
export const pageview = (url) => {
  (window as any).gtag('config', NEXT_PUBLIC_GA_MEASUREMENT_ID, {
    page_location: url,
  });
};

// https://developers.google.com/analytics/devguides/collection/gtagjs/events
export const event = ({ action, category, label }) => {
  (window as any).gtag('event', action, {
    event_category: category,
    event_label: label,
  });
};

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\lib\isMobile.ts -----

const mobileRE =
  /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i;

export function isMobile(opts) {
  if (!opts) {
    opts = {};
  }

  let ua = opts.ua;

  if (!ua && typeof navigator !== 'undefined') {
    ua = navigator.userAgent;
  }

  if (!ua && opts.req && opts.req.headers && typeof opts.req.headers['user-agent'] === 'string') {
    ua = opts.req.headers['user-agent'];
    // console.log(ua);
  }

  if (typeof ua !== 'string') {
    return false;
  }

  return mobileRE.test(ua);
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\lib\notify.ts -----

import { openSnackbarExternal } from '../components/common/Notifier';

export default function notify(obj) {
  openSnackbarExternal({ message: obj.message || obj.toString() });
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\lib\resizeImage.ts -----

function resizeImage(file: File, MAX_WIDTH, MAX_HEIGHT) {
  const image = document.createElement('img');

  const resize = (resolve) => () => {
    let isResizeNeeded = false;
    let width = image.width;
    let height = image.height;

    if (width > height) {
      if (width > MAX_WIDTH) {
        isResizeNeeded = true;
        height *= MAX_WIDTH / width;
        width = MAX_WIDTH;
      }
    } else {
      if (height > MAX_HEIGHT) {
        isResizeNeeded = true;
        width *= MAX_HEIGHT / height;
        height = MAX_HEIGHT;
      }
    }

    if (isResizeNeeded) {
      const canvas = document.createElement('canvas');

      canvas.width = width;
      canvas.height = height;

      console.log(width, height);

      const ctx = canvas.getContext('2d');
      ctx.drawImage(image, 0, 0, width, height);

      canvas.toBlob((blob) => {
        resolve(blob);
      }, file.type);
    } else {
      resolve(file);
    }
  };

  return new Promise((resolve) => {
    const reader = new FileReader();

    console.log(`before ${image.src}`);

    reader.readAsDataURL(file);

    reader.onload = (e) => {
      image.src = e.target.result.toString();

      image.onload = resize(resolve);

      console.log(`after ${image.src}`);
    };
  });
}

export { resizeImage };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\lib\sharedStyles.ts -----

const styleBigAvatar = {
  width: '80px',
  height: '80px',
  margin: '0px auto 15px',
};

const styleRaisedButton = {
  margin: '15px',
};

const styleToolbar = {
  background: '#FFF',
  height: '64px',
  paddingRight: '20px',
};

const styleTextField = {
  color: '#222',
  fontWeight: '300',
};

const styleForm = {
  margin: '7% auto',
  width: '360px',
};

export { styleBigAvatar, styleRaisedButton, styleToolbar, styleTextField, styleForm };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\lib\theme.ts -----

import { createTheme } from '@mui/material/styles';

const themeDark = createTheme({
  palette: {
    primary: { main: '#238636' },
    secondary: { main: '#b62324' },
    mode: 'dark',
    background: { default: '#0d1117' },
    text: {
      primary: '#c9d1d9',
    },
  },
  typography: {
    fontFamily: ['IBM Plex Mono', 'monospace'].join(','),
    button: {
      textTransform: 'none',
    },
  },
});

const themeLight = createTheme({
  palette: {
    primary: { main: '#238636' },
    secondary: { main: '#b62324' },
    mode: 'light',
    background: { default: '#fff' },
    text: {
      primary: '#222',
    },
  },
  typography: {
    fontFamily: ['IBM Plex Mono', 'monospace'].join(','),
    button: {
      textTransform: 'none',
    },
  },
});

export { themeDark, themeLight };

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\lib\withAuth.tsx -----

import { observer } from 'mobx-react';
import Router from 'next/router';
import React from 'react';

import * as NProgress from 'nprogress';

import * as gtag from './gtag';

import { Store, getStore } from './store';

Router.events.on('routeChangeStart', () => {
  NProgress.start();
});

Router.events.on('routeChangeComplete', (url) => {
  const store = getStore();
  if (store) {
    store.changeCurrentUrl(url);
  }

  if (window) {
    gtag.pageview(url);
    gtag.event({
      action: 'view_item',
      category: 'engagement',
      label: store.currentUser ? store.currentUser.email : 'no_email',
    });
  }

  NProgress.done();
});

Router.events.on('routeChangeError', () => NProgress.done());

export default function withAuth(Component, { loginRequired = true, logoutRequired = false } = {}) {
  class WithAuth extends React.Component<{ store: Store }> {
    public static async getInitialProps(ctx) {
      // console.log('WithAuth.getInitialProps');

      const { req } = ctx;

      let pageComponentProps = {};

      if (Component.getInitialProps) {
        pageComponentProps = await Component.getInitialProps(ctx);
      }

      return {
        ...pageComponentProps,
        isServer: !!req,
      };
    }

    public componentDidMount() {
      // console.log('WithAuth.componentDidMount');

      const { store } = this.props;
      const user = store.currentUser;

      if (loginRequired && !logoutRequired && !user) {
        Router.push('/login');
        return;
      }

      let redirectUrl = '/login';
      let asUrl = '/login';
      if (user) {
        if (!user.defaultTeamSlug) {
          redirectUrl = '/create-team';
          asUrl = '/create-team';
        } else {
          redirectUrl = `/your-settings?teamSlug=${user.defaultTeamSlug}`;
          asUrl = `/teams/${user.defaultTeamSlug}/your-settings`;
        }
      }

      if (logoutRequired && user) {
        Router.push(redirectUrl, asUrl);
      }
    }

    public render() {
      const { store } = this.props;
      const user = store.currentUser;

      if (loginRequired && !logoutRequired && !user) {
        return null;
      }

      if (logoutRequired && user) {
        return null;
      }

      return <Component {...this.props} />;
    }
  }

  return observer(WithAuth);
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\pages\billing.tsx -----

import { observer } from 'mobx-react';
import moment from 'moment';
import Head from 'next/head';

import * as React from 'react';
import { useState, useEffect } from 'react';

import { loadStripe } from '@stripe/stripe-js';
import Button from '@mui/material/Button';
import DoneIcon from '@mui/icons-material/Done';
import NProgress from 'nprogress';

import Layout from '../components/layout';
import notify from '../lib/notify';
import { Store } from '../lib/store';
import withAuth from '../lib/withAuth';
import { fetchCheckoutSessionApiMethod } from '../lib/api/team-leader';

const dev = process.env.NODE_ENV !== 'production';

const stripePromise = loadStripe(
  dev
    ? process.env.NEXT_PUBLIC_STRIPE_TEST_PUBLISHABLEKEY
    : process.env.NEXT_PUBLIC_STRIPE_LIVE_PUBLISHABLEKEY,
);

type Props = {
  store: Store;
  isMobile: boolean;
  firstGridItem: boolean;
  teamRequired: boolean;
  teamSlug: string;
  redirectMessage?: string;
};

function Billing({
  store,
  isMobile,
  firstGridItem,
  teamRequired,
  teamSlug,
  redirectMessage,
}: Props) {
  const [disabled, setDisabled] = useState<boolean>(false);
  const [showInvoices, setShowInvoices] = useState<boolean>(false);

  useEffect(() => {
    if (redirectMessage) {
      notify(redirectMessage);
    }
  }, []);

  const handleCheckoutClick = async (mode: 'subscription' | 'setup') => {
    try {
      const { currentTeam } = store;

      NProgress.start();
      setDisabled(true);

      const { sessionId } = await fetchCheckoutSessionApiMethod({ mode, teamId: currentTeam._id });

      // console.log(process.env.NEXT_PUBLIC_STRIPE_TEST_PUBLISHABLEKEY, sessionId);

      // When the customer clicks on the button, redirect them to Checkout.
      const stripe = await stripePromise;
      const { error } = await stripe.redirectToCheckout({ sessionId });

      if (error) {
        notify(error);
        console.error(error);
      }
    } catch (err) {
      notify(err);
      console.error(err);
    } finally {
      setDisabled(false);
      NProgress.done();
    }
  };

  const cancelSubscriptionOnClick = async () => {
    const { currentTeam } = store;

    NProgress.start();
    setDisabled(true);

    try {
      await currentTeam.cancelSubscription({ teamId: currentTeam._id });
      notify('Success!');
    } catch (err) {
      notify(err);
    } finally {
      setDisabled(false);
      NProgress.done();
    }
  };

  const renderCardInfo = () => {
    const { currentUser } = store;

    if (currentUser && currentUser.hasCardInformation) {
      return (
        <span>
          {' '}
          <DoneIcon color="action" style={{ verticalAlign: 'text-bottom' }} /> Your default payment
          method:
          <li>
            {currentUser.stripeCard.brand}, {currentUser.stripeCard.funding} card
          </li>
          <li>Last 4 digits: *{currentUser.stripeCard.last4}</li>
          <li>
            Expiration: {currentUser.stripeCard.exp_month}/{currentUser.stripeCard.exp_year}
          </li>
          <p />
          <Button
            variant="outlined"
            color="primary"
            onClick={() => handleCheckoutClick('setup')}
            disabled={disabled}
          >
            Update card
          </Button>
        </span>
      );
    } else {
      return 'You have not added a card.';
    }
  };

  const renderInvoices = () => {
    const { currentUser } = store;

    if (!showInvoices) {
      return null;
    }

    if (currentUser && currentUser.stripeCard) {
      return (
        <React.Fragment>
          {currentUser.stripeListOfInvoices.data.map((invoice, i) => (
            <React.Fragment key={i}>
              <p>Your history of payments:</p>
              <li>
                ${invoice.amount_paid / 100} was paid on{' '}
                {moment(invoice.created * 1000).format('MMM Do YYYY')} for Team '{invoice.teamName}'
                -{' '}
                <a href={invoice.hosted_invoice_url} target="_blank" rel="noopener noreferrer">
                  See invoice
                </a>
              </li>
            </React.Fragment>
          ))}
        </React.Fragment>
      );
    } else {
      return 'You have no history of payments.';
    }
  };

  const showListOfInvoicesOnClick = async () => {
    const { currentUser } = store;

    NProgress.start();
    setDisabled(true);

    try {
      await currentUser.getListOfInvoices();
      setShowInvoices(true);
    } catch (err) {
      notify(err);
    } finally {
      setDisabled(false);
      NProgress.done();
    }
  };

  const renderSubscriptionButton = () => {
    const { currentTeam } = store;

    let subscriptionDate;
    let billingDay;
    if (currentTeam && currentTeam.stripeSubscription) {
      subscriptionDate = moment(currentTeam.stripeSubscription.billing_cycle_anchor * 1000).format(
        'MMM Do YYYY',
      );
      billingDay = moment(currentTeam.stripeSubscription.billing_cycle_anchor * 1000).format('Do');
    }

    if (currentTeam && !currentTeam.isSubscriptionActive && currentTeam.isPaymentFailed) {
      return (
        <>
          <p>You are not a paying customer.</p>
          <Button
            variant="contained"
            color="primary"
            onClick={() => handleCheckoutClick('subscription')}
            disabled={disabled}
          >
            Buy subscription
          </Button>
          <p />
          <p>
            Team was automatically unsubscribed due to failed payment. You will be prompt to update
            card information if you choose to re-subscribe Team.
          </p>
        </>
      );
    } else if (currentTeam && !currentTeam.isSubscriptionActive && !currentTeam.isPaymentFailed) {
      return (
        <React.Fragment>
          <p>You are not a paying customer.</p>
          <p>
            Buy subscription using your current card, see below section for current card
            information.
          </p>
          <Button
            variant="contained"
            color="primary"
            onClick={() => handleCheckoutClick('subscription')}
            disabled={disabled}
          >
            Buy subscription
          </Button>
        </React.Fragment>
      );
    } else {
      return (
        <React.Fragment>
          <span>
            {' '}
            <DoneIcon color="action" style={{ verticalAlign: 'text-bottom' }} /> Subscription is
            active.
            <p>
              You subscribed <b>{currentTeam.name}</b> on <b>{subscriptionDate}</b>.
            </p>
            <p>
              You will be billed $50 on <b>{billingDay} day</b> of each month unless you cancel
              subscription or subscription is cancelled automatically due to failed payment.
            </p>
          </span>
          <p />
          <Button
            variant="outlined"
            color="primary"
            onClick={cancelSubscriptionOnClick}
            disabled={disabled}
          >
            Unsubscribe Team
          </Button>
          <br />
        </React.Fragment>
      );
    }
  };

  const { currentTeam, currentUser } = store;
  const isTeamLeader = currentTeam && currentUser && currentUser._id === currentTeam.teamLeaderId;

  if (!currentTeam || currentTeam.slug !== teamSlug) {
    return (
      <Layout
        store={store}
        isMobile={isMobile}
        teamRequired={teamRequired}
        firstGridItem={firstGridItem}
      >
        <div style={{ padding: isMobile ? '0px' : '0px 30px' }}>
          <p>You did not select any team.</p>
          <p>
            To access this page, please select existing team or create new team if you have no
            teams.
          </p>
        </div>
      </Layout>
    );
  }

  if (!isTeamLeader) {
    return (
      <Layout
        store={store}
        isMobile={isMobile}
        teamRequired={teamRequired}
        firstGridItem={firstGridItem}
      >
        <div style={{ padding: isMobile ? '0px' : '0px 30px' }}>
          <p>Only the Team Leader can access this page.</p>
          <p>Create your own team to become a Team Leader.</p>
        </div>
      </Layout>
    );
  }

  return (
    <Layout
      store={store}
      isMobile={isMobile}
      teamRequired={teamRequired}
      firstGridItem={firstGridItem}
    >
      <Head>
        <title>Your Billing</title>
      </Head>
      <div style={{ padding: isMobile ? '0px' : '0px 30px' }}>
        <h3>Your Billing</h3>
        <p />
        <h4 style={{ marginTop: '40px' }}>Paid plan</h4>
        {renderSubscriptionButton()}
        <p />
        <br />
        <h4>Card information</h4>
        {renderCardInfo()}
        <p />
        <br />
        <h4>Payment history</h4>
        <Button
          variant="outlined"
          color="primary"
          onClick={showListOfInvoicesOnClick}
          disabled={disabled}
        >
          Show payment history
        </Button>
        <p />
        {renderInvoices()}
        <p />
        <br />
      </div>
    </Layout>
  );
}

export default withAuth(observer(Billing));

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\pages\create-team.tsx -----

import { inject, observer } from 'mobx-react';
import * as React from 'react';
import { useState } from 'react';

import Avatar from '@mui/material/Avatar';
import Button from '@mui/material/Button';
import Grid from '@mui/material/Grid';
import TextField from '@mui/material/TextField';

import Head from 'next/head';
import { useRouter } from 'next/router';

import {
  getSignedRequestForUploadApiMethod,
  uploadFileUsingSignedPutRequestApiMethod,
} from '../lib/api/team-member';
import notify from '../lib/notify';
import { resizeImage } from '../lib/resizeImage';
import { Store } from '../lib/store';
import withAuth from '../lib/withAuth';

import Layout from '../components/layout';

const styleGrid = {
  height: '100%',
};

type Props = { store: Store; isMobile: boolean; firstGridItem: boolean; teamRequired: boolean };

function CreateTeam({ store, isMobile, firstGridItem, teamRequired }: Props) {
  const [newName, setNewName] = useState<string>('');
  const [newAvatarUrl, setNewAvatarUrl] = useState<string>(
    'https://storage.googleapis.com/async-await/default-user.png?v=1',
  );
  const [disabled, setDisabled] = useState<boolean>(false);

  const router = useRouter();

  const onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();

    if (!newName) {
      notify('Team name is required.');
      return;
    }

    const file = (document.getElementById('upload-file') as HTMLFormElement).files[0];

    try {
      setDisabled(true);

      const defaultAvatarUrl = 'https://storage.googleapis.com/async-await/default-user.png?v=1';

      const team = await store.addTeam({
        name: newName,
        avatarUrl: defaultAvatarUrl,
      });

      console.log(`Returned to client: ${team._id}, ${team.name}, ${team.slug}`);

      if (file == null) {
        notify('You successfully created Team.<p />Redirecting...');
        router.push(`/teams/${team.slug}/team-settings`);
        return;
      }

      const fileName = file.name;
      const fileType = file.type;
      const bucket = process.env.NEXT_PUBLIC_BUCKET_FOR_TEAM_LOGOS;
      const prefix = team.slug;

      const responseFromApiServerForUpload = await getSignedRequestForUploadApiMethod({
        fileName,
        fileType,
        prefix,
        bucket,
      });

      const resizedFile = await resizeImage(file, 128, 128);

      await uploadFileUsingSignedPutRequestApiMethod(
        resizedFile,
        responseFromApiServerForUpload.signedRequest,
        {
          'Cache-Control': 'max-age=2592000',
        },
      );

      const uploadedAvatarUrl = responseFromApiServerForUpload.url;

      await team.updateTheme({ name: team.name, avatarUrl: uploadedAvatarUrl });

      setNewName('');
      setNewAvatarUrl('https://storage.googleapis.com/async-await/default-user.png?v=1');

      (document.getElementById('upload-file') as HTMLFormElement).value = '';

      notify('You successfully created Team. Redirecting ...');

      router.push(`/teams/${team.slug}/team-settings`);
    } catch (error) {
      console.log(error);
      notify(error);
    } finally {
      setDisabled(false);
    }
  };

  const previewTeamLogo = () => {
    const file = (document.getElementById('upload-file') as HTMLFormElement).files[0];
    if (!file) {
      return;
    }

    const reader = new FileReader();

    reader.readAsDataURL(file);

    reader.onload = (e) => {
      setNewAvatarUrl(e.target.result as string);
    };
  };

  return (
    <Layout
      store={store}
      isMobile={isMobile}
      teamRequired={teamRequired}
      firstGridItem={firstGridItem}
    >
      <Head>
        <title>Create Team</title>
        <meta name="description" content="Create a new Team at SaaS Boilerplate" />
      </Head>
      <div style={{ padding: '0px', fontSize: '14px', height: '100%' }}>
        <Grid container style={styleGrid}>
          <Grid item sm={12} xs={12} style={{ padding: isMobile ? '0px' : '0px 30px' }}>
            <h3>Create team</h3>
            <p />
            <form onSubmit={onSubmit}>
              <h4>Team name</h4>
              <TextField
                value={newName}
                label="Type your team's name."
                helperText="Team name as seen by your team members."
                onChange={(event) => {
                  setNewName(event.target.value);
                }}
              />
              <p />
              <h4 style={{ marginTop: '40px' }}>Team logo (optional)</h4>
              <Avatar
                src={newAvatarUrl}
                style={{
                  display: 'inline-flex',
                  verticalAlign: 'middle',
                  marginRight: 20,
                  width: 60,
                  height: 60,
                }}
              />
              <label htmlFor="upload-file">
                <Button variant="outlined" color="primary" component="span">
                  Select team logo
                </Button>
              </label>
              <input
                accept="image/*"
                name="upload-file"
                id="upload-file"
                type="file"
                style={{ display: 'none' }}
                onChange={previewTeamLogo}
              />
              <p />
              <br />
              <br />
              <Button variant="contained" color="primary" type="submit" disabled={disabled}>
                Create new team
              </Button>
            </form>
          </Grid>
        </Grid>
        <br />
      </div>
    </Layout>
  );
}

export default withAuth(inject('store')(observer(CreateTeam)));

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\pages\discussion.tsx -----

import Avatar from '@mui/material/Avatar';
import Tooltip from '@mui/material/Tooltip';
import Head from 'next/head';
import Router from 'next/router';
import * as React from 'react';
import { useState, useEffect, useRef } from 'react';

import { observer } from 'mobx-react';

import Layout from '../components/layout';
import PostDetail from '../components/posts/PostDetail';
import PostForm from '../components/posts/PostForm';
import notify from '../lib/notify';
import { Store } from '../lib/store';
import { Discussion } from '../lib/store/discussion';
import withAuth from '../lib/withAuth';
import { Post } from 'lib/store/post';

type Props = {
  store: Store;
  teamSlug: string;
  discussionSlug: string;
  isServer: boolean;
  isMobile: boolean;
  firstGridItem: boolean;
  teamRequired: boolean;
};

function DiscussionPageCompFunctional({
  store,
  teamSlug,
  discussionSlug,
  isServer,
  isMobile,
  firstGridItem,
  teamRequired,
}: Props) {
  const [selectedPost, setSelectedPost] = useState<Post>(null);
  const [showMarkdownClicked, setShowMarkdownClicked] = useState<boolean>(false);

  function usePrevious(value) {
    const ref = useRef();
    useEffect(() => {
      ref.current = value;
    });
    return ref.current;
  }

  const prevDiscussionSlug = usePrevious(discussionSlug);

  const mounted = useRef();

  useEffect(() => {
    if (!mounted.current) {
      console.log('useEffect 1 for DiscussionPageCompFunctional');

      if (store.currentTeam && (!isServer || !discussionSlug)) {
        store.currentTeam.loadDiscussions().catch((err) => notify(err));
      }

      const discussion = getDiscussion(discussionSlug);

      if (discussion) {
        discussion.joinSocketRooms();
      }

      // console.log(store.socket);

      store.socket.on('discussionEvent', handleDiscussionEvent);
      store.socket.on('postEvent', handlePostEvent);
      store.socket.on('reconnect', handleSocketReconnect);

      (mounted as any).current = true;
    } else {
      console.log('useEffect 2 for DiscussionPageCompFunctional');

      if (prevDiscussionSlug) {
        const prevDiscussion = getDiscussion(prevDiscussionSlug);
        if (prevDiscussion) {
          prevDiscussion.leaveSocketRooms();
        }
      }

      const discussion = getDiscussion(discussionSlug);

      if (!isServer && discussion) {
        discussion.loadPosts().catch((err) => notify(err));
      }

      if (discussion) {
        discussion.joinSocketRooms();
      }
    }

    return () => {
      const discussion = getDiscussion(discussionSlug);

      if (discussion) {
        discussion.leaveSocketRooms();
      }

      store.socket.off('discussionEvent', handleDiscussionEvent);
      store.socket.off('postEvent', handlePostEvent);
      store.socket.off('reconnect', handleSocketReconnect);
    };
  }, [discussionSlug]);

  const { currentTeam } = store;

  const getDiscussion = (slug: string): Discussion => {
    if (!currentTeam) {
      return;
    }

    if (!slug && currentTeam.discussions.length > 0) {
      Router.replace(
        `/discussion?teamSlug=${teamSlug}&discussionSlug=${currentTeam.orderedDiscussions[0].slug}`,
        `/teams/${teamSlug}/discussions/${currentTeam.orderedDiscussions[0].slug}`,
      );
      return;
    }

    if (slug && currentTeam) {
      return currentTeam.getDiscussionBySlug(slug);
    }

    return null;
  };

  const renderPosts = () => {
    const discussion = getDiscussion(discussionSlug);

    if (!discussion.isLoadingPosts && discussion.posts.length === 0) {
      return <p>Empty Discussion.</p>;
    }

    let loading = 'loading Posts ...';
    if (discussion.posts.length > 0) {
      loading = 'checking for newer Posts ...';
    }

    return (
      <React.Fragment>
        {discussion
          ? discussion.posts.map((p) =>
              selectedPost && selectedPost._id === p._id ? (
                <PostForm
                  store={store}
                  isMobile={isMobile}
                  key={p._id}
                  post={p}
                  showMarkdownToNonCreator={showMarkdownClicked}
                  discussion={discussion}
                  members={discussion.members}
                  onFinished={() => {
                    setSelectedPost(null);
                    setShowMarkdownClicked(false);
                  }}
                />
              ) : (
                <PostDetail
                  key={p._id}
                  post={p}
                  onEditClick={onEditClickCallback}
                  onShowMarkdownClick={onSnowMarkdownClickCallback}
                  isMobile={isMobile}
                  store={store}
                />
              ),
            )
          : null}

        {discussion && discussion.isLoadingPosts && !isServer ? <p>{loading}</p> : null}
      </React.Fragment>
    );
  };

  const onEditClickCallback = (post) => {
    setSelectedPost(post);
    setShowMarkdownClicked(false);
  };

  const onSnowMarkdownClickCallback = (post) => {
    setSelectedPost(post);
    setShowMarkdownClicked(true);
  };

  const handleDiscussionEvent = (data) => {
    // console.log('discussion realtime event', data);

    const discussion = getDiscussion(discussionSlug);
    if (discussion) {
      discussion.handleDiscussionRealtimeEvent(data);
    }
  };

  const handlePostEvent = (data) => {
    // console.log('post realtime event', data);

    const discussion = getDiscussion(discussionSlug);
    if (discussion) {
      discussion.handlePostRealtimeEvent(data);
    }
  };

  const handleSocketReconnect = () => {
    console.log('pages/discussion.tsx: socket re-connected');

    const discussion = getDiscussion(discussionSlug);
    if (discussion) {
      discussion.loadPosts().catch((err) => notify(err));
      discussion.joinSocketRooms();
    }
  };

  if (!currentTeam || currentTeam.slug !== teamSlug) {
    return (
      <Layout
        store={store}
        isMobile={isMobile}
        firstGridItem={firstGridItem}
        teamRequired={teamRequired}
      >
        <Head>
          <title>No Team is found.</title>
        </Head>
        <div style={{ padding: isMobile ? '0px' : '0px 30px' }}>No Team is found.</div>
      </Layout>
    );
  }

  const discussion = getDiscussion(discussionSlug);

  if (!discussion) {
    if (currentTeam.isLoadingDiscussions) {
      return (
        <Layout
          store={store}
          isMobile={isMobile}
          firstGridItem={firstGridItem}
          teamRequired={teamRequired}
        >
          <Head>
            <title>Loading...</title>
          </Head>
          <div style={{ padding: isMobile ? '0px' : '0px 30px' }}>
            <p>Loading Discussions...</p>
          </div>
        </Layout>
      );
    } else {
      return (
        <Layout
          store={store}
          isMobile={isMobile}
          firstGridItem={firstGridItem}
          teamRequired={teamRequired}
        >
          <Head>
            <title>No Discussion is found.</title>
          </Head>
          <div style={{ padding: isMobile ? '0px' : '0px 30px' }}>
            <p>No Discussion is found.</p>
          </div>
        </Layout>
      );
    }
  }

  const title = discussion ? `${discussion.name}  Discussion` : 'Discussions';

  return (
    <Layout
      store={store}
      isMobile={isMobile}
      firstGridItem={firstGridItem}
      teamRequired={teamRequired}
    >
      <Head>
        <title>{title}</title>
      </Head>
      <div style={{ padding: isMobile ? '0px' : '0px 30px', height: '100vh' }}>
        <h4>
          <span style={{ fontWeight: 300 }}>Discussion : </span>
          {(discussion && discussion.name) || 'No Discussion is found.'}
        </h4>{' '}
        Visible to :{' '}
        {discussion
          ? discussion.members.map((m) => (
              <Tooltip
                title={m.displayName}
                placement="right"
                disableFocusListener
                disableTouchListener
                key={m._id}
              >
                <Avatar
                  role="presentation"
                  src={m.avatarUrl}
                  alt={m.avatarUrl}
                  key={m._id}
                  style={{
                    margin: '0px 5px',
                    display: 'inline-flex',
                    width: '30px',
                    height: '30px',
                    verticalAlign: 'middle',
                  }}
                />
              </Tooltip>
            ))
          : null}
        <p />
        {renderPosts()}
        {discussion && !discussion.isLoadingPosts ? (
          <React.Fragment>
            {selectedPost ? null : (
              <PostForm
                post={null}
                discussion={discussion}
                members={discussion.members}
                isMobile={isMobile}
                store={store}
              />
            )}
          </React.Fragment>
        ) : null}
        <p />
        <br />
      </div>
    </Layout>
  );
}

export default withAuth(observer(DiscussionPageCompFunctional));

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\pages\invitation.tsx -----

import Avatar from '@mui/material/Avatar';
import { observer } from 'mobx-react';
import Error from 'next/error';
import Head from 'next/head';
import Router from 'next/router';
import { NextPageContext } from 'next';

import React from 'react';
import { useEffect } from 'react';

import LoginButton from '../components/common/LoginButton';
import Layout from '../components/layout';
import { getTeamByTokenApiMethod } from '../lib/api/public';
import { Team } from '../lib/store/team';
import { Store } from '../lib/store';
import withAuth from '../lib/withAuth';

const dev = process.env.NODE_ENV !== 'production';

type Props = {
  store: Store;
  isMobile: boolean;
  firstGridItem: boolean;
  teamRequired: boolean;
  team: Team;
  token: string;
};

function InvitationPageComp({ store, isMobile, firstGridItem, teamRequired, team, token }: Props) {
  useEffect(() => {
    const user = store.currentUser;

    if (user && team) {
      Router.push(
        `${
          dev ? process.env.NEXT_PUBLIC_URL_API : process.env.NEXT_PUBLIC_PRODUCTION_URL_API
        }/logout?invitationToken=${token}`,
        `${
          dev ? process.env.NEXT_PUBLIC_URL_API : process.env.NEXT_PUBLIC_PRODUCTION_URL_API
        }/logout`,
      );
    }
  }, []);

  if (!team) {
    return <Error statusCode={404} />;
  }

  const user = store.currentUser;

  if (user) {
    return null;
  }

  return (
    <Layout
      store={store}
      isMobile={isMobile}
      teamRequired={teamRequired}
      firstGridItem={firstGridItem}
    >
      <Head>
        <title>Invitation to {team.name}</title>
        <meta name="description" content={`Invitation to join ${team.name}`} />
      </Head>
      <div style={{ textAlign: 'center', margin: '0 20px' }}>
        <br />
        <Avatar
          src={`${
            team.avatarUrl || 'https://storage.googleapis.com/async-await/default-user.png?v=1'
          }`}
          alt="Team logo"
          style={{
            verticalAlign: 'middle',
            display: 'inline-flex',
          }}
        />{' '}
        <h2>{team.name}</h2>
        <p>
          Join <b>{team.name}</b> by logging in or signing up.
        </p>
        <br />
        <LoginButton invitationToken={token} />
      </div>
    </Layout>
  );
}

InvitationPageComp.getInitialProps = async (ctx: NextPageContext) => {
  const { token } = ctx.query;

  if (!token) {
    return {};
  }

  try {
    const { team } = await getTeamByTokenApiMethod(token as string, ctx.req);

    return { team, token };
  } catch (error) {
    console.log(error);
    return {};
  }
};

// export async function getServerSideProps(context: NextPageContext) {
//   const { token } = context.query;

//   try {
//     const { team } = await getTeamByTokenApiMethod(token as string, context.req);

//     if (team && token) {
//       return { props: { team, token } };
//     } else {
//       return { props: {} };
//     }
//   } catch (error) {
//     console.log(error);
//     return { props: {} };
//   }
// }

// see our explanation for not using getServerSideProps at this time: https://github.com/async-labs/saas/issues/193

export default withAuth(observer(InvitationPageComp), { loginRequired: false });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\pages\login-cached.tsx -----

import Head from 'next/head';
import React from 'react';
import LoginButton from '../components/common/LoginButton';
import Layout from '../components/layout';
import withAuth from '../lib/withAuth';
import { Store } from '../lib/store';

type Props = {
  store: Store;
  isMobile: boolean;
  firstGridItem: boolean;
};

function Login({ store, isMobile, firstGridItem }: Props) {
  return (
    <Layout store={store} isMobile={isMobile} firstGridItem={firstGridItem}>
      <div style={{ textAlign: 'center', margin: '0 20px' }}>
        <Head>
          <title>Log in or Sign up to SaaS boilerplate</title>
          <meta
            name="description"
            content="Login and signup page for SaaS boilerplate demo by Async"
          />
        </Head>
        <br />
        <p style={{ margin: '45px auto', fontSize: '44px', fontWeight: 400 }}>Log in or Sign up</p>
        <p>Youll be logged in for 14 days unless you log out manually.</p>
        <br />
        <LoginButton />
      </div>
    </Layout>
  );
}

export default withAuth(Login, { logoutRequired: true });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\pages\login.tsx -----

import Head from 'next/head';
import React from 'react';
import LoginButton from '../components/common/LoginButton';
import Layout from '../components/layout';
import withAuth from '../lib/withAuth';
import { Store } from '../lib/store';

type Props = {
  store: Store;
  isMobile: boolean;
  firstGridItem: boolean;
};

function Login({ store, isMobile, firstGridItem }: Props) {
  return (
    <Layout store={store} isMobile={isMobile} firstGridItem={firstGridItem}>
      <div style={{ textAlign: 'center', margin: '0 20px' }}>
        <Head>
          <title>Log in or Sign up to SaaS boilerplate</title>
          <meta
            name="description"
            content="Login and signup page for SaaS boilerplate demo by Async"
          />
        </Head>
        <br />
        <p style={{ margin: '45px auto', fontSize: '44px', fontWeight: 400 }}>Log in or Sign up</p>
        <p>Youll be logged in for 14 days unless you log out manually.</p>
        <br />
        <LoginButton />
      </div>
    </Layout>
  );
}

export default withAuth(Login, { logoutRequired: true });

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\pages\team-settings.tsx -----

import Avatar from '@mui/material/Avatar';
import Button from '@mui/material/Button';
import Hidden from '@mui/material/Hidden';
import TextField from '@mui/material/TextField';
import DeleteOutlineIcon from '@mui/icons-material/DeleteOutline';
import { inject, observer } from 'mobx-react';
import Head from 'next/head';
import NProgress from 'nprogress';

import * as React from 'react';
import { useState } from 'react';

import Table from '@mui/material/Table';
import TableBody from '@mui/material/TableBody';
import TableCell from '@mui/material/TableCell';
import TableContainer from '@mui/material/TableContainer';
import TableHead from '@mui/material/TableHead';
import TableRow from '@mui/material/TableRow';

import Layout from '../components/layout';
import InviteMember from '../components/teams/InviteMember';
import {
  getSignedRequestForUploadApiMethod,
  uploadFileUsingSignedPutRequestApiMethod,
} from '../lib/api/team-member';
import confirm from '../lib/confirm';
import notify from '../lib/notify';
import { resizeImage } from '../lib/resizeImage';
import { Store } from '../lib/store';
import withAuth from '../lib/withAuth';

type Props = {
  store: Store;
  isMobile: boolean;
  firstGridItem: boolean;
  teamRequired: boolean;
  teamSlug: string;
};

function TeamSettings({ store, isMobile, firstGridItem, teamRequired, teamSlug }: Props) {
  const [newName, setNewName] = useState<string>(store.currentTeam.name);
  const [newAvatarUrl, setNewAvatarUrl] = useState<string>(store.currentTeam.avatarUrl);
  const [disabled, setDisabled] = useState<boolean>(false);
  const [inviteMemberOpen, setInviteMemberOpen] = useState<boolean>(false);

  const onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    const { currentTeam } = store;

    if (!newName) {
      notify('Team name is required');
      return;
    }

    NProgress.start();
    setDisabled(true);

    try {
      await currentTeam.updateTheme({ name: newName, avatarUrl: newAvatarUrl });

      notify('You successfully updated Team name.');
    } catch (error) {
      notify(error);
    } finally {
      setDisabled(false);
      NProgress.done();
    }
  };

  const uploadFile = async () => {
    const { currentTeam } = store;

    const fileElement = document.getElementById('upload-file-team-logo') as HTMLFormElement;
    const file = fileElement.files[0];

    if (file == null) {
      notify('No file selected for upload.');
      return;
    }

    const fileName = file.name;
    const fileType = file.type;

    NProgress.start();
    setDisabled(true);

    const bucket = process.env.NEXT_PUBLIC_BUCKET_FOR_TEAM_LOGOS;
    const prefix = `${currentTeam.slug}`;

    console.log(bucket);

    try {
      const responseFromApiServerForUpload = await getSignedRequestForUploadApiMethod({
        fileName,
        fileType,
        prefix,
        bucket,
      });

      const resizedFile = await resizeImage(file, 128, 128);

      await uploadFileUsingSignedPutRequestApiMethod(
        resizedFile,
        responseFromApiServerForUpload.signedRequest,
        { 'Cache-Control': 'max-age=2592000' },
      );

      setNewAvatarUrl(responseFromApiServerForUpload.url);

      await currentTeam.updateTheme({
        name: newName,
        avatarUrl: newAvatarUrl,
      });

      notify('You successfully uploaded new Team logo.');
    } catch (error) {
      notify(error);
    } finally {
      setDisabled(false);
      NProgress.done();
    }
  };

  const openInviteMember = async () => {
    const { currentTeam } = store;
    if (!currentTeam) {
      notify('You have not selected a Team.');
      return;
    }

    const ifTeamLeaderMustBeCustomer = await currentTeam.checkIfTeamLeaderMustBeCustomer();

    if (ifTeamLeaderMustBeCustomer) {
      notify(
        'To add a third team member, you have to become a paid customer.' +
          '<p />' +
          ' To become a paid customer,' +
          ' navigate to Billing page.',
      );
      return;
    }

    setInviteMemberOpen(true);
  };

  const handleInviteMemberClose = () => {
    setInviteMemberOpen(false);
  };

  const removeMember = (event) => {
    const { currentTeam } = store;

    if (!currentTeam) {
      notify('You have not selected a Team.');
      return;
    }

    const userId = event.currentTarget.dataset.id;
    if (!userId) {
      notify('Select user.');
      return;
    }

    confirm({
      title: 'Are you sure?',
      message: '',
      onAnswer: async (answer) => {
        if (answer) {
          try {
            await currentTeam.removeMember(userId);
          } catch (error) {
            notify(error);
          }
        }
      },
    });
  };

  const { currentTeam, currentUser } = store;
  const isTeamLeader = currentTeam && currentUser && currentUser._id === currentTeam.teamLeaderId;

  if (!currentTeam || currentTeam.slug !== teamSlug) {
    return (
      <Layout
        store={store}
        isMobile={isMobile}
        teamRequired={teamRequired}
        firstGridItem={firstGridItem}
      >
        <div style={{ padding: isMobile ? '0px' : '0px 30px' }}>
          <p>You did not select any team.</p>
          <p>
            To access this page, please select existing team or create new team if you have no
            teams.
          </p>
        </div>
      </Layout>
    );
  }

  if (!isTeamLeader) {
    return (
      <Layout
        store={store}
        isMobile={isMobile}
        teamRequired={teamRequired}
        firstGridItem={firstGridItem}
      >
        <div style={{ padding: isMobile ? '0px' : '0px 30px' }}>
          <p>Only the Team Leader can access this page.</p>
          <p>Create your own team to become a Team Leader.</p>
        </div>
      </Layout>
    );
  }

  return (
    <Layout
      store={store}
      isMobile={isMobile}
      teamRequired={teamRequired}
      firstGridItem={firstGridItem}
    >
      <Head>
        <title>Team Settings</title>
      </Head>
      <div style={{ padding: isMobile ? '0px' : '0px 30px', fontSize: '15px', height: '100%' }}>
        <h3>Team Settings</h3>
        <p />
        <br />
        <form onSubmit={onSubmit}>
          <h4>Team name</h4>
          <TextField
            value={newName}
            helperText="Team name as seen by your team members"
            onChange={(event) => {
              setNewName(event.target.value);
            }}
          />
          <br />
          <br />
          <Button variant="contained" color="primary" type="submit" disabled={disabled}>
            Update username
          </Button>
        </form>
        <p />
        <br />
        <h4>Team logo</h4>
        <Avatar
          src={newAvatarUrl}
          style={{
            display: 'inline-flex',
            verticalAlign: 'middle',
            marginRight: 20,
            width: 60,
            height: 60,
          }}
        />
        <label htmlFor="upload-file-team-logo">
          <Button variant="contained" color="primary" component="span" disabled={disabled}>
            Update logo
          </Button>
        </label>
        <input
          accept="image/*"
          name="upload-file-team-logo"
          id="upload-file-team-logo"
          type="file"
          style={{ display: 'none' }}
          onChange={uploadFile}
        />
        <p />
        <br />
        <br />
        <h4 style={{ marginRight: 20, display: 'inline' }}>
          Team Members ( {Array.from(currentTeam.members.values()).length} / 20 )
        </h4>
        <Button
          onClick={openInviteMember}
          variant="contained"
          color="primary"
          style={{ float: 'right', marginTop: '-20px' }}
          disabled={disabled}
        >
          Invite member
        </Button>
        <p />
        <TableContainer>
          <Table>
            <TableHead>
              <TableRow>
                <TableCell>Person</TableCell>
                <TableCell>Role</TableCell>
                <TableCell>Action</TableCell>
              </TableRow>
            </TableHead>

            <TableBody>
              {currentTeam.memberIds
                .map((userId) => currentTeam.members.get(userId))
                .map((m) => (
                  <TableRow key={m._id}>
                    <TableCell style={{ width: '300px' }}>
                      <Hidden mdDown>
                        <Avatar
                          role="presentation"
                          src={m.avatarUrl}
                          alt={(m.displayName || m.email)[0]}
                          key={m._id}
                          style={{
                            margin: '0px 5px',
                            display: 'inline-flex',
                            width: '30px',
                            height: '30px',
                            verticalAlign: 'middle',
                          }}
                        />
                      </Hidden>
                      {m.email}
                    </TableCell>
                    <TableCell>
                      {isTeamLeader && m._id !== currentUser._id ? 'Team Member' : 'Team Leader'}
                    </TableCell>
                    <TableCell>
                      {isTeamLeader && m._id !== currentUser._id ? (
                        <DeleteOutlineIcon
                          color="action"
                          data-id={m._id}
                          onClick={removeMember}
                          style={{
                            marginLeft: '20px',
                            fontSize: '16px',
                            opacity: 0.6,
                            cursor: 'pointer',
                            verticalAlign: 'middle',
                          }}
                        />
                      ) : null}
                    </TableCell>
                  </TableRow>
                ))}
            </TableBody>
          </Table>
        </TableContainer>

        <p />
        <br />

        {Array.from(currentTeam.invitations.values()).length > 0 ? (
          <React.Fragment>
            <h4>Invited users</h4>
            <p />
            <TableContainer>
              <Table>
                <TableHead>
                  <TableRow>
                    <TableCell>Email</TableCell>
                    <TableCell>Status</TableCell>
                  </TableRow>
                </TableHead>

                <TableBody>
                  {Array.from(currentTeam.invitations.values()).map((i) => (
                    <TableRow key={i._id}>
                      <TableCell style={{ width: '300px' }}>{i.email}</TableCell>
                      <TableCell>Sent</TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            </TableContainer>
          </React.Fragment>
        ) : null}
        <p />
        <br />
        <InviteMember open={inviteMemberOpen} onClose={handleInviteMemberClose} store={store} />
        <br />
      </div>
    </Layout>
  );
}

export default withAuth(inject('store')(observer(TeamSettings)));

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\pages\your-settings.tsx -----

import Avatar from '@mui/material/Avatar';
import Button from '@mui/material/Button';
import TextField from '@mui/material/TextField';
import DoneIcon from '@mui/icons-material/Done';

import Table from '@mui/material/Table';
import TableBody from '@mui/material/TableBody';
import TableCell from '@mui/material/TableCell';
import TableContainer from '@mui/material/TableContainer';
import TableHead from '@mui/material/TableHead';
import TableRow from '@mui/material/TableRow';

import { inject, observer } from 'mobx-react';
import Head from 'next/head';
import Link from 'next/link';
import NProgress from 'nprogress';

import * as React from 'react';
import { useState } from 'react';

import Layout from '../components/layout';

import {
  getSignedRequestForUploadApiMethod,
  uploadFileUsingSignedPutRequestApiMethod,
} from '../lib/api/team-member';

import notify from '../lib/notify';
import { resizeImage } from '../lib/resizeImage';
import { Store } from '../lib/store';
import withAuth from '../lib/withAuth';

const dev = process.env.NODE_ENV !== 'production';
const URL_APP = dev ? process.env.NEXT_PUBLIC_URL_APP : process.env.NEXT_PUBLIC_PRODUCTION_URL_APP;

type Props = {
  store: Store;
  isMobile: boolean;
  firstGridItem: boolean;
  teamRequired: boolean;
};

function YourSettings({ store, isMobile, firstGridItem, teamRequired }: Props) {
  const [newName, setNewName] = useState<string>(store.currentUser.displayName);
  const [newAvatarUrl, setNewAvatarUrl] = useState<string>(store.currentUser.avatarUrl);
  const [disabled, setDisabled] = useState<boolean>(false);

  const onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();

    const { currentUser } = store;

    if (!newName) {
      notify('Name is required');
      return;
    }

    NProgress.start();
    setDisabled(true);

    try {
      await currentUser.updateProfile({ name: newName, avatarUrl: newAvatarUrl });

      notify('You successfully updated your profile.');
    } catch (error) {
      notify(error);
    } finally {
      setDisabled(false);
      NProgress.done();
    }
  };

  const uploadFile = async () => {
    const fileElement = document.getElementById('upload-file-user-avatar') as HTMLFormElement;
    const file = fileElement.files[0];

    const { currentUser } = store;

    if (file == null) {
      notify('No file selected for upload.');
      return;
    }

    const fileName = file.name;
    const fileType = file.type;

    NProgress.start();
    setDisabled(true);

    const bucket = process.env.NEXT_PUBLIC_BUCKET_FOR_AVATARS;

    const prefix = `${currentUser.slug}`;

    try {
      const responseFromApiServerForUpload = await getSignedRequestForUploadApiMethod({
        fileName,
        fileType,
        prefix,
        bucket,
      });

      const resizedFile = await resizeImage(file, 128, 128);

      // console.log(file);
      // console.log(resizedFile);

      await uploadFileUsingSignedPutRequestApiMethod(
        resizedFile,
        responseFromApiServerForUpload.signedRequest,
        { 'Cache-Control': 'max-age=2592000' },
      );

      setNewAvatarUrl(responseFromApiServerForUpload.url);

      await currentUser.updateProfile({
        name: newName,
        avatarUrl: newAvatarUrl,
      });

      notify('You successfully uploaded new avatar.');
    } catch (error) {
      notify(error);
    } finally {
      fileElement.value = '';
      setDisabled(false);
      NProgress.done();
    }
  };

  const { currentUser } = store;

  return (
    <Layout
      store={store}
      isMobile={isMobile}
      teamRequired={teamRequired}
      firstGridItem={firstGridItem}
    >
      <Head>
        <title>Your Settings at Async</title>
      </Head>
      <div
        style={{
          padding: isMobile ? '0px' : '0px 30px',
          height: '100%',
        }}
      >
        <h3>Your Settings</h3>
        <h4 style={{ marginTop: '40px' }}>Your account</h4>
        <div>
          <DoneIcon color="action" style={{ verticalAlign: 'text-bottom' }} />{' '}
          {currentUser.isSignedupViaGoogle
            ? 'You signed up on Async using your Google account.'
            : 'You signed up on Async using your email.'}
          <p />
          <li>
            Your email: <b>{currentUser.email}</b>
          </li>
          <li>
            Your username: <b>{currentUser.displayName}</b>
          </li>
        </div>
        <form onSubmit={onSubmit} autoComplete="off">
          <h4>Your username</h4>
          <TextField
            autoComplete="off"
            value={newName}
            helperText="Your username as seen by your team members"
            onChange={(event) => {
              setNewName(event.target.value);
            }}
          />
          <br />
          <br />
          <Button variant="contained" color="primary" type="submit" disabled={disabled}>
            Update username
          </Button>
        </form>

        <br />
        <h4>Your photo</h4>
        <Avatar
          src={newAvatarUrl}
          style={{
            display: 'inline-flex',
            verticalAlign: 'middle',
            marginRight: 20,
            width: 60,
            height: 60,
          }}
        />
        <label htmlFor="upload-file-user-avatar">
          <Button variant="outlined" color="primary" component="span" disabled={disabled}>
            Update avatar
          </Button>
        </label>
        <input
          accept="image/*"
          name="upload-file-user-avatar"
          id="upload-file-user-avatar"
          type="file"
          style={{ display: 'none' }}
          onChange={uploadFile}
        />
        <p />
        <br />
        <h4 style={{ marginRight: 20, display: 'inline' }}>Your Teams</h4>
        <Link href={`${URL_APP}/create-team`}>
          <Button
            variant="contained"
            color="primary"
            style={{
              fontSize: isMobile ? '13px' : '14px',
              marginTop: isMobile ? '10px' : '-20px',
              float: 'right',
            }}
          >
            + Add team
          </Button>
        </Link>
        <TableContainer>
          <Table>
            <TableHead>
              <TableRow>
                <TableCell>Team name</TableCell>
                <TableCell>Team slug</TableCell>
                <TableCell>Action</TableCell>
              </TableRow>
            </TableHead>

            <TableBody>
              {store.teams.map((t) => (
                <TableRow key={t._id}>
                  <TableCell style={{ width: '300px' }}>{t.name}</TableCell>
                  <TableCell>{t.slug}</TableCell>
                  <TableCell>
                    <Link href={`${URL_APP}/teams/${t.slug}/discussions`}>
                      <Button
                        variant="contained"
                        color="primary"
                        style={{
                          fontSize: isMobile ? '13px' : '14px',
                          marginTop: isMobile ? '10px' : 'inherit',
                        }}
                      >
                        See team
                      </Button>
                    </Link>
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </TableContainer>
      </div>
    </Layout>
  );
}

export default withAuth(inject('store')(observer(YourSettings)));

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\pages\_app.tsx -----

import createCache from '@emotion/cache';
import { CacheProvider } from '@emotion/react';
import CssBaseline from '@mui/material/CssBaseline';
import { ThemeProvider } from '@mui/material/styles';
import { Provider } from 'mobx-react';
import Head from 'next/head';
import React from 'react';

import { themeDark, themeLight } from '../lib/theme';
import { getUserApiMethod } from '../lib/api/public';
import { getInitialDataApiMethod } from '../lib/api/team-member';
import { isMobile } from '../lib/isMobile';
import { getStore, initializeStore, Store } from '../lib/store';

// import type { AppProps } from 'next/app';
import { NextPage, NextPageContext } from 'next';

// add types
type Props = {
  Component: NextPage;
  pageProps: any;
  initialState: any;
};

function MyApp({ Component, pageProps, initialState }: Props) {
  // console.log('initialState', initialState);

  const store: Store = initializeStore(initialState);

  // console.log('store.currentUser.email', store.currentUser);

  const isThemeDark = store.currentUser ? store.currentUser.darkTheme : true;

  const isServer = typeof window === 'undefined';

  return (
    <CacheProvider value={createCache({ key: 'css', prepend: true })}>
      <ThemeProvider theme={isThemeDark ? themeDark : themeLight}>
        <Head>
          <meta name="viewport" content="width=device-width, initial-scale=1.0" />
          <link rel="stylesheet" href={isServer ? '/fonts/server.css' : '/fonts/cdn.css'} />
          <link
            rel="stylesheet"
            href={
              isThemeDark
                ? 'https://storage.googleapis.com/async-await/nprogress-light-spinner.css'
                : 'https://storage.googleapis.com/async-await/nprogress-dark-spinner.css'
            }
          />
        </Head>
        <CssBaseline />
        <Provider store={store}>
          <Component {...pageProps} store={store} />
        </Provider>
      </ThemeProvider>
    </CacheProvider>
  );
}

MyApp.getInitialProps = async ({
  Component,
  ctx,
}: {
  Component: NextPage;
  ctx: NextPageContext;
}) => {
  // console.log('MyApp.getInitialProps');

  let firstGridItem = true;
  let teamRequired = false;

  if (
    ctx.pathname.includes('/login') ||
    ctx.pathname.includes('/create-team') ||
    ctx.pathname.includes('/invitation')
  ) {
    firstGridItem = false;
  }

  if (
    ctx.pathname.includes('/your-settings') ||
    ctx.pathname.includes('/team-settings') ||
    ctx.pathname.includes('/discussion') ||
    ctx.pathname.includes('/billing')
  ) {
    teamRequired = true;
  }

  const { teamSlug, discussionSlug, redirectMessage } = ctx.query;

  const pageProps = {
    isMobile: isMobile({ req: ctx.req }),
    firstGridItem,
    teamRequired,
    teamSlug,
    discussionSlug,
    redirectMessage,
  };

  if (Component.getInitialProps) {
    Object.assign(pageProps, await Component.getInitialProps(ctx));
  }

  const appProps = { pageProps };

  // console.log('before getStore');

  const store = getStore();
  if (store) {
    return appProps;
  }

  let userObj = null;
  try {
    const { user } = await getUserApiMethod(ctx.req);
    userObj = user;
  } catch (error) {
    console.log(error);
  }

  let initialData;

  if (userObj) {
    try {
      initialData = await getInitialDataApiMethod({
        request: ctx.req,
        data: { teamSlug, discussionSlug },
      });
    } catch (error) {
      console.error(error);
    }
  }

  // console.log(initialData);

  let selectedTeamSlug = '';

  if (teamSlug) {
    selectedTeamSlug = teamSlug as string;
  } else {
    selectedTeamSlug = userObj && userObj.defaultTeamSlug;
  }

  const team =
    initialData && initialData.teams && initialData.teams.find((t) => t.slug === selectedTeamSlug);

  // console.log('userObj', userObj);

  return {
    ...appProps,
    initialState: { user: userObj, currentUrl: ctx.asPath, team, teamSlug, ...initialData },
  };
};

export default MyApp;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\pages\_document.tsx -----

import Document, { DocumentContext, Head, Html, Main, NextScript } from 'next/document';

import React from 'react';

import createEmotionServer from '@emotion/server/create-instance';
import createCache from '@emotion/cache';

function MyDocument({ __NEXT_DATA__ }: { __NEXT_DATA__: any }) {
  const isThemeDark = __NEXT_DATA__.props.initialState.user
    ? __NEXT_DATA__.props.initialState.user.darkTheme
    : true;

  return (
    <Html lang="en">
      <Head>
        <meta charSet="utf-8" />
        <meta name="google" content="notranslate" />
        <meta name="theme-color" content="#303030" />

        <link
          rel="shortcut icon"
          href="https://storage.googleapis.com/async-await/async-favicon32.png"
        />

        <link
          rel="stylesheet"
          href={
            isThemeDark
              ? 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/a11y-dark.min.css'
              : 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/a11y-light.min.css'
          }
        />

        <style>
          {`
          #__next {
            width: 100%;
            height: 100%;
          }
          a {
            font-weight: 400;
            color: #58a6ff;
            text-decoration: none;
            outline: none;
          }
          hr {
            border: 0.5px #707070 solid;
            color: #000;
          }
          blockquote {
            padding: 0 0.5em;
            margin: 20px 1em;
            border-left: 0.25em solid #dfe2e5;
            color: #000;
          }
          pre {
            display: block;
            overflow-x: auto;
            padding: 0.5em;
            background: #d0d0d0;
            border: 1px solid #ddd;
            font-size: 14px;
            color: #000;
          }
          pre code {
            font-size: 13px;
            background: #d0d0d0;
            padding: 0px;
            color: #000;
          }
          code {
            font-size: 13px;
            background: #d0d0d0;
            padding: 3px 5px;
            color: #000;
          }
          mark {
            background-color: #ffff0060;
          }
          summary:focus {
            outline: none;
          }
          table {
            border-collapse: collapse;
            margin: 15px 0px;
          }
          table, th, td {
            border: 1px solid #a1a1a1;
          }
          th, td {
            line-height: 1.5em;
            padding: 10px;
          }
        `}
        </style>
        <script
          async
          src={`https://www.googletagmanager.com/gtag/js?id=${process.env.NEXT_PUBLIC_GA_MEASUREMENT_ID}`}
        />
        <script
          dangerouslySetInnerHTML={{
            __html: `
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', '${process.env.NEXT_PUBLIC_GA_MEASUREMENT_ID}', {
            page_path: window.location.pathname,
          });
        `,
          }}
        />
      </Head>
      <body>
        <Main />
        <NextScript />
      </body>
    </Html>
  );
}

MyDocument.getInitialProps = async (ctx: DocumentContext) => {
  // Render app and page and get the context of the page with collected side effects.
  const originalRenderPage = ctx.renderPage;

  // You can consider sharing the same emotion cache between all the SSR requests to speed up performance.
  // However, be aware that it can have global side effects.
  const cache = createCache({ key: 'css' });
  const { extractCriticalToChunks } = createEmotionServer(cache);

  ctx.renderPage = () =>
    originalRenderPage({
      // eslint-disable-next-line react/display-name
      enhanceApp: (App: any) => (props) => <App emotionCache={cache} {...props} />,
    });

  const initialProps = await Document.getInitialProps(ctx);
  // This is important. It prevents emotion to render invalid HTML.
  // See https://github.com/mui-org/material-ui/issues/26561#issuecomment-855286153
  const emotionStyles = extractCriticalToChunks(initialProps.html);
  const emotionStyleTags = emotionStyles.styles.map((style) => (
    <style
      data-emotion={`${style.key} ${style.ids.join(' ')}`}
      key={style.key}
      // eslint-disable-next-line react/no-danger
      dangerouslySetInnerHTML={{ __html: style.css }}
    />
  ));

  return {
    ...initialProps,
    // Styles fragment is rendered after the app and page rendering finish.
    styles: [...React.Children.toArray(initialProps.styles), ...emotionStyleTags],
  };
};

export default MyDocument;

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\server\routesWithCache.ts -----

import { LRUCache } from 'lru-cache';

export default function routesWithCache({ server, app }) {
  const ssrCache = new LRUCache({
    max: 100, // 100 items
    ttl: 1000 * 60 * 60, // in ms, 1hr
  });

  function getCacheKey(req) {
    if (req.user) {
      return `${req.url}${req.user.id}`;
    }
    return `${req.url}`;
  }

  async function renderAndCache(req, res, pagePath, queryParams) {
    const key = getCacheKey(req);

    if (ssrCache.has(key)) {
      res.setHeader('x-cache', 'HIT');
      res.send(ssrCache.get(key));
      return;
    }

    try {
      const renderedPage = await app.renderToHTML(req, res, pagePath, queryParams);

      ssrCache.set(key, renderedPage);

      res.send(renderedPage);
    } catch (err) {
      app.renderError(err, req, res, pagePath, queryParams);
    }
  }

  server.get('/login-cached', (req, res) => {
    renderAndCache(req, res, '/login-cached', {});
  });
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\server\server.ts -----

import express from 'express';
import next from 'next';

import setupSitemapAndRobots from './setupSitemapAndRobots';

import routesWithCache from './routesWithCache';

const dev = process.env.NODE_ENV !== 'production';
const port = process.env.PORT || 3000;

const app = next({ dev });
const handle = app.getRequestHandler();

app.prepare().then(() => {
  const server = express();

  // give all Nextjs's request to next server before anything else
  server.get('/_next/*', (req, res) => {
    // console.log('next server, page');
    handle(req, res);
  });

  server.use(express.json());

  if (!dev) {
    server.set('trust proxy', 1); // sets req.hostname, req.ip
  }

  server.get('/', async (req: any, res) => {
    let redirectUrl = 'login';

    if (req.user) {
      if (!req.user.defaultTeamSlug) {
        redirectUrl = 'create-team';
      } else {
        redirectUrl = `team/${req.user.defaultTeamSlug}/discussions`;
      }
    }

    res.redirect(
      `${
        dev ? process.env.NEXT_PUBLIC_URL_APP : process.env.NEXT_PUBLIC_PRODUCTION_URL_APP
      }/${redirectUrl}`,
    );
  });

  // server.get('/api/v1/public/get-user', (_, res) => {
  //   res.json({ user: { email: 'team@builderbook.org' } });
  // });

  server.get('/teams/:teamSlug/your-settings', (req, res) => {
    const { teamSlug } = req.params;
    app.render(req, res, '/your-settings', { teamSlug });
  });

  server.get('/teams/:teamSlug/team-settings', (req, res) => {
    const { teamSlug } = req.params;
    app.render(req, res, '/team-settings', { teamSlug });
  });

  server.get('/teams/:teamSlug/billing', (req, res) => {
    const { teamSlug } = req.params;
    app.render(req, res, '/billing', { teamSlug, ...(req.query || {}) });
  });

  server.get('/teams/:teamSlug/discussions/:discussionSlug', (req, res) => {
    const { teamSlug, discussionSlug } = req.params;
    app.render(req, res, '/discussion', { teamSlug, discussionSlug });
  });

  server.get('/teams/:teamSlug/discussions', (req, res) => {
    const { teamSlug } = req.params;
    app.render(req, res, '/discussion', { teamSlug });
  });

  server.get('/signup', (req, res) => {
    app.render(req, res, '/login');
  });

  server.get('/invitation', (req, res) => {
    app.render(req, res, '/invitation', { token: req.query.token as string });
  });

  setupSitemapAndRobots({ server });

  routesWithCache({ server, app });

  server.get('*', (req, res) => {
    handle(req, res);
  });

  // listen(handle: any, listeningListener?: () => void): http.Server;
  // "@types/express-serve-static-core", "version": "4.17.1"
  server.listen(port, () => {
    console.log(
      `> Ready on ${
        dev ? process.env.NEXT_PUBLIC_URL_APP : process.env.NEXT_PUBLIC_PRODUCTION_URL_APP
      }`,
    );
  });
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\server\setupSitemapAndRobots.ts -----

import { SitemapStream, streamToPromise } from 'sitemap';
import path from 'path';
import zlib from 'zlib';

const dev = process.env.NODE_ENV !== 'production';

export default function setupSitemapAndRobots({ server }) {
  let sitemap;

  server.get('/sitemap.xml', async (_, res) => {
    res.header('Content-Type', 'application/xml');
    res.header('Content-Encoding', 'gzip');

    if (sitemap) {
      res.send(sitemap);
      return;
    }

    try {
      const smStream = new SitemapStream({
        hostname: dev ? process.env.NEXT_PUBLIC_URL_APP : process.env.NEXT_PUBLIC_PRODUCTION_URL_APP,
      });
      const gzip = zlib.createGzip();

      smStream.write({
        url: '/login',
        changefreq: 'daily',
        priority: 1,
      });

      streamToPromise(smStream.pipe(gzip)).then((sm) => (sitemap = sm));

      smStream.end();

      smStream
        .pipe(gzip)
        .pipe(res)
        .on('error', (err) => {
          throw err;
        });
    } catch (err) {
      console.error(err);
      res.status(500).end();
    }
  });

  server.get('/robots.txt', (_, res) => {
    res.sendFile(path.join(__dirname, '../static', 'robots.txt'));
  });
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\.eslintrc.js -----

module.exports = {
  settings: {
    react: { version: 'detect' },
  },
  parser: '@typescript-eslint/parser',
  extends: ['plugin:react/recommended', 'plugin:@typescript-eslint/recommended', 'prettier'],
  env: {
    es6: true,
    node: true,
  },
  plugins: ['prettier', 'react'],
  rules: {
    'prettier/prettier': [
      'error',
      {
        singleQuote: true,
        trailingComma: 'all',
        arrowParens: 'always',
        printWidth: 100,
        semi: true,
      },
    ],
    '@typescript-eslint/camelcase': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    'react/no-unescaped-entities': 'off',
    'react/jsx-filename-extension': ['error', { extensions: ['.tsx'] }],
    '@typescript-eslint/no-explicit-any': 'off',
    'prefer-arrow-callback': 'error',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
  },
};

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\next-env.d.ts -----

/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/basic-features/typescript for more information.

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\next.config.js -----

const withTM = require('next-transpile-modules')([ // eslint-disable-line
  '@mui/material',
  '@mui/icons-material',
]);

module.exports = withTM({
  typescript: {
    ignoreBuildErrors: true,
  },
  poweredByHeader: false,
  swcMinify: true,
  experimental: {
    forceSwcTransforms: true,
  },
  modularizeImports: {
    '@mui/material/?(((\\w*)?/?)*)': {
      transform: '@mui/material/{{ matches.[1] }}/{{member}}',
    },
    '@mui/icons-material/?(((\\w*)?/?)*)': {
      transform: '@mui/icons-material/{{ matches.[1] }}/{{member}}',
    },
  },
});

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\nodemon.json -----

{
  "watch": ["server"],
  "exec": "ts-node --project tsconfig.server.json",
  "ext": "ts"
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\package.json -----

{
  "name": "app-same-as-10-end-app",
  "version": "1.0.0",
  "license": "MIT",
  "engines": {
    "node": "18.17.0",
    "yarn": "1.22.19"
  },
  "scripts": {
    "dev": "nodemon server/server.ts",
    "lint": "eslint . --ext .ts,.tsx",
    "postinstall": "rm -rf production-server/",
    "build": "next build && tsc --project tsconfig.server.json && cp server/robots.txt production-server",
    "start": "node production-server/server.js"
  },
  "dependencies": {
    "@emotion/cache": "^11.11.0",
    "@emotion/react": "^11.11.1",
    "@emotion/server": "^11.11.0",
    "@emotion/styled": "^11.11.0",
    "@mui/icons-material": "^5.14.19",
    "@mui/material": "^5.14.20",
    "@stripe/stripe-js": "^2.2.0",
    "express": "^4.18.2",
    "he": "^1.2.0",
    "isomorphic-unfetch": "^4.0.2",
    "keycode": "^2.2.0",
    "lru-cache": "^10.1.0",
    "marked": "^11.0.0",
    "mobx": "^6.12.0",
    "mobx-react": "^9.1.0",
    "moment": "^2.29.4",
    "next": "^14.0.4",
    "next-transpile-modules": "^10.0.1",
    "nprogress": "0.2.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-mentions": "^4.4.10",
    "sitemap": "^7.1.1",
    "socket.io-client": "^4.7.2",
    "typescript": "^5.3.3"
  },
  "devDependencies": {
    "@babel/core": "^7.23.5",
    "@babel/plugin-proposal-private-methods": "^7.18.6",
    "@babel/plugin-proposal-private-property-in-object": "^7.21.11",
    "@types/express": "^4.17.21",
    "@types/he": "^1.2.3",
    "@types/node": "^20.10.4",
    "@types/react": "^18.2.42",
    "@types/react-dom": "^18.2.17",
    "@typescript-eslint/eslint-plugin": "^6.13.2",
    "@typescript-eslint/parser": "^6.13.2",
    "babel-eslint": "^10.1.0",
    "eslint": "^8.55.0",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-prettier": "^5.0.1",
    "eslint-plugin-react": "^7.33.2",
    "nodemon": "^3.0.2",
    "prettier": "^3.1.0",
    "ts-node": "^10.9.1"
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\tsconfig.json -----

{
  "compileOnSave": false,
  "compilerOptions": {
    "target": "esnext",
    "module": "esnext",
    "jsx": "preserve",
    "allowJs": true,
    "alwaysStrict": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "removeComments": true,
    "preserveConstEnums": true,
    "sourceMap": false,
    "skipLibCheck": true,
    "baseUrl": ".",
    "typeRoots": [
      "./node_modules/@types"
    ],
    "lib": [
      "dom",
      "es2017"
    ],
    "strict": false,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "incremental": true,
    "experimentalDecorators": true ,
    "useDefineForClassFields": true,
  },
  "include": [
    "next-env.d.ts",
    "./**/*.tsx",
    "./**/*.ts"
  ],
  "exclude": [
    "dist",
    "production-server",
    ".next",
    "out",
    "next.config.js",
    "node_modules"
  ]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\app\tsconfig.server.json -----

{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "module": "commonjs",
    "outDir": "production-server/",
    "target": "es2017",
    "isolatedModules": false,
    "noEmit": false
  },
  "exclude": ["./server/types.d.ts"],
  "include": ["./server/**/*.ts"],
  "typeRoots": ["./node_modules/@types", "./server/types.d.ts"]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\lambda\.eslintrc.js -----

module.exports = {
  parser: "@typescript-eslint/parser",
  extends: ["plugin:@typescript-eslint/recommended", "prettier"],
  env: {
    "es6": true,
    "node": true,
  },
  rules: {
    'prettier/prettier': [
      'error',
      {
        singleQuote: true,
        trailingComma: 'all',
        arrowParens: 'always',
        printWidth: 100,
        semi: true,
      },
    ],
    '@typescript-eslint/no-unused-vars': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/no-explicit-any': 'off',
    'prefer-arrow-callback': 'error',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
 },
  plugins: [
    "prettier",
  ]
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\lambda\handler.ts -----

import * as mongoose from 'mongoose';

import sendEmail from './api/server/aws-ses';
import getEmailTemplate from './api/server/models/EmailTemplate';
import User from './api/server/models/User';

const dev = process.env.NODE_ENV !== 'production';

export const sendEmailForNewPost = async (event) => {
  console.log('Received event (request representation):', JSON.stringify(event));

  const reqBody = JSON.parse(event.body);

  const { discussionName, discussionLink, postContent, authorName, userIds } = reqBody;

  if (
    discussionName === undefined ||
    discussionLink === undefined ||
    postContent === undefined ||
    authorName === undefined ||
    userIds === undefined
  ) {
    throw new Error('Missing data');
  }

  console.log(discussionName, discussionLink, postContent, authorName, userIds);

  await mongoose.connect(dev ? process.env.MONGO_URL_TEST : process.env.MONGO_URL);

  try {
    const emailTemplate = await getEmailTemplate('newPost', {
      discussionName,
      discussionLink,
      postContent,
      authorName,
    });

    if (!emailTemplate) {
      throw new Error('newPost Email template not found');
    }

    const usersToNotify = await User.find({ _id: { $in: userIds } })
      .select('email')
      .setOptions({ lean: true });

    console.log('usersToNotify', usersToNotify);

    const jobs = usersToNotify
      .filter((user) => !!user.email)
      .map(async (user) => {
        try {
          await sendEmail({
            from: `From async-await.com <${process.env.EMAIL_SUPPORT_FROM_ADDRESS}>`,
            to: [user.email],
            subject: emailTemplate.subject,
            body: emailTemplate.message,
          });
          console.log('email is sent');
        } catch (err) {
          console.error(err.stack);
        }
      });

    await Promise.all(jobs);
  } catch (error) {
    console.error(error.stack);
    return { error: error.message, event };
  } finally {
    await mongoose.disconnect();
  }

  const response = {
    statusCode: 200,
    headers: {
      'Access-Control-Allow-Headers': 'Content-Type',
      'Access-Control-Allow-Origin': dev ? process.env.URL_APP : process.env.PRODUCTION_URL_APP,
      'Access-Control-Allow-Methods': 'OPTIONS,POST,GET',
      'Access-Control-Allow-Credentials': true,
    },
    body: JSON.stringify({
      message: 'Email notification was sent!',
      input: event,
    }),
  };

  return response;
};

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\lambda\package.json -----

{
  "name": "lambda",
  "version": "1.0.0",
  "license": "MIT",
  "scripts": {
    "lint": "eslint . --ext .ts,.tsx"
  },
  "dependencies": {
    "aws-sdk": "^2.1286.0",
    "bcrypt": "^5.1.0",
    "connect-mongo": "^4.6.0",
    "cors": "^2.8.5",
    "dotenv": "^16.0.3",
    "express": "^4.18.2",
    "express-session": "^1.17.3",
    "he": "^1.2.0",
    "highlight.js": "^11.7.0",
    "lodash": "^4.17.21",
    "marked": "^4.2.5",
    "mongoose": "^6.8.2",
    "node-fetch": "^3.3.0",
    "passport": "^0.6.0",
    "passport-google-oauth": "^2.0.0",
    "passwordless": "^1.1.3",
    "passwordless-tokenstore": "^0.0.10",
    "socket.io": "^4.5.4",
    "stripe": "^11.5.0",
    "typescript": "^4.9.4",
    "winston": "^3.8.2"
  },
  "devDependencies": {
    "@types/connect-mongo": "^3.1.3",
    "@types/dotenv": "^8.2.0",
    "@types/express": "^4.17.15",
    "@types/express-session": "^1.17.5",
    "@types/jest": "^29.2.5",
    "@types/lodash": "^4.14.191",
    "@types/mongoose": "^5.11.97",
    "@types/node": "^18.11.18",
    "@types/node-fetch": "^2.6.2",
    "@types/passport": "^1.0.11",
    "@types/socket.io": "^3.0.2",
    "@typescript-eslint/eslint-plugin": "^5.47.1",
    "@typescript-eslint/parser": "^5.47.1",
    "eslint": "^8.31.0",
    "eslint-config-prettier": "^8.5.0",
    "eslint-plugin-prettier": "^4.2.1",
    "jest": "^29.3.1",
    "prettier": "^2.8.1",
    "serverless-dotenv-plugin": "^4.0.2",
    "serverless-plugin-typescript": "^2.1.4",
    "ts-jest": "^29.0.3",
    "ts-node-dev": "^2.0.0"
  }
}

----- FILE: C:\Users\annes\Desktop\smetasc-saas-multi-tenancy-app\reference-code\async-labs-saas\saas\lambda\tsconfig.json -----

{
  "compileOnSave": false,
  "compilerOptions": {
    "jsx": "preserve",
    "allowJs": true,
    "alwaysStrict": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "removeComments": false,
    "preserveConstEnums": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "sourceMap": true,
    "skipLibCheck": true,
    "baseUrl": ".",
    "experimentalDecorators": true,
    "typeRoots": ["./node_modules/@types"],
    "lib": ["es2015", "es2016"],
    "module": "commonjs",
    "outDir": ".build/",
    "rootDir": "./"
  }
}
